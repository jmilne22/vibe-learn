conceptLinks:
  Slice Operations: "#slice-operations-under-pressure"
  In-Place Manipulation: "#in-place-manipulation"
  Map Patterns: "#map-patterns"
  String Parsing: "#string-parsing--building"
  Numbers & Percentages: "#numbers-floats--percentages"
  Sorting & Filtering: "#sorting--filtering"
  Line Parsing: "#line-by-line-parsing"
  Combining Patterns: "#putting-it-together"
sharedContent: {}
variants:
  warmups:
    - id: warmup_1
      concept: Slice Operations
      variants:
        - id: v0a
          title: First Two Servers
          description: >-
            Given <code>servers := []string{"web-1", "web-2", "api-1", "api-2", "db-1"}</code>, create a new slice
            containing only the first 2 elements. Print the result.
          hints:
            - "A slice expression <code>s[start:end]</code> gives you elements from start up to (not including) end."
            - "When the start index is 0, you can omit it from the slice expression."
          solution: |-
            servers := []string{"web-1", "web-2", "api-1", "api-2", "db-1"}
            first2 := servers[:2]
            fmt.Println(first2) // [web-1 web-2]
        - id: v0b
          title: Middle Element
          description: >-
            Given <code>nodes := []string{"node-1", "node-2", "node-3", "node-4", "node-5"}</code>, print the middle
            element. Use <code>len()</code> to find it.
          hints:
            - "The middle index of a slice with 5 elements is 2 (indices go 0,1,2,3,4)."
            - "Use <code>len(nodes)/2</code> to compute the middle index."
          solution: |-
            nodes := []string{"node-1", "node-2", "node-3", "node-4", "node-5"}
            mid := nodes[len(nodes)/2]
            fmt.Println(mid) // node-3
        - id: v1
          title: Last N Servers
          description: >-
            Given <code>servers := []string{"web-1", "web-2", "api-1", "api-2", "db-1"}</code>, return a new slice
            containing the last 3 elements.
          hints:
            - How do you get elements from the end of a slice when Go doesn't support negative indexing?
            - "Think about using <code>len(s)</code> to calculate the starting position of your slice expression."
          solution: |-
            servers := []string{"web-1", "web-2", "api-1", "api-2", "db-1"}
            last3 := servers[len(servers)-3:]
            fmt.Println(last3) // [api-1 api-2 db-1]
        - id: v4
          title: Build a Slice from Scratch
          description: >-
            Start with an empty slice. Append the strings <code>"node-1"</code> through <code>"node-5"</code> using a
            loop. Then print the length, capacity, and contents.
          hints:
            - Start with a nil slice and grow it inside a counting loop. You need to build each name dynamically from the loop index.
            - "Check the lesson's Building Strings section for how to combine a string with a number. Use <code>len</code> and <code>cap</code> to inspect the slice afterwards."
          solution: |-
            var nodes []string
            for i := 1; i <= 5; i++ {
                nodes = append(nodes, fmt.Sprintf("node-%d", i))
            }
            fmt.Printf("len=%d cap=%d %v\n", len(nodes), cap(nodes), nodes)
        - id: v5
          title: Append to a Slice
          description: >-
            Given <code>colors := []string{"red", "green"}</code>, append <code>"blue"</code> to the slice. Print the
            result.
          hints:
            - "<code>append</code> returns a new slice — you must assign it back to the variable."
            - "The syntax is <code>append(slice, element)</code> — remember to assign the result back."
          solution: |-
            colors := []string{"red", "green"}
            colors = append(colors, "blue")
            fmt.Println(colors) // [red green blue]
        - id: v6
          title: Combine Two Slices
          description: >-
            Given <code>front := []string{"a", "b"}</code> and <code>back := []string{"c", "d"}</code>, combine them into
            a single slice using <code>append</code>. Print the result.
          hints:
            - "To append all elements of one slice to another, use the spread operator: <code>...</code>"
            - "The <code>...</code> goes after the second slice in the <code>append</code> call."
          solution: |-
            front := []string{"a", "b"}
            back := []string{"c", "d"}
            all := append(front, back...)
            fmt.Println(all) // [a b c d]
    - id: warmup_2
      concept: In-Place Manipulation
      variants:
        - id: v0a
          title: Swap First and Last
          description: >-
            Given <code>pods := []string{"web-1", "web-2", "web-3", "web-4"}</code>, swap the first and last elements
            <strong>in place</strong>. Print the result.
          hints:
            - "Go lets you swap two values in one line: <code>a, b = b, a</code>."
            - "Use index 0 for first and <code>len(pods)-1</code> for last."
          solution: |-
            pods := []string{"web-1", "web-2", "web-3", "web-4"}
            pods[0], pods[len(pods)-1] = pods[len(pods)-1], pods[0]
            fmt.Println(pods) // [web-4 web-2 web-3 web-1]
        - id: v0b
          title: Overwrite an Element
          description: >-
            Given <code>statuses := []string{"Running", "Pending", "Running", "Failed"}</code>, change the
            <code>"Failed"</code> pod (index 3) to <code>"Running"</code>. Print the result.
          hints:
            - "You can assign to a specific index in a slice, just like a variable."
            - Slices are mutable — assigning to an index changes the original slice.
          solution: |-
            statuses := []string{"Running", "Pending", "Running", "Failed"}
            statuses[3] = "Running"
            fmt.Println(statuses) // [Running Pending Running Running]
        - id: v2
          title: Remove Terminated Pod
          description: >-
            Given <code>pods := []string{"web-1", "web-2", "web-3", "web-4"}</code>, remove the pod at index 1
            (<code>"web-2"</code>) <strong>without preserving order</strong> (swap with last element, then shrink).
            Print the result.
          hints:
            - "If order doesn't matter, you don't need to shift everything. What's the cheapest way to fill the gap left by the removed element?"
            - "After filling the gap, the slice is one element too long. How do you shrink a slice by one without copying?"
          solution: |-
            pods := []string{"web-1", "web-2", "web-3", "web-4"}
            pods[1] = pods[len(pods)-1]
            pods = pods[:len(pods)-1]
            fmt.Println(pods) // [web-1 web-4 web-3]
        - id: v6
          title: Remove Last Element
          description: >-
            Given <code>tasks := []string{"deploy", "test", "lint", "scan"}</code>, remove the last element. Print the
            result.
          hints:
            - "You can shrink a slice by re-slicing it with a shorter length."
            - "Use a slice expression that stops one element short of the current length."
          solution: |-
            tasks := []string{"deploy", "test", "lint", "scan"}
            tasks = tasks[:len(tasks)-1]
            fmt.Println(tasks) // [deploy test lint]
        - id: v7
          title: Replace by Value
          description: >-
            Given <code>envs := []string{"dev", "staging", "prod", "dev"}</code>, replace all occurrences of
            <code>"dev"</code> with <code>"development"</code>. Print the result.
          hints:
            - "Loop through the slice and check each element. If it matches, overwrite it."
            - "Use <code>range</code> with the index to modify in place: <code>envs[i] = \"development\"</code>."
          solution: |-
            envs := []string{"dev", "staging", "prod", "dev"}
            for i, e := range envs {
                if e == "dev" {
                    envs[i] = "development"
                }
            }
            fmt.Println(envs) // [development staging prod development]
        - id: v8
          title: Move to Front
          description: >-
            Given <code>servers := []string{"api-1", "db-1", "web-1", "cache-1"}</code>, find <code>"web-1"</code> and
            swap it with the first element. Print the result.
          hints:
            - "First find the index of the target element with a loop. Then swap it with index 0."
            - "Use Go's parallel assignment to swap: <code>servers[0], servers[i] = servers[i], servers[0]</code>."
          solution: |-
            servers := []string{"api-1", "db-1", "web-1", "cache-1"}
            for i, s := range servers {
                if s == "web-1" {
                    servers[0], servers[i] = servers[i], servers[0]
                    break
                }
            }
            fmt.Println(servers) // [web-1 db-1 api-1 cache-1]
    - id: warmup_3
      concept: Map Patterns
      variants:
        - id: v0a
          title: Look Up a Config Value
          description: >-
            Given <code>config := map[string]string{"host": "localhost", "port": "5432", "db": "myapp"}</code>,
            look up the key <code>"port"</code> and print its value. Then check if the key <code>"timeout"</code>
            exists using the comma-ok pattern, and print whether it was found.
          hints:
            - "Access a map value with <code>config[\"port\"]</code>."
            - "Comma-ok pattern: <code>val, ok := config[\"timeout\"]</code>. <code>ok</code> is <code>true</code> if the key exists."
          solution: |-
            config := map[string]string{"host": "localhost", "port": "5432", "db": "myapp"}
            fmt.Println(config["port"]) // 5432
            val, ok := config["timeout"]
            fmt.Printf("timeout=%q found=%t\n", val, ok) // timeout="" found=false
        - id: v1
          title: Count Log Levels
          description: |-
            Given this slice of log levels:
            <pre>levels := []string{"INFO", "ERROR", "INFO", "WARN", "ERROR", "INFO", "DEBUG", "ERROR"}</pre>
            Count occurrences of each level using a map. Print each level and its count.
          hints:
            - What data structure maps a string key to an integer count?
            - "The zero value of int is 0. So incrementing a key that doesn't exist yet just works — no need to check first."
          solution: |-
            levels := []string{"INFO", "ERROR", "INFO", "WARN", "ERROR", "INFO", "DEBUG", "ERROR"}
            counts := make(map[string]int)
            for _, level := range levels {
                counts[level]++
            }
            for level, count := range counts {
                fmt.Printf("%s: %d\n", level, count)
            }
        - id: v4
          title: Unique Error Messages
          description: |-
            Given this slice of error messages:
            <pre>errors := []string{"timeout", "connection refused", "timeout",
                "DNS lookup failed", "timeout", "connection refused"}</pre>
            Use a map-as-set to find unique error messages. Print them in any order.
          hints:
            - "A map's keys are always unique. How can you exploit that to deduplicate a list?"
            - "After recording each string as a map key, the map's keys ARE your unique set. Iterate the keys to print them."
          solution: |-
            errors := []string{"timeout", "connection refused", "timeout",
                "DNS lookup failed", "timeout", "connection refused"}
            seen := make(map[string]bool)
            for _, err := range errors {
                seen[err] = true
            }
            for msg := range seen {
                fmt.Println(msg)
            }
        - id: v5
          title: Delete a Key
          description: >-
            Given <code>config := map[string]string{"host": "localhost", "port": "5432", "debug": "true"}</code>, delete
            the <code>"debug"</code> key from the map. Print the map.
          hints:
            - "Go has a built-in function specifically for removing map keys."
            - "The function is called <code>delete</code>. It takes two arguments: the map and the key to remove."
          solution: |-
            config := map[string]string{"host": "localhost", "port": "5432", "debug": "true"}
            delete(config, "debug")
            fmt.Println(config) // map[host:localhost port:5432]
        - id: v6
          title: Keys to Slice
          description: >-
            Given <code>ports := map[string]int{"http": 80, "https": 443, "ssh": 22}</code>, collect all the keys into a
            string slice. Print the slice.
          hints:
            - "Use <code>range</code> over the map to get each key."
            - "Append each key to a slice: <code>keys = append(keys, k)</code>."
          solution: |-
            ports := map[string]int{"http": 80, "https": 443, "ssh": 22}
            var keys []string
            for k := range ports {
                keys = append(keys, k)
            }
            fmt.Println(keys)
        - id: v7
          title: Update a Value
          description: >-
            Given <code>counts := map[string]int{"errors": 5, "warnings": 12}</code>, increment <code>"errors"</code> by
            1 and set <code>"warnings"</code> to 0. Print the map.
          hints:
            - "Map values can be updated by assigning to the key: <code>counts[\"key\"] = newValue</code>."
            - "You can use <code>++</code> directly on a map value to increment it, and assign to a key to overwrite."
          solution: |-
            counts := map[string]int{"errors": 5, "warnings": 12}
            counts["errors"]++
            counts["warnings"] = 0
            fmt.Println(counts) // map[errors:6 warnings:0]
    - id: warmup_4
      concept: String Parsing
      variants:
        - id: v0a
          title: Split a Host:Port String
          description: >-
            Given <code>addr := "api-server:8080"</code>, split it into the hostname and port parts. Print each on
            its own line.
          hints:
            - "Use <code>strings.SplitN(addr, \":\", 2)</code> to split on the first colon only."
            - "The result is a two-element slice: <code>parts[0]</code> is the host, <code>parts[1]</code> is the port."
          solution: |-
            addr := "api-server:8080"
            parts := strings.SplitN(addr, ":", 2)
            fmt.Println("host:", parts[0]) // host: api-server
            fmt.Println("port:", parts[1]) // port: 8080
        - id: v0b
          title: Check a String Prefix
          description: >-
            Given <code>image := "registry.io/nginx:1.25"</code>, check if it starts with <code>"registry.io/"</code>.
            If it does, extract just the image name and tag after the registry prefix. Print the result.
          hints:
            - "Use <code>strings.HasPrefix</code> to check the prefix."
            - "Use <code>strings.TrimPrefix</code> to remove the prefix, or slice the string from a known position."
          solution: |-
            image := "registry.io/nginx:1.25"
            if strings.HasPrefix(image, "registry.io/") {
                nameTag := strings.TrimPrefix(image, "registry.io/")
                fmt.Println(nameTag) // nginx:1.25
            }
        - id: v1
          title: Parse Label Pair
          description: >-
            Write a function <code>func parseLabel(s string) (string, string)</code> that takes a string like
            <code>"app=nginx"</code> and returns the key and value. Split on the first <code>=</code> only (values might
            contain <code>=</code>).
          hints:
            - "You need to find the position of the first <code>=</code>, not split on all of them. Which <code>strings</code> function finds the index of a substring?"
            - "Once you have the position, use slice expressions to grab everything before it (the key) and everything after it (the value)."
          solution: |-
            func parseLabel(s string) (string, string) {
                idx := strings.Index(s, "=")
                if idx < 0 {
                    return s, ""
                }
                return s[:idx], s[idx+1:]
            }
        - id: v2
          title: Extract Namespace from Resource
          description: >-
            K8s resource names are often formatted as <code>"namespace/resource"</code>. Write a function <code>func
            splitResource(s string) (string, string)</code> that returns the namespace and resource name. If there's no
            <code>/</code>, return <code>"default"</code> as the namespace.
          hints:
            - "First determine whether the separator exists at all. If it doesn't, you need to return a default namespace."
            - "Limit your split to at most 2 parts, then check the result length to determine which format you got."
          solution: |-
            func splitResource(s string) (string, string) {
                parts := strings.SplitN(s, "/", 2)
                if len(parts) == 1 {
                    return "default", parts[0]
                }
                return parts[0], parts[1]
            }
        - id: v5
          title: Join Words
          description: >-
            Given <code>words := []string{"hello", "world", "from", "Go"}</code>, join them into a single string
            separated by spaces. Print the result.
          hints:
            - "The <code>strings</code> package has a function that joins a slice of strings with a separator."
            - "The function is <code>strings.Join</code>. It takes two arguments: the slice and the separator string."
          solution: |-
            words := []string{"hello", "world", "from", "Go"}
            result := strings.Join(words, " ")
            fmt.Println(result) // hello world from Go
        - id: v6
          title: Replace in String
          description: >-
            Given <code>msg := "error: disk full, error: retry failed"</code>, replace all occurrences of
            <code>"error"</code> with <code>"warn"</code>. Print the result.
          hints:
            - "The <code>strings</code> package has a function for replacing all occurrences of a substring."
            - "The function is <code>strings.ReplaceAll</code>. It takes three arguments: the original string, what to find, and what to replace it with."
          solution: |-
            msg := "error: disk full, error: retry failed"
            result := strings.ReplaceAll(msg, "error", "warn")
            fmt.Println(result) // warn: disk full, warn: retry failed
    - id: warmup_5
      concept: Numbers & Percentages
      variants:
        - id: v1
          title: Error Percentage
          description: >-
            Given <code>errors := 3</code> and <code>total := 8</code>, calculate the error rate as a percentage and
            print it with one decimal place followed by a percent sign. Expected output: <code>37.5%</code>
          hints:
            - Dividing two ints in Go gives an int — the decimal part is thrown away. How do you get the real percentage?
            - "Convert both to <code>float64</code> before dividing, multiply by 100, then use the right format verb to get one decimal place and a literal <code>%</code>."
          solution: |-
            errors := 3
            total := 8
            pct := float64(errors) / float64(total) * 100
            fmt.Printf("%.1f%%\n", pct)
        - id: v2
          title: Round to One Decimal
          description: >-
            Given <code>rate := 33.33333</code>, round it to one decimal place and print the result.
            Expected output: <code>33.3</code>
          hints:
            - "Go has no <code>math.Round(x, places)</code>. You need to shift the decimal point, round, then shift back."
            - "Multiply by 10, round with <code>math.Round</code>, divide by 10."
          solution: |-
            rate := 33.33333
            rounded := math.Round(rate*10) / 10
            fmt.Println(rounded) // 33.3
        - id: v4
          title: Int to String
          description: >-
            Given <code>port := 8080</code>, convert it to a string using <code>strconv.Itoa</code> and print the
            result.
          hints:
            - "<code>strconv.Itoa</code> converts an int to its string representation."
            - "It takes one int argument and returns a string — no error return."
          solution: |-
            port := 8080
            s := strconv.Itoa(port)
            fmt.Println(s) // 8080
    - id: warmup_6
      concept: Sorting & Filtering
      variants:
        - id: v0a
          title: Sort Scores Ascending
          description: >-
            Given <code>scores := []int{42, 7, 89, 23, 56}</code>, sort them in ascending order (smallest first) using
            <code>sort.Slice</code>. Print the result.
          hints:
            - "<code>sort.Slice</code> takes the slice and a comparator: <code>func(i, j int) bool</code>. Return true if element i should come before element j."
            - "For ascending order, return <code>scores[i] < scores[j]</code>."
          solution: |-
            scores := []int{42, 7, 89, 23, 56}
            sort.Slice(scores, func(i, j int) bool {
                return scores[i] < scores[j]
            })
            fmt.Println(scores) // [7 23 42 56 89]
        - id: v1
          title: Sort Server Names
          description: >-
            Given <code>servers := []string{"web-3", "api-1", "db-2", "web-1", "api-2"}</code>, sort them
            alphabetically in place and print the result.
          hints:
            - "Go's <code>sort</code> package has a convenience function specifically for string slices."
            - "The function name matches the element type. It sorts in place — no return value needed."
          solution: |-
            servers := []string{"web-3", "api-1", "db-2", "web-1", "api-2"}
            sort.Strings(servers)
            fmt.Println(servers) // [api-1 api-2 db-2 web-1 web-3]
        - id: v2
          title: Sort by Value Descending
          description: >-
            Given <code>counts := []int{42, 7, 256, 13, 89}</code>, sort them in descending order (largest first)
            and print the result.
          hints:
            - "<code>sort.Slice</code> takes a comparator function. For descending order, which element should come first?"
            - "Return <code>counts[i] > counts[j]</code> to sort largest first."
          solution: |-
            counts := []int{42, 7, 256, 13, 89}
            sort.Slice(counts, func(i, j int) bool {
                return counts[i] > counts[j]
            })
            fmt.Println(counts) // [256 89 42 13 7]
        - id: v3
          title: Top 3 Elements
          description: >-
            Given <code>latencies := []int{234, 12, 891, 45, 567, 23, 445}</code>, find and print the top 3 highest
            values. Sort descending, then slice.
          hints:
            - "Sort the slice in descending order first, then take the first 3 elements."
            - "After sorting, use a slice expression to grab just the first N elements. Don't forget to check if the slice is shorter than N."
          solution: |-
            latencies := []int{234, 12, 891, 45, 567, 23, 445}
            sort.Slice(latencies, func(i, j int) bool {
                return latencies[i] > latencies[j]
            })
            top3 := latencies[:3]
            fmt.Println(top3) // [891 567 445]
    - id: warmup_7
      concept: Line Parsing
      variants:
        - id: v0a
          title: Count Lines
          description: >-
            Given <code>content := "web-1\nweb-2\nweb-3\napi-1\ndb-1"</code>, split it into lines and print how many
            lines there are.
          hints:
            - "Use <code>strings.Split(content, \"\\n\")</code> to split on newlines."
            - "Then use <code>len()</code> on the resulting slice."
          solution: |-
            content := "web-1\nweb-2\nweb-3\napi-1\ndb-1"
            lines := strings.Split(content, "\n")
            fmt.Println(len(lines)) // 5
        - id: v1
          title: Extract Non-Empty Lines
          description: >-
            Given a multi-line string <code>content := "alpha\n\nbeta\n\n\ngamma\n"</code>, split it into lines,
            skip empty lines, and collect the non-empty ones into a slice. Print the result.
          hints:
            - "Split on newlines first, then filter. What does an empty line look like after trimming?"
            - "Loop through the lines, trim each one, and only append non-empty ones to your result slice."
          solution: |-
            content := "alpha\n\nbeta\n\n\ngamma\n"
            var result []string
            for _, line := range strings.Split(content, "\n") {
                line = strings.TrimSpace(line)
                if line != "" {
                    result = append(result, line)
                }
            }
            fmt.Println(result) // [alpha beta gamma]
        - id: v2
          title: Skip Comments
          description: |-
            Given a config string:
            <pre>"# database config\nhost=localhost\n# port\nport=5432\nname=mydb"</pre>
            Split into lines, skip lines starting with <code>#</code> and empty lines, and print each remaining line.
          hints:
            - "After trimming, check two conditions: is it empty? Does it start with <code>#</code>? Skip both."
            - "Use <code>strings.HasPrefix</code> to check for the comment character."
          solution: |-
            content := "# database config\nhost=localhost\n# port\nport=5432\nname=mydb"
            for _, line := range strings.Split(content, "\n") {
                line = strings.TrimSpace(line)
                if line == "" || strings.HasPrefix(line, "#") {
                    continue
                }
                fmt.Println(line)
            }
        - id: v3
          title: First and Last Line
          description: >-
            Given <code>content := "alpha\nbeta\ngamma\ndelta"</code>, split it into lines and print the first line and
            the last line.
          hints:
            - "Use <code>strings.Split(content, \"\\n\")</code> to get all lines as a slice."
            - "Think about how you access the first and last elements of any slice."
          solution: |-
            content := "alpha\nbeta\ngamma\ndelta"
            lines := strings.Split(content, "\n")
            fmt.Println(lines[0])              // alpha
            fmt.Println(lines[len(lines)-1])   // delta
    - id: warmup_8
      concept: Combining Patterns
      variants:
        - id: v1
          title: Pod Status Summary
          description: >-
            Given <code>statuses := []string{"Running", "Failed", "Running", "Pending", "Running", "Failed"}</code>,
            count each status with a map and print the results sorted alphabetically by status name.
            Format each line as <code>"status: count"</code>.
          hints:
            - "Two patterns back to back: counting with a map, then sorted-keys iteration."
            - "After counting, collect keys into a slice, <code>sort.Strings</code>, then loop the sorted keys to print."
          solution: |-
            statuses := []string{"Running", "Failed", "Running", "Pending", "Running", "Failed"}
            counts := make(map[string]int)
            for _, s := range statuses {
                counts[s]++
            }
            keys := make([]string, 0, len(counts))
            for k := range counts {
                keys = append(keys, k)
            }
            sort.Strings(keys)
            for _, k := range keys {
                fmt.Printf("%s: %d\n", k, counts[k])
            }
        - id: v2
          title: Most Common Log Level
          description: >-
            Given log lines <code>["INFO request started", "ERROR timeout", "INFO done", "ERROR OOM", "WARN
            slow"]</code>, parse the first word of each line as the level, count occurrences, and print the most
            common level and its count. Format: <code>"INFO: 2"</code>.
          hints:
            - "Parse each line with <code>strings.Fields</code> to get the first word. Count with a map."
            - "After counting, loop the map to find the key with the highest value — track both the max count and its key."
          solution: |-
            lines := []string{"INFO request started", "ERROR timeout", "INFO done", "ERROR OOM", "WARN slow"}
            counts := make(map[string]int)
            for _, line := range lines {
                fields := strings.Fields(line)
                if len(fields) > 0 {
                    counts[fields[0]]++
                }
            }
            maxLevel := ""
            maxCount := 0
            for level, count := range counts {
                if count > maxCount {
                    maxCount = count
                    maxLevel = level
                }
            }
            fmt.Printf("%s: %d\n", maxLevel, maxCount)
        - id: v3
          title: Parse and Group Config
          description: >-
            Given config lines <code>["host=web-1", "env=prod", "host=web-2", "env=staging", "host=db-1",
            "env=prod"]</code>, parse each key=value pair and group the values by key. Print each key and its
            values, sorted alphabetically by key.
          hints:
            - "Combine <code>SplitN</code> parsing with map grouping: <code>map[string][]string</code>."
            - "After grouping, use the sorted-keys pattern to print in deterministic order."
          solution: |-
            lines := []string{"host=web-1", "env=prod", "host=web-2", "env=staging", "host=db-1", "env=prod"}
            groups := make(map[string][]string)
            for _, line := range lines {
                parts := strings.SplitN(line, "=", 2)
                if len(parts) == 2 {
                    groups[parts[0]] = append(groups[parts[0]], parts[1])
                }
            }
            keys := make([]string, 0, len(groups))
            for k := range groups {
                keys = append(keys, k)
            }
            sort.Strings(keys)
            for _, k := range keys {
                fmt.Printf("%s: %v\n", k, groups[k])
            }
        - id: v4
          title: Error Rate from Logs
          description: >-
            Given log lines where the first word is the level (INFO, ERROR, WARN), count total lines and ERROR
            lines, then print the error percentage with one decimal place.
            Input: <code>["INFO ok", "ERROR bad", "INFO fine", "ERROR oom", "WARN slow"]</code>.
            Expected: <code>"Error rate: 40.0%"</code>.
          hints:
            - "This combines parsing (<code>strings.Fields</code>), counting, and percentage calculation."
            - "Count errors in the loop, then compute <code>float64(errors) / float64(total) * 100</code> and format with <code>%.1f%%</code>."
          solution: |-
            lines := []string{"INFO ok", "ERROR bad", "INFO fine", "ERROR oom", "WARN slow"}
            errors := 0
            for _, line := range lines {
                fields := strings.Fields(line)
                if len(fields) > 0 && fields[0] == "ERROR" {
                    errors++
                }
            }
            pct := float64(errors) / float64(len(lines)) * 100
            fmt.Printf("Error rate: %.1f%%\n", pct)
  challenges:
    - id: challenge_1
      block: 1
      difficulty: 1
      concept: Map Patterns
      docLinks:
        - url: https://pkg.go.dev/sort#Slice
          title: sort.Slice documentation
          note: custom sorting
      variants:
        - id: v1
          title: Error Rate Calculator
          description: >-
            Write <code>func errorRate(lines []string) float64</code> that takes log lines in the format <code>"LEVEL
            message"</code> and returns the percentage of lines that are ERROR level (0.0 to 100.0, rounded to one
            decimal). Return 0.0 for empty input.
          functionSignature: func errorRate(lines []string) float64
          difficulty: 1
          testCases:
            - input: errorRate([]string{"INFO ok", "ERROR bad", "INFO ok2", "ERROR oom", "WARN slow"})
              output: "40.0"
            - input: errorRate([]string{"ERROR a", "ERROR b"})
              output: "100.0"
            - input: errorRate([]string{})
              output: "0.0"
          hints:
            - title: Think about it
              content: You need two numbers — how many errors and how many total lines. What do you do with those to get a percentage?
            - title: Hint
              content: >-
                Extract the first word from each line to check its level. For the percentage, remember that dividing two
                ints truncates — you need floats. Check the Numbers section in the lesson for how to round to one decimal.
          solution: |-
            func errorRate(lines []string) float64 {
                if len(lines) == 0 {
                    return 0.0
                }
                errors := 0
                for _, line := range lines {
                    fields := strings.Fields(line)
                    if len(fields) > 0 && fields[0] == "ERROR" {
                        errors++
                    }
                }
                rate := float64(errors) / float64(len(lines)) * 100
                return math.Round(rate*10) / 10
            }
        - id: v2
          title: Log Level Report
          description: >-
            Write <code>func logReport(lines []string) string</code> that takes log lines in the format <code>"LEVEL
            message text"</code> and returns a report string with each level and its count, sorted alphabetically
            by level name.
          functionSignature: func logReport(lines []string) string
          difficulty: 2
          testCases:
            - input: logReport([]string{"INFO ok", "ERROR bad", "INFO ok2", "WARN slow", "ERROR oom"})
              output: "\"ERROR: 2\\nINFO: 2\\nWARN: 1\""
            - input: logReport([]string{"DEBUG x", "DEBUG y", "DEBUG z"})
              output: "\"DEBUG: 3\""
            - input: logReport([]string{})
              output: "\"\""
          hints:
            - title: Think about it
              content: >-
                You need two steps: counting and sorting. What data structure counts things? Since maps iterate
                in random order, how do you output alphabetically?
            - title: Hint
              content: >-
                This follows the count → sort-keys → format pattern from the Putting It Together section. Count
                with a map, collect keys into a slice, sort.Strings, then format each entry.
          solution: |-
            func logReport(lines []string) string {
                if len(lines) == 0 {
                    return ""
                }
                counts := make(map[string]int)
                for _, line := range lines {
                    fields := strings.Fields(line)
                    if len(fields) > 0 {
                        counts[fields[0]]++
                    }
                }
                keys := make([]string, 0, len(counts))
                for k := range counts {
                    keys = append(keys, k)
                }
                sort.Strings(keys)
                parts := make([]string, len(keys))
                for i, k := range keys {
                    parts[i] = fmt.Sprintf("%s: %d", k, counts[k])
                }
                return strings.Join(parts, "\n")
            }
          annotations:
            - type: pattern
              label: Count-SortKeys-Format
              text: >-
                This three-step pattern (count with map → sort keys → format output) appears everywhere in infra tooling. Log
                analysis, metric aggregation, resource reporting — same shape.
        - id: v3
          title: Level Frequency with Percentages
          description: >-
            Write <code>func logFrequency(lines []string) string</code> that takes log lines and returns a report with
            each level, its count, AND its percentage of total, sorted alphabetically by level name.<br><br>Format: <code>"ERROR:
            2 (66.7%)\nINFO: 1 (33.3%)"</code>
          functionSignature: func logFrequency(lines []string) string
          difficulty: 3
          testCases:
            - input: logFrequency([]string{"INFO a", "ERROR b", "ERROR c"})
              output: "\"ERROR: 2 (66.7%)\\nINFO: 1 (33.3%)\""
          hints:
            - title: Think about it
              content: >-
                This builds on the Log Level Report — same count → sort-keys → format pattern. The extra step is
                computing a percentage for each level. How do you format a float to one decimal place with a percent sign?
            - title: Hint
              content: >-
                Reuse the count → sort-keys → format pattern. The percentage is each level's count divided by total lines. See the
                Numbers section for float conversion, and the Printing section for the format verb that outputs one decimal
                place and a literal percent sign.
          solution: |-
            func logFrequency(lines []string) string {
                if len(lines) == 0 {
                    return ""
                }
                counts := make(map[string]int)
                for _, line := range lines {
                    fields := strings.Fields(line)
                    if len(fields) > 0 {
                        counts[fields[0]]++
                    }
                }
                keys := make([]string, 0, len(counts))
                for k := range counts {
                    keys = append(keys, k)
                }
                sort.Strings(keys)
                total := len(lines)
                parts := make([]string, len(keys))
                for i, k := range keys {
                    pct := float64(counts[k]) / float64(total) * 100
                    parts[i] = fmt.Sprintf("%s: %d (%.1f%%)", k, counts[k], pct)
                }
                return strings.Join(parts, "\n")
            }
    - id: challenge_2
      block: 2
      difficulty: 2
      concept: String Parsing
      variants:
        - id: v1
          title: Parse Metric Labels
          description: >-
            Write <code>func parseLabels(s string) map[string]string</code> that takes a Prometheus-style label string
            like <code>method="GET",status="200"</code> and returns a map of label keys to values (without
            quotes).
          functionSignature: func parseLabels(s string) map[string]string
          difficulty: 1
          testCases:
            - input: parseLabels("method=\"GET\",status=\"200\"")
              output: map[method:GET status:200]
            - input: parseLabels("app=\"nginx\"")
              output: map[app:nginx]
            - input: parseLabels("")
              output: map[]
          hints:
            - title: Think about it
              content: >-
                Two levels of splitting: first separate the individual pairs, then separate key from value within each
                pair. What character separates pairs? What separates key from value?
            - title: Hint
              content: >-
                After splitting each pair on <code>=</code>, the value still has quotes around it. You need to strip those.
                Don't forget to handle empty input.
          solution: |-
            func parseLabels(s string) map[string]string {
                result := make(map[string]string)
                if s == "" {
                    return result
                }
                pairs := strings.Split(s, ",")
                for _, pair := range pairs {
                    parts := strings.SplitN(pair, "=", 2)
                    if len(parts) == 2 {
                        key := parts[0]
                        val := strings.Trim(parts[1], "\"")
                        result[key] = val
                    }
                }
                return result
            }
          annotations:
            - type: infra
              label: Prometheus Format
              text: >-
                This is the actual format Prometheus uses for metric labels. Tools like <code>promtool</code> parse this
                exact syntax.
        - id: v2
          title: Parse Full Metric Line
          description: >-
            Write <code>func parseMetric(line string) (string, map[string]string, float64, error)</code> that parses a
            full Prometheus metric line like <code>http_requests_total{method="GET",status="200"} 1027</code> and
            returns the metric name, labels map, value, and any error.<br><br>Handle metrics with no labels too:
            <code>up 1</code> → name="up", empty labels, value=1.
          functionSignature: func parseMetric(line string) (string, map[string]string, float64, error)
          difficulty: 2
          testCases:
            - input: parseMetric("http_requests{method=\"GET\"} 42")
              output: "\"http_requests\", map[method:GET], 42.0, nil"
            - input: parseMetric("up 1")
              output: "\"up\", map[], 1.0, nil"
          hints:
            - title: Think about it
              content: >-
                There are two formats: with labels (<code>name{labels} value</code>) and without (<code>name
                value</code>). How can you tell which format a line is? Handle them separately.
            - title: Hint
              content: >-
                For the labeled format, find the braces to identify three sections: the name (before <code>{</code>), the
                labels (between the braces), and the value (after <code>}</code>). You can reuse your label parser from
                the easier variant.
          solution: |-
            func parseMetric(line string) (string, map[string]string, float64, error) {
                labels := make(map[string]string)
                if strings.Contains(line, "{") {
                    nameEnd := strings.Index(line, "{")
                    name := line[:nameEnd]
                    labelsEnd := strings.Index(line, "}")
                    labelStr := line[nameEnd+1 : labelsEnd]
                    if labelStr != "" {
                        pairs := strings.Split(labelStr, ",")
                        for _, pair := range pairs {
                            parts := strings.SplitN(pair, "=", 2)
                            if len(parts) == 2 {
                                labels[parts[0]] = strings.Trim(parts[1], "\"")
                            }
                        }
                    }
                    valStr := strings.TrimSpace(line[labelsEnd+1:])
                    val, err := strconv.ParseFloat(valStr, 64)
                    if err != nil {
                        return "", nil, 0, err
                    }
                    return name, labels, val, nil
                }
                parts := strings.Fields(line)
                if len(parts) != 2 {
                    return "", nil, 0, fmt.Errorf("invalid metric line: %s", line)
                }
                val, err := strconv.ParseFloat(parts[1], 64)
                if err != nil {
                    return "", nil, 0, err
                }
                return parts[0], labels, val, nil
            }
          annotations:
            - type: complexity
              label: String Scanning
              text: >-
                This solution scans the string multiple times with Index calls. For a real metrics parser handling
                millions of lines, you'd use a single-pass scanner. For now, clarity wins over performance.
            - type: interview
              label: String Parsing
              text: >-
                Parsing structured text is a very common interview question. The key skill is breaking it into clear
                steps: find boundaries, extract parts, parse values.
        - id: v3
          title: Aggregate Metrics by Name
          description: >-
            Write <code>func aggregateMetrics(lines []string) map[string]float64</code> that parses multiple Prometheus
            metric lines and sums values by metric name (ignoring labels).
          functionSignature: func aggregateMetrics(lines []string) map[string]float64
          difficulty: 3
          testCases:
            - input: aggregateMetrics([]string{"req{m=\"GET\"} 10", "req{m=\"POST\"} 5", "up 1"})
              output: map[req:15 up:1]
          hints:
            - title: Think about it
              content: >-
                You already have a metric parser. Now you need to loop through lines, parse each one, and accumulate
                values. What map type stores running totals by name?
            - title: Hint
              content: >-
                Reuse your metric parser from the previous variant. Skip lines that fail to parse or that are comments.
                The accumulation pattern is the same as counting, but with addition instead of increment.
          solution: |-
            func aggregateMetrics(lines []string) map[string]float64 {
                totals := make(map[string]float64)
                for _, line := range lines {
                    line = strings.TrimSpace(line)
                    if line == "" || strings.HasPrefix(line, "#") {
                        continue
                    }
                    name, _, val, err := parseMetric(line)
                    if err != nil {
                        continue
                    }
                    totals[name] += val
                }
                return totals
            }
    - id: challenge_3
      block: 3
      difficulty: 2
      concept: Sorting & Filtering
      variants:
        - id: v1
          title: Sort Pods by Name
          description: >-
            Write <code>func sortPodNames(names []string) []string</code> that returns the input slice sorted
            alphabetically. Sort in place and return the same slice.
          functionSignature: func sortPodNames(names []string) []string
          difficulty: 1
          testCases:
            - input: sortPodNames([]string{"web-3", "api-1", "db-2", "web-1"})
              output: "[\"api-1\", \"db-2\", \"web-1\", \"web-3\"]"
          hints:
            - title: Think about it
              content: "Go's sort package has a convenience function specifically for string slices. Check the Sorting section of the lesson."
            - title: Hint
              content: "It's a one-liner. The function sorts in place, then you return the same slice."
          solution: |-
            func sortPodNames(names []string) []string {
                sort.Strings(names)
                return names
            }
        - id: v2
          title: Filter and Sort Pods
          description: >-
            Write <code>func filterSorted(names []string, prefix string) []string</code> that returns all names
            starting with <code>prefix</code>, sorted alphabetically.
          functionSignature: func filterSorted(names []string, prefix string) []string
          difficulty: 2
          testCases:
            - input: filterSorted([]string{"web-3","api-1","db-2","web-1","api-2"}, "web")
              output: "[\"web-1\", \"web-3\"]"
            - input: filterSorted([]string{"web-3","api-1","db-2","web-1","api-2"}, "db")
              output: "[\"db-2\"]"
            - input: filterSorted([]string{"a","b"}, "z")
              output: "[]"
          hints:
            - title: Think about it
              content: >-
                Two operations: filter matching names into a new slice, then sort that slice.
            - title: Hint
              content: >-
                Use <code>strings.HasPrefix</code> to check each name. Collect matches into a result slice,
                then <code>sort.Strings(result)</code> before returning.
          solution: |-
            func filterSorted(names []string, prefix string) []string {
                var result []string
                for _, name := range names {
                    if strings.HasPrefix(name, prefix) {
                        result = append(result, name)
                    }
                }
                sort.Strings(result)
                return result
            }
          annotations:
            - type: pattern
              label: Filter-then-Sort
              text: >-
                Filter first, sort second. Sorting after filtering means you sort a smaller slice — more efficient
                and the code is clearer.
        - id: v3
          title: Sorted Key-Value Report
          description: >-
            Write <code>func kvReport(lines []string) string</code> that takes lines in <code>"key=value"</code>
            format, parses them, and returns a formatted report sorted by key. Skip malformed lines (no <code>=</code>).
            Format each line as <code>"  key: value"</code> (two-space indent).
          functionSignature: func kvReport(lines []string) string
          difficulty: 3
          testCases:
            - input: kvReport([]string{"port=8080", "host=localhost", "db=myapp"})
              output: "\"  db: myapp\\n  host: localhost\\n  port: 8080\""
            - input: kvReport([]string{"z=1", "a=2"})
              output: "\"  a: 2\\n  z: 1\""
          hints:
            - title: Think about it
              content: >-
                Parse into a map (SplitN on "="), then use the sorted-keys pattern to output in order.
            - title: Hint
              content: >-
                This combines line parsing, map storage, sorted-keys iteration, and formatted output —
                the full parse → store → sort → format pipeline from the Putting It Together section.
          solution: |-
            func kvReport(lines []string) string {
                kv := make(map[string]string)
                for _, line := range lines {
                    parts := strings.SplitN(line, "=", 2)
                    if len(parts) != 2 {
                        continue
                    }
                    kv[parts[0]] = parts[1]
                }
                keys := make([]string, 0, len(kv))
                for k := range kv {
                    keys = append(keys, k)
                }
                sort.Strings(keys)
                result := make([]string, len(keys))
                for i, k := range keys {
                    result[i] = fmt.Sprintf("  %s: %s", k, kv[k])
                }
                return strings.Join(result, "\n")
            }
          annotations:
            - type: pattern
              label: Parse-Store-Sort-Format
              text: >-
                Parse into a map, sort keys, format output. This is the same pipeline as the Putting It Together
                capstone — you'll use this shape constantly in infra tooling.
    - id: challenge_4
      block: 4
      difficulty: 2
      concept: String Parsing
      variants:
        - id: v1
          title: Parse Env File
          description: >-
            Write <code>func parseEnvFile(content string) map[string]string</code> that parses a <code>.env</code> file.
            Rules:<br>• Each line is <code>KEY=VALUE</code><br>• Lines starting with <code>#</code> are comments
            (skip)<br>• Empty lines are skipped<br>• Trim whitespace on keys and values<br>• Strip optional surrounding
            double quotes from values
          functionSignature: func parseEnvFile(content string) map[string]string
          difficulty: 1
          testCases:
            - input: parseEnvFile("A=1\nB=2")
              output: map[A:1 B:2]
            - input: parseEnvFile("# comment\nKEY=\"value\"")
              output: map[KEY:value]
            - input: parseEnvFile("  HOST = localhost  ")
              output: map[HOST:localhost]
          hints:
            - title: Think about it
              content: >-
                This follows the standard line-by-line parsing pattern: split into lines, decide what to skip, parse the
                rest. What kinds of lines should be skipped?
            - title: Hint
              content: >-
                The Line-by-Line Parsing section in the lesson walks through this exact pattern with a complete example.
                The key steps are: split lines, trim whitespace, skip empties and comments, split key from value, clean
                up the value.
          solution: |-
            func parseEnvFile(content string) map[string]string {
                result := make(map[string]string)
                lines := strings.Split(content, "\n")
                for _, line := range lines {
                    line = strings.TrimSpace(line)
                    if line == "" || strings.HasPrefix(line, "#") {
                        continue
                    }
                    parts := strings.SplitN(line, "=", 2)
                    if len(parts) != 2 {
                        continue
                    }
                    key := strings.TrimSpace(parts[0])
                    val := strings.TrimSpace(parts[1])
                    val = strings.Trim(val, "\"")
                    result[key] = val
                }
                return result
            }
          annotations:
            - type: infra
              label: .env Files
              text: >-
                This is the exact format used by Docker Compose, systemd EnvironmentFile, and tools like direnv. You'll
                parse this format in real infra code.
        - id: v2
          title: Parse INI Sections
          description: >-
            Write <code>func parseINI(content string) map[string]map[string]string</code> that parses a simple INI file.
            Rules:<br>• Section headers: <code>[section_name]</code><br>• Key-value pairs: <code>key = value</code>
            under the current section<br>• Lines before any section go under <code>"default"</code><br>• Comments
            (<code>#</code>) and empty lines are skipped
          functionSignature: func parseINI(content string) map[string]map[string]string
          difficulty: 2
          testCases:
            - input: parseINI("[db]\nhost=localhost")
              output: map[db:map[host:localhost]]
            - input: parseINI("key=val\n[s]\nk=v")
              output: map[default:map[key:val] s:map[k:v]]
          hints:
            - title: Think about it
              content: >-
                This builds on the line-by-line pattern with one extra idea: you need to track which section you're
                currently in. When you see a section header, update the tracker. When you see a key-value pair, file it
                under the current section.
            - title: Hint
              content: >-
                The return type is a nested map. Be careful — writing to an inner map that hasn't been initialized will
                panic. Check the Nested Maps section of the lesson for how to handle this safely.
          solution: |-
            func parseINI(content string) map[string]map[string]string {
                result := make(map[string]map[string]string)
                currentSection := "default"
                lines := strings.Split(content, "\n")
                for _, line := range lines {
                    line = strings.TrimSpace(line)
                    if line == "" || strings.HasPrefix(line, "#") {
                        continue
                    }
                    if strings.HasPrefix(line, "[") && strings.HasSuffix(line, "]") {
                        currentSection = line[1 : len(line)-1]
                        continue
                    }
                    parts := strings.SplitN(line, "=", 2)
                    if len(parts) != 2 {
                        continue
                    }
                    key := strings.TrimSpace(parts[0])
                    val := strings.TrimSpace(parts[1])
                    if result[currentSection] == nil {
                        result[currentSection] = make(map[string]string)
                    }
                    result[currentSection][key] = val
                }
                return result
            }
          annotations:
            - type: pattern
              label: State Machine Parsing
              text: >-
                Tracking "current section" as you iterate is a simple state machine. The same pattern works for parsing
                Dockerfiles (current stage), Terraform configs (current block), and K8s multi-doc YAML (current
                document).
        - id: v3
          title: INI with Environment Variable Expansion
          description: >-
            Write <code>func parseINIExpand(content string, env map[string]string) map[string]map[string]string</code>
            that parses an INI file like above, but also expands <code>${VAR}</code> references in values using the
            provided env map. Unknown variables become empty strings.
          functionSignature: func parseINIExpand(content string, env map[string]string) map[string]map[string]string
          difficulty: 3
          testCases:
            - input: "parseINIExpand(\"[db]\\nhost=${DB_HOST}\\nport=5432\", map[string]string{\"DB_HOST\": \"prod-db\"})"
              output: map[db:map[host:prod-db port:5432]]
          hints:
            - title: Think about it
              content: >-
                Build on your INI parser. After extracting each value, you need to find <code>${...}</code> patterns and
                replace them with lookups from the env map.
            - title: Hint
              content: >-
                Go's stdlib has a function in the <code>os</code> package that does variable expansion with a custom
                lookup function. Check <code>go doc os.Expand</code> — it handles both <code>${VAR}</code> and
                <code>$VAR</code> syntax.
          solution: |-
            func parseINIExpand(content string, env map[string]string) map[string]map[string]string {
                result := make(map[string]map[string]string)
                currentSection := "default"
                lines := strings.Split(content, "\n")
                for _, line := range lines {
                    line = strings.TrimSpace(line)
                    if line == "" || strings.HasPrefix(line, "#") {
                        continue
                    }
                    if strings.HasPrefix(line, "[") && strings.HasSuffix(line, "]") {
                        currentSection = line[1 : len(line)-1]
                        continue
                    }
                    parts := strings.SplitN(line, "=", 2)
                    if len(parts) != 2 {
                        continue
                    }
                    key := strings.TrimSpace(parts[0])
                    val := strings.TrimSpace(parts[1])
                    val = os.Expand(val, func(k string) string {
                        return env[k]
                    })
                    if result[currentSection] == nil {
                        result[currentSection] = make(map[string]string)
                    }
                    result[currentSection][key] = val
                }
                return result
            }
          annotations:
            - type: stdlib
              label: os.Expand
              text: >-
                Go's <code>os.Expand</code> handles <code>${VAR}</code> and <code>$VAR</code> expansion with a custom
                mapping function. Much cleaner than regex. Used internally by Docker and other tools.
  scaffolds:
    - id: scaffold_swap
      concept: "In-Place Manipulation"
      variants:
        - id: v1
          type: trace
          title: "Predict the Swap"
          description: |-
            Trace through this code and predict the output:
            <pre>nums := []int{10, 20, 30}
            nums[0], nums[2] = nums[2], nums[0]
            fmt.Println(nums)</pre>
          solution: "[30 20 10]"
        - id: v2
          type: fix
          title: "Fix the Broken Swap"
          description: |-
            This code tries to swap the first and last elements, but it prints <code>[30 20 30]</code> instead of <code>[30 20 10]</code>. Why?
            <pre>nums := []int{10, 20, 30}
            nums[0] = nums[2]
            nums[2] = nums[0]
            fmt.Println(nums)</pre>
            Fix it so both values actually swap.
          hints: ["After <code>nums[0] = nums[2]</code> runs, what is <code>nums[0]</code>? The original 10 is gone."]
          solution: |-
            // The original nums[0] is overwritten before nums[2] reads it.
            // Fix: use simultaneous assignment so both sides read before writing.
            nums[0], nums[2] = nums[2], nums[0]
        - id: v3
          type: complete
          title: "Complete the Swap"
          description: |-
            Fill in the blank to swap index 1 and 3:
            <pre>vals := []string{"a", "b", "c", "d"}
            ____________________________
            fmt.Println(vals) // [a d c b]</pre>
          solution: 'vals[1], vals[3] = vals[3], vals[1]'
        - id: v4
          type: produce
          title: "Swap Two Elements"
          description: >-
            Given <code>nums := []int{10, 20, 30}</code>, swap index 0 and 2 in a single statement. Print the result.
          hints: ["Go supports simultaneous assignment: <code>a, b = b, a</code>"]
          solution: |-
            nums := []int{10, 20, 30}
            nums[0], nums[2] = nums[2], nums[0]
            fmt.Println(nums) // [30 20 10]
    - id: scaffold_swap_t
      concept: "In-Place Manipulation"
      template:
        type: produce
        title: "Swap in {{name}}"
        description: "Given <code>{{name}} := {{value}}</code>, swap index {{i}} and {{j}}. Print the result."
        hints: ["Use <code>{{name}}[{{i}}], {{name}}[{{j}}] = {{name}}[{{j}}], {{name}}[{{i}}]</code>"]
        solution: |-
          {{name}} := {{value}}
          {{name}}[{{i}}], {{name}}[{{j}}] = {{name}}[{{j}}], {{name}}[{{i}}]
          fmt.Println({{name}})
      params:
        - { name: colors, value: '[]string{"red", "green", "blue"}', i: "0", j: "2" }
        - { name: scores, value: '[]int{88, 95, 72}', i: "0", j: "1" }
    - id: scaffold_reverse
      concept: "In-Place Manipulation"
      variants:
        - id: v1
          type: trace
          title: "Predict the Reverse"
          description: |-
            Trace through this two-pointer loop and predict the output:
            <pre>s := []int{1, 2, 3, 4}
            for i, j := 0, len(s)-1; i < j; i, j = i+1, j-1 {
                s[i], s[j] = s[j], s[i]
            }
            fmt.Println(s)</pre>
          solution: "[4 3 2 1]"
        - id: v2
          type: fix
          title: "Fix the Reverse Loop"
          description: |-
            This reverse loop runs too many iterations and double-reverses back to the original order. Fix the loop condition:
            <pre>s := []string{"a", "b", "c", "d"}
            for i, j := 0, len(s)-1; i < len(s); i, j = i+1, j-1 {
                s[i], s[j] = s[j], s[i]
            }
            fmt.Println(s) // prints [a b c d] — unchanged!</pre>
          hints: ["The loop should stop when the two pointers meet in the middle, not when i reaches the end."]
          solution: |-
            // i < len(s) makes i go all the way across, swapping everything
            // back to where it started. Stop when pointers meet:
            for i, j := 0, len(s)-1; i < j; i, j = i+1, j-1 {
                s[i], s[j] = s[j], s[i]
            }
        - id: v3
          type: complete
          title: "Complete the Reverse"
          description: |-
            Fill in the four blanks to reverse this slice in place:
            <pre>items := []string{"x", "y", "z", "w"}
            for i, j := _____, _____; i < j; _____, _____ {
                items[i], items[j] = items[j], items[i]
            }</pre>
          solution: |-
            for i, j := 0, len(items)-1; i < j; i, j = i+1, j-1 {
                items[i], items[j] = items[j], items[i]
            }
        - id: v4
          type: produce
          title: "Reverse a Server List"
          description: >-
            Given <code>servers := []string{"a", "b", "c", "d"}</code>, reverse it in place (no new slice) and print the result.
          hints: ["Use two pointers starting from opposite ends. Swap and move inward until they meet."]
          solution: |-
            servers := []string{"a", "b", "c", "d"}
            for i, j := 0, len(servers)-1; i < j; i, j = i+1, j-1 {
                servers[i], servers[j] = servers[j], servers[i]
            }
            fmt.Println(servers) // [d c b a]
    - id: scaffold_filter
      concept: "In-Place Manipulation"
      variants:
        - id: v1
          type: trace
          title: "Predict the Filter"
          description: |-
            Trace through the write-index pattern and predict the output:
            <pre>nums := []int{1, 2, 3, 4, 5, 6}
            n := 0
            for _, v := range nums {
                if v%2 == 0 {
                    nums[n] = v
                    n++
                }
            }
            nums = nums[:n]
            fmt.Println(nums)</pre>
          solution: "[2 4 6]"
        - id: v2
          type: complete
          title: "Complete the Filter"
          description: |-
            Fill in the three blanks to filter in place, keeping only strings starting with "web":
            <pre>pods := []string{"web-1", "api-1", "web-2", "db-1"}
            n := 0
            for _, p := range pods {
                if ________________________ {
                    _____________
                    _____________
                }
            }
            pods = pods[:n]</pre>
          solution: |-
            if strings.HasPrefix(p, "web") {
                pods[n] = p
                n++
            }
        - id: v3
          type: produce
          title: "Filter Tags In Place"
          description: >-
            Given <code>tags := []string{"v1.0", "latest", "v2.0", "dev"}</code>, remove all non-version tags
            in place (keep only tags starting with "v"). Print the result.
          hints: ["Use the write-index pattern: <code>n</code> tracks where to write, the loop reads every element. Truncate at the end."]
          solution: |-
            tags := []string{"v1.0", "latest", "v2.0", "dev"}
            n := 0
            for _, tag := range tags {
                if strings.HasPrefix(tag, "v") {
                    tags[n] = tag
                    n++
                }
            }
            tags = tags[:n]
            fmt.Println(tags) // [v1.0 v2.0]
    - id: scaffold_sort
      concept: "Sorting & Filtering"
      variants:
        - id: v1
          type: trace
          title: "Predict the Sort"
          description: |-
            The <code>></code> comparator sorts descending. What does this print?
            <pre>nums := []int{3, 1, 4, 1, 5}
            sort.Slice(nums, func(i, j int) bool {
                return nums[i] > nums[j]
            })
            fmt.Println(nums)</pre>
          solution: "[5 4 3 1 1]"
        - id: v2
          type: fix
          title: "Fix the Sort Order"
          description: |-
            This should sort names A-Z, but it outputs <code>[charlie bob alice]</code>. Fix the comparator:
            <pre>names := []string{"charlie", "alice", "bob"}
            sort.Slice(names, func(i, j int) bool {
                return names[i] > names[j]
            })</pre>
          hints: ["<code>></code> means 'i comes first if it's larger' — that's descending. What operator gives ascending?"]
          solution: |-
            // Change > to < for ascending (A-Z) order:
            sort.Slice(names, func(i, j int) bool {
                return names[i] < names[j]
            })
        - id: v3
          type: complete
          title: "Complete the Sort"
          description: |-
            Fill in the comparator to sort response times ascending (fastest first):
            <pre>times := []int{234, 12, 891, 45}
            sort.Slice(times, func(i, j int) bool {
                return _______________________
            })
            fmt.Println(times) // [12 45 234 891]</pre>
          solution: "times[i] < times[j]"
        - id: v4
          type: produce
          title: "Sort Scores Ascending"
          description: >-
            Given <code>scores := []int{42, 7, 89, 23}</code>, sort them smallest-first using <code>sort.Slice</code> and print the result.
          hints: ["The comparator returns true when element i should come before element j. For ascending, that means i < j."]
          solution: |-
            scores := []int{42, 7, 89, 23}
            sort.Slice(scores, func(i, j int) bool {
                return scores[i] < scores[j]
            })
            fmt.Println(scores) // [7 23 42 89]
    - id: scaffold_sort_t
      concept: "Sorting & Filtering"
      template:
        type: produce
        title: "Sort {{name}}"
        description: "Given <code>{{name}} := {{value}}</code>, sort in {{order}} order and print the result."
        hints: ["Use <code>sort.Slice</code> with <code>{{name}}[i] {{op}} {{name}}[j]</code>"]
        solution: |-
          {{name}} := {{value}}
          sort.Slice({{name}}, func(i, j int) bool {
              return {{name}}[i] {{op}} {{name}}[j]
          })
          fmt.Println({{name}})
      params:
        - { name: ages, value: '[]int{25, 18, 42, 31}', order: ascending, op: "<" }
        - { name: prices, value: '[]float64{9.99, 4.50, 15.00, 7.25}', order: descending, op: ">" }
    - id: scaffold_topn
      concept: "Sorting & Filtering"
      variants:
        - id: v1
          type: trace
          title: "Predict Top 2"
          description: |-
            Sort descending, then slice. What does this print?
            <pre>vals := []int{10, 50, 30, 20, 40}
            sort.Slice(vals, func(i, j int) bool {
                return vals[i] > vals[j]
            })
            fmt.Println(vals[:2])</pre>
          solution: "[50 40]"
        - id: v2
          type: complete
          title: "Complete Top N"
          description: |-
            Fill in the two blanks to get the top 3 highest latencies:
            <pre>latencies := []int{234, 12, 891, 45, 567}
            sort.Slice(latencies, func(i, j int) bool {
                return _______________________
            })
            top3 := latencies[:___]
            fmt.Println(top3)</pre>
          solution: |-
            latencies[i] > latencies[j]
            // and
            latencies[:3]
        - id: v3
          type: produce
          title: "Find the Top 2"
          description: >-
            Given <code>scores := []int{42, 7, 89, 23, 56}</code>, find and print the 2 highest values.
          hints: ["Sort the slice in descending order, then take a slice of the first 2 elements."]
          solution: |-
            scores := []int{42, 7, 89, 23, 56}
            sort.Slice(scores, func(i, j int) bool {
                return scores[i] > scores[j]
            })
            fmt.Println(scores[:2]) // [89 56]
    - id: scaffold_slice_ops
      concept: "Slice Operations"
      variants:
        - id: v1
          type: trace
          title: "Predict the Slice"
          description: |-
            What does this print?
            <pre>s := []string{"a", "b", "c", "d", "e"}
            fmt.Println(s[1:4])
            fmt.Println(s[:2])
            fmt.Println(s[3:])</pre>
          solution: |-
            [b c d]
            [a b]
            [d e]
        - id: v2
          type: fix
          title: "Fix the Slice Bounds"
          description: |-
            This code should print the last 3 elements, but it panics with an out-of-range error:
            <pre>items := []string{"a", "b", "c", "d", "e"}
            last3 := items[len(items)-3 : len(items)+1]
            fmt.Println(last3)</pre>
            Fix the slice expression.
          hints: ["The end index in a slice expression is exclusive — it goes up to but not including that index."]
          solution: |-
            // End index must be <= len(items), not len(items)+1
            last3 := items[len(items)-3:]
        - id: v3
          type: complete
          title: "Complete the Slice"
          description: |-
            Fill in the blank to get elements at index 1 and 2:
            <pre>nodes := []string{"a", "b", "c", "d"}
            mid := nodes[___:___]
            fmt.Println(mid) // [b c]</pre>
          solution: "nodes[1:3]"
        - id: v4
          type: produce
          title: "Get the Last Two"
          description: >-
            Given <code>pods := []string{"web-1", "api-1", "db-1", "cache-1"}</code>, get a slice of the last 2 elements. Print it.
          hints: ["Use <code>len()</code> to calculate the start index from the end."]
          solution: |-
            pods := []string{"web-1", "api-1", "db-1", "cache-1"}
            last2 := pods[len(pods)-2:]
            fmt.Println(last2) // [db-1 cache-1]
    - id: scaffold_append
      concept: "Slice Operations"
      variants:
        - id: v1
          type: trace
          title: "Predict Append"
          description: |-
            What does this print?
            <pre>a := []int{1, 2}
            b := append(a, 3, 4)
            fmt.Println(a)
            fmt.Println(b)
            fmt.Println(len(a), len(b))</pre>
          solution: |-
            [1 2]
            [1 2 3 4]
            2 4
        - id: v2
          type: fix
          title: "Fix the Append"
          description: |-
            This should build a list of names, but it always prints an empty slice:
            <pre>var names []string
            for _, n := range []string{"a", "b", "c"} {
                append(names, n)
            }
            fmt.Println(names)</pre>
            Fix it.
          hints: ["<code>append</code> returns a new slice — it doesn't modify the original."]
          solution: |-
            // append returns the result; you must assign it back
            names = append(names, n)
        - id: v3
          type: complete
          title: "Complete the Append"
          description: |-
            Fill in the blank to add "db-1" to the end of the slice:
            <pre>servers := []string{"web-1", "api-1"}
            servers = ___________________________
            fmt.Println(servers) // [web-1 api-1 db-1]</pre>
          solution: 'append(servers, "db-1")'
        - id: v4
          type: produce
          title: "Build a Slice"
          description: >-
            Start with an empty slice. Use a loop to append the strings <code>"item-1"</code> through <code>"item-4"</code>. Print the result.
          hints: ["Use <code>fmt.Sprintf(\"item-%d\", i)</code> to build each string."]
          solution: |-
            var items []string
            for i := 1; i <= 4; i++ {
                items = append(items, fmt.Sprintf("item-%d", i))
            }
            fmt.Println(items) // [item-1 item-2 item-3 item-4]
    - id: scaffold_map_count
      concept: "Map Patterns"
      variants:
        - id: v1
          type: trace
          title: "Predict the Map"
          description: |-
            What does this print?
            <pre>m := make(map[string]int)
            m["a"]++
            m["b"]++
            m["a"]++
            fmt.Println(m["a"], m["b"], m["c"])</pre>
          solution: "2 1 0"
        - id: v2
          type: fix
          title: "Fix the Map Lookup"
          description: |-
            This code should print "found" for keys that exist, but it always prints "found" even for missing keys:
            <pre>config := map[string]string{"host": "localhost", "port": "5432"}
            val := config["timeout"]
            if val != "" {
                fmt.Println("found:", val)
            } else {
                fmt.Println("not found")
            }</pre>
            What's the problem? What if a key exists with an empty string value?
          hints: ["An empty string is the zero value for string — you can't tell if the key exists or has an empty value. Use the comma-ok pattern."]
          solution: |-
            // Use comma-ok to distinguish "missing" from "empty value":
            val, ok := config["timeout"]
            if ok {
                fmt.Println("found:", val)
            } else {
                fmt.Println("not found")
            }
        - id: v3
          type: complete
          title: "Complete the Counter"
          description: |-
            Fill in the blanks to count word frequencies:
            <pre>words := []string{"go", "is", "go", "fun"}
            counts := make(map[string]int)
            for _, w := range words {
                _____________
            }
            fmt.Println(counts)</pre>
          solution: "counts[w]++"
        - id: v4
          type: produce
          title: "Count Characters"
          description: >-
            Given <code>s := "banana"</code>, count how many times each character appears using a map. Print the map.
          hints: ["Range over a string to get each character. Use a <code>map[rune]int</code> or <code>map[byte]int</code>."]
          solution: |-
            s := "banana"
            counts := make(map[rune]int)
            for _, ch := range s {
                counts[ch]++
            }
            for ch, n := range counts {
                fmt.Printf("%c: %d\n", ch, n)
            }
    - id: scaffold_map_group
      concept: "Map Patterns"
      variants:
        - id: v1
          type: trace
          title: "Predict the Grouping"
          description: |-
            What does <code>grouped["short"]</code> contain after this runs?
            <pre>words := []string{"go", "rust", "c", "java", "py"}
            grouped := make(map[string][]string)
            for _, w := range words {
                if len(w) <= 2 {
                    grouped["short"] = append(grouped["short"], w)
                } else {
                    grouped["long"] = append(grouped["long"], w)
                }
            }
            fmt.Println(grouped["short"])</pre>
          solution: "[go c py]"
        - id: v2
          type: complete
          title: "Complete the Grouping"
          description: |-
            Fill in the blank to group numbers as even or odd:
            <pre>nums := []int{1, 2, 3, 4, 5, 6}
            groups := make(map[string][]int)
            for _, n := range nums {
                if n%2 == 0 {
                    ___________________________________
                } else {
                    ___________________________________
                }
            }</pre>
          solution: |-
            groups["even"] = append(groups["even"], n)
            // and
            groups["odd"] = append(groups["odd"], n)
        - id: v3
          type: produce
          title: "Group by First Letter"
          description: >-
            Given <code>names := []string{"alice", "bob", "anna", "ben"}</code>, build a <code>map[string][]string</code> grouping names by their first letter. Print the map.
          hints: ["Get the first letter with <code>string(name[0])</code> or <code>name[:1]</code>."]
          solution: |-
            names := []string{"alice", "bob", "anna", "ben"}
            groups := make(map[string][]string)
            for _, name := range names {
                key := name[:1]
                groups[key] = append(groups[key], name)
            }
            for k, v := range groups {
                fmt.Printf("%s: %v\n", k, v)
            }
    - id: scaffold_string_split
      concept: "String Parsing"
      variants:
        - id: v1
          type: trace
          title: "Predict the Split"
          description: |-
            What does this print?
            <pre>s := "a:b:c:d"
            fmt.Println(strings.Split(s, ":"))
            fmt.Println(strings.SplitN(s, ":", 2))</pre>
          solution: |-
            [a b c d]
            [a b:c:d]
        - id: v2
          type: fix
          title: "Fix the Split"
          description: |-
            This should extract the host from <code>"host:port"</code> but it panics when there's no colon:
            <pre>addr := "localhost"
            parts := strings.Split(addr, ":")
            host := parts[0]
            port := parts[1]
            fmt.Println(host, port)</pre>
            Fix it to handle addresses with or without a port.
          hints: ["When there's no colon, <code>strings.Split</code> returns a single-element slice. Accessing index 1 panics."]
          solution: |-
            parts := strings.SplitN(addr, ":", 2)
            host := parts[0]
            port := ""
            if len(parts) == 2 {
                port = parts[1]
            }
        - id: v3
          type: complete
          title: "Complete the Parse"
          description: |-
            Fill in the blank to extract the key and value from <code>"name=Go"</code>:
            <pre>pair := "name=Go"
            parts := strings.SplitN(pair, "=", ___)
            key := parts[0]
            val := parts[1]
            fmt.Println(key, val) // name Go</pre>
          solution: "2"
        - id: v4
          type: produce
          title: "Split a CSV Line"
          description: >-
            Given <code>line := "alice,30,engineer"</code>, split it on commas and print each field on its own line.
          hints: ["Use <code>strings.Split(line, \",\")</code> then range over the result."]
          solution: |-
            line := "alice,30,engineer"
            for _, field := range strings.Split(line, ",") {
                fmt.Println(field)
            }
    - id: scaffold_string_build
      concept: "String Parsing"
      variants:
        - id: v1
          type: trace
          title: "Predict the Join"
          description: |-
            What does this print?
            <pre>parts := []string{"hello", "world"}
            fmt.Println(strings.Join(parts, "-"))
            fmt.Println(strings.Join(parts, ""))
            fmt.Println(strings.Join(parts, ", "))</pre>
          solution: |-
            hello-world
            helloworld
            hello, world
        - id: v2
          type: complete
          title: "Complete the Builder"
          description: |-
            Fill in the blanks to build <code>"a|b|c"</code> from a slice:
            <pre>items := []string{"a", "b", "c"}
            result := strings._______(items, "___")
            fmt.Println(result)</pre>
          solution: 'strings.Join(items, "|")'
        - id: v3
          type: produce
          title: "Build a Path"
          description: >-
            Given <code>segments := []string{"usr", "local", "bin"}</code>, join them with <code>"/"</code> and print the result.
          hints: ["Use <code>strings.Join</code>."]
          solution: |-
            segments := []string{"usr", "local", "bin"}
            fmt.Println(strings.Join(segments, "/")) // usr/local/bin
    - id: scaffold_numbers
      concept: "Numbers & Percentages"
      variants:
        - id: v1
          type: trace
          title: "Predict the Division"
          description: |-
            What does this print?
            <pre>a := 7
            b := 2
            fmt.Println(a / b)
            fmt.Println(float64(a) / float64(b))</pre>
          solution: |-
            3
            3.5
        - id: v2
          type: fix
          title: "Fix the Percentage"
          description: |-
            This should print <code>75.0%</code> but prints <code>0.0%</code>:
            <pre>passed := 3
            total := 4
            pct := passed / total * 100
            fmt.Printf("%.1f%%\n", float64(pct))</pre>
            Fix it.
          hints: ["Integer division <code>3 / 4</code> equals 0, not 0.75. You need floats BEFORE dividing."]
          solution: |-
            // Convert to float64 before dividing
            pct := float64(passed) / float64(total) * 100
            fmt.Printf("%.1f%%\n", pct) // 75.0%
        - id: v3
          type: complete
          title: "Complete the Conversion"
          description: |-
            Fill in the blank to convert a string to an int safely:
            <pre>s := "42"
            n, err := strconv._______(s)
            if err != nil {
                fmt.Println("bad number")
            }
            fmt.Println(n)</pre>
          solution: "Atoi"
        - id: v4
          type: produce
          title: "Calculate a Ratio"
          description: >-
            Given <code>errors := 7</code> and <code>total := 20</code>, calculate the error rate as a percentage with one decimal place. Print it as <code>35.0%</code>.
          hints: ["Convert to <code>float64</code> before dividing. Use <code>%.1f%%</code> format verb."]
          solution: |-
            errors := 7
            total := 20
            pct := float64(errors) / float64(total) * 100
            fmt.Printf("%.1f%%\n", pct) // 35.0%
    - id: scaffold_line_parse
      concept: "Line Parsing"
      variants:
        - id: v1
          type: trace
          title: "Predict the Lines"
          description: |-
            What does this print?
            <pre>s := "one\ntwo\n\nthree"
            lines := strings.Split(s, "\n")
            fmt.Println(len(lines))
            fmt.Println(lines[2] == "")</pre>
          solution: |-
            4
            true
        - id: v2
          type: fix
          title: "Fix the Line Filter"
          description: |-
            This should skip comment lines (starting with #) but it skips ALL lines:
            <pre>input := "# comment\ndata\n# another\nmore"
            for _, line := range strings.Split(input, "\n") {
                if strings.HasPrefix(line, "#") {
                    break
                }
                fmt.Println(line)
            }</pre>
            Fix it.
          hints: ["<code>break</code> exits the entire loop. You want to skip just this iteration."]
          solution: |-
            // Use continue instead of break to skip one iteration
            if strings.HasPrefix(line, "#") {
                continue
            }
        - id: v3
          type: complete
          title: "Complete the Parser"
          description: |-
            Fill in the blanks to parse <code>"a=1\nb=2"</code> into a map:
            <pre>input := "a=1\nb=2"
            m := make(map[string]string)
            for _, line := range strings.Split(input, "\n") {
                parts := strings.SplitN(line, "=", ___)
                if len(parts) == ___ {
                    m[parts[0]] = parts[1]
                }
            }
            fmt.Println(m)</pre>
          solution: |-
            2
            // and
            2
        - id: v4
          type: produce
          title: "Count Non-Empty Lines"
          description: >-
            Given <code>text := "alpha\n\nbeta\n\ngamma\n"</code>, count and print how many non-empty lines there are.
          hints: ["Split on newlines, then loop and count lines where <code>strings.TrimSpace(line) != \"\"</code>."]
          solution: |-
            text := "alpha\n\nbeta\n\ngamma\n"
            count := 0
            for _, line := range strings.Split(text, "\n") {
                if strings.TrimSpace(line) != "" {
                    count++
                }
            }
            fmt.Println(count) // 3
    - id: scaffold_range
      concept: "Slice Operations"
      variants:
        - id: v1
          type: trace
          title: "Predict Range Copy"
          description: |-
            What does this print?
            <pre>nums := []int{1, 2, 3}
            for _, v := range nums {
                v = v * 10
            }
            fmt.Println(nums)</pre>
          solution: "[1 2 3]"
        - id: v2
          type: fix
          title: "Fix the Range Mutation"
          description: |-
            This code tries to double every element, but the slice is unchanged:
            <pre>nums := []int{5, 10, 15}
            for _, v := range nums {
                v = v * 2
            }
            fmt.Println(nums) // still [5 10 15]!</pre>
            Fix it so the elements are actually doubled.
          hints: ["<code>v</code> is a copy of the element. To modify the original, you need the index to write back to the slice."]
          solution: |-
            // v is a copy — changes to it don't affect the slice.
            // Fix: use the index form to modify in place.
            for i := range nums {
                nums[i] = nums[i] * 2
            }
        - id: v3
          type: complete
          title: "Complete the Range Mutation"
          description: |-
            Fill in the blanks to triple every element in place:
            <pre>vals := []int{2, 4, 6}
            for _____ := range vals {
                vals[___] = vals[___] * 3
            }
            fmt.Println(vals) // [6 12 18]</pre>
          solution: |-
            for i := range vals {
                vals[i] = vals[i] * 3
            }
        - id: v4
          type: trace
          title: "Predict Range Length Lock"
          description: |-
            What does this print?
            <pre>nums := []int{1, 2, 3}
            for i := range nums {
                if nums[i] == 2 {
                    nums = append(nums, 99)
                }
            }
            fmt.Println(nums)
            fmt.Println(len(nums))</pre>
          solution: |-
            [1 2 3 99]
            4
    - id: scaffold_numbers_format
      concept: "Numbers & Percentages"
      variants:
        - id: v1
          type: trace
          title: "Predict the Rounding"
          description: |-
            What does this print?
            <pre>val := 3.14159
            fmt.Printf("%.2f\n", val)
            fmt.Printf("%.0f\n", val)
            fmt.Printf("%d\n", int(val))</pre>
          solution: |-
            3.14
            3
            3
        - id: v2
          type: fix
          title: "Fix the Average"
          description: |-
            This should print the average as <code>2.5</code> but prints <code>2</code>:
            <pre>nums := []int{1, 2, 3, 4}
            sum := 0
            for _, n := range nums {
                sum += n
            }
            avg := sum / len(nums)
            fmt.Println(avg)</pre>
            Fix it.
          hints: ["Both <code>sum</code> and <code>len(nums)</code> are ints — integer division truncates. Convert to float64 before dividing."]
          solution: |-
            // sum and len(nums) are both ints, so division truncates.
            // Fix: convert before dividing.
            avg := float64(sum) / float64(len(nums))
            fmt.Println(avg) // 2.5
        - id: v3
          type: complete
          title: "Complete the Formatter"
          description: |-
            Fill in the blanks to convert a string to a float and print it with two decimal places:
            <pre>s := "3.14159"
            val, err := strconv.____________(s, 64)
            if err != nil {
                fmt.Println("bad number")
            }
            fmt.Printf("_____\n", val) // 3.14</pre>
          solution: |-
            strconv.ParseFloat(s, 64)
            // and
            fmt.Printf("%.2f\n", val)
        - id: v4
          type: produce
          title: "Compute an Average"
          description: >-
            Given <code>latencies := []int{120, 45, 200, 80, 55}</code>, calculate the average as a float and print it with one decimal place. Expected: <code>100.0</code>.
          hints: ["Sum all values, then divide <code>float64(sum) / float64(len(latencies))</code>. Use <code>%.1f</code> to format."]
          solution: |-
            latencies := []int{120, 45, 200, 80, 55}
            sum := 0
            for _, v := range latencies {
                sum += v
            }
            avg := float64(sum) / float64(len(latencies))
            fmt.Printf("%.1f\n", avg) // 100.0
    - id: scaffold_line_kv
      concept: "Line Parsing"
      variants:
        - id: v1
          type: trace
          title: "Predict the Parse"
          description: |-
            What does this print?
            <pre>input := "name=alice\nage=30\ncity=london"
            m := make(map[string]string)
            for _, line := range strings.Split(input, "\n") {
                parts := strings.SplitN(line, "=", 2)
                m[parts[0]] = parts[1]
            }
            fmt.Println(m["age"])
            fmt.Println(len(m))</pre>
          solution: |-
            30
            3
        - id: v2
          type: fix
          title: "Fix the Key-Value Parser"
          description: |-
            This should parse <code>"key=value"</code> lines into a map, but it panics on the blank line:
            <pre>input := "host=localhost\n\nport=5432"
            m := make(map[string]string)
            for _, line := range strings.Split(input, "\n") {
                parts := strings.SplitN(line, "=", 2)
                m[parts[0]] = parts[1]
            }
            fmt.Println(m)</pre>
            Fix it to skip blank lines.
          hints: ["When <code>line</code> is empty, <code>SplitN</code> returns one element — accessing <code>parts[1]</code> panics. Guard the assignment."]
          solution: |-
            // Check that SplitN actually produced two parts:
            for _, line := range strings.Split(input, "\n") {
                parts := strings.SplitN(line, "=", 2)
                if len(parts) == 2 {
                    m[parts[0]] = parts[1]
                }
            }
        - id: v3
          type: complete
          title: "Complete the Config Parser"
          description: |-
            Fill in the blanks to parse config lines, skipping comments and blanks:
            <pre>input := "# settings\nhost=localhost\n\nport=5432"
            m := make(map[string]string)
            for _, line := range strings.Split(input, "\n") {
                line = strings.TrimSpace(line)
                if line == "" || _________________________ {
                    _________
                }
                parts := strings.SplitN(line, "=", 2)
                if len(parts) == 2 {
                    m[parts[0]] = parts[1]
                }
            }</pre>
          solution: |-
            if line == "" || strings.HasPrefix(line, "#") {
                continue
            }
        - id: v4
          type: produce
          title: "Parse Environment Variables"
          description: >-
            Given <code>env := "APP_NAME=myservice\nAPP_PORT=8080\nAPP_DEBUG=true"</code>, parse it into a <code>map[string]string</code> and print the value of <code>APP_PORT</code>.
          hints: ["Split on newlines, then split each line on <code>=</code> with a limit of 2. Build a map from the key-value pairs."]
          solution: |-
            env := "APP_NAME=myservice\nAPP_PORT=8080\nAPP_DEBUG=true"
            m := make(map[string]string)
            for _, line := range strings.Split(env, "\n") {
                parts := strings.SplitN(line, "=", 2)
                if len(parts) == 2 {
                    m[parts[0]] = parts[1]
                }
            }
            fmt.Println(m["APP_PORT"]) // 8080
    - id: scaffold_combining
      concept: "Combining Patterns"
      variants:
        - id: v1
          type: trace
          title: "Predict the Pipeline"
          description: |-
            Trace through this code — what does it print?
            <pre>lines := []string{"INFO ok", "ERROR bad", "INFO done", "ERROR oom"}
            counts := make(map[string]int)
            for _, line := range lines {
                level := strings.Fields(line)[0]
                counts[level]++
            }
            keys := make([]string, 0, len(counts))
            for k := range counts {
                keys = append(keys, k)
            }
            sort.Strings(keys)
            fmt.Println(keys[0], counts[keys[0]])</pre>
          solution: "ERROR 2"
        - id: v2
          type: fix
          title: "Fix the Group and Sort"
          description: |-
            This should group names by first letter and print each group sorted, but the output has duplicate keys because of casing:
            <pre>names := []string{"Alice", "bob", "anna", "Ben"}
            groups := make(map[string][]string)
            for _, n := range names {
                key := n[:1]
                groups[key] = append(groups[key], n)
            }
            fmt.Println(groups)</pre>
            It creates separate <code>"A"</code> and <code>"a"</code> keys. Fix the grouping key to be case-insensitive.
          hints: ["Normalise the key to lowercase with <code>strings.ToLower</code> so <code>\"Alice\"</code> and <code>\"anna\"</code> share the <code>\"a\"</code> bucket."]
          solution: |-
            // Normalise key to lowercase:
            key := strings.ToLower(n[:1])
            groups[key] = append(groups[key], n)
        - id: v3
          type: complete
          title: "Complete the Pipeline"
          description: |-
            Fill in the blanks to count pod statuses, then print only statuses with count > 1:
            <pre>pods := []string{"Running", "Failed", "Running", "Pending", "Running"}
            counts := make(map[string]int)
            for _, p := range pods {
                ___________
            }
            for status, n := range counts {
                if _________ {
                    fmt.Printf("%s: %d\n", status, n)
                }
            }</pre>
          solution: |-
            counts[p]++
            // and
            if n > 1 {
        - id: v4
          type: produce
          title: "Top Error from Logs"
          description: >-
            Given <code>logs := []string{"disk full", "timeout", "disk full", "oom", "timeout", "disk full"}</code>, count each error, find the most frequent one, and print it as <code>"disk full (3)"</code>.
          hints: ["Count with a map, then loop the map to find the max. Track the winning key and count."]
          solution: |-
            logs := []string{"disk full", "timeout", "disk full", "oom", "timeout", "disk full"}
            counts := make(map[string]int)
            for _, e := range logs {
                counts[e]++
            }
            topErr := ""
            topN := 0
            for e, n := range counts {
                if n > topN {
                    topN = n
                    topErr = e
                }
            }
            fmt.Printf("%s (%d)\n", topErr, topN)
