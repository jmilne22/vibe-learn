conceptLinks:
  Slice Operations: "#slice-operations-under-pressure"
  In-Place Manipulation: "#in-place-manipulation"
  Map Patterns: "#map-patterns-for-infra"
  String Parsing: "#string-parsing--building"
  Numbers & Percentages: "#numbers-floats--percentages"
  Sorting & Filtering: "#sorting--filtering"
  Line Parsing: "#line-by-line-parsing"
sharedContent: {}
variants:
  warmups:
    - id: warmup_1
      concept: Slice Operations
      variants:
        - id: v0a
          title: First Two Servers
          description: >-
            Given <code>servers := []string{"web-1", "web-2", "api-1", "api-2", "db-1"}</code>, create a new slice
            containing only the first 2 elements. Print the result.
          hints:
            - "A slice expression <code>s[start:end]</code> gives you elements from start up to (not including) end."
            - "To get the first two, you start at 0 and end at 2: <code>servers[:2]</code>."
          solution: |-
            servers := []string{"web-1", "web-2", "api-1", "api-2", "db-1"}
            first2 := servers[:2]
            fmt.Println(first2) // [web-1 web-2]
        - id: v0b
          title: Middle Element
          description: >-
            Given <code>nodes := []string{"node-1", "node-2", "node-3", "node-4", "node-5"}</code>, print the middle
            element. Use <code>len()</code> to find it.
          hints:
            - "The middle index of a slice with 5 elements is 2 (indices go 0,1,2,3,4)."
            - "Use <code>len(nodes)/2</code> to compute the middle index."
          solution: |-
            nodes := []string{"node-1", "node-2", "node-3", "node-4", "node-5"}
            mid := nodes[len(nodes)/2]
            fmt.Println(mid) // node-3
        - id: v1
          title: Last N Servers
          description: >-
            Given <code>servers := []string{"web-1", "web-2", "api-1", "api-2", "db-1"}</code>, return a new slice
            containing the last 3 elements.
          hints:
            - How do you get elements from the end of a slice when Go doesn't support negative indexing?
            - "Think about using <code>len(s)</code> to calculate the starting position of your slice expression."
          solution: |-
            servers := []string{"web-1", "web-2", "api-1", "api-2", "db-1"}
            last3 := servers[len(servers)-3:]
            fmt.Println(last3) // [api-1 api-2 db-1]
        - id: v2
          title: Response Time Range
          description: >-
            Given <code>times := []int{234, 12, 891, 45, 567, 23, 445}</code> (response times in ms), find and print the
            minimum and maximum values. Use a single loop.
          hints:
            - "What's a safe starting value for min and max? Using 0 won't work â€” think about what element you already know exists."
            - You only need one pass through the slice. Compare each element against your running min and max.
          solution: |-
            times := []int{234, 12, 891, 45, 567, 23, 445}
            min, max := times[0], times[0]
            for _, t := range times[1:] {
                if t < min {
                    min = t
                }
                if t > max {
                    max = t
                }
            }
            fmt.Printf("min=%dms max=%dms\n", min, max)
        - id: v3
          title: Batch Pods
          description: |-
            Given this slice and a batch size of 3:
            <pre>pods := []string{"web-1", "web-2", "web-3", "web-4", "web-5", "web-6", "web-7"}</pre>
            Print each batch on its own line: <code>[web-1 web-2 web-3]</code>, <code>[web-4 web-5 web-6]</code>, <code>[web-7]</code>.
          hints:
            - You need a loop that jumps forward by the batch size each iteration, not one element at a time. Which loop form supports a custom step?
            - What happens when the last batch is smaller than the batch size? You need to cap the end index so it doesn't go past the slice length.
          solution: |-
            pods := []string{"web-1", "web-2", "web-3", "web-4", "web-5", "web-6", "web-7"}
            batchSize := 3
            for i := 0; i < len(pods); i += batchSize {
                end := i + batchSize
                if end > len(pods) {
                    end = len(pods)
                }
                fmt.Println(pods[i:end])
            }
        - id: v4
          title: Build a Slice from Scratch
          description: >-
            Start with an empty slice. Append the strings <code>"node-1"</code> through <code>"node-5"</code> using a
            loop. Then print the length, capacity, and contents.
          hints:
            - Start with a nil slice and grow it inside a counting loop. You need to build each name dynamically from the loop index.
            - "Check the lesson's Building Strings section for how to combine a string with a number. Use <code>len</code> and <code>cap</code> to inspect the slice afterwards."
          solution: |-
            var nodes []string
            for i := 1; i <= 5; i++ {
                nodes = append(nodes, fmt.Sprintf("node-%d", i))
            }
            fmt.Printf("len=%d cap=%d %v\n", len(nodes), cap(nodes), nodes)
    - id: warmup_2
      concept: In-Place Manipulation
      variants:
        - id: v0a
          title: Swap First and Last
          description: >-
            Given <code>pods := []string{"web-1", "web-2", "web-3", "web-4"}</code>, swap the first and last elements
            <strong>in place</strong>. Print the result.
          hints:
            - "Go lets you swap two values in one line: <code>a, b = b, a</code>."
            - "Use index 0 for first and <code>len(pods)-1</code> for last."
          solution: |-
            pods := []string{"web-1", "web-2", "web-3", "web-4"}
            pods[0], pods[len(pods)-1] = pods[len(pods)-1], pods[0]
            fmt.Println(pods) // [web-4 web-2 web-3 web-1]
        - id: v0b
          title: Overwrite an Element
          description: >-
            Given <code>statuses := []string{"Running", "Pending", "Running", "Failed"}</code>, change the
            <code>"Failed"</code> pod (index 3) to <code>"Running"</code>. Print the result.
          hints:
            - "Assign directly by index: <code>statuses[3] = \"Running\"</code>."
            - Slices are mutable â€” assigning to an index changes the original slice.
          solution: |-
            statuses := []string{"Running", "Pending", "Running", "Failed"}
            statuses[3] = "Running"
            fmt.Println(statuses) // [Running Pending Running Running]
        - id: v0c
          title: Remove Keeping Order
          description: >-
            Given <code>services := []string{"auth", "api", "web", "cache"}</code>, remove the element at index 1
            (<code>"api"</code>) while <strong>preserving the order</strong> of the remaining elements. Print the
            result.
          hints:
            - "You need everything before the index joined with everything after it. Which Go builtin combines two slices?"
            - "Use <code>append(s[:i], s[i+1:]...)</code> â€” this slides the later elements left to fill the gap."
          solution: |-
            services := []string{"auth", "api", "web", "cache"}
            services = append(services[:1], services[2:]...)
            fmt.Println(services) // [auth web cache]
        - id: v1
          title: Reverse Server List
          description: >-
            Given <code>servers := []string{"nginx", "redis", "postgres", "mongo"}</code>, reverse the slice <strong>in
            place</strong> (don't create a new slice). Print the result.
          hints:
            - Think about approaching from both ends simultaneously. When should you stop?
            - "Each step, move both positions one closer to the center, swapping as you go."
          solution: |-
            servers := []string{"nginx", "redis", "postgres", "mongo"}
            for i, j := 0, len(servers)-1; i < j; i, j = i+1, j-1 {
                servers[i], servers[j] = servers[j], servers[i]
            }
            fmt.Println(servers)
        - id: v2
          title: Remove Terminated Pod
          description: >-
            Given <code>pods := []string{"web-1", "web-2", "web-3", "web-4"}</code>, remove the pod at index 1
            (<code>"web-2"</code>) <strong>without preserving order</strong> (swap with last element, then shrink).
            Print the result.
          hints:
            - "If order doesn't matter, you don't need to shift everything. What's the cheapest way to fill the gap left by the removed element?"
            - "After filling the gap, the slice is one element too long. How do you shrink a slice by one without copying?"
          solution: |-
            pods := []string{"web-1", "web-2", "web-3", "web-4"}
            pods[1] = pods[len(pods)-1]
            pods = pods[:len(pods)-1]
            fmt.Println(pods) // [web-1 web-4 web-3]
        - id: v3
          title: Insert at Position
          description: >-
            Given <code>queue := []string{"job-a", "job-b", "job-d"}</code>, insert <code>"job-c"</code> at index 2
            (before <code>"job-d"</code>). Print the result: <code>[job-a job-b job-c job-d]</code>.
          hints:
            - "Inserting needs three steps: make room, shift existing elements right, write the new value into the gap."
            - "First grow the slice by one (append a zero value). Then shift elements at and after the target index one position right. Then assign the new value."
          solution: |-
            queue := []string{"job-a", "job-b", "job-d"}
            queue = append(queue, "")
            copy(queue[3:], queue[2:])
            queue[2] = "job-c"
            fmt.Println(queue) // [job-a job-b job-c job-d]
        - id: v3b
          title: Filter Tags In Place
          description: >-
            Given <code>tags := []string{"v1.0", "latest", "v2.0", "dev", "v3.0"}</code>, filter the slice
            <strong>in place</strong> to keep only tags that start with <code>"v"</code>. Print the result.
          hints:
            - "Use the write-index pattern: a variable <code>n</code> tracks where to write, the loop reads every element."
            - "Use <code>strings.HasPrefix(tag, \"v\")</code> to check the condition. After the loop, truncate with <code>tags = tags[:n]</code>."
          solution: |-
            tags := []string{"v1.0", "latest", "v2.0", "dev", "v3.0"}
            n := 0
            for _, tag := range tags {
                if strings.HasPrefix(tag, "v") {
                    tags[n] = tag
                    n++
                }
            }
            tags = tags[:n]
            fmt.Println(tags) // [v1.0 v2.0 v3.0]
        - id: v4
          title: Filter Running Pods
          description: |-
            Given these parallel slices:
            <pre>names   := []string{"web-1", "web-2", "db-1", "cache-1", "web-3"}
            statuses := []string{"Running", "Failed", "Running", "Running", "Pending"}</pre>
            Filter <code>names</code> <strong>in place</strong> to keep only pods where status is <code>"Running"</code>. Print the result.
          hints:
            - "Use the write-index pattern from the lesson â€” one variable tracks where to write, the loop reads from each position."
            - "Range over statuses to decide which elements to keep. Use the loop index to grab the matching name from the parallel slice. Truncate at the end."
          solution: |-
            names := []string{"web-1", "web-2", "db-1", "cache-1", "web-3"}
            statuses := []string{"Running", "Failed", "Running", "Running", "Pending"}
            n := 0
            for i, s := range statuses {
                if s == "Running" {
                    names[n] = names[i]
                    n++
                }
            }
            names = names[:n]
            fmt.Println(names) // [web-1 db-1 cache-1]
        - id: v5
          title: Deduplicate Sorted
          description: |-
            Given this already-sorted slice:
            <pre>versions := []string{"v1.0", "v1.0", "v1.1", "v1.1", "v1.1", "v1.2", "v1.3", "v1.3"}</pre>
            Remove duplicates <strong>in place</strong>. Print the result: <code>[v1.0 v1.1 v1.2 v1.3]</code>.
          hints:
            - "This is a variant of the filter pattern. Since the slice is sorted, duplicates are always next to each other. How can you use that?"
            - "Compare each element to the one before it. If it's different, it's a new unique value â€” keep it. The first element always stays."
          solution: |-
            versions := []string{"v1.0", "v1.0", "v1.1", "v1.1", "v1.1", "v1.2", "v1.3", "v1.3"}
            n := 1
            for i := 1; i < len(versions); i++ {
                if versions[i] != versions[i-1] {
                    versions[n] = versions[i]
                    n++
                }
            }
            versions = versions[:n]
            fmt.Println(versions) // [v1.0 v1.1 v1.2 v1.3]
    - id: warmup_3
      concept: Map Patterns
      variants:
        - id: v0a
          title: Look Up a Config Value
          description: >-
            Given <code>config := map[string]string{"host": "localhost", "port": "5432", "db": "myapp"}</code>,
            look up the key <code>"port"</code> and print its value. Then check if the key <code>"timeout"</code>
            exists using the comma-ok pattern, and print whether it was found.
          hints:
            - "Access a map value with <code>config[\"port\"]</code>."
            - "Comma-ok pattern: <code>val, ok := config[\"timeout\"]</code>. <code>ok</code> is <code>true</code> if the key exists."
          solution: |-
            config := map[string]string{"host": "localhost", "port": "5432", "db": "myapp"}
            fmt.Println(config["port"]) // 5432
            val, ok := config["timeout"]
            fmt.Printf("timeout=%q found=%t\n", val, ok) // timeout="" found=false
        - id: v1
          title: Count Log Levels
          description: |-
            Given this slice of log levels:
            <pre>levels := []string{"INFO", "ERROR", "INFO", "WARN", "ERROR", "INFO", "DEBUG", "ERROR"}</pre>
            Count occurrences of each level using a map. Print each level and its count.
          hints:
            - What data structure maps a string key to an integer count?
            - "The zero value of int is 0. So incrementing a key that doesn't exist yet just works â€” no need to check first."
          solution: |-
            levels := []string{"INFO", "ERROR", "INFO", "WARN", "ERROR", "INFO", "DEBUG", "ERROR"}
            counts := make(map[string]int)
            for _, level := range levels {
                counts[level]++
            }
            for level, count := range counts {
                fmt.Printf("%s: %d\n", level, count)
            }
        - id: v2
          title: Group by Namespace
          description: |-
            Given these parallel slices:
            <pre>pods       := []string{"web-1", "web-2", "api-1", "db-1", "api-2"}
            namespaces := []string{"frontend", "frontend", "backend", "data", "backend"}</pre>
            Build a <code>map[string][]string</code> grouping pod names by namespace. Print the map.
          hints:
            - What map type lets you store multiple strings under each key? Think about the value type.
            - "Loop over the indices. The namespace determines which key to use, and the pod name gets appended to that key's slice."
          solution: |-
            pods := []string{"web-1", "web-2", "api-1", "db-1", "api-2"}
            namespaces := []string{"frontend", "frontend", "backend", "data", "backend"}
            grouped := make(map[string][]string)
            for i, ns := range namespaces {
                grouped[ns] = append(grouped[ns], pods[i])
            }
            for ns, names := range grouped {
                fmt.Printf("%s: %v\n", ns, names)
            }
        - id: v3
          title: Merge Config Maps
          description: |-
            Given two config maps:
            <pre>defaults  := map[string]string{"timeout": "30s", "retries": "3", "log_level": "info"}
            overrides := map[string]string{"timeout": "10s", "log_level": "debug"}</pre>
            Merge them into a new map where overrides win. Print the result.
          hints:
            - "If both maps have the same key, which value should survive? Build your solution around that priority."
            - "Iterate both maps into a fresh map. The order you iterate them determines which values win on conflicts."
          solution: |-
            defaults := map[string]string{"timeout": "30s", "retries": "3", "log_level": "info"}
            overrides := map[string]string{"timeout": "10s", "log_level": "debug"}
            merged := make(map[string]string)
            for k, v := range defaults {
                merged[k] = v
            }
            for k, v := range overrides {
                merged[k] = v
            }
            for k, v := range merged {
                fmt.Printf("%s=%s\n", k, v)
            }
        - id: v4
          title: Unique Error Messages
          description: |-
            Given this slice of error messages:
            <pre>errors := []string{"timeout", "connection refused", "timeout",
                "DNS lookup failed", "timeout", "connection refused"}</pre>
            Use a map-as-set to find unique error messages. Print them in any order.
          hints:
            - "A map's keys are always unique. How can you exploit that to deduplicate a list?"
            - "After recording each string as a map key, the map's keys ARE your unique set. Iterate the keys to print them."
          solution: |-
            errors := []string{"timeout", "connection refused", "timeout",
                "DNS lookup failed", "timeout", "connection refused"}
            seen := make(map[string]bool)
            for _, err := range errors {
                seen[err] = true
            }
            for msg := range seen {
                fmt.Println(msg)
            }
    - id: warmup_4
      concept: String Parsing
      variants:
        - id: v0a
          title: Split a Host:Port String
          description: >-
            Given <code>addr := "api-server:8080"</code>, split it into the hostname and port parts. Print each on
            its own line.
          hints:
            - "Use <code>strings.SplitN(addr, \":\", 2)</code> to split on the first colon only."
            - "The result is a two-element slice: <code>parts[0]</code> is the host, <code>parts[1]</code> is the port."
          solution: |-
            addr := "api-server:8080"
            parts := strings.SplitN(addr, ":", 2)
            fmt.Println("host:", parts[0]) // host: api-server
            fmt.Println("port:", parts[1]) // port: 8080
        - id: v0b
          title: Check a String Prefix
          description: >-
            Given <code>image := "registry.io/nginx:1.25"</code>, check if it starts with <code>"registry.io/"</code>.
            If it does, extract just the image name and tag after the registry prefix. Print the result.
          hints:
            - "Use <code>strings.HasPrefix</code> to check the prefix."
            - "Use <code>strings.TrimPrefix</code> to remove the prefix, or slice the string from a known position."
          solution: |-
            image := "registry.io/nginx:1.25"
            if strings.HasPrefix(image, "registry.io/") {
                nameTag := strings.TrimPrefix(image, "registry.io/")
                fmt.Println(nameTag) // nginx:1.25
            }
        - id: v1
          title: Parse Label Pair
          description: >-
            Write a function <code>func parseLabel(s string) (string, string)</code> that takes a string like
            <code>"app=nginx"</code> and returns the key and value. Split on the first <code>=</code> only (values might
            contain <code>=</code>).
          hints:
            - "You need to find the position of the first <code>=</code>, not split on all of them. Which <code>strings</code> function finds the index of a substring?"
            - "Once you have the position, use slice expressions to grab everything before it (the key) and everything after it (the value)."
          solution: |-
            func parseLabel(s string) (string, string) {
                idx := strings.Index(s, "=")
                if idx < 0 {
                    return s, ""
                }
                return s[:idx], s[idx+1:]
            }
        - id: v2
          title: Extract Namespace from Resource
          description: >-
            K8s resource names are often formatted as <code>"namespace/resource"</code>. Write a function <code>func
            splitResource(s string) (string, string)</code> that returns the namespace and resource name. If there's no
            <code>/</code>, return <code>"default"</code> as the namespace.
          hints:
            - "First determine whether the separator exists at all. If it doesn't, you need to return a default namespace."
            - "Limit your split to at most 2 parts, then check the result length to determine which format you got."
          solution: |-
            func splitResource(s string) (string, string) {
                parts := strings.SplitN(s, "/", 2)
                if len(parts) == 1 {
                    return "default", parts[0]
                }
                return parts[0], parts[1]
            }
        - id: v3
          title: Parse Log Line
          description: >-
            Given a log line like <code>"2024-01-15T10:30:00Z ERROR [auth-service] connection refused"</code>, extract
            the timestamp, level, service name (without brackets), and message. Print each field.
          hints:
            - "Splitting on whitespace gives you the individual parts: timestamp, level, service (with brackets), and the remaining message words."
            - "The service name has brackets around it that need stripping. The message is all remaining words after the service, joined back into a single string."
          solution: |-
            line := "2024-01-15T10:30:00Z ERROR [auth-service] connection refused"
            fields := strings.Fields(line)
            timestamp := fields[0]
            level := fields[1]
            service := strings.Trim(fields[2], "[]")
            message := strings.Join(fields[3:], " ")
            fmt.Printf("time=%s level=%s service=%s msg=%s\n", timestamp, level, service, message)
        - id: v4
          title: Build Prometheus Labels
          description: |-
            Given this map:
            <pre>labels := map[string]string{"method": "GET", "status": "200", "path": "/api/health"}</pre>
            Build a Prometheus-style label string: <code>method="GET",status="200",path="/api/health"</code>. The pairs can be in any order.
          hints:
            - "Build each label pair as a formatted string, collect them all, then combine them. Look at the collect-and-join pattern in the lesson."
            - "Each pair needs to include the quotes around the value. Remember to escape quotes inside a Go string with a backslash."
          solution: |-
            labels := map[string]string{"method": "GET", "status": "200", "path": "/api/health"}
            parts := make([]string, 0, len(labels))
            for k, v := range labels {
                parts = append(parts, fmt.Sprintf("%s=\"%s\"", k, v))
            }
            result := strings.Join(parts, ",")
            fmt.Println(result)
    - id: warmup_5
      concept: Numbers & Percentages
      variants:
        - id: v1
          title: Error Percentage
          description: >-
            Given <code>errors := 3</code> and <code>total := 8</code>, calculate the error rate as a percentage and
            print it with one decimal place followed by a percent sign. Expected output: <code>37.5%</code>
          hints:
            - Dividing two ints in Go gives an int â€” the decimal part is thrown away. How do you get the real percentage?
            - "Convert both to <code>float64</code> before dividing, multiply by 100, then use the right format verb to get one decimal place and a literal <code>%</code>."
          solution: |-
            errors := 3
            total := 8
            pct := float64(errors) / float64(total) * 100
            fmt.Printf("%.1f%%\n", pct)
        - id: v2
          title: Round to One Decimal
          description: >-
            Given <code>rate := 33.33333</code>, round it to one decimal place and print the result.
            Expected output: <code>33.3</code>
          hints:
            - "Go has no <code>math.Round(x, places)</code>. You need to shift the decimal point, round, then shift back."
            - "Multiply by 10, round with <code>math.Round</code>, divide by 10."
          solution: |-
            rate := 33.33333
            rounded := math.Round(rate*10) / 10
            fmt.Println(rounded) // 33.3
        - id: v3
          title: Parse Port Number
          description: >-
            Given <code>portStr := "8080"</code>, convert it to an integer, check it's in the valid range (1-65535),
            and print it. If the conversion fails or the port is out of range, print an error message.
          hints:
            - Which <code>strconv</code> function converts a string to an int? What does it return on failure?
            - "Use <code>strconv.Atoi</code> and check the error. Then validate the numeric range separately."
          solution: |-
            portStr := "8080"
            port, err := strconv.Atoi(portStr)
            if err != nil {
                fmt.Println("invalid port:", portStr)
                return
            }
            if port < 1 || port > 65535 {
                fmt.Println("port out of range:", port)
                return
            }
            fmt.Println(port) // 8080
    - id: warmup_6
      concept: Sorting & Filtering
      variants:
        - id: v0a
          title: Sort Scores Ascending
          description: >-
            Given <code>scores := []int{42, 7, 89, 23, 56}</code>, sort them in ascending order (smallest first) using
            <code>sort.Slice</code>. Print the result.
          hints:
            - "<code>sort.Slice</code> takes the slice and a comparator: <code>func(i, j int) bool</code>. Return true if element i should come before element j."
            - "For ascending order, return <code>scores[i] < scores[j]</code>."
          solution: |-
            scores := []int{42, 7, 89, 23, 56}
            sort.Slice(scores, func(i, j int) bool {
                return scores[i] < scores[j]
            })
            fmt.Println(scores) // [7 23 42 56 89]
        - id: v1
          title: Sort Server Names
          description: >-
            Given <code>servers := []string{"web-3", "api-1", "db-2", "web-1", "api-2"}</code>, sort them
            alphabetically in place and print the result.
          hints:
            - "Go's <code>sort</code> package has a convenience function specifically for string slices."
            - "It's a one-liner: <code>sort.Strings(slice)</code> sorts in place."
          solution: |-
            servers := []string{"web-3", "api-1", "db-2", "web-1", "api-2"}
            sort.Strings(servers)
            fmt.Println(servers) // [api-1 api-2 db-2 web-1 web-3]
        - id: v2
          title: Sort by Value Descending
          description: >-
            Given <code>counts := []int{42, 7, 256, 13, 89}</code>, sort them in descending order (largest first)
            and print the result.
          hints:
            - "<code>sort.Slice</code> takes a comparator function. For descending order, which element should come first?"
            - "Return <code>counts[i] > counts[j]</code> to sort largest first."
          solution: |-
            counts := []int{42, 7, 256, 13, 89}
            sort.Slice(counts, func(i, j int) bool {
                return counts[i] > counts[j]
            })
            fmt.Println(counts) // [256 89 42 13 7]
        - id: v3
          title: Top 3 Elements
          description: >-
            Given <code>latencies := []int{234, 12, 891, 45, 567, 23, 445}</code>, find and print the top 3 highest
            values. Sort descending, then slice.
          hints:
            - "Sort the slice in descending order first, then take the first 3 elements."
            - "After sorting, use a slice expression to grab just the first N elements. Don't forget to check if the slice is shorter than N."
          solution: |-
            latencies := []int{234, 12, 891, 45, 567, 23, 445}
            sort.Slice(latencies, func(i, j int) bool {
                return latencies[i] > latencies[j]
            })
            top3 := latencies[:3]
            fmt.Println(top3) // [891 567 445]
    - id: warmup_7
      concept: Line Parsing
      variants:
        - id: v0a
          title: Count Lines
          description: >-
            Given <code>content := "web-1\nweb-2\nweb-3\napi-1\ndb-1"</code>, split it into lines and print how many
            lines there are.
          hints:
            - "Use <code>strings.Split(content, \"\\n\")</code> to split on newlines."
            - "Then use <code>len()</code> on the resulting slice."
          solution: |-
            content := "web-1\nweb-2\nweb-3\napi-1\ndb-1"
            lines := strings.Split(content, "\n")
            fmt.Println(len(lines)) // 5
        - id: v1
          title: Extract Non-Empty Lines
          description: >-
            Given a multi-line string <code>content := "alpha\n\nbeta\n\n\ngamma\n"</code>, split it into lines,
            skip empty lines, and collect the non-empty ones into a slice. Print the result.
          hints:
            - "Split on newlines first, then filter. What does an empty line look like after trimming?"
            - "Loop through the lines, trim each one, and only append non-empty ones to your result slice."
          solution: |-
            content := "alpha\n\nbeta\n\n\ngamma\n"
            var result []string
            for _, line := range strings.Split(content, "\n") {
                line = strings.TrimSpace(line)
                if line != "" {
                    result = append(result, line)
                }
            }
            fmt.Println(result) // [alpha beta gamma]
        - id: v2
          title: Skip Comments
          description: |-
            Given a config string:
            <pre>"# database config\nhost=localhost\n# port\nport=5432\nname=mydb"</pre>
            Split into lines, skip lines starting with <code>#</code> and empty lines, and print each remaining line.
          hints:
            - "After trimming, check two conditions: is it empty? Does it start with <code>#</code>? Skip both."
            - "Use <code>strings.HasPrefix</code> to check for the comment character."
          solution: |-
            content := "# database config\nhost=localhost\n# port\nport=5432\nname=mydb"
            for _, line := range strings.Split(content, "\n") {
                line = strings.TrimSpace(line)
                if line == "" || strings.HasPrefix(line, "#") {
                    continue
                }
                fmt.Println(line)
            }
        - id: v3
          title: Parse Key-Value Lines
          description: >-
            Given <code>content := "HOST=localhost\nPORT=5432\nDB_NAME=myapp"</code>, parse it into a
            <code>map[string]string</code> and print the map.
          hints:
            - "Split into lines, then split each line on <code>=</code>. How many parts should you limit the split to?"
            - "Use <code>strings.SplitN(line, \"=\", 2)</code> to split on the first <code>=</code> only, in case values contain <code>=</code>."
          solution: |-
            content := "HOST=localhost\nPORT=5432\nDB_NAME=myapp"
            result := make(map[string]string)
            for _, line := range strings.Split(content, "\n") {
                parts := strings.SplitN(line, "=", 2)
                if len(parts) == 2 {
                    result[strings.TrimSpace(parts[0])] = strings.TrimSpace(parts[1])
                }
            }
            fmt.Println(result)
  challenges:
    - id: challenge_1
      block: 1
      difficulty: 1
      concept: Map Patterns
      docLinks:
        - url: https://pkg.go.dev/sort#Slice
          title: sort.Slice documentation
          note: custom sorting
      variants:
        - id: v1
          title: Error Rate Calculator
          description: >-
            Write <code>func errorRate(lines []string) float64</code> that takes log lines in the format <code>"LEVEL
            message"</code> and returns the percentage of lines that are ERROR level (0.0 to 100.0, rounded to one
            decimal). Return 0.0 for empty input.<br><br>Example: <code>["INFO ok", "ERROR bad", "INFO ok2", "ERROR
            oom", "WARN slow"]</code> â†’ <code>40.0</code>
          functionSignature: func errorRate(lines []string) float64
          difficulty: 1
          testCases:
            - input: errorRate([]string{"INFO ok", "ERROR bad", "INFO ok2", "ERROR oom", "WARN slow"})
              output: "40.0"
            - input: errorRate([]string{"ERROR a", "ERROR b"})
              output: "100.0"
            - input: errorRate([]string{})
              output: "0.0"
          hints:
            - title: ðŸ¤” Think about it
              content: You need two numbers â€” how many errors and how many total lines. What do you do with those to get a percentage?
            - title: ðŸ’¡ Hint
              content: >-
                Extract the first word from each line to check its level. For the percentage, remember that dividing two
                ints truncates â€” you need floats. Check the Numbers section in the lesson for how to round to one decimal.
          solution: |-
            func errorRate(lines []string) float64 {
                if len(lines) == 0 {
                    return 0.0
                }
                errors := 0
                for _, line := range lines {
                    fields := strings.Fields(line)
                    if len(fields) > 0 && fields[0] == "ERROR" {
                        errors++
                    }
                }
                rate := float64(errors) / float64(len(lines)) * 100
                return math.Round(rate*10) / 10
            }
        - id: v2
          title: Log Level Report
          description: >-
            Write <code>func logReport(lines []string) string</code> that takes log lines in the format <code>"LEVEL
            message text"</code> and returns a report string with each level and its count, sorted by count
            descending.<br><br>Example input: <code>["INFO request started", "ERROR timeout", "INFO request done", "WARN
            slow query", "ERROR OOM"]</code><br>Example output: <code>"INFO: 2\nERROR: 2\nWARN: 1"</code>
          functionSignature: func logReport(lines []string) string
          difficulty: 2
          testCases:
            - input: logReport([]string{"INFO ok", "ERROR bad", "INFO ok2", "WARN slow", "ERROR oom"})
              output: "\"INFO: 2\\nERROR: 2\\nWARN: 1\""
            - input: logReport([]string{"DEBUG x", "DEBUG y", "DEBUG z"})
              output: "\"DEBUG: 3\""
            - input: logReport([]string{})
              output: "\"\""
          hints:
            - title: ðŸ¤” Think about it
              content: >-
                You need two steps: counting and sorting. What data structure counts things? And since maps aren't
                sortable â€” what do you need to convert the data into before you can sort it?
            - title: ðŸ’¡ Hint
              content: >-
                This follows the count â†’ sort â†’ format pattern from the Putting It Together section of the lesson. The
                key insight is transferring map data into a sortable slice.
          solution: |-
            func logReport(lines []string) string {
                counts := make(map[string]int)
                for _, line := range lines {
                    fields := strings.Fields(line)
                    if len(fields) > 0 {
                        counts[fields[0]]++
                    }
                }
                type entry struct {
                    level string
                    count int
                }
                entries := make([]entry, 0, len(counts))
                for k, v := range counts {
                    entries = append(entries, entry{k, v})
                }
                sort.Slice(entries, func(i, j int) bool {
                    return entries[i].count > entries[j].count
                })
                parts := make([]string, len(entries))
                for i, e := range entries {
                    parts[i] = fmt.Sprintf("%s: %d", e.level, e.count)
                }
                return strings.Join(parts, "\n")
            }
          annotations:
            - type: pattern
              label: Count-Sort-Format
              text: >-
                This three-step pattern (count with map â†’ sort â†’ format output) appears everywhere in infra tooling. Log
                analysis, metric aggregation, resource reporting â€” same shape.
        - id: v3
          title: Level Frequency with Percentages
          description: >-
            Write <code>func logFrequency(lines []string) string</code> that takes log lines and returns a report with
            each level, its count, AND its percentage of total, sorted by count descending.<br><br>Format: <code>"ERROR:
            3 (37.5%)\nINFO: 3 (37.5%)\nWARN: 2 (25.0%)"</code>
          functionSignature: func logFrequency(lines []string) string
          difficulty: 3
          testCases:
            - input: logFrequency([]string{"INFO a", "ERROR b", "ERROR c"})
              output: "\"ERROR: 2 (66.7%)\\nINFO: 1 (33.3%)\""
          hints:
            - title: ðŸ¤” Think about it
              content: >-
                This builds on the Log Level Report â€” same count-sort pattern. The extra step is computing a percentage
                for each level. How do you format a float to one decimal place with a percent sign?
            - title: ðŸ’¡ Hint
              content: >-
                Reuse the count-sort-format pattern. The percentage is each level's count divided by total lines. See the
                Numbers section for float conversion, and the Printing section for the format verb that outputs one decimal
                place and a literal percent sign.
          solution: |-
            func logFrequency(lines []string) string {
                if len(lines) == 0 {
                    return ""
                }
                counts := make(map[string]int)
                for _, line := range lines {
                    fields := strings.Fields(line)
                    if len(fields) > 0 {
                        counts[fields[0]]++
                    }
                }
                type entry struct {
                    level string
                    count int
                }
                entries := make([]entry, 0, len(counts))
                for k, v := range counts {
                    entries = append(entries, entry{k, v})
                }
                sort.Slice(entries, func(i, j int) bool {
                    return entries[i].count > entries[j].count
                })
                total := len(lines)
                parts := make([]string, len(entries))
                for i, e := range entries {
                    pct := float64(e.count) / float64(total) * 100
                    parts[i] = fmt.Sprintf("%s: %d (%.1f%%)", e.level, e.count, pct)
                }
                return strings.Join(parts, "\n")
            }
    - id: challenge_2
      block: 2
      difficulty: 2
      concept: String Parsing
      variants:
        - id: v1
          title: Parse Metric Labels
          description: >-
            Write <code>func parseLabels(s string) map[string]string</code> that takes a Prometheus-style label string
            like <code>method="GET",status="200"</code> and returns a map of label keys to values (without
            quotes).<br><br>Example: <code>"method=\"GET\",status=\"200\""</code> â†’ <code>map[method:GET
            status:200]</code>
          functionSignature: func parseLabels(s string) map[string]string
          difficulty: 1
          testCases:
            - input: parseLabels("method=\"GET\",status=\"200\"")
              output: map[method:GET status:200]
            - input: parseLabels("app=\"nginx\"")
              output: map[app:nginx]
            - input: parseLabels("")
              output: map[]
          hints:
            - title: ðŸ¤” Think about it
              content: >-
                Two levels of splitting: first separate the individual pairs, then separate key from value within each
                pair. What character separates pairs? What separates key from value?
            - title: ðŸ’¡ Hint
              content: >-
                After splitting each pair on <code>=</code>, the value still has quotes around it. You need to strip those.
                Don't forget to handle empty input.
          solution: |-
            func parseLabels(s string) map[string]string {
                result := make(map[string]string)
                if s == "" {
                    return result
                }
                pairs := strings.Split(s, ",")
                for _, pair := range pairs {
                    parts := strings.SplitN(pair, "=", 2)
                    if len(parts) == 2 {
                        key := parts[0]
                        val := strings.Trim(parts[1], "\"")
                        result[key] = val
                    }
                }
                return result
            }
          annotations:
            - type: infra
              label: Prometheus Format
              text: >-
                This is the actual format Prometheus uses for metric labels. Tools like <code>promtool</code> parse this
                exact syntax.
        - id: v2
          title: Parse Full Metric Line
          description: >-
            Write <code>func parseMetric(line string) (string, map[string]string, float64, error)</code> that parses a
            full Prometheus metric line like <code>http_requests_total{method="GET",status="200"} 1027</code> and
            returns the metric name, labels map, value, and any error.<br><br>Handle metrics with no labels too:
            <code>up 1</code> â†’ name="up", empty labels, value=1.
          functionSignature: func parseMetric(line string) (string, map[string]string, float64, error)
          difficulty: 2
          testCases:
            - input: parseMetric("http_requests{method=\"GET\"} 42")
              output: "\"http_requests\", map[method:GET], 42.0, nil"
            - input: parseMetric("up 1")
              output: "\"up\", map[], 1.0, nil"
          hints:
            - title: ðŸ¤” Think about it
              content: >-
                There are two formats: with labels (<code>name{labels} value</code>) and without (<code>name
                value</code>). How can you tell which format a line is? Handle them separately.
            - title: ðŸ’¡ Hint
              content: >-
                For the labeled format, find the braces to identify three sections: the name (before <code>{</code>), the
                labels (between the braces), and the value (after <code>}</code>). You can reuse your label parser from
                the easier variant.
          solution: |-
            func parseMetric(line string) (string, map[string]string, float64, error) {
                labels := make(map[string]string)
                if strings.Contains(line, "{") {
                    nameEnd := strings.Index(line, "{")
                    name := line[:nameEnd]
                    labelsEnd := strings.Index(line, "}")
                    labelStr := line[nameEnd+1 : labelsEnd]
                    if labelStr != "" {
                        pairs := strings.Split(labelStr, ",")
                        for _, pair := range pairs {
                            parts := strings.SplitN(pair, "=", 2)
                            if len(parts) == 2 {
                                labels[parts[0]] = strings.Trim(parts[1], "\"")
                            }
                        }
                    }
                    valStr := strings.TrimSpace(line[labelsEnd+1:])
                    val, err := strconv.ParseFloat(valStr, 64)
                    if err != nil {
                        return "", nil, 0, err
                    }
                    return name, labels, val, nil
                }
                parts := strings.Fields(line)
                if len(parts) != 2 {
                    return "", nil, 0, fmt.Errorf("invalid metric line: %s", line)
                }
                val, err := strconv.ParseFloat(parts[1], 64)
                if err != nil {
                    return "", nil, 0, err
                }
                return parts[0], labels, val, nil
            }
          annotations:
            - type: complexity
              label: String Scanning
              text: >-
                This solution scans the string multiple times with Index calls. For a real metrics parser handling
                millions of lines, you'd use a single-pass scanner. For now, clarity wins over performance.
            - type: interview
              label: String Parsing
              text: >-
                Parsing structured text is a very common interview question. The key skill is breaking it into clear
                steps: find boundaries, extract parts, parse values.
        - id: v3
          title: Aggregate Metrics by Name
          description: >-
            Write <code>func aggregateMetrics(lines []string) map[string]float64</code> that parses multiple Prometheus
            metric lines and sums values by metric name (ignoring labels).<br><br>Example: given
            <code>http_req{method="GET"} 10</code> and <code>http_req{method="POST"} 5</code>, return
            <code>map[http_req:15]</code>.
          functionSignature: func aggregateMetrics(lines []string) map[string]float64
          difficulty: 3
          testCases:
            - input: aggregateMetrics([]string{"req{m=\"GET\"} 10", "req{m=\"POST\"} 5", "up 1"})
              output: map[req:15 up:1]
          hints:
            - title: ðŸ¤” Think about it
              content: >-
                You already have a metric parser. Now you need to loop through lines, parse each one, and accumulate
                values. What map type stores running totals by name?
            - title: ðŸ’¡ Hint
              content: >-
                Reuse your metric parser from the previous variant. Skip lines that fail to parse or that are comments.
                The accumulation pattern is the same as counting, but with addition instead of increment.
          solution: |-
            func aggregateMetrics(lines []string) map[string]float64 {
                totals := make(map[string]float64)
                for _, line := range lines {
                    line = strings.TrimSpace(line)
                    if line == "" || strings.HasPrefix(line, "#") {
                        continue
                    }
                    name, _, val, err := parseMetric(line)
                    if err != nil {
                        continue
                    }
                    totals[name] += val
                }
                return totals
            }
    - id: challenge_3
      block: 3
      difficulty: 2
      concept: Sorting & Filtering
      variants:
        - id: v1
          title: Sort Pods by Name
          description: >-
            Write <code>func sortPodNames(names []string) []string</code> that returns the input slice sorted
            alphabetically. Sort in place and return the same slice.<br><br>Example: <code>["web-3", "api-1", "db-2",
            "web-1"]</code> â†’ <code>["api-1", "db-2", "web-1", "web-3"]</code>
          functionSignature: func sortPodNames(names []string) []string
          difficulty: 1
          testCases:
            - input: sortPodNames([]string{"web-3", "api-1", "db-2", "web-1"})
              output: "[\"api-1\", \"db-2\", \"web-1\", \"web-3\"]"
          hints:
            - title: ðŸ¤” Think about it
              content: "Go's sort package has a convenience function specifically for string slices. Check the Sorting section of the lesson."
            - title: ðŸ’¡ Hint
              content: "It's a one-liner. The function sorts in place, then you return the same slice."
          solution: |-
            func sortPodNames(names []string) []string {
                sort.Strings(names)
                return names
            }
        - id: v2
          title: Top N by Memory
          description: |-
            Given parallel slices of pod names and memory usage:
            <pre>names    := []string{"web-1", "api-1", "db-1", "cache-1", "worker-1"}
            memoryMB := []int{512, 256, 2048, 1024, 128}</pre>
            Write <code>func topByMemory(names []string, memoryMB []int, n int) []string</code> that returns the names of the top <code>n</code> pods by memory usage (descending).
          functionSignature: func topByMemory(names []string, memoryMB []int, n int) []string
          difficulty: 2
          testCases:
            - input: topByMemory([]string{"web-1","api-1","db-1","cache-1","worker-1"}, []int{512,256,2048,1024,128}, 3)
              output: "[\"db-1\", \"cache-1\", \"web-1\"]"
            - input: topByMemory([]string{"a","b"}, []int{100,200}, 5)
              output: "[\"b\", \"a\"]"
          hints:
            - title: ðŸ¤” Think about it
              content: >-
                You have two parallel slices that need to stay paired during sorting. What data structure lets you bundle
                a name and a value together so they move as one unit?
            - title: ðŸ’¡ Hint
              content: >-
                Zip the parallel slices into structs so they stay paired when sorted. After sorting, extract just the
                names from the top entries. Don't forget the edge case where n is larger than the input.
          solution: |-
            func topByMemory(names []string, memoryMB []int, n int) []string {
                type pod struct {
                    name string
                    mem  int
                }
                pods := make([]pod, len(names))
                for i := range names {
                    pods[i] = pod{names[i], memoryMB[i]}
                }
                sort.Slice(pods, func(i, j int) bool {
                    return pods[i].mem > pods[j].mem
                })
                if n > len(pods) {
                    n = len(pods)
                }
                result := make([]string, n)
                for i := 0; i < n; i++ {
                    result[i] = pods[i].name
                }
                return result
            }
          annotations:
            - type: pattern
              label: Parallel Slice â†’ Struct
              text: >-
                When you have parallel slices (names[i] goes with values[i]), zip them into a slice of structs first.
                This is safer and makes sorting straightforward.
            - type: interview
              label: Top K Pattern
              text: >-
                "Find top K elements" is one of the most common interview questions. For small K, sort and slice. For
                large data, use a min-heap (covered in Module 12).
        - id: v3
          title: Resource Usage Table
          description: >-
            Write <code>func resourceTable(names []string, cpuPercent []float64, memMB []int) string</code> that returns
            a formatted table sorted by CPU usage descending.<br><br>Format each row as <code>"%-12s %6.1f%%
            %6dMB"</code>.
          functionSignature: func resourceTable(names []string, cpuPercent []float64, memMB []int) string
          difficulty: 3
          testCases:
            - input: resourceTable([]string{"web","api"}, []float64{45.2, 82.3}, []int{256, 512})
              output: "\"api           82.3%    512MB\\nweb           45.2%    256MB\""
          hints:
            - title: ðŸ¤” Think about it
              content: >-
                Same zip-sort-format pattern as Top N, but with three parallel slices and formatted output. The tricky
                part is getting the format string right.
            - title: ðŸ’¡ Hint
              content: >-
                After zipping and sorting, check the Printing section of the lesson for width specifiers (left-aligned
                strings, right-aligned numbers) and how to print a literal percent sign.
          solution: |-
            func resourceTable(names []string, cpuPercent []float64, memMB []int) string {
                type resource struct {
                    name string
                    cpu  float64
                    mem  int
                }
                resources := make([]resource, len(names))
                for i := range names {
                    resources[i] = resource{names[i], cpuPercent[i], memMB[i]}
                }
                sort.Slice(resources, func(i, j int) bool {
                    return resources[i].cpu > resources[j].cpu
                })
                lines := make([]string, len(resources))
                for i, r := range resources {
                    lines[i] = fmt.Sprintf("%-12s %6.1f%% %6dMB", r.name, r.cpu, r.mem)
                }
                return strings.Join(lines, "\n")
            }
    - id: challenge_4
      block: 4
      difficulty: 2
      concept: String Parsing
      variants:
        - id: v1
          title: Parse Env File
          description: >-
            Write <code>func parseEnvFile(content string) map[string]string</code> that parses a <code>.env</code> file.
            Rules:<br>â€¢ Each line is <code>KEY=VALUE</code><br>â€¢ Lines starting with <code>#</code> are comments
            (skip)<br>â€¢ Empty lines are skipped<br>â€¢ Trim whitespace on keys and values<br>â€¢ Strip optional surrounding
            double quotes from values
          functionSignature: func parseEnvFile(content string) map[string]string
          difficulty: 1
          testCases:
            - input: parseEnvFile("A=1\nB=2")
              output: map[A:1 B:2]
            - input: parseEnvFile("# comment\nKEY=\"value\"")
              output: map[KEY:value]
            - input: parseEnvFile("  HOST = localhost  ")
              output: map[HOST:localhost]
          hints:
            - title: ðŸ¤” Think about it
              content: >-
                This follows the standard line-by-line parsing pattern: split into lines, decide what to skip, parse the
                rest. What kinds of lines should be skipped?
            - title: ðŸ’¡ Hint
              content: >-
                The Line-by-Line Parsing section in the lesson walks through this exact pattern with a complete example.
                The key steps are: split lines, trim whitespace, skip empties and comments, split key from value, clean
                up the value.
          solution: |-
            func parseEnvFile(content string) map[string]string {
                result := make(map[string]string)
                lines := strings.Split(content, "\n")
                for _, line := range lines {
                    line = strings.TrimSpace(line)
                    if line == "" || strings.HasPrefix(line, "#") {
                        continue
                    }
                    parts := strings.SplitN(line, "=", 2)
                    if len(parts) != 2 {
                        continue
                    }
                    key := strings.TrimSpace(parts[0])
                    val := strings.TrimSpace(parts[1])
                    val = strings.Trim(val, "\"")
                    result[key] = val
                }
                return result
            }
          annotations:
            - type: infra
              label: .env Files
              text: >-
                This is the exact format used by Docker Compose, systemd EnvironmentFile, and tools like direnv. You'll
                parse this format in real infra code.
        - id: v2
          title: Parse INI Sections
          description: >-
            Write <code>func parseINI(content string) map[string]map[string]string</code> that parses a simple INI file.
            Rules:<br>â€¢ Section headers: <code>[section_name]</code><br>â€¢ Key-value pairs: <code>key = value</code>
            under the current section<br>â€¢ Lines before any section go under <code>"default"</code><br>â€¢ Comments
            (<code>#</code>) and empty lines are skipped
          functionSignature: func parseINI(content string) map[string]map[string]string
          difficulty: 2
          testCases:
            - input: parseINI("[db]\nhost=localhost")
              output: map[db:map[host:localhost]]
            - input: parseINI("key=val\n[s]\nk=v")
              output: map[default:map[key:val] s:map[k:v]]
          hints:
            - title: ðŸ¤” Think about it
              content: >-
                This builds on the line-by-line pattern with one extra idea: you need to track which section you're
                currently in. When you see a section header, update the tracker. When you see a key-value pair, file it
                under the current section.
            - title: ðŸ’¡ Hint
              content: >-
                The return type is a nested map. Be careful â€” writing to an inner map that hasn't been initialized will
                panic. Check the Nested Maps section of the lesson for how to handle this safely.
          solution: |-
            func parseINI(content string) map[string]map[string]string {
                result := make(map[string]map[string]string)
                currentSection := "default"
                lines := strings.Split(content, "\n")
                for _, line := range lines {
                    line = strings.TrimSpace(line)
                    if line == "" || strings.HasPrefix(line, "#") {
                        continue
                    }
                    if strings.HasPrefix(line, "[") && strings.HasSuffix(line, "]") {
                        currentSection = line[1 : len(line)-1]
                        continue
                    }
                    parts := strings.SplitN(line, "=", 2)
                    if len(parts) != 2 {
                        continue
                    }
                    key := strings.TrimSpace(parts[0])
                    val := strings.TrimSpace(parts[1])
                    if result[currentSection] == nil {
                        result[currentSection] = make(map[string]string)
                    }
                    result[currentSection][key] = val
                }
                return result
            }
          annotations:
            - type: pattern
              label: State Machine Parsing
              text: >-
                Tracking "current section" as you iterate is a simple state machine. The same pattern works for parsing
                Dockerfiles (current stage), Terraform configs (current block), and K8s multi-doc YAML (current
                document).
        - id: v3
          title: INI with Environment Variable Expansion
          description: >-
            Write <code>func parseINIExpand(content string, env map[string]string) map[string]map[string]string</code>
            that parses an INI file like above, but also expands <code>${VAR}</code> references in values using the
            provided env map. Unknown variables become empty strings.
          functionSignature: func parseINIExpand(content string, env map[string]string) map[string]map[string]string
          difficulty: 3
          testCases:
            - input: "parseINIExpand(\"[db]\\nhost=${DB_HOST}\\nport=5432\", map[string]string{\"DB_HOST\": \"prod-db\"})"
              output: map[db:map[host:prod-db port:5432]]
          hints:
            - title: ðŸ¤” Think about it
              content: >-
                Build on your INI parser. After extracting each value, you need to find <code>${...}</code> patterns and
                replace them with lookups from the env map.
            - title: ðŸ’¡ Hint
              content: >-
                Go's stdlib has a function in the <code>os</code> package that does variable expansion with a custom
                lookup function. Check <code>go doc os.Expand</code> â€” it handles both <code>${VAR}</code> and
                <code>$VAR</code> syntax.
          solution: |-
            func parseINIExpand(content string, env map[string]string) map[string]map[string]string {
                result := make(map[string]map[string]string)
                currentSection := "default"
                lines := strings.Split(content, "\n")
                for _, line := range lines {
                    line = strings.TrimSpace(line)
                    if line == "" || strings.HasPrefix(line, "#") {
                        continue
                    }
                    if strings.HasPrefix(line, "[") && strings.HasSuffix(line, "]") {
                        currentSection = line[1 : len(line)-1]
                        continue
                    }
                    parts := strings.SplitN(line, "=", 2)
                    if len(parts) != 2 {
                        continue
                    }
                    key := strings.TrimSpace(parts[0])
                    val := strings.TrimSpace(parts[1])
                    val = os.Expand(val, func(k string) string {
                        return env[k]
                    })
                    if result[currentSection] == nil {
                        result[currentSection] = make(map[string]string)
                    }
                    result[currentSection][key] = val
                }
                return result
            }
          annotations:
            - type: stdlib
              label: os.Expand
              text: >-
                Go's <code>os.Expand</code> handles <code>${VAR}</code> and <code>$VAR</code> expansion with a custom
                mapping function. Much cleaner than regex. Used internally by Docker and other tools.
  scaffolds:
    - id: scaffold_swap
      concept: "In-Place Manipulation"
      variants:
        - id: v1
          type: trace
          title: "Predict the Swap"
          description: |-
            Trace through this code and predict the output:
            <pre>nums := []int{10, 20, 30}
            nums[0], nums[2] = nums[2], nums[0]
            fmt.Println(nums)</pre>
          solution: "[30 20 10]"
        - id: v2
          type: fix
          title: "Fix the Broken Swap"
          description: |-
            This code tries to swap the first and last elements, but it prints <code>[30 20 30]</code> instead of <code>[30 20 10]</code>. Why?
            <pre>nums := []int{10, 20, 30}
            nums[0] = nums[2]
            nums[2] = nums[0]
            fmt.Println(nums)</pre>
            Fix it so both values actually swap.
          hints: ["After <code>nums[0] = nums[2]</code> runs, what is <code>nums[0]</code>? The original 10 is gone."]
          solution: |-
            // The original nums[0] is overwritten before nums[2] reads it.
            // Fix: use simultaneous assignment so both sides read before writing.
            nums[0], nums[2] = nums[2], nums[0]
        - id: v3
          type: complete
          title: "Complete the Swap"
          description: |-
            Fill in the blank to swap index 1 and 3:
            <pre>vals := []string{"a", "b", "c", "d"}
            ____________________________
            fmt.Println(vals) // [a d c b]</pre>
          solution: 'vals[1], vals[3] = vals[3], vals[1]'
        - id: v4
          type: produce
          title: "Swap Two Elements"
          description: >-
            Given <code>nums := []int{10, 20, 30}</code>, swap index 0 and 2 in a single statement. Print the result.
          hints: ["Go supports simultaneous assignment: <code>a, b = b, a</code>"]
          solution: |-
            nums := []int{10, 20, 30}
            nums[0], nums[2] = nums[2], nums[0]
            fmt.Println(nums) // [30 20 10]
    - id: scaffold_swap_t
      concept: "In-Place Manipulation"
      template:
        type: produce
        title: "Swap in {{name}}"
        description: "Given <code>{{name}} := {{value}}</code>, swap index {{i}} and {{j}}. Print the result."
        hints: ["Use <code>{{name}}[{{i}}], {{name}}[{{j}}] = {{name}}[{{j}}], {{name}}[{{i}}]</code>"]
        solution: |-
          {{name}} := {{value}}
          {{name}}[{{i}}], {{name}}[{{j}}] = {{name}}[{{j}}], {{name}}[{{i}}]
          fmt.Println({{name}})
      params:
        - { name: colors, value: '[]string{"red", "green", "blue"}', i: "0", j: "2" }
        - { name: scores, value: '[]int{88, 95, 72}', i: "0", j: "1" }
    - id: scaffold_reverse
      concept: "In-Place Manipulation"
      variants:
        - id: v1
          type: trace
          title: "Predict the Reverse"
          description: |-
            Trace through this two-pointer loop and predict the output:
            <pre>s := []int{1, 2, 3, 4}
            for i, j := 0, len(s)-1; i < j; i, j = i+1, j-1 {
                s[i], s[j] = s[j], s[i]
            }
            fmt.Println(s)</pre>
          solution: "[4 3 2 1]"
        - id: v2
          type: fix
          title: "Fix the Reverse Loop"
          description: |-
            This reverse loop runs too many iterations and double-reverses back to the original order. Fix the loop condition:
            <pre>s := []string{"a", "b", "c", "d"}
            for i, j := 0, len(s)-1; i < len(s); i, j = i+1, j-1 {
                s[i], s[j] = s[j], s[i]
            }
            fmt.Println(s) // prints [a b c d] â€” unchanged!</pre>
          hints: ["The loop should stop when the two pointers meet in the middle, not when i reaches the end."]
          solution: |-
            // i < len(s) makes i go all the way across, swapping everything
            // back to where it started. Stop when pointers meet:
            for i, j := 0, len(s)-1; i < j; i, j = i+1, j-1 {
                s[i], s[j] = s[j], s[i]
            }
        - id: v3
          type: complete
          title: "Complete the Reverse"
          description: |-
            Fill in the four blanks to reverse this slice in place:
            <pre>items := []string{"x", "y", "z", "w"}
            for i, j := _____, _____; i < j; _____, _____ {
                items[i], items[j] = items[j], items[i]
            }</pre>
          solution: |-
            for i, j := 0, len(items)-1; i < j; i, j = i+1, j-1 {
                items[i], items[j] = items[j], items[i]
            }
        - id: v4
          type: produce
          title: "Reverse a Server List"
          description: >-
            Given <code>servers := []string{"a", "b", "c", "d"}</code>, reverse it in place (no new slice) and print the result.
          hints: ["Use two pointers starting from opposite ends. Swap and move inward until they meet."]
          solution: |-
            servers := []string{"a", "b", "c", "d"}
            for i, j := 0, len(servers)-1; i < j; i, j = i+1, j-1 {
                servers[i], servers[j] = servers[j], servers[i]
            }
            fmt.Println(servers) // [d c b a]
    - id: scaffold_filter
      concept: "In-Place Manipulation"
      variants:
        - id: v1
          type: trace
          title: "Predict the Filter"
          description: |-
            Trace through the write-index pattern and predict the output:
            <pre>nums := []int{1, 2, 3, 4, 5, 6}
            n := 0
            for _, v := range nums {
                if v%2 == 0 {
                    nums[n] = v
                    n++
                }
            }
            nums = nums[:n]
            fmt.Println(nums)</pre>
          solution: "[2 4 6]"
        - id: v2
          type: complete
          title: "Complete the Filter"
          description: |-
            Fill in the three blanks to filter in place, keeping only strings starting with "web":
            <pre>pods := []string{"web-1", "api-1", "web-2", "db-1"}
            n := 0
            for _, p := range pods {
                if ________________________ {
                    _____________
                    _____________
                }
            }
            pods = pods[:n]</pre>
          solution: |-
            if strings.HasPrefix(p, "web") {
                pods[n] = p
                n++
            }
        - id: v3
          type: produce
          title: "Filter Tags In Place"
          description: >-
            Given <code>tags := []string{"v1.0", "latest", "v2.0", "dev"}</code>, remove all non-version tags
            in place (keep only tags starting with "v"). Print the result.
          hints: ["Use the write-index pattern: <code>n</code> tracks where to write, the loop reads every element. Truncate at the end."]
          solution: |-
            tags := []string{"v1.0", "latest", "v2.0", "dev"}
            n := 0
            for _, tag := range tags {
                if strings.HasPrefix(tag, "v") {
                    tags[n] = tag
                    n++
                }
            }
            tags = tags[:n]
            fmt.Println(tags) // [v1.0 v2.0]
    - id: scaffold_sort
      concept: "Sorting & Filtering"
      variants:
        - id: v1
          type: trace
          title: "Predict the Sort"
          description: |-
            The <code>></code> comparator sorts descending. What does this print?
            <pre>nums := []int{3, 1, 4, 1, 5}
            sort.Slice(nums, func(i, j int) bool {
                return nums[i] > nums[j]
            })
            fmt.Println(nums)</pre>
          solution: "[5 4 3 1 1]"
        - id: v2
          type: fix
          title: "Fix the Sort Order"
          description: |-
            This should sort names A-Z, but it outputs <code>[charlie bob alice]</code>. Fix the comparator:
            <pre>names := []string{"charlie", "alice", "bob"}
            sort.Slice(names, func(i, j int) bool {
                return names[i] > names[j]
            })</pre>
          hints: ["<code>></code> means 'i comes first if it's larger' â€” that's descending. What operator gives ascending?"]
          solution: |-
            // Change > to < for ascending (A-Z) order:
            sort.Slice(names, func(i, j int) bool {
                return names[i] < names[j]
            })
        - id: v3
          type: complete
          title: "Complete the Sort"
          description: |-
            Fill in the comparator to sort response times ascending (fastest first):
            <pre>times := []int{234, 12, 891, 45}
            sort.Slice(times, func(i, j int) bool {
                return _______________________
            })
            fmt.Println(times) // [12 45 234 891]</pre>
          solution: "times[i] < times[j]"
        - id: v4
          type: produce
          title: "Sort Scores Ascending"
          description: >-
            Given <code>scores := []int{42, 7, 89, 23}</code>, sort them smallest-first using <code>sort.Slice</code> and print the result.
          hints: ["The comparator returns true when element i should come before element j. For ascending, that means i < j."]
          solution: |-
            scores := []int{42, 7, 89, 23}
            sort.Slice(scores, func(i, j int) bool {
                return scores[i] < scores[j]
            })
            fmt.Println(scores) // [7 23 42 89]
    - id: scaffold_sort_t
      concept: "Sorting & Filtering"
      template:
        type: produce
        title: "Sort {{name}}"
        description: "Given <code>{{name}} := {{value}}</code>, sort in {{order}} order and print the result."
        hints: ["Use <code>sort.Slice</code> with <code>{{name}}[i] {{op}} {{name}}[j]</code>"]
        solution: |-
          {{name}} := {{value}}
          sort.Slice({{name}}, func(i, j int) bool {
              return {{name}}[i] {{op}} {{name}}[j]
          })
          fmt.Println({{name}})
      params:
        - { name: ages, value: '[]int{25, 18, 42, 31}', order: ascending, op: "<" }
        - { name: prices, value: '[]float64{9.99, 4.50, 15.00, 7.25}', order: descending, op: ">" }
    - id: scaffold_topn
      concept: "Sorting & Filtering"
      variants:
        - id: v1
          type: trace
          title: "Predict Top 2"
          description: |-
            Sort descending, then slice. What does this print?
            <pre>vals := []int{10, 50, 30, 20, 40}
            sort.Slice(vals, func(i, j int) bool {
                return vals[i] > vals[j]
            })
            fmt.Println(vals[:2])</pre>
          solution: "[50 40]"
        - id: v2
          type: complete
          title: "Complete Top N"
          description: |-
            Fill in the two blanks to get the top 3 highest latencies:
            <pre>latencies := []int{234, 12, 891, 45, 567}
            sort.Slice(latencies, func(i, j int) bool {
                return _______________________
            })
            top3 := latencies[:___]
            fmt.Println(top3)</pre>
          solution: |-
            latencies[i] > latencies[j]
            // and
            latencies[:3]
        - id: v3
          type: produce
          title: "Find the Top 2"
          description: >-
            Given <code>scores := []int{42, 7, 89, 23, 56}</code>, find and print the 2 highest values.
          hints: ["Sort the slice in descending order, then take a slice of the first 2 elements."]
          solution: |-
            scores := []int{42, 7, 89, 23, 56}
            sort.Slice(scores, func(i, j int) bool {
                return scores[i] > scores[j]
            })
            fmt.Println(scores[:2]) // [89 56]
    - id: scaffold_slice_ops
      concept: "Slice Operations"
      variants:
        - id: v1
          type: trace
          title: "Predict the Slice"
          description: |-
            What does this print?
            <pre>s := []string{"a", "b", "c", "d", "e"}
            fmt.Println(s[1:4])
            fmt.Println(s[:2])
            fmt.Println(s[3:])</pre>
          solution: |-
            [b c d]
            [a b]
            [d e]
        - id: v2
          type: fix
          title: "Fix the Slice Bounds"
          description: |-
            This code should print the last 3 elements, but it panics with an out-of-range error:
            <pre>items := []string{"a", "b", "c", "d", "e"}
            last3 := items[len(items)-3 : len(items)+1]
            fmt.Println(last3)</pre>
            Fix the slice expression.
          hints: ["The end index in a slice expression is exclusive â€” it goes up to but not including that index."]
          solution: |-
            // End index must be <= len(items), not len(items)+1
            last3 := items[len(items)-3:]
        - id: v3
          type: complete
          title: "Complete the Slice"
          description: |-
            Fill in the blank to get elements at index 1 and 2:
            <pre>nodes := []string{"a", "b", "c", "d"}
            mid := nodes[___:___]
            fmt.Println(mid) // [b c]</pre>
          solution: "nodes[1:3]"
        - id: v4
          type: produce
          title: "Get the Last Two"
          description: >-
            Given <code>pods := []string{"web-1", "api-1", "db-1", "cache-1"}</code>, get a slice of the last 2 elements. Print it.
          hints: ["Use <code>len()</code> to calculate the start index from the end."]
          solution: |-
            pods := []string{"web-1", "api-1", "db-1", "cache-1"}
            last2 := pods[len(pods)-2:]
            fmt.Println(last2) // [db-1 cache-1]
    - id: scaffold_append
      concept: "Slice Operations"
      variants:
        - id: v1
          type: trace
          title: "Predict Append"
          description: |-
            What does this print?
            <pre>a := []int{1, 2}
            b := append(a, 3, 4)
            fmt.Println(a)
            fmt.Println(b)
            fmt.Println(len(a), len(b))</pre>
          solution: |-
            [1 2]
            [1 2 3 4]
            2 4
        - id: v2
          type: fix
          title: "Fix the Append"
          description: |-
            This should build a list of names, but it always prints an empty slice:
            <pre>var names []string
            for _, n := range []string{"a", "b", "c"} {
                append(names, n)
            }
            fmt.Println(names)</pre>
            Fix it.
          hints: ["<code>append</code> returns a new slice â€” it doesn't modify the original."]
          solution: |-
            // append returns the result; you must assign it back
            names = append(names, n)
        - id: v3
          type: complete
          title: "Complete the Append"
          description: |-
            Fill in the blank to add "db-1" to the end of the slice:
            <pre>servers := []string{"web-1", "api-1"}
            servers = ___________________________
            fmt.Println(servers) // [web-1 api-1 db-1]</pre>
          solution: 'append(servers, "db-1")'
        - id: v4
          type: produce
          title: "Build a Slice"
          description: >-
            Start with an empty slice. Use a loop to append the strings <code>"item-1"</code> through <code>"item-4"</code>. Print the result.
          hints: ["Use <code>fmt.Sprintf(\"item-%d\", i)</code> to build each string."]
          solution: |-
            var items []string
            for i := 1; i <= 4; i++ {
                items = append(items, fmt.Sprintf("item-%d", i))
            }
            fmt.Println(items) // [item-1 item-2 item-3 item-4]
    - id: scaffold_map_count
      concept: "Map Patterns"
      variants:
        - id: v1
          type: trace
          title: "Predict the Map"
          description: |-
            What does this print?
            <pre>m := make(map[string]int)
            m["a"]++
            m["b"]++
            m["a"]++
            fmt.Println(m["a"], m["b"], m["c"])</pre>
          solution: "2 1 0"
        - id: v2
          type: fix
          title: "Fix the Map Lookup"
          description: |-
            This code should print "found" for keys that exist, but it always prints "found" even for missing keys:
            <pre>config := map[string]string{"host": "localhost", "port": "5432"}
            val := config["timeout"]
            if val != "" {
                fmt.Println("found:", val)
            } else {
                fmt.Println("not found")
            }</pre>
            What's the problem? What if a key exists with an empty string value?
          hints: ["An empty string is the zero value for string â€” you can't tell if the key exists or has an empty value. Use the comma-ok pattern."]
          solution: |-
            // Use comma-ok to distinguish "missing" from "empty value":
            val, ok := config["timeout"]
            if ok {
                fmt.Println("found:", val)
            } else {
                fmt.Println("not found")
            }
        - id: v3
          type: complete
          title: "Complete the Counter"
          description: |-
            Fill in the blanks to count word frequencies:
            <pre>words := []string{"go", "is", "go", "fun"}
            counts := make(map[string]int)
            for _, w := range words {
                _____________
            }
            fmt.Println(counts)</pre>
          solution: "counts[w]++"
        - id: v4
          type: produce
          title: "Count Characters"
          description: >-
            Given <code>s := "banana"</code>, count how many times each character appears using a map. Print the map.
          hints: ["Range over a string to get each character. Use a <code>map[rune]int</code> or <code>map[byte]int</code>."]
          solution: |-
            s := "banana"
            counts := make(map[rune]int)
            for _, ch := range s {
                counts[ch]++
            }
            for ch, n := range counts {
                fmt.Printf("%c: %d\n", ch, n)
            }
    - id: scaffold_map_group
      concept: "Map Patterns"
      variants:
        - id: v1
          type: trace
          title: "Predict the Grouping"
          description: |-
            What does <code>grouped["short"]</code> contain after this runs?
            <pre>words := []string{"go", "rust", "c", "java", "py"}
            grouped := make(map[string][]string)
            for _, w := range words {
                if len(w) <= 2 {
                    grouped["short"] = append(grouped["short"], w)
                } else {
                    grouped["long"] = append(grouped["long"], w)
                }
            }
            fmt.Println(grouped["short"])</pre>
          solution: "[go c py]"
        - id: v2
          type: complete
          title: "Complete the Grouping"
          description: |-
            Fill in the blank to group numbers as even or odd:
            <pre>nums := []int{1, 2, 3, 4, 5, 6}
            groups := make(map[string][]int)
            for _, n := range nums {
                if n%2 == 0 {
                    ___________________________________
                } else {
                    ___________________________________
                }
            }</pre>
          solution: |-
            groups["even"] = append(groups["even"], n)
            // and
            groups["odd"] = append(groups["odd"], n)
        - id: v3
          type: produce
          title: "Group by First Letter"
          description: >-
            Given <code>names := []string{"alice", "bob", "anna", "ben"}</code>, build a <code>map[string][]string</code> grouping names by their first letter. Print the map.
          hints: ["Get the first letter with <code>string(name[0])</code> or <code>name[:1]</code>."]
          solution: |-
            names := []string{"alice", "bob", "anna", "ben"}
            groups := make(map[string][]string)
            for _, name := range names {
                key := name[:1]
                groups[key] = append(groups[key], name)
            }
            for k, v := range groups {
                fmt.Printf("%s: %v\n", k, v)
            }
    - id: scaffold_string_split
      concept: "String Parsing"
      variants:
        - id: v1
          type: trace
          title: "Predict the Split"
          description: |-
            What does this print?
            <pre>s := "a:b:c:d"
            fmt.Println(strings.Split(s, ":"))
            fmt.Println(strings.SplitN(s, ":", 2))</pre>
          solution: |-
            [a b c d]
            [a b:c:d]
        - id: v2
          type: fix
          title: "Fix the Split"
          description: |-
            This should extract the host from <code>"host:port"</code> but it panics when there's no colon:
            <pre>addr := "localhost"
            parts := strings.Split(addr, ":")
            host := parts[0]
            port := parts[1]
            fmt.Println(host, port)</pre>
            Fix it to handle addresses with or without a port.
          hints: ["When there's no colon, <code>strings.Split</code> returns a single-element slice. Accessing index 1 panics."]
          solution: |-
            parts := strings.SplitN(addr, ":", 2)
            host := parts[0]
            port := ""
            if len(parts) == 2 {
                port = parts[1]
            }
        - id: v3
          type: complete
          title: "Complete the Parse"
          description: |-
            Fill in the blank to extract the key and value from <code>"name=Go"</code>:
            <pre>pair := "name=Go"
            parts := strings.SplitN(pair, "=", ___)
            key := parts[0]
            val := parts[1]
            fmt.Println(key, val) // name Go</pre>
          solution: "2"
        - id: v4
          type: produce
          title: "Split a CSV Line"
          description: >-
            Given <code>line := "alice,30,engineer"</code>, split it on commas and print each field on its own line.
          hints: ["Use <code>strings.Split(line, \",\")</code> then range over the result."]
          solution: |-
            line := "alice,30,engineer"
            for _, field := range strings.Split(line, ",") {
                fmt.Println(field)
            }
    - id: scaffold_string_build
      concept: "String Parsing"
      variants:
        - id: v1
          type: trace
          title: "Predict the Join"
          description: |-
            What does this print?
            <pre>parts := []string{"hello", "world"}
            fmt.Println(strings.Join(parts, "-"))
            fmt.Println(strings.Join(parts, ""))
            fmt.Println(strings.Join(parts, ", "))</pre>
          solution: |-
            hello-world
            helloworld
            hello, world
        - id: v2
          type: complete
          title: "Complete the Builder"
          description: |-
            Fill in the blanks to build <code>"a|b|c"</code> from a slice:
            <pre>items := []string{"a", "b", "c"}
            result := strings._______(items, "___")
            fmt.Println(result)</pre>
          solution: 'strings.Join(items, "|")'
        - id: v3
          type: produce
          title: "Build a Path"
          description: >-
            Given <code>segments := []string{"usr", "local", "bin"}</code>, join them with <code>"/"</code> and print the result.
          hints: ["Use <code>strings.Join</code>."]
          solution: |-
            segments := []string{"usr", "local", "bin"}
            fmt.Println(strings.Join(segments, "/")) // usr/local/bin
    - id: scaffold_numbers
      concept: "Numbers & Percentages"
      variants:
        - id: v1
          type: trace
          title: "Predict the Division"
          description: |-
            What does this print?
            <pre>a := 7
            b := 2
            fmt.Println(a / b)
            fmt.Println(float64(a) / float64(b))</pre>
          solution: |-
            3
            3.5
        - id: v2
          type: fix
          title: "Fix the Percentage"
          description: |-
            This should print <code>75.0%</code> but prints <code>0.0%</code>:
            <pre>passed := 3
            total := 4
            pct := passed / total * 100
            fmt.Printf("%.1f%%\n", float64(pct))</pre>
            Fix it.
          hints: ["Integer division <code>3 / 4</code> equals 0, not 0.75. You need floats BEFORE dividing."]
          solution: |-
            // Convert to float64 before dividing
            pct := float64(passed) / float64(total) * 100
            fmt.Printf("%.1f%%\n", pct) // 75.0%
        - id: v3
          type: complete
          title: "Complete the Conversion"
          description: |-
            Fill in the blank to convert a string to an int safely:
            <pre>s := "42"
            n, err := strconv._______(s)
            if err != nil {
                fmt.Println("bad number")
            }
            fmt.Println(n)</pre>
          solution: "Atoi"
        - id: v4
          type: produce
          title: "Calculate a Ratio"
          description: >-
            Given <code>errors := 7</code> and <code>total := 20</code>, calculate the error rate as a percentage with one decimal place. Print it as <code>35.0%</code>.
          hints: ["Convert to <code>float64</code> before dividing. Use <code>%.1f%%</code> format verb."]
          solution: |-
            errors := 7
            total := 20
            pct := float64(errors) / float64(total) * 100
            fmt.Printf("%.1f%%\n", pct) // 35.0%
    - id: scaffold_line_parse
      concept: "Line Parsing"
      variants:
        - id: v1
          type: trace
          title: "Predict the Lines"
          description: |-
            What does this print?
            <pre>s := "one\ntwo\n\nthree"
            lines := strings.Split(s, "\n")
            fmt.Println(len(lines))
            fmt.Println(lines[2] == "")</pre>
          solution: |-
            4
            true
        - id: v2
          type: fix
          title: "Fix the Line Filter"
          description: |-
            This should skip comment lines (starting with #) but it skips ALL lines:
            <pre>input := "# comment\ndata\n# another\nmore"
            for _, line := range strings.Split(input, "\n") {
                if strings.HasPrefix(line, "#") {
                    break
                }
                fmt.Println(line)
            }</pre>
            Fix it.
          hints: ["<code>break</code> exits the entire loop. You want to skip just this iteration."]
          solution: |-
            // Use continue instead of break to skip one iteration
            if strings.HasPrefix(line, "#") {
                continue
            }
        - id: v3
          type: complete
          title: "Complete the Parser"
          description: |-
            Fill in the blanks to parse <code>"a=1\nb=2"</code> into a map:
            <pre>input := "a=1\nb=2"
            m := make(map[string]string)
            for _, line := range strings.Split(input, "\n") {
                parts := strings.SplitN(line, "=", ___)
                if len(parts) == ___ {
                    m[parts[0]] = parts[1]
                }
            }
            fmt.Println(m)</pre>
          solution: |-
            2
            // and
            2
        - id: v4
          type: produce
          title: "Count Non-Empty Lines"
          description: >-
            Given <code>text := "alpha\n\nbeta\n\ngamma\n"</code>, count and print how many non-empty lines there are.
          hints: ["Split on newlines, then loop and count lines where <code>strings.TrimSpace(line) != \"\"</code>."]
          solution: |-
            text := "alpha\n\nbeta\n\ngamma\n"
            count := 0
            for _, line := range strings.Split(text, "\n") {
                if strings.TrimSpace(line) != "" {
                    count++
                }
            }
            fmt.Println(count) // 3
