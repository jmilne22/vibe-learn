conceptLinks:
  Hash Maps: "#hash-maps-the-universal-solver"
  Two Pointers: "#two-pointers"
  Sliding Window: "#sliding-window"
  Binary Search: "#binary-search"
  Stacks: "#stack-patterns"
sharedContent: {}
variants:
  warmups:
    - id: warmup_1
      concept: Hash Maps
      variants:
        - id: v1
          title: Frequency Count
          description: >-
            Write a function that counts the frequency of each log level in a slice of log entries. Each entry is a
            string like <code>"ERROR: connection timeout"</code>. Return a <code>map[string]int</code> of level → count.
          hints:
            - "Split each entry on <code>\": \"</code> or use <code>strings.SplitN(entry, \":\", 2)</code> to get the level"
            - Increment <code>counts[level]++</code>
          solution: |-
            func countLogLevels(entries []string) map[string]int {
                counts := make(map[string]int)
                for _, entry := range entries {
                    parts := strings.SplitN(entry, ":", 2)
                    if len(parts) > 0 {
                        level := strings.TrimSpace(parts[0])
                        counts[level]++
                    }
                }
                return counts
            }
        - id: v2
          title: Two Sum
          description: >-
            Write a function that finds two indices in a slice of server latencies (ints) that sum to a target value.
            Return the indices, or (-1, -1) if no pair exists. Use a hash map for O(n) time.
          hints:
            - For each element, compute <code>complement = target - latency</code>. Check if complement is in the map.
            - Store <code>seen[latency] = index</code> as you iterate
          solution: |-
            func twoSum(latencies []int, target int) (int, int) {
                seen := make(map[int]int)
                for i, lat := range latencies {
                    if j, ok := seen[target-lat]; ok {
                        return j, i
                    }
                    seen[lat] = i
                }
                return -1, -1
            }
    - id: warmup_2
      concept: Two Pointers
      variants:
        - id: v1
          title: Merge Sorted Log Timestamps
          description: >-
            Write a function that merges two sorted slices of integers (representing Unix timestamps) into one sorted
            slice. O(n+m) time.
          hints:
            - Use two index variables, i and j. Compare <code>a[i]</code> and <code>b[j]</code>, append the smaller one.
            - "After the main loop, append remaining elements: <code>result = append(result, a[i:]...)</code>"
          solution: |-
            func mergeSorted(a, b []int) []int {
                result := make([]int, 0, len(a)+len(b))
                i, j := 0, 0
                for i < len(a) && j < len(b) {
                    if a[i] <= b[j] {
                        result = append(result, a[i])
                        i++
                    } else {
                        result = append(result, b[j])
                        j++
                    }
                }
                result = append(result, a[i:]...)
                result = append(result, b[j:]...)
                return result
            }
    - id: warmup_3
      concept: Sliding Window
      variants:
        - id: v1
          title: Moving Average
          description: >-
            Write a function that computes the moving average of CPU samples over a window of size k. Return a slice of
            averages.
          hints:
            - >-
              Compute the initial window sum, then slide: add <code>samples[i]</code>, subtract
              <code>samples[i-k]</code>
            - Divide the running sum by <code>float64(k)</code> for each window position
          solution: |-
            func movingAverage(samples []float64, k int) []float64 {
                if len(samples) < k {
                    return nil
                }
                var sum float64
                for i := 0; i < k; i++ {
                    sum += samples[i]
                }
                avgs := []float64{sum / float64(k)}
                for i := k; i < len(samples); i++ {
                    sum += samples[i] - samples[i-k]
                    avgs = append(avgs, sum/float64(k))
                }
                return avgs
            }
    - id: warmup_4
      concept: Binary Search
      variants:
        - id: v1
          title: Find Config Version
          description: >-
            Write a binary search function that finds a target string in a sorted slice of version strings (e.g.,
            <code>["v1.0", "v1.1", "v2.0"]</code>). Return the index or -1 if not found.
          hints:
            - Use <code>lo, hi := 0, len(versions)-1</code>. Compare <code>versions[mid]</code> with target.
            - Use <code>mid = lo + (hi-lo)/2</code> to avoid integer overflow
          solution: |-
            func findVersion(versions []string, target string) int {
                lo, hi := 0, len(versions)-1
                for lo <= hi {
                    mid := lo + (hi-lo)/2
                    if versions[mid] == target {
                        return mid
                    } else if versions[mid] < target {
                        lo = mid + 1
                    } else {
                        hi = mid - 1
                    }
                }
                return -1
            }
    - id: warmup_5
      concept: Stacks
      variants:
        - id: v1
          title: Valid Brackets
          description: >-
            Write a function that validates matching brackets in a string: <code>()[]{}"</code>. Return true if all
            brackets are properly matched and nested.
          hints:
            - Use a <code>[]byte</code> slice as a stack. Push opening brackets, pop on closing brackets.
            - "Check that the popped bracket matches: map <code>')' → '('</code>, etc."
          solution: |-
            func isValid(s string) bool {
                stack := []byte{}
                pairs := map[byte]byte{')': '(', ']': '[', '}': '{'}
                for i := 0; i < len(s); i++ {
                    ch := s[i]
                    if ch == '(' || ch == '[' || ch == '{' {
                        stack = append(stack, ch)
                    } else if match, ok := pairs[ch]; ok {
                        if len(stack) == 0 || stack[len(stack)-1] != match {
                            return false
                        }
                        stack = stack[:len(stack)-1]
                    }
                }
                return len(stack) == 0
            }
  challenges:
    - id: challenge_1
      block: 1
      difficulty: 1
      concept: Hash Maps
      variants:
        - id: v1
          title: Alert Deduplicator
          description: >-
            Write a function that deduplicates alert names while preserving their first occurrence order. Input:
            <code>[]string</code> of alert names. Output: deduplicated <code>[]string</code>.
          functionSignature: func dedup(alerts []string) []string
          difficulty: 1
          testCases:
            - input: "[\"cpu_high\", \"mem_high\", \"cpu_high\", \"disk_full\", \"mem_high\"]"
              output: "[\"cpu_high\", \"mem_high\", \"disk_full\"]"
            - input: "[]string{}"
              output: "[]string{}"
          hints:
            - title: Think about it
              content: How do you track what you've already seen while preserving order?
            - title: Hint
              content: Use a map[string]bool for O(1) lookups. Only append to result if !seen[alert].
          solution: |-
            func dedup(alerts []string) []string {
                seen := make(map[string]bool)
                var result []string
                for _, alert := range alerts {
                    if !seen[alert] {
                        seen[alert] = true
                        result = append(result, alert)
                    }
                }
                return result
            }
          annotations:
            - type: complexity
              label: Linear Scan
              text: O(n) time, O(n) space for the seen map
            - type: interview
              label: Order-Preserving Dedup
              text: Deduplication preserving order is a classic easy interview question
        - id: v2
          title: Pod Pair Finder
          description: >-
            Write a function that finds all unique pairs of pods whose combined memory usage equals a target. Each pod
            can only be used once. Return pairs as <code>[][2]string</code> (pod names).
          functionSignature: func findPodPairs(pods map[string]int, target int) [][2]string
          difficulty: 2
          testCases:
            - input: "pods: {web:300, api:200, cache:100, db:400}, target: 500"
              output: "[[web,api], [cache,db]]"
            - input: "pods: {a:250, b:250}, target: 500"
              output: "[[a,b]]"
          hints:
            - title: Think about it
              content: This is Two Sum but with names instead of indices. How do you avoid duplicating pairs (a,b) and (b,a)?
            - title: Hint
              content: >-
                Build a map of memory → []podNames. For each pod, check if target-memory exists. Track used pods to
                avoid duplicates.
          solution: |-
            func findPodPairs(pods map[string]int, target int) [][2]string {
                memToNames := make(map[int][]string)
                for name, mem := range pods {
                    memToNames[mem] = append(memToNames[mem], name)
                }
                used := make(map[string]bool)
                var pairs [][2]string
                for name, mem := range pods {
                    if used[name] {
                        continue
                    }
                    complement := target - mem
                    for _, other := range memToNames[complement] {
                        if other != name && !used[other] {
                            pairs = append(pairs, [2]string{name, other})
                            used[name] = true
                            used[other] = true
                            break
                        }
                    }
                }
                return pairs
            }
          annotations:
            - type: complexity
              label: Hash Map Lookup
              text: O(n) average case with hash map lookups
            - type: pattern
              label: Two Sum Variant
              text: "Two Sum variant: complement lookup in a map, with deduplication via a used set"
        - id: v3
          title: Log Analyzer Pipeline
          description: >-
            Build a log analysis pipeline: (1) Parse log lines in format <code>"TIMESTAMP LEVEL MESSAGE"</code>. (2)
            Group by level. (3) For each level, find the most common word in messages (excluding stop words: the, a, an,
            is, to, in). (4) Return <code>map[string]string</code> of level → most common word.
          functionSignature: func analyzeTopWords(logs []string) map[string]string
          difficulty: 3
          testCases:
            - input: 5 ERROR logs about "connection timeout"
              output: map[ERROR:"connection"]
            - input: mixed INFO and ERROR logs
              output: top word for each level
          hints:
            - title: Think about it
              content: This combines parsing, grouping, and frequency counting. What data structures do you need?
            - title: Hint
              content: >-
                Parse: SplitN(line, " ", 3) for timestamp, level, message. Group messages by level. For each group,
                split messages into words, count frequencies (skipping stop words), find the max.
          solution: |-
            func analyzeTopWords(logs []string) map[string]string {
                stop := map[string]bool{"the":true, "a":true, "an":true, "is":true, "to":true, "in":true}
                grouped := make(map[string][]string)
                for _, line := range logs {
                    parts := strings.SplitN(line, " ", 3)
                    if len(parts) < 3 {
                        continue
                    }
                    level := parts[1]
                    grouped[level] = append(grouped[level], parts[2])
                }
                result := make(map[string]string)
                for level, messages := range grouped {
                    freq := make(map[string]int)
                    for _, msg := range messages {
                        for _, word := range strings.Fields(strings.ToLower(msg)) {
                            if !stop[word] {
                                freq[word]++
                            }
                        }
                    }
                    maxWord, maxCount := "", 0
                    for word, count := range freq {
                        if count > maxCount {
                            maxWord = word
                            maxCount = count
                        }
                    }
                    result[level] = maxWord
                }
                return result
            }
          annotations:
            - type: complexity
              label: Nested Iteration
              text: O(n * m) where n=log lines, m=average words per message
            - type: pattern
              label: Parse-Group-Aggregate
              text: "Parse → Group → Aggregate: a pipeline of map operations, very common in data processing"
    - id: challenge_2
      block: 2
      difficulty: 1
      concept: Sliding Window
      variants:
        - id: v1
          title: Longest Healthy Streak
          description: >-
            Write a function that finds the longest consecutive streak of non-error statuses. Input:
            <code>[]string</code> of statuses. An "error" status breaks the streak.
          functionSignature: func longestHealthyStreak(statuses []string) int
          difficulty: 1
          testCases:
            - input: "[\"ok\",\"ok\",\"error\",\"ok\",\"ok\",\"ok\"]"
              output: "3"
            - input: "[\"error\"]"
              output: "0"
            - input: "[\"ok\",\"ok\",\"ok\"]"
              output: "3"
          hints:
            - title: Think about it
              content: When you hit an error, what happens to the window?
            - title: Hint
              content: Reset left pointer to right+1 on error. Track maxLen as max(maxLen, right-left+1).
          solution: |-
            func longestHealthyStreak(statuses []string) int {
                maxLen := 0
                left := 0
                for right := 0; right < len(statuses); right++ {
                    if statuses[right] == "error" {
                        left = right + 1
                    }
                    if right-left+1 > maxLen {
                        maxLen = right - left + 1
                    }
                }
                return maxLen
            }
          annotations:
            - type: complexity
              label: Single Pass
              text: O(n) time, O(1) space — single pass
            - type: pattern
              label: Variable Window
              text: "Variable sliding window: expand right, reset left on constraint violation"
        - id: v2
          title: Max Requests in Time Window
          description: >-
            Given a sorted list of request timestamps (ints, seconds since epoch), find the maximum number of requests
            that occur within any <code>windowSec</code>-second window.
          functionSignature: func maxRequestsInWindow(timestamps []int, windowSec int) int
          difficulty: 2
          testCases:
            - input: "[1,2,3,10,11,12,13], window=3"
              output: 4 (timestamps 10,11,12,13)
            - input: "[1,1,1,1], window=1"
              output: "4"
          hints:
            - title: Think about it
              content: Since timestamps are sorted, when should you shrink the left side?
            - title: Hint
              content: Expand right. While timestamps[right]-timestamps[left] >= windowSec, shrink left. Track max window size.
          solution: |-
            func maxRequestsInWindow(timestamps []int, windowSec int) int {
                maxCount := 0
                left := 0
                for right := 0; right < len(timestamps); right++ {
                    for timestamps[right]-timestamps[left] >= windowSec {
                        left++
                    }
                    if right-left+1 > maxCount {
                        maxCount = right - left + 1
                    }
                }
                return maxCount
            }
          annotations:
            - type: complexity
              label: Amortized Linear
              text: O(n) — each pointer moves forward at most n times
            - type: interview
              label: Rate Limiting Window
              text: Rate limiting / sliding window on timestamps is a common systems design interview question
        - id: v3
          title: Minimum Window Covering All Services
          description: >-
            Given a list of log entries with service names and a set of required services, find the shortest contiguous
            subarray of logs that contains at least one entry from every required service. Return the start and end
            indices.
          functionSignature: func minWindowAllServices(logs []string, required []string) (int, int)
          difficulty: 3
          testCases:
            - input: logs=[api,web,db,api,cache,web,db], required=[web,db]
              output: (1,2) — [web,db]
            - input: logs=[a,b,c], required=[d]
              output: (-1,-1) — not found
          hints:
            - title: Think about it
              content: This is the minimum window substring problem. What do you need to track?
            - title: Hint
              content: >-
                Track counts of required services in the current window with a map. When all required are present, try
                to shrink from left. Track the minimum window size.
          solution: |-
            func minWindowAllServices(logs []string, required []string) (int, int) {
                need := make(map[string]int)
                for _, s := range required {
                    need[s]++
                }
                have := make(map[string]int)
                formed := 0
                target := len(need)
                bestLen := len(logs) + 1
                bestL, bestR := -1, -1
                left := 0
                for right := 0; right < len(logs); right++ {
                    s := logs[right]
                    if _, ok := need[s]; ok {
                        have[s]++
                        if have[s] == need[s] {
                            formed++
                        }
                    }
                    for formed == target {
                        if right-left+1 < bestLen {
                            bestLen = right - left + 1
                            bestL = left
                            bestR = right
                        }
                        ls := logs[left]
                        if _, ok := need[ls]; ok {
                            have[ls]--
                            if have[ls] < need[ls] {
                                formed--
                            }
                        }
                        left++
                    }
                }
                return bestL, bestR
            }
          annotations:
            - type: complexity
              label: Two-Pointer Linear
              text: O(n) time — classic minimum window substring, each pointer moves at most n times
            - type: interview
              label: Min Window Substring
              text: Minimum window substring is a LeetCode hard and a common interview question — know this pattern cold
