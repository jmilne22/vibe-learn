conceptLinks:
  Structs: "#structs-as-infrastructure-models"
  Pointers: "#pointers"
  Constructors: "#constructors--validation"
  Methods: "#methods--receivers"
  Composition: "#composition-over-inheritance"
  Interfaces: "#interfaces-the-go-way"
  Type Assertions: "#type-assertions--switches"
sharedContent: {}
variants:
  warmups:
    - id: warmup_1
      concept: Structs
      variants:
        - id: v0a
          title: Create and Print a Pod
          description: >-
            Define a <code>Pod</code> struct with two fields: <code>Name</code> (string) and <code>Status</code>
            (string). Create a pod named <code>"web-1"</code> with status <code>"Running"</code> and print it.
          hints:
            - "Use <code>type Pod struct { ... }</code> with exported (capitalized) field names."
            - "Create with: <code>Pod{Name: \"web-1\", Status: \"Running\"}</code>."
          solution: |-
            type Pod struct {
                Name   string
                Status string
            }

            pod := Pod{Name: "web-1", Status: "Running"}
            fmt.Println(pod) // {web-1 Running}
        - id: v1
          title: Define a ConfigEntry
          description: >-
            Define a <code>ConfigEntry</code> struct with <code>Key</code> (string), <code>Value</code> (string), and
            <code>Source</code> (string) fields. Create a literal for a config entry: key
            <code>"max_connections"</code>, value <code>"100"</code>, source <code>"env"</code>. Print it.
          hints:
            - Use <code>type ConfigEntry struct { ... }</code> with exported fields
            - "Struct literal: <code>ConfigEntry{Key: \"max_connections\", Value: \"100\", Source: \"env\"}</code>"
          solution: |-
            type ConfigEntry struct {
                Key    string
                Value  string
                Source string
            }

            entry := ConfigEntry{Key: "max_connections", Value: "100", Source: "env"}
            fmt.Println(entry)
        - id: v2
          title: Service with Nested Selector
          description: >-
            Define a <code>Service</code> struct with <code>Name</code> (string), <code>Port</code> (int), and
            <code>Selector</code> (<code>map[string]string</code>). Create a service named <code>"api-gateway"</code> on
            port 8080 with selector <code>{"app": "api", "tier": "frontend"}</code>.
          hints:
            - The Selector field type is <code>map[string]string</code>
            - "Initialize the map inline: <code>map[string]string{\"app\": \"api\", \"tier\": \"frontend\"}</code>"
          solution: |-
            type Service struct {
                Name     string
                Port     int
                Selector map[string]string
            }

            svc := Service{
                Name: "api-gateway",
                Port: 8080,
                Selector: map[string]string{"app": "api", "tier": "frontend"},
            }
            fmt.Println(svc)
        - id: v3
          title: Nested Resources Struct
          description: >-
            Define a <code>Resources</code> struct with <code>MemoryMB</code> (int) and <code>CPUM</code> (int). Define
            a <code>Pod</code> struct with <code>Name</code> (string), <code>Namespace</code> (string), and
            <code>Resources</code> (Resources). Create a pod <code>"cache-1"</code> in <code>"production"</code> with
            1024MB memory and 500 millicores. Print its memory.
          hints:
            - "Nest the struct: <code>Resources Resources</code> inside Pod"
            - "Access nested fields: <code>pod.Resources.MemoryMB</code>"
          solution: |-
            type Resources struct {
                MemoryMB int
                CPUM     int
            }

            type Pod struct {
                Name      string
                Namespace string
                Resources Resources
            }

            pod := Pod{
                Name:      "cache-1",
                Namespace: "production",
                Resources: Resources{MemoryMB: 1024, CPUM: 500},
            }
            fmt.Println(pod.Resources.MemoryMB) // 1024
        - id: v4
          title: Zero Values Matter
          description: >-
            Create a <code>Pod</code> struct (Name string, Namespace string, MemoryMB int, Ready bool). Create one with
            only <code>Name: "web-1"</code> set. Print all four fields and observe the zero values.
          hints:
            - "Zero values: string â†’ \"\", int â†’ 0, bool â†’ false"
            - Use <code>fmt.Printf</code> to format the output clearly
          solution: |-
            type Pod struct {
                Name      string
                Namespace string
                MemoryMB  int
                Ready     bool
            }

            p := Pod{Name: "web-1"}
            fmt.Printf("Name=%q Namespace=%q MemoryMB=%d Ready=%t\n", p.Name, p.Namespace, p.MemoryMB, p.Ready)
            // Name="web-1" Namespace="" MemoryMB=0 Ready=false
    - id: warmup_2
      concept: Constructors
      variants:
        - id: v1
          title: NewService Constructor
          description: >-
            Write a <code>NewService(name string, port int) (Service, error)</code> function. Validate: name must not be
            empty, port must be between 1-65535. Return a Service with the given name and port. Default the
            <code>Protocol</code> field to <code>"TCP"</code>.
          hints:
            - Return <code>(Service{}, fmt.Errorf(...))</code> for validation failures
            - Check <code>port < 1 || port > 65535</code> for the range validation
          solution: |-
            type Service struct {
                Name     string
                Port     int
                Protocol string
            }

            func NewService(name string, port int) (Service, error) {
                if name == "" {
                    return Service{}, fmt.Errorf("service name cannot be empty")
                }
                if port < 1 || port > 65535 {
                    return Service{}, fmt.Errorf("invalid port: %d", port)
                }
                return Service{Name: name, Port: port, Protocol: "TCP"}, nil
            }
        - id: v2
          title: NewConfigEntry with Defaults
          description: >-
            Write <code>NewConfigEntry(key, value string) (ConfigEntry, error)</code>. Validate: key must not be empty.
            If <code>value</code> is empty, default it to <code>""</code> (that's fine â€” empty values are valid). If key
            contains spaces, return an error. Set <code>Source</code> to <code>"manual"</code>.
          hints:
            - Use <code>strings.Contains(key, " ")</code> to check for spaces
            - Empty value is valid â€” only key has constraints
          solution: |-
            type ConfigEntry struct {
                Key    string
                Value  string
                Source string
            }

            func NewConfigEntry(key, value string) (ConfigEntry, error) {
                if key == "" {
                    return ConfigEntry{}, fmt.Errorf("key cannot be empty")
                }
                if strings.Contains(key, " ") {
                    return ConfigEntry{}, fmt.Errorf("key cannot contain spaces: %q", key)
                }
                return ConfigEntry{Key: key, Value: value, Source: "manual"}, nil
            }
        - id: v3
          title: NewNode with Resource Limits
          description: >-
            Write <code>NewNode(name string, memoryGB, cpuCores int) (Node, error)</code>. Validate: name non-empty,
            memoryGB > 0, cpuCores > 0. Set <code>Status</code> to <code>"Ready"</code> and <code>PodCount</code> to 0.
          hints:
            - "Node struct needs: Name, MemoryGB, CPUCores, Status, PodCount"
            - Return <code>(Node{}, error)</code> for validation failures, <code>(node, nil)</code> on success
          solution: |-
            type Node struct {
                Name     string
                MemoryGB int
                CPUCores int
                Status   string
                PodCount int
            }

            func NewNode(name string, memoryGB, cpuCores int) (Node, error) {
                if name == "" {
                    return Node{}, fmt.Errorf("node name cannot be empty")
                }
                if memoryGB <= 0 {
                    return Node{}, fmt.Errorf("memory must be positive: %d", memoryGB)
                }
                if cpuCores <= 0 {
                    return Node{}, fmt.Errorf("CPU cores must be positive: %d", cpuCores)
                }
                return Node{
                    Name: name, MemoryGB: memoryGB, CPUCores: cpuCores,
                    Status: "Ready", PodCount: 0,
                }, nil
            }
    - id: warmup_3
      concept: Methods
      variants:
        - id: v0a
          title: Simple Status Method
          description: >-
            Define a <code>Pod</code> struct with <code>Name</code> (string) and <code>Ready</code> (bool). Write a
            value receiver method <code>StatusLine() string</code> that returns <code>"name: ready"</code> if Ready is
            true, or <code>"name: not ready"</code> otherwise. Test with both cases.
          hints:
            - "Value receiver: <code>func (p Pod) StatusLine() string</code>."
            - "Use an if/else to pick the suffix, then combine with the name."
          solution: |-
            type Pod struct {
                Name  string
                Ready bool
            }

            func (p Pod) StatusLine() string {
                if p.Ready {
                    return p.Name + ": ready"
                }
                return p.Name + ": not ready"
            }

            fmt.Println(Pod{"web-1", true}.StatusLine())  // web-1: ready
            fmt.Println(Pod{"web-2", false}.StatusLine()) // web-2: not ready
        - id: v1
          title: Pod FullName Method
          description: >-
            Given a <code>Pod</code> struct with <code>Name</code> and <code>Namespace</code> fields, write a value
            receiver method <code>FullName() string</code> that returns <code>"namespace/name"</code>. Test it with pod
            <code>"web-1"</code> in <code>"production"</code>.
          hints:
            - "Value receiver: <code>func (p Pod) FullName() string</code>"
            - Use string concatenation or <code>fmt.Sprintf("%s/%s", ...)</code>
          solution: |-
            type Pod struct {
                Name      string
                Namespace string
            }

            func (p Pod) FullName() string {
                return p.Namespace + "/" + p.Name
            }

            pod := Pod{Name: "web-1", Namespace: "production"}
            fmt.Println(pod.FullName()) // production/web-1
        - id: v2
          title: Scale Deployment
          description: >-
            Define a <code>Deployment</code> struct with <code>Name</code> (string) and <code>Replicas</code> (int).
            Write a pointer receiver method <code>Scale(n int)</code> that sets Replicas to <code>n</code> (minimum 0).
            Create a deployment with 3 replicas, scale to 5, then scale to -1 (should clamp to 0). Print replicas after
            each scale.
          hints:
            - "Pointer receiver: <code>func (d *Deployment) Scale(n int)</code>"
            - "Clamp: <code>if n < 0 { n = 0 }</code>"
          solution: |-
            type Deployment struct {
                Name     string
                Replicas int
            }

            func (d *Deployment) Scale(n int) {
                if n < 0 {
                    n = 0
                }
                d.Replicas = n
            }

            d := Deployment{Name: "api", Replicas: 3}
            d.Scale(5)
            fmt.Println(d.Replicas) // 5
            d.Scale(-1)
            fmt.Println(d.Replicas) // 0
        - id: v3
          title: AddLabel with Nil Map Init
          description: >-
            Define a <code>Pod</code> struct with <code>Name</code> (string) and <code>Labels</code>
            (<code>map[string]string</code>). Write a pointer receiver method <code>AddLabel(key, value string)</code>
            that initializes the map if nil, then sets the key-value pair. Create a pod with no labels, add
            <code>"app"="web"</code> and <code>"env"="prod"</code>, print the labels.
          hints:
            - Check <code>if p.Labels == nil</code> before writing to the map
            - Use <code>make(map[string]string)</code> to initialize
          solution: |-
            type Pod struct {
                Name   string
                Labels map[string]string
            }

            func (p *Pod) AddLabel(key, value string) {
                if p.Labels == nil {
                    p.Labels = make(map[string]string)
                }
                p.Labels[key] = value
            }

            pod := Pod{Name: "web-1"}
            pod.AddLabel("app", "web")
            pod.AddLabel("env", "prod")
            fmt.Println(pod.Labels) // map[app:web env:prod]
        - id: v4
          title: Node CanSchedule Method
          description: >-
            Define a <code>Node</code> struct with <code>Name</code> (string), <code>MemoryGB</code> (int),
            <code>CPUCores</code> (int), and <code>AllocatedPods</code> (int). Write a value receiver
            <code>CanSchedule(memGB, cpu int) bool</code> that returns true if the node has at least that much memory
            and CPU available, AND <code>AllocatedPods < 110</code> (K8s default limit).
          hints:
            - "Value receiver since we're only reading: <code>func (n Node) CanSchedule(...) bool</code>"
            - "Check all three conditions: memory, CPU, and pod count"
          solution: |-
            type Node struct {
                Name          string
                MemoryGB      int
                CPUCores      int
                AllocatedPods int
            }

            func (n Node) CanSchedule(memGB, cpu int) bool {
                return n.MemoryGB >= memGB && n.CPUCores >= cpu && n.AllocatedPods < 110
            }

            node := Node{Name: "node-1", MemoryGB: 64, CPUCores: 16, AllocatedPods: 42}
            fmt.Println(node.CanSchedule(8, 2))   // true
            fmt.Println(node.CanSchedule(128, 2)) // false
    - id: warmup_4
      concept: Composition
      variants:
        - id: v1
          title: Embed Metadata
          description: >-
            Define a <code>Metadata</code> struct with <code>Name</code> and <code>Namespace</code>. Add a method
            <code>FullName() string</code> that returns <code>"namespace/name"</code>. Define a <code>Pod</code> that
            embeds <code>Metadata</code> and adds <code>Status</code> (string). Create a pod and access
            <code>Name</code> directly (promoted field) and call <code>FullName()</code> (promoted method).
          hints:
            - "Embed with just the type name: <code>Metadata</code> (no field name)"
            - "Initialize: <code>Pod{Metadata: Metadata{Name: \"web\", Namespace: \"prod\"}, Status: \"Running\"}</code>"
          solution: |-
            type Metadata struct {
                Name      string
                Namespace string
            }

            func (m Metadata) FullName() string {
                return m.Namespace + "/" + m.Name
            }

            type Pod struct {
                Metadata
                Status string
            }

            pod := Pod{
                Metadata: Metadata{Name: "web-1", Namespace: "production"},
                Status:   "Running",
            }
            fmt.Println(pod.Name)       // web-1 (promoted)
            fmt.Println(pod.FullName()) // production/web-1 (promoted method)
        - id: v2
          title: Multiple Embeds
          description: >-
            Define <code>Metadata</code> (Name, Namespace string) and <code>ResourceSpec</code> (MemoryMB, CPUM int).
            Define a <code>Pod</code> that embeds both. Create a pod and access fields from both embedded types.
          hints:
            - "You can embed multiple types: both <code>Metadata</code> and <code>ResourceSpec</code>"
            - Access <code>pod.Name</code> from Metadata, <code>pod.MemoryMB</code> from ResourceSpec
          solution: |-
            type Metadata struct {
                Name      string
                Namespace string
            }

            type ResourceSpec struct {
                MemoryMB int
                CPUM     int
            }

            type Pod struct {
                Metadata
                ResourceSpec
                Status string
            }

            pod := Pod{
                Metadata:     Metadata{Name: "web-1", Namespace: "prod"},
                ResourceSpec: ResourceSpec{MemoryMB: 512, CPUM: 250},
                Status:       "Running",
            }
            fmt.Printf("%s: %dMB, %dm CPU\n", pod.Name, pod.MemoryMB, pod.CPUM)
    - id: warmup_5
      concept: Interfaces
      variants:
        - id: v1
          title: Implement Stringer
          description: >-
            Define a <code>Pod</code> struct with <code>Name</code>, <code>Namespace</code>, and <code>Status</code>.
            Implement <code>fmt.Stringer</code> (<code>String() string</code>) so that <code>fmt.Println(pod)</code>
            prints <code>"namespace/name (status)"</code>. Test with a Running pod.
          hints:
            - The <code>fmt.Stringer</code> interface requires <code>String() string</code>
            - Use <code>fmt.Sprintf("%s/%s (%s)", p.Namespace, p.Name, p.Status)</code>
          solution: |-
            type Pod struct {
                Name      string
                Namespace string
                Status    string
            }

            func (p Pod) String() string {
                return fmt.Sprintf("%s/%s (%s)", p.Namespace, p.Name, p.Status)
            }

            pod := Pod{Name: "web-1", Namespace: "production", Status: "Running"}
            fmt.Println(pod) // production/web-1 (Running)
        - id: v2
          title: HealthChecker Interface
          description: >-
            Define a <code>HealthChecker</code> interface with <code>IsHealthy() bool</code>. Make both <code>Pod</code>
            (healthy if Status is "Running") and <code>Node</code> (healthy if Status is "Ready") satisfy it. Write a
            function <code>countHealthy(items []HealthChecker) int</code> that counts healthy items.
          hints:
            - Both Pod and Node need <code>IsHealthy() bool</code> methods
            - The function accepts <code>[]HealthChecker</code> â€” any type satisfying the interface works
          solution: |-
            type HealthChecker interface {
                IsHealthy() bool
            }

            type Pod struct {
                Name   string
                Status string
            }

            func (p Pod) IsHealthy() bool {
                return p.Status == "Running"
            }

            type Node struct {
                Name   string
                Status string
            }

            func (n Node) IsHealthy() bool {
                return n.Status == "Ready"
            }

            func countHealthy(items []HealthChecker) int {
                count := 0
                for _, item := range items {
                    if item.IsHealthy() {
                        count++
                    }
                }
                return count
            }
        - id: v3
          title: Validator Interface
          description: >-
            Define a <code>Validator</code> interface with <code>Validate() error</code>. Make a
            <code>ConfigEntry</code> struct (Key, Value string) satisfy it: key must be non-empty and contain no spaces.
            Write a function <code>validateAll(items []Validator) []error</code> that collects all validation errors.
          hints:
            - Return <code>nil</code> from Validate() when valid, <code>fmt.Errorf(...)</code> when invalid
            - In validateAll, only append non-nil errors
          solution: |-
            type Validator interface {
                Validate() error
            }

            type ConfigEntry struct {
                Key   string
                Value string
            }

            func (c ConfigEntry) Validate() error {
                if c.Key == "" {
                    return fmt.Errorf("key cannot be empty")
                }
                if strings.Contains(c.Key, " ") {
                    return fmt.Errorf("key cannot contain spaces: %q", c.Key)
                }
                return nil
            }

            func validateAll(items []Validator) []error {
                var errs []error
                for _, item := range items {
                    if err := item.Validate(); err != nil {
                        errs = append(errs, err)
                    }
                }
                return errs
            }
    - id: warmup_6
      concept: Type Assertions
      variants:
        - id: v1
          title: Type Switch Describe
          description: >-
            Given an interface <code>Resource</code> with <code>FullName() string</code> and two types â€”
            <code>Pod</code> (with Status) and <code>Service</code> (with Port) â€” write a <code>describe(r Resource)
            string</code> function using a type switch that returns <code>"Pod: namespace/name (status)"</code> or
            <code>"Service: namespace/name :port"</code>.
          hints:
            - Use <code>switch v := r.(type)</code> to access the concrete type
            - In each case, <code>v</code> is the concrete type â€” access type-specific fields
          solution: |-
            type Resource interface {
                FullName() string
            }

            type Pod struct {
                Name, Namespace, Status string
            }
            func (p Pod) FullName() string { return p.Namespace + "/" + p.Name }

            type Service struct {
                Name, Namespace string
                Port            int
            }
            func (s Service) FullName() string { return s.Namespace + "/" + s.Name }

            func describe(r Resource) string {
                switch v := r.(type) {
                case Pod:
                    return fmt.Sprintf("Pod: %s (%s)", v.FullName(), v.Status)
                case Service:
                    return fmt.Sprintf("Service: %s :%d", v.FullName(), v.Port)
                default:
                    return fmt.Sprintf("Unknown: %s", v.FullName())
                }
            }
        - id: v2
          title: Safe Type Assertion
          description: >-
            Given a <code>HealthChecker</code> interface value, use the comma-ok pattern to check if it's a
            <code>Pod</code>. If it is, print the pod's memory. If not, print <code>"not a pod"</code>.
          hints:
            - "Comma-ok: <code>pod, ok := checker.(Pod)</code>"
            - If <code>ok</code> is false, the assertion failed safely (no panic)
          solution: |-
            type HealthChecker interface {
                IsHealthy() bool
            }

            type Pod struct {
                Name     string
                MemoryMB int
                Status   string
            }
            func (p Pod) IsHealthy() bool { return p.Status == "Running" }

            var checker HealthChecker = Pod{Name: "web-1", MemoryMB: 512, Status: "Running"}

            if pod, ok := checker.(Pod); ok {
                fmt.Printf("Pod memory: %dMB\n", pod.MemoryMB)
            } else {
                fmt.Println("not a pod")
            }
    - id: warmup_7
      concept: Pointers
      variants:
        - id: v0a
          title: Pass by Value vs Pointer
          description: >-
            Create a <code>Counter</code> struct with a <code>Count</code> (int) field. Write two functions:
            <code>incrementValue(c Counter)</code> (takes by value) and <code>incrementPointer(c *Counter)</code>
            (takes by pointer). Both should add 1 to Count. Call each and print the counter after to see which one
            actually changed it.
          hints:
            - "By value: the function gets a copy, so changes don't affect the original."
            - "By pointer: the function modifies the original via <code>c.Count++</code>."
          solution: |-
            type Counter struct {
                Count int
            }

            func incrementValue(c Counter) {
                c.Count++ // modifies the copy only
            }

            func incrementPointer(c *Counter) {
                c.Count++ // modifies the original
            }

            c := Counter{Count: 0}
            incrementValue(c)
            fmt.Println(c.Count) // 0 (unchanged!)
            incrementPointer(&c)
            fmt.Println(c.Count) // 1 (changed)
        - id: v1
          title: Pointer Basics
          description: >-
            Create a <code>Pod</code> struct with <code>Name</code> and <code>Status</code> fields. Write a function
            <code>markRunning(p *Pod)</code> that takes a pointer to a Pod and sets its Status to <code>"Running"</code>.
            Create a pod with status <code>"Pending"</code>, call the function, and print the status to confirm it changed.
          hints:
            - "Use <code>*Pod</code> in the parameter â€” the <code>*</code> means pointer"
            - "Pass with <code>&pod</code> â€” the <code>&</code> means address-of"
          solution: |-
            type Pod struct {
                Name   string
                Status string
            }

            func markRunning(p *Pod) {
                p.Status = "Running"
            }

            pod := Pod{Name: "web-1", Status: "Pending"}
            markRunning(&pod)
            fmt.Println(pod.Status) // "Running"
        - id: v2
          title: Nil Pointer Check
          description: >-
            Write a function <code>podStatus(p *Pod) string</code> that returns the pod's Status if p is not nil, or
            <code>"unknown"</code> if p is nil. Test it with both a valid pod and a nil pointer.
          hints:
            - Check <code>p == nil</code> before accessing any fields
            - A nil pointer dereference causes a panic â€” always guard against it
          solution: |-
            type Pod struct {
                Name   string
                Status string
            }

            func podStatus(p *Pod) string {
                if p == nil {
                    return "unknown"
                }
                return p.Status
            }

            pod := &Pod{Name: "web-1", Status: "Running"}
            fmt.Println(podStatus(pod)) // "Running"
            fmt.Println(podStatus(nil)) // "unknown"
        - id: v3
          title: Swap with Pointers
          description: >-
            Write a function <code>swapStatus(a, b *Pod)</code> that swaps the Status fields of two pods using pointers.
            Create two pods â€” one <code>"Running"</code>, one <code>"Pending"</code> â€” call swap, and print both to
            confirm.
          hints:
            - "Store one status in a temp variable: <code>tmp := a.Status</code>"
            - You're swapping the field values, not the pointers themselves
          solution: |-
            type Pod struct {
                Name   string
                Status string
            }

            func swapStatus(a, b *Pod) {
                a.Status, b.Status = b.Status, a.Status
            }

            p1 := Pod{Name: "web-1", Status: "Running"}
            p2 := Pod{Name: "web-2", Status: "Pending"}
            swapStatus(&p1, &p2)
            fmt.Println(p1.Status) // "Pending"
            fmt.Println(p2.Status) // "Running"
  challenges:
    - id: challenge_1
      block: 1
      difficulty: 2
      concept: Structs
      variants:
        - id: v1
          title: Build a Pod Registry
          description: >-
            Write a function that takes a slice of Pod structs (Name, Namespace, Status, MemoryMB) and returns a
            <code>map[string][]Pod</code> grouping pods by namespace.
          functionSignature: func groupByNamespace(pods []Pod) map[string][]Pod
          difficulty: 1
          testCases:
            - input: >-
                groupByNamespace([]Pod{{"web","prod","Running",512},{"api","prod","Running",256},{"db","data","Running",1024}})
              output: map[data:[{db data Running 1024}] prod:[{web prod Running 512} {api prod Running 256}]]
          hints:
            - title: ðŸ¤” Think about it
              content: What map key groups pods together? What's the value type for multiple pods per namespace?
            - title: ðŸ’¡ Hint
              content: Use <code>map[string][]Pod</code>. Append each pod to the slice at <code>m[pod.Namespace]</code>.
          solution: |-
            func groupByNamespace(pods []Pod) map[string][]Pod {
                result := make(map[string][]Pod)
                for _, pod := range pods {
                    result[pod.Namespace] = append(result[pod.Namespace], pod)
                }
                return result
            }
          annotations:
            - type: pattern
              label: Grouping
              text: map[K][]V is the standard Go grouping pattern. Works for any key type.
            - type: idiom
              label: append to map value
              text: append works even when the slice is nil (zero value). No need to check if the key exists first.
        - id: v2
          title: Pod Summary Report
          description: >-
            Write a function that takes a slice of Pods and returns a summary string: total count, running count, total
            memory, and average memory. Format: <code>"Pods: 5 (3 running), Memory: 2560MB (avg 512MB)"</code>.
          functionSignature: func podSummary(pods []Pod) string
          difficulty: 2
          testCases:
            - input: podSummary([]Pod{{"a","ns","Running",512},{"b","ns","Pending",256},{"c","ns","Running",1024}})
              output: "\"Pods: 3 (2 running), Memory: 1792MB (avg 597MB)\""
          hints:
            - title: ðŸ¤” Think about it
              content: You need running count and total memory. Can you compute both in one pass?
            - title: ðŸ’¡ Hint
              content: >-
                Loop once, track <code>running</code> count and <code>totalMem</code>. Average is <code>totalMem /
                len(pods)</code>. Use <code>fmt.Sprintf</code> to format.
          solution: |-
            func podSummary(pods []Pod) string {
                running := 0
                totalMem := 0
                for _, p := range pods {
                    if p.Status == "Running" {
                        running++
                    }
                    totalMem += p.MemoryMB
                }
                avg := 0
                if len(pods) > 0 {
                    avg = totalMem / len(pods)
                }
                return fmt.Sprintf("Pods: %d (%d running), Memory: %dMB (avg %dMB)", len(pods), running, totalMem, avg)
            }
          annotations:
            - type: complexity
              label: O(n)
              text: Single pass over all pods. Two accumulators in one loop.
            - type: gotcha
              label: Division by zero
              text: Always guard against len(pods) == 0 before dividing.
        - id: v3
          title: Resource Quota Check
          description: >-
            Write a function that checks if a slice of Pods exceeds a resource quota. The quota specifies max total
            MemoryMB and max total CPUM. Return the names of all pods that would be scheduled, stopping when adding the
            next pod would exceed either limit.
          functionSignature: func scheduleWithinQuota(pods []Pod, maxMemMB, maxCPUM int) []string
          difficulty: 3
          testCases:
            - input: >-
                scheduleWithinQuota([]Pod{{Name:"a",MemoryMB:512,CPUM:100},{Name:"b",MemoryMB:512,CPUM:100},{Name:"c",MemoryMB:512,CPUM:100}},
                1024, 300)
              output: "[a b]"
            - input: scheduleWithinQuota([]Pod{{Name:"x",MemoryMB:2000,CPUM:100}}, 1024, 300)
              output: "[]"
          hints:
            - title: ðŸ¤” Think about it
              content: Track running totals. Before adding each pod, check if it would push either total over the limit.
            - title: ðŸ’¡ Hint
              content: >-
                Loop through pods. Before appending, check <code>usedMem + pod.MemoryMB <= maxMemMB && usedCPU +
                pod.CPUM <= maxCPUM</code>. If it exceeds, stop (don't skip â€” ordering matters).
          solution: |-
            func scheduleWithinQuota(pods []Pod, maxMemMB, maxCPUM int) []string {
                var names []string
                usedMem, usedCPU := 0, 0
                for _, p := range pods {
                    if usedMem+p.MemoryMB > maxMemMB || usedCPU+p.CPUM > maxCPUM {
                        break
                    }
                    usedMem += p.MemoryMB
                    usedCPU += p.CPUM
                    names = append(names, p.Name)
                }
                return names
            }
          annotations:
            - type: pattern
              label: Greedy scheduling
              text: >-
                This is first-fit scheduling â€” take pods in order until quota is full. Real K8s schedulers use scoring
                and bin-packing.
            - type: interview
              label: Knapsack variant
              text: >-
                This is a simplified 0/1 knapsack with two constraints. Interview follow-up: what if you could reorder
                pods to fit more?
    - id: challenge_2
      block: 2
      difficulty: 2
      concept: Methods
      variants:
        - id: v1
          title: Deployment Rollout Tracker
          description: >-
            Define a <code>Deployment</code> struct with <code>Name</code> (string), <code>Replicas</code> (int), and
            <code>Ready</code> (int). Add methods: <code>Scale(n int)</code> (pointer, clamp to 0), <code>MarkReady(n
            int)</code> (pointer, clamp to Replicas), <code>IsComplete() bool</code> (value, true when Ready ==
            Replicas). Test all three.
          functionSignature: type Deployment struct { Name string; Replicas int; Ready int }
          difficulty: 1
          testCases:
            - input: d := Deployment{"api",3,0}; d.Scale(5); d.MarkReady(5); d.IsComplete()
              output: "true"
            - input: d := Deployment{"api",3,0}; d.Scale(5); d.MarkReady(3); d.IsComplete()
              output: "false"
          hints:
            - title: ðŸ¤” Think about it
              content: MarkReady needs to clamp â€” you can't have more ready than total replicas.
            - title: ðŸ’¡ Hint
              content: >-
                Scale: <code>if n < 0 { n = 0 }</code>. MarkReady: <code>if n > d.Replicas { n = d.Replicas }</code>.
                IsComplete: <code>return d.Ready == d.Replicas</code>.
          solution: |-
            type Deployment struct {
                Name     string
                Replicas int
                Ready    int
            }

            func (d *Deployment) Scale(n int) {
                if n < 0 {
                    n = 0
                }
                d.Replicas = n
            }

            func (d *Deployment) MarkReady(n int) {
                if n > d.Replicas {
                    n = d.Replicas
                }
                if n < 0 {
                    n = 0
                }
                d.Ready = n
            }

            func (d Deployment) IsComplete() bool {
                return d.Ready == d.Replicas
            }
          annotations:
            - type: idiom
              label: Pointer receivers for mutation
              text: >-
                Scale and MarkReady modify the struct, so they need pointer receivers. IsComplete only reads, so value
                receiver is fine.
            - type: gotcha
              label: Receiver consistency
              text: In practice, if any method needs a pointer, use pointer for all. Here we mix for teaching purposes.
        - id: v2
          title: Node Resource Tracker
          description: >-
            Define a <code>Node</code> with Name, MemoryGB, CPUCores, UsedMemGB, UsedCPU. Write methods:
            <code>Allocate(mem, cpu int) error</code> (returns error if insufficient), <code>Release(mem, cpu
            int)</code> (clamp to 0), and <code>Utilization() (float64, float64)</code> (returns mem%, cpu% as 0-100).
          functionSignature: type Node struct { Name string; MemoryGB, CPUCores, UsedMemGB, UsedCPU int }
          difficulty: 2
          testCases:
            - input: n := Node{"n1",64,16,0,0}; n.Allocate(32,8); n.Utilization()
              output: (50, 50)
            - input: n := Node{"n1",64,16,60,14}; n.Allocate(32,8)
              output: "error: insufficient memory"
          hints:
            - title: ðŸ¤” Think about it
              content: Allocate must check BEFORE updating. Release must not go below zero.
            - title: ðŸ’¡ Hint
              content: >-
                Allocate: check <code>n.UsedMemGB + mem > n.MemoryGB</code> before modifying. Utilization:
                <code>float64(n.UsedMemGB) / float64(n.MemoryGB) * 100</code>.
          solution: |-
            type Node struct {
                Name     string
                MemoryGB int
                CPUCores int
                UsedMemGB int
                UsedCPU  int
            }

            func (n *Node) Allocate(mem, cpu int) error {
                if n.UsedMemGB+mem > n.MemoryGB {
                    return fmt.Errorf("insufficient memory")
                }
                if n.UsedCPU+cpu > n.CPUCores {
                    return fmt.Errorf("insufficient CPU")
                }
                n.UsedMemGB += mem
                n.UsedCPU += cpu
                return nil
            }

            func (n *Node) Release(mem, cpu int) {
                n.UsedMemGB -= mem
                if n.UsedMemGB < 0 {
                    n.UsedMemGB = 0
                }
                n.UsedCPU -= cpu
                if n.UsedCPU < 0 {
                    n.UsedCPU = 0
                }
            }

            func (n Node) Utilization() (float64, float64) {
                memPct := float64(n.UsedMemGB) / float64(n.MemoryGB) * 100
                cpuPct := float64(n.UsedCPU) / float64(n.CPUCores) * 100
                return memPct, cpuPct
            }
          annotations:
            - type: pattern
              label: Check-then-act
              text: Allocate validates before mutating. This prevents partial updates on failure.
            - type: interview
              label: Resource management
              text: "This is how real schedulers track capacity. Interview variant: what if Allocate needs to be thread-safe?"
        - id: v3
          title: Service Discovery Registry
          description: >-
            Build a <code>Registry</code> struct with an internal <code>map[string][]Service</code>. Write methods:
            <code>Register(svc Service)</code> (groups by namespace), <code>Lookup(namespace, name string) (Service,
            bool)</code>, and <code>ListNamespaces() []string</code> (sorted). Services have Name, Namespace, Port.
          functionSignature: type Registry struct { services map[string][]Service }
          difficulty: 3
          testCases:
            - input: r := NewRegistry(); r.Register(Service{"api","prod",8080}); r.Lookup("prod","api")
              output: (Service{"api","prod",8080}, true)
            - input: >-
                r := NewRegistry(); r.Register(Service{"api","prod",8080}); r.Register(Service{"db","data",5432});
                r.ListNamespaces()
              output: "[data prod]"
          hints:
            - title: ðŸ¤” Think about it
              content: You need a constructor (NewRegistry) to initialize the map. Lookup searches within a namespace.
            - title: ðŸ’¡ Hint
              content: >-
                Register: <code>r.services[svc.Namespace] = append(...)</code>. Lookup: iterate
                <code>r.services[namespace]</code> to find by name. ListNamespaces: collect map keys,
                <code>sort.Strings</code>.
          solution: |-
            type Service struct {
                Name      string
                Namespace string
                Port      int
            }

            type Registry struct {
                services map[string][]Service
            }

            func NewRegistry() *Registry {
                return &Registry{services: make(map[string][]Service)}
            }

            func (r *Registry) Register(svc Service) {
                r.services[svc.Namespace] = append(r.services[svc.Namespace], svc)
            }

            func (r *Registry) Lookup(namespace, name string) (Service, bool) {
                for _, svc := range r.services[namespace] {
                    if svc.Name == name {
                        return svc, true
                    }
                }
                return Service{}, false
            }

            func (r *Registry) ListNamespaces() []string {
                keys := make([]string, 0, len(r.services))
                for k := range r.services {
                    keys = append(keys, k)
                }
                sort.Strings(keys)
                return keys
            }
          annotations:
            - type: pattern
              label: Registry pattern
              text: "Map-backed registries are everywhere in infra: service discovery, plugin registries, route tables."
            - type: idiom
              label: Constructor returns pointer
              text: >-
                NewRegistry returns *Registry so all methods share the same map. This is the standard Go constructor
                pattern for stateful types.
            - type: stdlib
              label: sort.Strings
              text: sort.Strings sorts a []string in place. Use this whenever you need deterministic map key ordering.
    - id: challenge_3
      block: 3
      difficulty: 2
      concept: Interfaces
      variants:
        - id: v1
          title: Resource Stringer
          description: >-
            Define <code>Pod</code> (Name, Namespace, Status) and <code>Service</code> (Name, Namespace, Port). Make
            both implement <code>fmt.Stringer</code>. Pod prints <code>"namespace/name (status)"</code>, Service prints
            <code>"namespace/name :port"</code>. Write a function that takes a <code>[]fmt.Stringer</code> and returns
            all string representations joined with newlines.
          functionSignature: func summarize(items []fmt.Stringer) string
          difficulty: 1
          testCases:
            - input: summarize([]fmt.Stringer{Pod{"web","prod","Running"}, Service{"api","prod",8080}})
              output: "\"prod/web (Running)\\nprod/api :8080\""
          hints:
            - title: ðŸ¤” Think about it
              content: >-
                Both types need String() string. The function doesn't care about the concrete type â€” it just calls
                String().
            - title: ðŸ’¡ Hint
              content: >-
                Build a <code>[]string</code> from calling <code>item.String()</code> on each, then
                <code>strings.Join(result, "\n")</code>.
          solution: |-
            type Pod struct {
                Name, Namespace, Status string
            }
            func (p Pod) String() string {
                return fmt.Sprintf("%s/%s (%s)", p.Namespace, p.Name, p.Status)
            }

            type Service struct {
                Name, Namespace string
                Port            int
            }
            func (s Service) String() string {
                return fmt.Sprintf("%s/%s :%d", s.Namespace, s.Name, s.Port)
            }

            func summarize(items []fmt.Stringer) string {
                parts := make([]string, len(items))
                for i, item := range items {
                    parts[i] = item.String()
                }
                return strings.Join(parts, "\n")
            }
          annotations:
            - type: idiom
              label: fmt.Stringer
              text: "Implementing String() string controls how your types print everywhere: fmt.Println, log, Sprintf %v."
            - type: pattern
              label: Accept interfaces
              text: summarize accepts []fmt.Stringer â€” works with any type that can describe itself as a string.
        - id: v2
          title: Health Dashboard
          description: >-
            Define a <code>HealthChecker</code> interface (<code>Name() string</code>, <code>IsHealthy() bool</code>).
            Implement it for <code>Pod</code> (healthy = Running), <code>Node</code> (healthy = Ready), and
            <code>Endpoint</code> (healthy = StatusCode 200). Write <code>healthReport(items []HealthChecker)
            string</code> that returns a report like <code>"web-1: healthy\nnode-1: unhealthy\napi: healthy"</code>.
          functionSignature: func healthReport(items []HealthChecker) string
          difficulty: 2
          testCases:
            - input: healthReport([]HealthChecker{Pod{"web","Running"}, Node{"node-1","NotReady"}, Endpoint{"api",200}})
              output: "\"web: healthy\\nnode-1: unhealthy\\napi: healthy\""
          hints:
            - title: ðŸ¤” Think about it
              content: >-
                Three different types, one interface. The report function doesn't need to know the concrete types at
                all.
            - title: ðŸ’¡ Hint
              content: >-
                Each type implements <code>Name() string</code> and <code>IsHealthy() bool</code>. In the report, use a
                ternary-like pattern: <code>status := "healthy"</code>, then <code>if !item.IsHealthy() { status =
                "unhealthy" }</code>.
          solution: |-
            type HealthChecker interface {
                Name() string
                IsHealthy() bool
            }

            type Pod struct {
                PodName string
                Status  string
            }
            func (p Pod) Name() string      { return p.PodName }
            func (p Pod) IsHealthy() bool    { return p.Status == "Running" }

            type Node struct {
                NodeName string
                Status   string
            }
            func (n Node) Name() string      { return n.NodeName }
            func (n Node) IsHealthy() bool    { return n.Status == "Ready" }

            type Endpoint struct {
                URL        string
                StatusCode int
            }
            func (e Endpoint) Name() string      { return e.URL }
            func (e Endpoint) IsHealthy() bool    { return e.StatusCode == 200 }

            func healthReport(items []HealthChecker) string {
                var lines []string
                for _, item := range items {
                    status := "healthy"
                    if !item.IsHealthy() {
                        status = "unhealthy"
                    }
                    lines = append(lines, fmt.Sprintf("%s: %s", item.Name(), status))
                }
                return strings.Join(lines, "\n")
            }
          annotations:
            - type: pattern
              label: Interface polymorphism
              text: >-
                Three different types, one function. This is the power of Go interfaces â€” behavior-based grouping, not
                type hierarchies.
            - type: interview
              label: Interface design
              text: "Common interview question: 'How would you design a health check system?' This is exactly that answer."
        - id: v3
          title: Resource Validator Pipeline
          description: >-
            Define a <code>Validator</code> interface (<code>Validate() error</code>). Implement for: <code>Pod</code>
            (name non-empty, namespace non-empty, memory > 0), <code>Service</code> (name non-empty, port 1-65535),
            <code>ConfigEntry</code> (key non-empty, no spaces in key). Write <code>validatePipeline(items []Validator)
            map[int]error</code> that returns a map of indexâ†’error for all failing items.
          functionSignature: func validatePipeline(items []Validator) map[int]error
          difficulty: 3
          testCases:
            - input: validatePipeline([]Validator{Pod{"web","prod",512}, Service{"",-1}, ConfigEntry{"good","val"}})
              output: map[1:service name cannot be empty]
            - input: validatePipeline([]Validator{Pod{"","",0}})
              output: map[0:pod name cannot be empty]
          hints:
            - title: ðŸ¤” Think about it
              content: Each type validates differently. The pipeline collects failures with their positions.
            - title: ðŸ’¡ Hint
              content: >-
                Loop with index. Call <code>item.Validate()</code>. If non-nil, store in <code>result[i] = err</code>.
                Only return the map if non-empty.
          solution: |-
            type Validator interface {
                Validate() error
            }

            type Pod struct {
                Name, Namespace string
                MemoryMB        int
            }
            func (p Pod) Validate() error {
                if p.Name == "" {
                    return fmt.Errorf("pod name cannot be empty")
                }
                if p.Namespace == "" {
                    return fmt.Errorf("pod namespace cannot be empty")
                }
                if p.MemoryMB <= 0 {
                    return fmt.Errorf("pod memory must be positive")
                }
                return nil
            }

            type Service struct {
                Name string
                Port int
            }
            func (s Service) Validate() error {
                if s.Name == "" {
                    return fmt.Errorf("service name cannot be empty")
                }
                if s.Port < 1 || s.Port > 65535 {
                    return fmt.Errorf("invalid port: %d", s.Port)
                }
                return nil
            }

            type ConfigEntry struct {
                Key, Value string
            }
            func (c ConfigEntry) Validate() error {
                if c.Key == "" {
                    return fmt.Errorf("key cannot be empty")
                }
                if strings.Contains(c.Key, " ") {
                    return fmt.Errorf("key cannot contain spaces")
                }
                return nil
            }

            func validatePipeline(items []Validator) map[int]error {
                result := make(map[int]error)
                for i, item := range items {
                    if err := item.Validate(); err != nil {
                        result[i] = err
                    }
                }
                return result
            }
          annotations:
            - type: pattern
              label: Validation pipeline
              text: >-
                Collecting errors by index lets callers report exactly which items failed. This pattern is used in K8s
                admission controllers.
            - type: idiom
              label: Return first error
              text: >-
                Each Validate() returns the first error found. For comprehensive validation, you'd return []error â€” but
                for exercises, one is enough.
            - type: interview
              label: Design question
              text: >-
                Follow-up: how would you make validation rules configurable? (Answer: pass a []ValidationRule to each
                type's constructor.)
    - id: challenge_4
      block: 4
      difficulty: 2
      concept: Composition
      variants:
        - id: v1
          title: Resource Labels
          description: >-
            Define a <code>Labeled</code> struct with <code>Labels map[string]string</code> and methods
            <code>AddLabel(k, v string)</code> and <code>HasLabel(k string) bool</code>. Embed it in both
            <code>Pod</code> and <code>Service</code>. Show that both types can use <code>AddLabel</code> and
            <code>HasLabel</code> directly.
          functionSignature: type Labeled struct { Labels map[string]string }
          difficulty: 1
          testCases:
            - input: p := Pod{Name:"web"}; p.AddLabel("app","web"); p.HasLabel("app")
              output: "true"
            - input: s := Service{Name:"api"}; s.HasLabel("app")
              output: "false"
          hints:
            - title: ðŸ¤” Think about it
              content: Embedding promotes methods. Both Pod and Service get AddLabel/HasLabel without writing them.
            - title: ðŸ’¡ Hint
              content: >-
                Embed <code>Labeled</code> in Pod and Service. Write <code>AddLabel</code> and <code>HasLabel</code> as
                pointer receiver methods on Labeled. Remember to init the map in AddLabel if nil.
          solution: |-
            type Labeled struct {
                Labels map[string]string
            }

            func (l *Labeled) AddLabel(k, v string) {
                if l.Labels == nil {
                    l.Labels = make(map[string]string)
                }
                l.Labels[k] = v
            }

            func (l *Labeled) HasLabel(k string) bool {
                _, ok := l.Labels[k]
                return ok
            }

            type Pod struct {
                Labeled
                Name   string
                Status string
            }

            type Service struct {
                Labeled
                Name string
                Port int
            }
          annotations:
            - type: pattern
              label: Mixin via embedding
              text: Labeled is a mixin â€” reusable behavior shared across types without inheritance.
            - type: idiom
              label: Comma-ok for existence
              text: >-
                HasLabel uses comma-ok to check key existence. This is more correct than checking the value against
                empty string.
        - id: v2
          title: Kubernetes-Style Resource
          description: >-
            Model a K8s resource: <code>ObjectMeta</code> (Name, Namespace, Labels map[string]string) with
            <code>FullName() string</code>. <code>PodSpec</code> (Image string, MemoryMB int). <code>Pod</code> embeds
            both and adds <code>Status string</code>. Write a <code>Describe() string</code> method on Pod that uses
            fields from all three.
          functionSignature: func (p Pod) Describe() string
          difficulty: 2
          testCases:
            - input: >-
                p :=
                Pod{ObjectMeta:ObjectMeta{Name:"web",Namespace:"prod"},PodSpec:PodSpec{Image:"nginx:1.25",MemoryMB:512},Status:"Running"};
                p.Describe()
              output: "\"Pod prod/web (Running) image=nginx:1.25 mem=512MB\""
          hints:
            - title: ðŸ¤” Think about it
              content: >-
                Pod embeds ObjectMeta and PodSpec. Describe() accesses fields from both embedded types plus Pod's own
                Status.
            - title: ðŸ’¡ Hint
              content: >-
                Use <code>fmt.Sprintf("Pod %s (%s) image=%s mem=%dMB", p.FullName(), p.Status, p.Image,
                p.MemoryMB)</code>. All fields are promoted.
          solution: |-
            type ObjectMeta struct {
                Name      string
                Namespace string
                Labels    map[string]string
            }

            func (m ObjectMeta) FullName() string {
                return m.Namespace + "/" + m.Name
            }

            type PodSpec struct {
                Image    string
                MemoryMB int
            }

            type Pod struct {
                ObjectMeta
                PodSpec
                Status string
            }

            func (p Pod) Describe() string {
                return fmt.Sprintf("Pod %s (%s) image=%s mem=%dMB", p.FullName(), p.Status, p.Image, p.MemoryMB)
            }
          annotations:
            - type: pattern
              label: K8s type structure
              text: "This mirrors real K8s types: ObjectMeta is embedded in every resource, spec is separate from status."
            - type: idiom
              label: Multiple embeds
              text: >-
                Go allows embedding multiple types. Fields from all embeds are promoted as long as there are no name
                collisions.
        - id: v3
          title: Composable Infra Inventory
          description: >-
            Build a mini inventory system. Define: <code>Metadata</code> (Name, Namespace, Labels),
            <code>Healthable</code> (Status string, <code>IsHealthy() bool</code>). <code>Pod</code> embeds both +
            Image. <code>Node</code> embeds Metadata + Healthable + MemoryGB. Write <code>inventoryReport(items
            []fmt.Stringer) string</code> â€” make Pod and Node both satisfy Stringer. Report shows one line per item.
          functionSignature: func inventoryReport(items []fmt.Stringer) string
          difficulty: 3
          testCases:
            - input: >-
                inventoryReport([]fmt.Stringer{Pod{Metadata{"web","prod",nil},Healthable{"Running"},"nginx"},
                Node{Metadata{"n1","",nil},Healthable{"Ready"},64}})
              output: "\"Pod prod/web (Running) [nginx]\\nNode n1 (Ready) [64GB]\""
          hints:
            - title: ðŸ¤” Think about it
              content: >-
                Both types embed Metadata and Healthable. Each has a different String() because they display
                type-specific fields.
            - title: ðŸ’¡ Hint
              content: >-
                Pod's String: <code>"Pod %s/%s (%s) [%s]"</code>. Node's String: <code>"Node %s (%s) [%dGB]"</code>.
                inventoryReport just joins String() outputs with newlines.
          solution: |-
            type Metadata struct {
                Name, Namespace string
                Labels          map[string]string
            }

            type Healthable struct {
                Status string
            }
            func (h Healthable) IsHealthy() bool {
                return h.Status == "Running" || h.Status == "Ready"
            }

            type Pod struct {
                Metadata
                Healthable
                Image string
            }
            func (p Pod) String() string {
                return fmt.Sprintf("Pod %s/%s (%s) [%s]", p.Namespace, p.Name, p.Status, p.Image)
            }

            type Node struct {
                Metadata
                Healthable
                MemoryGB int
            }
            func (n Node) String() string {
                return fmt.Sprintf("Node %s (%s) [%dGB]", n.Name, n.Status, n.MemoryGB)
            }

            func inventoryReport(items []fmt.Stringer) string {
                lines := make([]string, len(items))
                for i, item := range items {
                    lines[i] = item.String()
                }
                return strings.Join(lines, "\n")
            }
          annotations:
            - type: pattern
              label: Composition + interfaces
              text: >-
                Embedding provides shared fields. Interfaces provide shared behavior. Together they replace inheritance
                completely.
            - type: interview
              label: System design
              text: >-
                This is how you'd model an infrastructure inventory system. Interviewers love seeing composition over
                inheritance in Go.
            - type: gotcha
              label: Method override
              text: Pod and Node each define their own String(). This 'overrides' any promoted String() from embedded types.
    - id: challenge_5
      block: 5
      difficulty: 2
      concept: Structs
      variants:
        - id: v1
          title: Top N by Memory
          description: |-
            Given parallel slices of pod names and memory usage:
            <pre>names    := []string{"web-1", "api-1", "db-1", "cache-1", "worker-1"}
            memoryMB := []int{512, 256, 2048, 1024, 128}</pre>
            Write <code>func topByMemory(names []string, memoryMB []int, n int) []string</code> that returns the names of the top <code>n</code> pods by memory usage (descending).
          functionSignature: func topByMemory(names []string, memoryMB []int, n int) []string
          difficulty: 2
          testCases:
            - input: topByMemory([]string{"web-1","api-1","db-1","cache-1","worker-1"}, []int{512,256,2048,1024,128}, 3)
              output: "[\"db-1\", \"cache-1\", \"web-1\"]"
            - input: topByMemory([]string{"a","b"}, []int{100,200}, 5)
              output: "[\"b\", \"a\"]"
          hints:
            - title: ðŸ¤” Think about it
              content: >-
                You have two parallel slices that need to stay paired during sorting. What data structure lets you bundle
                a name and a value together so they move as one unit?
            - title: ðŸ’¡ Hint
              content: >-
                Zip the parallel slices into structs so they stay paired when sorted. After sorting, extract just the
                names from the top entries. Don't forget the edge case where n is larger than the input.
          solution: |-
            func topByMemory(names []string, memoryMB []int, n int) []string {
                type pod struct {
                    name string
                    mem  int
                }
                pods := make([]pod, len(names))
                for i := range names {
                    pods[i] = pod{names[i], memoryMB[i]}
                }
                sort.Slice(pods, func(i, j int) bool {
                    return pods[i].mem > pods[j].mem
                })
                if n > len(pods) {
                    n = len(pods)
                }
                result := make([]string, n)
                for i := 0; i < n; i++ {
                    result[i] = pods[i].name
                }
                return result
            }
          annotations:
            - type: pattern
              label: Parallel Slice â†’ Struct
              text: >-
                When you have parallel slices (names[i] goes with values[i]), zip them into a slice of structs first.
                This is safer and makes sorting straightforward.
            - type: interview
              label: Top K Pattern
              text: >-
                "Find top K elements" is one of the most common interview questions. For small K, sort and slice. For
                large data, use a min-heap (covered in Module 12).
        - id: v2
          title: Resource Usage Table
          description: >-
            Write <code>func resourceTable(names []string, cpuPercent []float64, memMB []int) string</code> that returns
            a formatted table sorted by CPU usage descending.<br><br>Format each row as <code>"%-12s %6.1f%%
            %6dMB"</code>.
          functionSignature: func resourceTable(names []string, cpuPercent []float64, memMB []int) string
          difficulty: 3
          testCases:
            - input: resourceTable([]string{"web","api"}, []float64{45.2, 82.3}, []int{256, 512})
              output: "\"api           82.3%    512MB\\nweb           45.2%    256MB\""
          hints:
            - title: ðŸ¤” Think about it
              content: >-
                Same zip-sort-format pattern as Top N, but with three parallel slices and formatted output. The tricky
                part is getting the format string right.
            - title: ðŸ’¡ Hint
              content: >-
                After zipping and sorting, check the Printing section in Module 1 for width specifiers (left-aligned
                strings, right-aligned numbers) and how to print a literal percent sign.
          solution: |-
            func resourceTable(names []string, cpuPercent []float64, memMB []int) string {
                type resource struct {
                    name string
                    cpu  float64
                    mem  int
                }
                resources := make([]resource, len(names))
                for i := range names {
                    resources[i] = resource{names[i], cpuPercent[i], memMB[i]}
                }
                sort.Slice(resources, func(i, j int) bool {
                    return resources[i].cpu > resources[j].cpu
                })
                lines := make([]string, len(resources))
                for i, r := range resources {
                    lines[i] = fmt.Sprintf("%-12s %6.1f%% %6dMB", r.name, r.cpu, r.mem)
                }
                return strings.Join(lines, "\n")
            }
          annotations:
            - type: pattern
              label: Zip-Sort-Format
              text: >-
                Zip parallel slices into structs, sort by any field, format output. This is the upgraded version of
                Module 1's sorted-keys pattern â€” structs let you sort by value, not just by key.
        - id: v3
          title: Log Level Report (by Count)
          description: >-
            Write <code>func logReportByCount(lines []string) string</code> that takes log lines in the format <code>"LEVEL
            message text"</code> and returns a report string with each level and its count, sorted by count
            descending. Ties are broken alphabetically.<br><br>Example input: <code>["INFO ok", "ERROR bad", "INFO ok2", "WARN
            slow", "ERROR oom"]</code><br>Example output: <code>"ERROR: 2\nINFO: 2\nWARN: 1"</code>
          functionSignature: func logReportByCount(lines []string) string
          difficulty: 2
          testCases:
            - input: logReportByCount([]string{"INFO ok", "ERROR bad", "INFO ok2", "WARN slow", "ERROR oom"})
              output: "\"ERROR: 2\\nINFO: 2\\nWARN: 1\""
            - input: logReportByCount([]string{"DEBUG x", "DEBUG y", "DEBUG z"})
              output: "\"DEBUG: 3\""
          hints:
            - title: ðŸ¤” Think about it
              content: >-
                In Module 1 you sorted alphabetically with sorted-keys. Now you need to sort by count descending â€”
                which requires bundling key-value pairs into a struct.
            - title: ðŸ’¡ Hint
              content: >-
                Count with a map, then zip into a struct slice. Sort with a comparator that compares counts descending,
                breaking ties alphabetically. Format with Sprintf.
          solution: |-
            func logReportByCount(lines []string) string {
                if len(lines) == 0 {
                    return ""
                }
                counts := make(map[string]int)
                for _, line := range lines {
                    fields := strings.Fields(line)
                    if len(fields) > 0 {
                        counts[fields[0]]++
                    }
                }
                type entry struct {
                    level string
                    count int
                }
                entries := make([]entry, 0, len(counts))
                for k, v := range counts {
                    entries = append(entries, entry{k, v})
                }
                sort.Slice(entries, func(i, j int) bool {
                    if entries[i].count != entries[j].count {
                        return entries[i].count > entries[j].count
                    }
                    return entries[i].level < entries[j].level
                })
                parts := make([]string, len(entries))
                for i, e := range entries {
                    parts[i] = fmt.Sprintf("%s: %d", e.level, e.count)
                }
                return strings.Join(parts, "\n")
            }
          annotations:
            - type: pattern
              label: Count â†’ Struct â†’ Sort
              text: >-
                This is the upgrade from Module 1's count â†’ sort-keys â†’ format. Structs let you sort by value (count)
                instead of just by key. Same pattern, more power.
