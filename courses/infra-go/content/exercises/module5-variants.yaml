conceptLinks:
  HTTP Requests: making-http-requests
  JSON Round-Tripping: json-round-tripping
  API Client: building-an-api-client
  HTTP Errors: error-handling-for-http
sharedContent: {}
variants:
  warmups:
    - id: warmup_1
      concept: HTTP Requests
      variants:
        - id: v1
          title: Build a GET Request
          description: >-
            Create an <code>http.Client</code> with a 10-second timeout. Build a GET request to
            <code>https://api.example.com/v1/nodes</code> with an Accept: application/json header. Execute it and check
            for errors.
          hints:
            - "Use <code>&http.Client{Timeout: 10 * time.Second}</code>"
            - Use <code>http.NewRequest("GET", url, nil)</code> then <code>req.Header.Set(...)
          solution: |-
            client := &http.Client{Timeout: 10 * time.Second}

            req, err := http.NewRequest("GET", "https://api.example.com/v1/nodes", nil)
            if err != nil {
                log.Fatal(err)
            }
            req.Header.Set("Accept", "application/json")

            resp, err := client.Do(req)
            if err != nil {
                log.Fatal(err)
            }
            defer resp.Body.Close()
            fmt.Println("Status:", resp.StatusCode)
        - id: v2
          title: POST JSON Body
          description: >-
            Build a POST request to <code>/v1/pods</code> with a JSON body:
            <code>{"name":"web-1","namespace":"prod"}</code>. Set Content-Type to application/json.
          hints:
            - Marshal the map with <code>json.Marshal</code>
            - Use <code>bytes.NewReader(body)</code> as the request body
          solution: |-
            payload := map[string]string{"name": "web-1", "namespace": "prod"}
            body, err := json.Marshal(payload)
            if err != nil {
                log.Fatal(err)
            }

            req, err := http.NewRequest("POST", "https://api.example.com/v1/pods", bytes.NewReader(body))
            if err != nil {
                log.Fatal(err)
            }
            req.Header.Set("Content-Type", "application/json")
    - id: warmup_2
      concept: JSON Round-Tripping
      variants:
        - id: v1
          title: Decode API Response
          description: >-
            Given an <code>http.Response</code> with JSON body
            <code>{"instances":[{"id":"i-1","type":"t3.medium"},{"id":"i-2","type":"t3.large"}]}</code>, decode it into
            a struct and print each instance ID.
          hints:
            - "Define a wrapper struct: <code>struct { Instances []Instance }</code>"
            - Use <code>json.NewDecoder(resp.Body).Decode(&result)</code>
          solution: |-
            type Instance struct {
                ID   string `json:"id"`
                Type string `json:"type"`
            }

            var result struct {
                Instances []Instance `json:"instances"`
            }
            if err := json.NewDecoder(resp.Body).Decode(&result); err != nil {
                log.Fatal(err)
            }
            for _, inst := range result.Instances {
                fmt.Println(inst.ID)
            }
        - id: v2
          title: Handle Optional Fields
          description: >-
            Define a <code>Node</code> struct where <code>Region</code> is optional (might be missing from JSON). Use a
            <code>*string</code> pointer to distinguish 'missing' from 'empty string'. Parse JSON with and without the
            region field.
          hints:
            - Use <code>Region *string `json:"region,omitempty"`</code>
            - nil means missing, empty pointer means explicitly empty
          solution: |-
            type Node struct {
                ID     string  `json:"id"`
                Name   string  `json:"name"`
                Region *string `json:"region,omitempty"`
            }

            // With region
            data1 := []byte(`{"id":"n1","name":"node-1","region":"us-east-1"}`)
            var n1 Node
            json.Unmarshal(data1, &n1)
            fmt.Println(*n1.Region) // us-east-1

            // Without region
            data2 := []byte(`{"id":"n2","name":"node-2"}`)
            var n2 Node
            json.Unmarshal(data2, &n2)
            fmt.Println(n2.Region == nil) // true
    - id: warmup_3
      concept: API Client
      variants:
        - id: v1
          title: Client Struct Skeleton
          description: >-
            Define an <code>APIClient</code> struct with baseURL (string), token (string), and httpClient
            (*http.Client). Write a <code>NewAPIClient(baseURL, token string) *APIClient</code> constructor that sets a
            15-second timeout.
          hints:
            - "Trim trailing slash from baseURL: <code>strings.TrimRight(baseURL, \"/\")</code>"
            - "Initialize httpClient in the constructor: <code>&http.Client{Timeout: 15 * time.Second}</code>"
          solution: |-
            type APIClient struct {
                baseURL    string
                token      string
                httpClient *http.Client
            }

            func NewAPIClient(baseURL, token string) *APIClient {
                return &APIClient{
                    baseURL:    strings.TrimRight(baseURL, "/"),
                    token:      token,
                    httpClient: &http.Client{Timeout: 15 * time.Second},
                }
            }
        - id: v2
          title: Check Response Status
          description: >-
            Write a <code>checkResponse(resp *http.Response) error</code> function that returns nil for 2xx status codes
            and an error with the status code and body for anything else.
          hints:
            - Check <code>resp.StatusCode >= 200 && resp.StatusCode < 300</code>
            - Read body with <code>io.ReadAll</code> for the error message
          solution: |-
            func checkResponse(resp *http.Response) error {
                if resp.StatusCode >= 200 && resp.StatusCode < 300 {
                    return nil
                }
                body, _ := io.ReadAll(resp.Body)
                return fmt.Errorf("API error (status %d): %s", resp.StatusCode, string(body))
            }
  challenges:
    - id: challenge_1
      block: 1
      difficulty: 2
      concept: API Client
      variants:
        - id: v1
          title: GitHub Repo Client
          description: >-
            Write a <code>GitHubClient</code> with a method <code>GetRepo(ctx context.Context, owner, repo string)
            (Repo, error)</code>. It should: build the URL, set Accept and Auth headers, check status code, and decode
            the JSON response into a Repo struct (Name, Stars, Language).
          functionSignature: func (c *GitHubClient) GetRepo(ctx context.Context, owner, repo string) (Repo, error)
          difficulty: 1
          testCases:
            - input: client.GetRepo(ctx, "hashicorp", "terraform")
              output: (Repo{Name:"terraform", Stars:40000, Language:"Go"}, nil)
          hints:
            - title: Think about it
              content: Build URL from owner+repo. Use NewRequestWithContext. Check status. Decode JSON.
            - title: Hint
              content: >-
                URL: <code>fmt.Sprintf("https://api.github.com/repos/%s/%s", owner, repo)</code>. Decode into a struct
                with json tags matching GitHub's API (<code>stargazers_count</code>, <code>language</code>).
          solution: |-
            type Repo struct {
                Name     string `json:"name"`
                Stars    int    `json:"stargazers_count"`
                Language string `json:"language"`
            }

            type GitHubClient struct {
                token      string
                httpClient *http.Client
            }

            func (c *GitHubClient) GetRepo(ctx context.Context, owner, repo string) (Repo, error) {
                url := fmt.Sprintf("https://api.github.com/repos/%s/%s", owner, repo)
                req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
                if err != nil {
                    return Repo{}, err
                }
                req.Header.Set("Accept", "application/vnd.github.v3+json")
                if c.token != "" {
                    req.Header.Set("Authorization", "Bearer "+c.token)
                }

                resp, err := c.httpClient.Do(req)
                if err != nil {
                    return Repo{}, fmt.Errorf("fetching repo: %w", err)
                }
                defer resp.Body.Close()

                if resp.StatusCode != http.StatusOK {
                    return Repo{}, fmt.Errorf("GitHub API error: %d", resp.StatusCode)
                }

                var r Repo
                if err := json.NewDecoder(resp.Body).Decode(&r); err != nil {
                    return Repo{}, fmt.Errorf("decoding repo: %w", err)
                }
                return r, nil
            }
          annotations:
            - type: pattern
              label: API client method
              text: >-
                Build URL → create request → set headers → execute → check status → decode. This sequence is identical
                for every API client method.
            - type: idiom
              label: Context everywhere
              text: >-
                Always accept context.Context as the first parameter. It enables timeout and cancellation from the
                caller.
        - id: v2
          title: API Client with Error Types
          description: >-
            Build a <code>CloudClient</code> with a <code>do()</code> helper that handles auth and error checking.
            Define an <code>APIError</code> type (StatusCode int, Message string) that implements error. Write
            <code>ListNodes(ctx) ([]Node, error)</code> that returns structured errors callers can inspect with
            errors.As.
          functionSignature: func (c *CloudClient) ListNodes(ctx context.Context) ([]Node, error)
          difficulty: 2
          testCases:
            - input: c.ListNodes(ctx) // 200 OK
              output: ([]Node{...}, nil)
            - input: c.ListNodes(ctx) // 401
              output: APIError{StatusCode:401, Message:"unauthorized"}
          hints:
            - title: Think about it
              content: The do() helper builds request, adds auth, executes, checks status. ListNodes calls do() and decodes.
            - title: Hint
              content: >-
                In <code>do()</code>, if status >= 400, decode the error body into APIError, set StatusCode, return it.
                Callers use <code>errors.As(err, &apiErr)</code> to check.
          solution: |-
            type APIError struct {
                StatusCode int    `json:"-"`
                Message    string `json:"message"`
            }
            func (e *APIError) Error() string {
                return fmt.Sprintf("API error %d: %s", e.StatusCode, e.Message)
            }

            type CloudClient struct {
                baseURL string
                token   string
                http    *http.Client
            }

            func (c *CloudClient) do(ctx context.Context, method, path string) (*http.Response, error) {
                req, err := http.NewRequestWithContext(ctx, method, c.baseURL+path, nil)
                if err != nil {
                    return nil, err
                }
                req.Header.Set("Authorization", "Bearer "+c.token)
                req.Header.Set("Accept", "application/json")
                resp, err := c.http.Do(req)
                if err != nil {
                    return nil, err
                }
                if resp.StatusCode >= 400 {
                    var apiErr APIError
                    json.NewDecoder(resp.Body).Decode(&apiErr)
                    resp.Body.Close()
                    apiErr.StatusCode = resp.StatusCode
                    return nil, &apiErr
                }
                return resp, nil
            }

            type Node struct {
                ID   string `json:"id"`
                Name string `json:"name"`
            }

            func (c *CloudClient) ListNodes(ctx context.Context) ([]Node, error) {
                resp, err := c.do(ctx, "GET", "/v1/nodes")
                if err != nil {
                    return nil, err
                }
                defer resp.Body.Close()
                var result struct {
                    Nodes []Node `json:"nodes"`
                }
                if err := json.NewDecoder(resp.Body).Decode(&result); err != nil {
                    return nil, fmt.Errorf("decoding: %w", err)
                }
                return result.Nodes, nil
            }
          annotations:
            - type: pattern
              label: Centralized error handling
              text: >-
                The do() helper handles auth and error checking once. Every endpoint method calls do() and just decodes
                the happy path.
            - type: idiom
              label: Custom error types
              text: >-
                APIError lets callers check status codes with errors.As without string parsing. Professional API clients
                always expose structured errors.
        - id: v3
          title: Paginated API Client
          description: >-
            Write <code>ListAllInstances(ctx) ([]Instance, error)</code> that fetches all pages from a paginated API.
            The API returns <code>{"instances":[...], "next_cursor":"abc"}</code>. When next_cursor is empty, you've
            fetched everything. Include a safety limit of 100 pages to prevent infinite loops.
          functionSignature: func (c *CloudClient) ListAllInstances(ctx context.Context) ([]Instance, error)
          difficulty: 3
          testCases:
            - input: c.ListAllInstances(ctx) // 3 pages of 10
              output: ([]Instance with 30 items, nil)
            - input: c.ListAllInstances(ctx) // single page
              output: ([]Instance with 5 items, nil)
          hints:
            - title: Think about it
              content: >-
                Loop: fetch page, append results, check next_cursor. Stop when empty or page limit reached. Pass cursor
                as query param.
            - title: Hint
              content: >-
                Build URL with <code>url.Values</code> for the cursor param. Check <code>ctx.Err()</code> each iteration
                for cancellation. Use a page counter and break at 100.
          solution: |-
            type Instance struct {
                ID     string `json:"id"`
                Name   string `json:"name"`
                Type   string `json:"type"`
                Region string `json:"region"`
            }

            func (c *CloudClient) ListAllInstances(ctx context.Context) ([]Instance, error) {
                var all []Instance
                cursor := ""
                maxPages := 100

                for page := 0; page < maxPages; page++ {
                    if err := ctx.Err(); err != nil {
                        return nil, err
                    }

                    path := "/v1/instances"
                    if cursor != "" {
                        path += "?cursor=" + url.QueryEscape(cursor)
                    }

                    resp, err := c.do(ctx, "GET", path)
                    if err != nil {
                        return nil, fmt.Errorf("page %d: %w", page, err)
                    }

                    var result struct {
                        Instances  []Instance `json:"instances"`
                        NextCursor string     `json:"next_cursor"`
                    }
                    err = json.NewDecoder(resp.Body).Decode(&result)
                    resp.Body.Close()
                    if err != nil {
                        return nil, fmt.Errorf("decoding page %d: %w", page, err)
                    }

                    all = append(all, result.Instances...)

                    if result.NextCursor == "" {
                        break
                    }
                    cursor = result.NextCursor
                }
                return all, nil
            }
          annotations:
            - type: pattern
              label: Cursor pagination
              text: >-
                cursor/next_cursor is the most common API pagination pattern. Others: page numbers, Link headers,
                offset/limit.
            - type: gotcha
              label: Infinite loop guard
              text: >-
                Always add a max page limit. A buggy API returning the same cursor forever will loop your client forever
                without it.
            - type: interview
              label: API design
              text: Pagination is asked in every backend interview. Know cursor vs offset pagination and the tradeoffs.
    - id: challenge_2
      block: 2
      difficulty: 2
      concept: HTTP Errors
      variants:
        - id: v1
          title: Status Code Checker
          description: >-
            Write <code>classifyStatus(code int) string</code> that returns: "success" for 2xx, "redirect" for 3xx,
            "client_error" for 4xx, "server_error" for 5xx, "unknown" otherwise. Then write <code>isRetryable(code int)
            bool</code> that returns true only for 429 and 5xx codes.
          functionSignature: func classifyStatus(code int) string
          difficulty: 1
          testCases:
            - input: classifyStatus(200)
              output: "\"success\""
            - input: classifyStatus(404)
              output: "\"client_error\""
            - input: isRetryable(503)
              output: "true"
            - input: isRetryable(404)
              output: "false"
          hints:
            - title: Think about it
              content: "Integer ranges: 200-299, 300-399, etc. 429 is special (rate limited = transient)."
            - title: Hint
              content: >-
                Use <code>code / 100</code> to get the class (2, 3, 4, 5). For isRetryable, check <code>code == 429 ||
                code >= 500</code>.
          solution: |-
            func classifyStatus(code int) string {
                switch {
                case code >= 200 && code < 300:
                    return "success"
                case code >= 300 && code < 400:
                    return "redirect"
                case code >= 400 && code < 500:
                    return "client_error"
                case code >= 500 && code < 600:
                    return "server_error"
                default:
                    return "unknown"
                }
            }

            func isRetryable(code int) bool {
                return code == 429 || code >= 500
            }
          annotations:
            - type: pattern
              label: Status classification
              text: Every HTTP client needs this logic. Classify by range, then special-case 429 for rate limiting.
            - type: gotcha
              label: 429 is retryable
              text: 429 Too Many Requests is a 4xx but IS retryable. Check Retry-After header for the wait time.
        - id: v2
          title: Structured API Error Handler
          description: >-
            Write <code>handleAPIError(resp *http.Response) error</code> that: reads the body, tries to decode as JSON
            <code>{"error":{"code":"...","message":"..."}}</code>, falls back to raw body text if JSON decode fails.
            Returns a structured <code>*APIError</code> with StatusCode, Code, and Message.
          functionSignature: func handleAPIError(resp *http.Response) error
          difficulty: 2
          testCases:
            - input: handleAPIError(jsonErrorResponse)
              output: "&APIError{404, \"not_found\", \"Pod not found\"}"
            - input: handleAPIError(plainTextResponse)
              output: "&APIError{500, \"\", \"Internal Server Error\"}"
          hints:
            - title: Think about it
              content: Read body bytes once. Try JSON decode. If it fails, use raw text as the message.
            - title: Hint
              content: >-
                Read all bytes first with <code>io.ReadAll</code>. Try <code>json.Unmarshal</code> into a struct. If err
                != nil, fall back to <code>string(body)</code> as message.
          solution: |-
            type APIError struct {
                StatusCode int
                Code       string `json:"code"`
                Message    string `json:"message"`
            }
            func (e *APIError) Error() string {
                if e.Code != "" {
                    return fmt.Sprintf("API error %d (%s): %s", e.StatusCode, e.Code, e.Message)
                }
                return fmt.Sprintf("API error %d: %s", e.StatusCode, e.Message)
            }

            func handleAPIError(resp *http.Response) error {
                body, _ := io.ReadAll(resp.Body)
                apiErr := &APIError{StatusCode: resp.StatusCode}

                var errBody struct {
                    Error struct {
                        Code    string `json:"code"`
                        Message string `json:"message"`
                    } `json:"error"`
                }
                if err := json.Unmarshal(body, &errBody); err == nil && errBody.Error.Message != "" {
                    apiErr.Code = errBody.Error.Code
                    apiErr.Message = errBody.Error.Message
                } else {
                    apiErr.Message = strings.TrimSpace(string(body))
                }
                return apiErr
            }
          annotations:
            - type: pattern
              label: Graceful degradation
              text: >-
                Try structured JSON first, fall back to raw text. Real APIs aren't always consistent with their error
                formats.
            - type: interview
              label: Error handling depth
              text: Most candidates just check status codes. Parsing error bodies shows you build production-quality code.
        - id: v3
          title: Retry with Exponential Backoff
          description: >-
            Write <code>fetchWithRetry(ctx context.Context, client *http.Client, url string, maxRetries int)
            (*http.Response, error)</code>. Retry on 5xx and 429. Use exponential backoff (100ms, 200ms, 400ms, ...).
            Respect context cancellation between retries. If 429 has a Retry-After header (seconds), use that instead of
            backoff.
          functionSignature: >-
            func fetchWithRetry(ctx context.Context, client *http.Client, url string, maxRetries int) (*http.Response,
            error)
          difficulty: 3
          testCases:
            - input: fetchWithRetry(ctx, client, url, 3) // succeeds on 2nd try
              output: (resp, nil)
            - input: fetchWithRetry(ctx, client, url, 3) // all 503s
              output: (nil, "max retries exceeded")
          hints:
            - title: Think about it
              content: >-
                Loop with attempts. On 5xx/429, close body and retry. Parse Retry-After for 429. Use select with
                ctx.Done() for cancellation.
            - title: Hint
              content: >-
                Backoff: <code>time.Duration(1<<attempt) * 100 * time.Millisecond</code>. For 429:
                <code>strconv.Atoi(resp.Header.Get("Retry-After"))</code>. Use <code>select { case <-ctx.Done(): case
                <-time.After(wait): }</code>.
          solution: >-
            func fetchWithRetry(ctx context.Context, client *http.Client, url string, maxRetries int) (*http.Response,
            error) {
                var lastErr error
                for attempt := 0; attempt <= maxRetries; attempt++ {
                    req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
                    if err != nil {
                        return nil, err
                    }
                    resp, err := client.Do(req)
                    if err != nil {
                        lastErr = err
                    } else if resp.StatusCode < 400 {
                        return resp, nil
                    } else if resp.StatusCode == 429 || resp.StatusCode >= 500 {
                        var wait time.Duration
                        if resp.StatusCode == 429 {
                            if s, err := strconv.Atoi(resp.Header.Get("Retry-After")); err == nil {
                                wait = time.Duration(s) * time.Second
                            }
                        }
                        resp.Body.Close()
                        lastErr = fmt.Errorf("status %d", resp.StatusCode)
                        if wait == 0 {
                            wait = time.Duration(1<<attempt) * 100 * time.Millisecond
                        }
                    } else {
                        return resp, nil // 4xx (not 429) — don't retry
                    }

                    select {
                    case <-ctx.Done():
                        return nil, ctx.Err()
                    case <-time.After(wait):
                    }
                }
                return nil, fmt.Errorf("max retries exceeded: %w", lastErr)
            }
          annotations:
            - type: pattern
              label: Exponential backoff
              text: 1<<attempt gives 1, 2, 4, 8... Multiply by base interval. This prevents hammering a struggling server.
            - type: idiom
              label: select for cancellation
              text: "select { case <-ctx.Done(): case <-time.After(d): } respects context cancellation during the wait."
            - type: gotcha
              label: Close body on retry
              text: >-
                You MUST close resp.Body before retrying. Leaving it open leaks connections and eventually deadlocks the
                client.
