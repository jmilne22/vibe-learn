conceptLinks:
  Flag Package: os-args-and-the-flag-package
  JSON Parsing: parsing-yaml-and-json
  File I/O: file-i-o-patterns
  Validation: validation-and-reporting
sharedContent: {}
variants:
  warmups:
    - id: warmup_1
      concept: JSON Parsing
      variants:
        - id: v1
          title: Unmarshal a Pod
          description: >-
            Given JSON string <code>{"name":"web-1","namespace":"prod","replicas":3}</code>, unmarshal it into a Pod
            struct with matching json tags. Print the pod's name.
          hints:
            - Define struct with <code>json:"name"</code> tags
            - Use <code>json.Unmarshal([]byte(data), &pod)</code>
          solution: |-
            type Pod struct {
                Name      string `json:"name"`
                Namespace string `json:"namespace"`
                Replicas  int    `json:"replicas"`
            }

            data := []byte(`{"name":"web-1","namespace":"prod","replicas":3}`)
            var pod Pod
            if err := json.Unmarshal(data, &pod); err != nil {
                log.Fatal(err)
            }
            fmt.Println(pod.Name) // web-1
        - id: v2
          title: Marshal to JSON
          description: >-
            Create a <code>Service</code> struct (Name, Port, Protocol) and marshal it to indented JSON. Use
            <code>json:"omitempty"</code> on Protocol so it's omitted when empty.
          hints:
            - Use <code>json.MarshalIndent(svc, "", "  ")</code>
            - "Tag: <code>Protocol string `json:\"protocol,omitempty\"`</code>"
          solution: |-
            type Service struct {
                Name     string `json:"name"`
                Port     int    `json:"port"`
                Protocol string `json:"protocol,omitempty"`
            }

            svc := Service{Name: "api", Port: 8080}
            out, err := json.MarshalIndent(svc, "", "  ")
            if err != nil {
                log.Fatal(err)
            }
            fmt.Println(string(out))
        - id: v3
          title: Parse YAML Config
          description: >-
            Given YAML string <code>"host: localhost\nport: 8080\ndebug: true"</code>, unmarshal it into a struct with
            <code>yaml</code> tags. Print each field.
          hints:
            - Use <code>yaml.Unmarshal([]byte(data), &cfg)</code>
            - "Tags: <code>Host string `yaml:\"host\"`</code>"
          solution: |-
            type AppConfig struct {
                Host  string `yaml:"host"`
                Port  int    `yaml:"port"`
                Debug bool   `yaml:"debug"`
            }

            data := []byte("host: localhost\nport: 8080\ndebug: true")
            var cfg AppConfig
            if err := yaml.Unmarshal(data, &cfg); err != nil {
                log.Fatal(err)
            }
            fmt.Printf("host=%s port=%d debug=%t\n", cfg.Host, cfg.Port, cfg.Debug)
    - id: warmup_2
      concept: JSON Parsing
      variants:
        - id: v1
          title: Parse Nested JSON
          description: >-
            Parse this JSON into structs:
            <code>{"metadata":{"name":"web","namespace":"prod"},"spec":{"replicas":3,"image":"nginx"}}</code>. Access
            the image field.
          hints:
            - Define Metadata and Spec as separate structs, embed in a Manifest struct
            - Access via <code>m.Spec.Image</code>
          solution: |-
            type Metadata struct {
                Name      string `json:"name"`
                Namespace string `json:"namespace"`
            }
            type Spec struct {
                Replicas int    `json:"replicas"`
                Image    string `json:"image"`
            }
            type Manifest struct {
                Metadata Metadata `json:"metadata"`
                Spec     Spec     `json:"spec"`
            }

            data := []byte(`{"metadata":{"name":"web","namespace":"prod"},"spec":{"replicas":3,"image":"nginx"}}`)
            var m Manifest
            json.Unmarshal(data, &m)
            fmt.Println(m.Spec.Image) // nginx
        - id: v2
          title: Parse Dynamic JSON
          description: >-
            Parse JSON <code>{"apiVersion":"v1","kind":"Pod","extra":"data"}</code> into a <code>map[string]any</code>.
            Print the kind value using a type assertion.
          hints:
            - Unmarshal into <code>map[string]any</code>
            - "Access: <code>raw[\"kind\"].(string)</code>"
          solution: |-
            data := []byte(`{"apiVersion":"v1","kind":"Pod","extra":"data"}`)
            var raw map[string]any
            if err := json.Unmarshal(data, &raw); err != nil {
                log.Fatal(err)
            }
            kind, ok := raw["kind"].(string)
            if !ok {
                log.Fatal("kind is not a string")
            }
            fmt.Println(kind) // Pod
    - id: warmup_3
      concept: File I/O
      variants:
        - id: v1
          title: Read and Count Lines
          description: >-
            Write a function <code>countLines(path string) (int, error)</code> that opens a file, counts lines with
            <code>bufio.Scanner</code>, and returns the count. Remember to check <code>scanner.Err()</code>.
          hints:
            - Use <code>os.Open</code> + <code>defer f.Close()</code>
            - "Loop: <code>for scanner.Scan() { count++ }</code>"
          solution: |-
            func countLines(path string) (int, error) {
                f, err := os.Open(path)
                if err != nil {
                    return 0, fmt.Errorf("opening %s: %w", path, err)
                }
                defer f.Close()

                count := 0
                scanner := bufio.NewScanner(f)
                for scanner.Scan() {
                    count++
                }
                if err := scanner.Err(); err != nil {
                    return 0, fmt.Errorf("reading %s: %w", path, err)
                }
                return count, nil
            }
        - id: v2
          title: Find YAML Files
          description: >-
            Write a function <code>findYAMLFiles(root string) ([]string, error)</code> that walks a directory tree and
            returns all <code>.yaml</code> and <code>.yml</code> file paths.
          hints:
            - Use <code>filepath.WalkDir</code>
            - Check extension with <code>filepath.Ext(path)</code>
          solution: |-
            func findYAMLFiles(root string) ([]string, error) {
                var files []string
                err := filepath.WalkDir(root, func(path string, d fs.DirEntry, err error) error {
                    if err != nil {
                        return err
                    }
                    if d.IsDir() {
                        return nil
                    }
                    ext := filepath.Ext(path)
                    if ext == ".yaml" || ext == ".yml" {
                        files = append(files, path)
                    }
                    return nil
                })
                return files, err
            }
    - id: warmup_4
      concept: Validation
      variants:
        - id: v1
          title: Validate K8s Manifest Fields
          description: >-
            Write <code>validateManifest(m Manifest) []string</code> that checks: apiVersion is non-empty, kind is one
            of "Pod"/"Service"/"Deployment", metadata.name is non-empty. Return a slice of error messages (empty if
            valid).
          hints:
            - Collect errors into <code>var errs []string</code>
            - Check kind with a map or switch statement
          solution: |-
            type Manifest struct {
                APIVersion string `yaml:"apiVersion"`
                Kind       string `yaml:"kind"`
                Metadata   struct {
                    Name string `yaml:"name"`
                } `yaml:"metadata"`
            }

            func validateManifest(m Manifest) []string {
                var errs []string
                if m.APIVersion == "" {
                    errs = append(errs, "apiVersion is required")
                }
                validKinds := map[string]bool{"Pod": true, "Service": true, "Deployment": true}
                if !validKinds[m.Kind] {
                    errs = append(errs, fmt.Sprintf("invalid kind: %q", m.Kind))
                }
                if m.Metadata.Name == "" {
                    errs = append(errs, "metadata.name is required")
                }
                return errs
            }
        - id: v2
          title: Format Lint Results
          description: >-
            Given a <code>[]LintResult</code> (File, Line int, Severity, Message string), write
            <code>formatResults(results []LintResult) string</code> that formats each as <code>"file.yaml:10 [error]
            message"</code>, one per line.
          hints:
            - Use <code>fmt.Sprintf("%s:%d [%s] %s", ...)</code>
            - Join with <code>strings.Join</code> or a <code>strings.Builder</code>
          solution: |-
            type LintResult struct {
                File     string
                Line     int
                Severity string
                Message  string
            }

            func formatResults(results []LintResult) string {
                lines := make([]string, len(results))
                for i, r := range results {
                    lines[i] = fmt.Sprintf("%s:%d [%s] %s", r.File, r.Line, r.Severity, r.Message)
                }
                return strings.Join(lines, "\n")
            }
  challenges:
    - id: challenge_1
      block: 1
      difficulty: 2
      concept: JSON Parsing
      variants:
        - id: v1
          title: Parse K8s Pod JSON
          description: >-
            Write <code>parsePodJSON(data []byte) (Pod, error)</code> that parses a K8s-style JSON pod with nested
            metadata (name, namespace, labels) and spec (containers with name and image). Return a flattened Pod struct.
          functionSignature: func parsePodJSON(data []byte) (Pod, error)
          difficulty: 1
          testCases:
            - input: >-
                parsePodJSON([]byte(`{"metadata":{"name":"web","namespace":"prod"},"spec":{"containers":[{"name":"app","image":"nginx"}]}}`))
              output: (Pod{Name:"web",Namespace:"prod",Image:"nginx"}, nil)
          hints:
            - title: Think about it
              content: You need intermediate structs that mirror the JSON structure, then extract the fields you want.
            - title: Hint
              content: >-
                Define a <code>rawPod</code> struct matching the JSON shape, unmarshal into that, then build your flat
                Pod from its fields. Use <code>Containers[0].Image</code> for the image.
          solution: |-
            type Pod struct {
                Name      string
                Namespace string
                Image     string
            }

            func parsePodJSON(data []byte) (Pod, error) {
                var raw struct {
                    Metadata struct {
                        Name      string `json:"name"`
                        Namespace string `json:"namespace"`
                    } `json:"metadata"`
                    Spec struct {
                        Containers []struct {
                            Name  string `json:"name"`
                            Image string `json:"image"`
                        } `json:"containers"`
                    } `json:"spec"`
                }
                if err := json.Unmarshal(data, &raw); err != nil {
                    return Pod{}, fmt.Errorf("parsing pod JSON: %w", err)
                }
                if len(raw.Spec.Containers) == 0 {
                    return Pod{}, fmt.Errorf("pod has no containers")
                }
                return Pod{
                    Name:      raw.Metadata.Name,
                    Namespace: raw.Metadata.Namespace,
                    Image:     raw.Spec.Containers[0].Image,
                }, nil
            }
          annotations:
            - type: pattern
              label: Anonymous structs
              text: Inline anonymous structs for one-off JSON parsing. No need to name types you only use once.
            - type: idiom
              label: Flat from nested
              text: >-
                Parse the raw shape, then extract into your domain struct. Don't force your domain model to match the
                wire format.
        - id: v2
          title: Multi-Document YAML Parser
          description: >-
            Write <code>parseManifests(data []byte) ([]Manifest, error)</code> that splits multi-document YAML
            (separated by <code>---</code>) and parses each into a Manifest struct (APIVersion, Kind, Name). Skip empty
            documents.
          functionSignature: func parseManifests(data []byte) ([]Manifest, error)
          difficulty: 2
          testCases:
            - input: >-
                parseManifests([]byte("apiVersion: v1\nkind: Pod\nmetadata:\n  name: web\n---\napiVersion: v1\nkind:
                Service\nmetadata:\n  name: api"))
              output: ([{v1 Pod web} {v1 Service api}], nil)
          hints:
            - title: Think about it
              content: Split on '---' first, then parse each chunk separately. Watch out for empty chunks.
            - title: Hint
              content: >-
                Use <code>bytes.Split(data, []byte("---"))</code>. For each chunk, <code>bytes.TrimSpace</code> and skip
                empty ones. Unmarshal each into a Manifest.
          solution: |-
            type Manifest struct {
                APIVersion string `yaml:"apiVersion"`
                Kind       string `yaml:"kind"`
                Metadata   struct {
                    Name string `yaml:"name"`
                } `yaml:"metadata"`
            }

            func parseManifests(data []byte) ([]Manifest, error) {
                chunks := bytes.Split(data, []byte("---"))
                var manifests []Manifest
                for i, chunk := range chunks {
                    chunk = bytes.TrimSpace(chunk)
                    if len(chunk) == 0 {
                        continue
                    }
                    var m Manifest
                    if err := yaml.Unmarshal(chunk, &m); err != nil {
                        return nil, fmt.Errorf("document %d: %w", i, err)
                    }
                    manifests = append(manifests, m)
                }
                return manifests, nil
            }
          annotations:
            - type: pattern
              label: Multi-doc YAML
              text: K8s manifests are often multi-document YAML. Split on '---' is the standard approach.
            - type: gotcha
              label: Empty chunks
              text: A file starting with '---' produces an empty first chunk. Always trim and skip empty.
        - id: v3
          title: Config File Merger
          description: >-
            Write <code>mergeConfigs(files []string) (map[string]any, error)</code> that reads multiple YAML files and
            deep-merges them (later files override earlier). Handle: file not found errors, YAML parse errors (with
            filename in error), and nested maps.
          functionSignature: func mergeConfigs(files []string) (map[string]any, error)
          difficulty: 3
          testCases:
            - input: mergeConfigs(["base.yaml", "override.yaml"]) // base has port:8080, override has port:9090
              output: map[port:9090 ...]
            - input: mergeConfigs(["missing.yaml"])
              output: error containing filename
          hints:
            - title: Think about it
              content: Read each file, unmarshal to map[string]any, then merge maps. For nested maps, recurse.
            - title: Hint
              content: >-
                Write a helper <code>mergeMaps(base, override map[string]any)</code> that iterates override keys. If
                both values are maps, recurse. Otherwise, override wins.
          solution: |-
            func mergeConfigs(files []string) (map[string]any, error) {
                result := make(map[string]any)
                for _, file := range files {
                    data, err := os.ReadFile(file)
                    if err != nil {
                        return nil, fmt.Errorf("reading %s: %w", file, err)
                    }
                    var layer map[string]any
                    if err := yaml.Unmarshal(data, &layer); err != nil {
                        return nil, fmt.Errorf("parsing %s: %w", file, err)
                    }
                    mergeMaps(result, layer)
                }
                return result, nil
            }

            func mergeMaps(base, override map[string]any) {
                for k, v := range override {
                    if baseMap, ok := base[k].(map[string]any); ok {
                        if overMap, ok := v.(map[string]any); ok {
                            mergeMaps(baseMap, overMap)
                            continue
                        }
                    }
                    base[k] = v
                }
            }
          annotations:
            - type: pattern
              label: Config layering
              text: >-
                Base → environment → local overrides. This is how Helm values, Docker Compose, and most config systems
                work.
            - type: interview
              label: Recursive merge
              text: >-
                Deep merging nested maps is a common interview question. The key insight: only recurse when both sides
                are maps.
    - id: challenge_2
      block: 2
      difficulty: 2
      concept: Validation
      variants:
        - id: v1
          title: K8s Label Validator
          description: >-
            Write <code>validateLabels(labels map[string]string) []string</code>. K8s label rules: keys max 63 chars,
            values max 63 chars, keys must be alphanumeric/hyphens/dots/slashes, values must be
            alphanumeric/hyphens/dots. Return all violations.
          functionSignature: func validateLabels(labels map[string]string) []string
          difficulty: 1
          testCases:
            - input: validateLabels(map[string]string{"app":"web","env":"prod"})
              output: "[] (no errors)"
            - input: validateLabels(map[string]string{"":"web"})
              output: "[\"empty key\"]"
            - input: validateLabels(map[string]string{strings.Repeat("a",64):"web"})
              output: "[\"key too long\"]"
          hints:
            - title: Think about it
              content: Loop through all key-value pairs, check each against the rules, collect errors.
            - title: Hint
              content: >-
                For character validation, use a regex or loop through runes checking <code>unicode.IsLetter</code>,
                <code>unicode.IsDigit</code>, and allowed special chars.
          solution: |-
            func validateLabels(labels map[string]string) []string {
                var errs []string
                for k, v := range labels {
                    if k == "" {
                        errs = append(errs, "empty key")
                        continue
                    }
                    if len(k) > 63 {
                        errs = append(errs, fmt.Sprintf("key %q too long (%d > 63)", k, len(k)))
                    }
                    if len(v) > 63 {
                        errs = append(errs, fmt.Sprintf("value %q for key %q too long", v, k))
                    }
                }
                return errs
            }
          annotations:
            - type: pattern
              label: Collect all errors
              text: Return all violations at once so users can fix everything in one pass.
            - type: stdlib
              label: regexp
              text: >-
                For complex character validation, regexp.MustCompile once at package level, then MatchString in the
                validator.
        - id: v2
          title: Deployment Manifest Linter
          description: >-
            Write <code>lintDeployment(data []byte) ([]LintResult, error)</code>. Parse YAML, check: (1) has apiVersion
            and kind, (2) kind is "Deployment", (3) replicas > 0, (4) has at least one container in spec, (5) container
            images don't use :latest tag. Return LintResults with severity and message.
          functionSignature: func lintDeployment(data []byte) ([]LintResult, error)
          difficulty: 2
          testCases:
            - input: lintDeployment(validDeploymentYAML)
              output: ([], nil)
            - input: lintDeployment(latestTagYAML)
              output: ([{warning, "image uses :latest"}], nil)
          hints:
            - title: Think about it
              content: Parse into a struct or map[string]any. Run each check. Each check appends to results.
            - title: Hint
              content: >-
                Parse to a struct matching the Deployment shape. For the :latest check, use
                <code>strings.HasSuffix(image, ":latest") || !strings.Contains(image, ":")</code> — untagged images
                default to latest.
          solution: |-
            type LintResult struct {
                Severity string
                Message  string
            }

            func lintDeployment(data []byte) ([]LintResult, error) {
                var dep struct {
                    APIVersion string `yaml:"apiVersion"`
                    Kind       string `yaml:"kind"`
                    Spec       struct {
                        Replicas   int `yaml:"replicas"`
                        Template   struct {
                            Spec struct {
                                Containers []struct {
                                    Name  string `yaml:"name"`
                                    Image string `yaml:"image"`
                                } `yaml:"containers"`
                            } `yaml:"spec"`
                        } `yaml:"template"`
                    } `yaml:"spec"`
                }
                if err := yaml.Unmarshal(data, &dep); err != nil {
                    return nil, fmt.Errorf("parsing YAML: %w", err)
                }

                var results []LintResult
                if dep.APIVersion == "" {
                    results = append(results, LintResult{"error", "missing apiVersion"})
                }
                if dep.Kind != "Deployment" {
                    results = append(results, LintResult{"error", fmt.Sprintf("expected Deployment, got %q", dep.Kind)})
                }
                if dep.Spec.Replicas <= 0 {
                    results = append(results, LintResult{"warning", "replicas should be > 0"})
                }
                containers := dep.Spec.Template.Spec.Containers
                if len(containers) == 0 {
                    results = append(results, LintResult{"error", "no containers defined"})
                }
                for _, c := range containers {
                    if strings.HasSuffix(c.Image, ":latest") || !strings.Contains(c.Image, ":") {
                        results = append(results, LintResult{"warning", fmt.Sprintf("container %q uses :latest tag", c.Name)})
                    }
                }
                return results, nil
            }
          annotations:
            - type: pattern
              label: Lint pipeline
              text: Each check is independent and appends to results. Easy to add new rules without touching existing ones.
            - type: gotcha
              label: Implicit :latest
              text: An image without a tag (nginx vs nginx:1.25) defaults to :latest. Always check for both.
            - type: interview
              label: Real-world tool
              text: >-
                This is literally what kubeval, kubeconform, and polaris do. Building a simple version shows you
                understand K8s manifests deeply.
        - id: v3
          title: Full Config Linter Pipeline
          description: >-
            Build a complete lint pipeline: <code>lintFiles(paths []string, strict bool) (int, error)</code>. For each
            path: read file, detect YAML/JSON by extension, parse, run validation checks, collect results. Return exit
            code: 0 = clean, 1 = warnings only, 2 = errors found. If strict, treat warnings as errors.
          functionSignature: func lintFiles(paths []string, strict bool) (int, error)
          difficulty: 3
          testCases:
            - input: lintFiles([]string{"valid.yaml"}, false)
              output: (0, nil)
            - input: lintFiles([]string{"warn.yaml"}, false)
              output: (1, nil)
            - input: lintFiles([]string{"warn.yaml"}, true)
              output: (2, nil)
          hints:
            - title: Think about it
              content: >-
                Loop through files, detect format, parse, validate, collect results. At the end, determine exit code
                from the highest severity.
            - title: Hint
              content: >-
                Track <code>maxSeverity</code> across all files. If strict and any warnings exist, promote to error. Map
                severity to exit code at the end.
          solution: |-
            func lintFiles(paths []string, strict bool) (int, error) {
                var allResults []LintResult
                for _, path := range paths {
                    data, err := os.ReadFile(path)
                    if err != nil {
                        return 0, fmt.Errorf("reading %s: %w", path, err)
                    }
                    ext := filepath.Ext(path)
                    var results []LintResult
                    switch ext {
                    case ".yaml", ".yml":
                        results, err = lintYAML(path, data)
                    case ".json":
                        results, err = lintJSON(path, data)
                    default:
                        return 0, fmt.Errorf("unsupported file type: %s", ext)
                    }
                    if err != nil {
                        return 0, err
                    }
                    allResults = append(allResults, results...)
                }

                hasWarnings, hasErrors := false, false
                for _, r := range allResults {
                    switch r.Severity {
                    case "warning":
                        hasWarnings = true
                    case "error":
                        hasErrors = true
                    }
                }

                if strict && hasWarnings {
                    hasErrors = true
                }
                if hasErrors {
                    return 2, nil
                }
                if hasWarnings {
                    return 1, nil
                }
                return 0, nil
            }
          annotations:
            - type: pattern
              label: Pipeline architecture
              text: Detect → Parse → Validate → Collect → Report. Each step is independent and testable.
            - type: idiom
              label: Exit codes
              text: "0/1/2 convention: clean/warnings/errors. Lets CI distinguish 'tool broke' from 'found problems'."
            - type: interview
              label: CLI design
              text: >-
                This is a simplified version of what every linting tool does internally. Great project to discuss in
                interviews.
    - id: challenge_3
      block: 3
      difficulty: 2
      concept: File I/O
      variants:
        - id: v1
          title: Log Grep
          description: >-
            Write <code>grepLog(path, pattern string) ([]string, error)</code> that reads a log file line by line and
            returns all lines containing the pattern. Use <code>bufio.Scanner</code> for memory efficiency.
          functionSignature: func grepLog(path, pattern string) ([]string, error)
          difficulty: 1
          testCases:
            - input: grepLog("app.log", "ERROR")
              output: all lines containing ERROR
            - input: grepLog("missing.log", "ERROR")
              output: "error: file not found"
          hints:
            - title: Think about it
              content: Open file, scan lines, check each with strings.Contains, collect matches.
            - title: Hint
              content: >-
                Use <code>strings.Contains(line, pattern)</code> for simple matching. Don't forget <code>defer
                f.Close()</code> and <code>scanner.Err()</code>.
          solution: |-
            func grepLog(path, pattern string) ([]string, error) {
                f, err := os.Open(path)
                if err != nil {
                    return nil, fmt.Errorf("opening %s: %w", path, err)
                }
                defer f.Close()

                var matches []string
                scanner := bufio.NewScanner(f)
                for scanner.Scan() {
                    line := scanner.Text()
                    if strings.Contains(line, pattern) {
                        matches = append(matches, line)
                    }
                }
                if err := scanner.Err(); err != nil {
                    return nil, fmt.Errorf("reading %s: %w", path, err)
                }
                return matches, nil
            }
          annotations:
            - type: idiom
              label: Scanner pattern
              text: bufio.Scanner reads one line at a time — memory efficient for large log files.
            - type: stdlib
              label: bufio
              text: Scanner handles line splitting, buffering, and EOF detection. Always check scanner.Err() after the loop.
        - id: v2
          title: Directory Stats
          description: >-
            Write <code>dirStats(root string) (Stats, error)</code> that walks a directory and returns: total files,
            total size in bytes, file count by extension (map[string]int). Use <code>filepath.WalkDir</code> and
            <code>d.Info()</code> for file size.
          functionSignature: func dirStats(root string) (Stats, error)
          difficulty: 2
          testCases:
            - input: dirStats("./manifests")
              output: Stats{Files:10, Bytes:4096, ByExt:map[.yaml:8 .json:2]}
          hints:
            - title: Think about it
              content: WalkDir gives you each entry. For files, get Info() for size. Track extension counts in a map.
            - title: Hint
              content: >-
                Call <code>d.Info()</code> to get file size via <code>info.Size()</code>. Use
                <code>filepath.Ext(path)</code> for extension. Accumulate into your Stats struct.
          solution: |-
            type Stats struct {
                Files int
                Bytes int64
                ByExt map[string]int
            }

            func dirStats(root string) (Stats, error) {
                s := Stats{ByExt: make(map[string]int)}
                err := filepath.WalkDir(root, func(path string, d fs.DirEntry, err error) error {
                    if err != nil {
                        return err
                    }
                    if d.IsDir() {
                        return nil
                    }
                    s.Files++
                    info, err := d.Info()
                    if err != nil {
                        return err
                    }
                    s.Bytes += info.Size()
                    ext := filepath.Ext(path)
                    if ext != "" {
                        s.ByExt[ext]++
                    }
                    return nil
                })
                return s, err
            }
          annotations:
            - type: stdlib
              label: filepath.WalkDir
              text: WalkDir is more efficient than Walk — it doesn't call Stat on every entry unless you ask for Info().
            - type: pattern
              label: Accumulator struct
              text: Passing a Stats struct through the walk function is cleaner than managing multiple variables.
        - id: v3
          title: Config File Discovery & Load
          description: >-
            Write <code>loadAllConfigs(root string) (map[string]map[string]any, error)</code> that: walks a directory
            tree, finds all .yaml/.yml files, parses each, and returns a map of filepath → parsed content. Include the
            filepath in any parse errors.
          functionSignature: func loadAllConfigs(root string) (map[string]map[string]any, error)
          difficulty: 3
          testCases:
            - input: loadAllConfigs("./configs")
              output: map[configs/app.yaml:map[...] configs/db.yaml:map[...]]
            - input: loadAllConfigs("./bad") // contains invalid YAML
              output: error containing filename
          hints:
            - title: Think about it
              content: Combine directory walking with YAML parsing. The filepath becomes the map key.
            - title: Hint
              content: >-
                WalkDir to find files, ReadFile each, yaml.Unmarshal into <code>map[string]any</code>. Wrap errors with
                filepath context.
          solution: |-
            func loadAllConfigs(root string) (map[string]map[string]any, error) {
                result := make(map[string]map[string]any)
                err := filepath.WalkDir(root, func(path string, d fs.DirEntry, err error) error {
                    if err != nil {
                        return err
                    }
                    if d.IsDir() {
                        return nil
                    }
                    ext := filepath.Ext(path)
                    if ext != ".yaml" && ext != ".yml" {
                        return nil
                    }
                    data, err := os.ReadFile(path)
                    if err != nil {
                        return fmt.Errorf("reading %s: %w", path, err)
                    }
                    var parsed map[string]any
                    if err := yaml.Unmarshal(data, &parsed); err != nil {
                        return fmt.Errorf("parsing %s: %w", path, err)
                    }
                    result[path] = parsed
                    return nil
                })
                return result, err
            }
          annotations:
            - type: pattern
              label: Walk + parse
              text: Discover files → read → parse → collect. This is the core of any config management tool.
            - type: gotcha
              label: Error context
              text: >-
                Always include the filename in parse errors. 'YAML parse error' is useless. 'configs/db.yaml: YAML parse
                error at line 42' is actionable.
