"0":
  - topic: Go Toolchain
    q: What command compiles and runs a Go file in one step?
    a: >-
      `go run main.go` compiles and executes in a temporary directory. For a permanent binary, use
      `go build` instead.
  - topic: For Loops
    q: How many loop keywords does Go have, and what are they?
    a: >-
      Go has exactly one: `for`. It handles C-style counting (`for i := 0; i < n; i++`),
      while-style (`for condition {}`), infinite (`for {}`), and range-based
      (`for i, v := range collection`).
  - topic: Error Handling
    q: What is the standard Go pattern for returning and checking errors?
    a: >-
      Functions return `(value, error)`. Callers check immediately:
      `result, err := doThing(); if err != nil { return err }`.
      There is no try/catch. `nil` means no error.
  - topic: Multiple Returns
    q: How do you return multiple values from a Go function?
    a: >-
      List the return types in parentheses: `func parse(s string) (string, error)`.
      Capture with `key, err := parse(s)`. The `(value, error)` pair is the most
      common pattern.
  - topic: Format Verbs
    q: What format verb prints a float with one decimal place and a literal percent sign?
    a: >-
      `fmt.Printf("%.1f%%\n", 42.7)` prints `42.7%`.
      `.1f` controls decimal places. `%%` is a literal percent (because `%`
      is the format prefix).
  - topic: Type Conversions
    q: What happens when you divide two ints in Go, and how do you get a float result?
    a: >-
      Integer division truncates: `3 / 8 == 0`. Convert before dividing:
      `float64(3) / float64(8)` gives `0.375`. Go never converts implicitly.
  - topic: Exported Names
    q: How does Go determine whether a name is exported (public)?
    a: >-
      Names starting with an uppercase letter are exported: `Pod` is public,
      `pod` is package-private. This applies to functions, types, variables, struct fields,
      and methods. No `public`/`private` keywords.
  - topic: Blank Identifier
    q: What is `_` in Go and when do you use it?
    a: >-
      The blank identifier `_` discards a value. Common uses: ignore the index in
      `for _, v := range items`, or ignore an unwanted return value. Go requires all
      variables to be used — `_` is the escape hatch.
  - topic: Strings Package
    q: Name three `strings` functions you use when parsing config files.
    a: >-
      `strings.SplitN(s, "=", 2)` — split on first delimiter.
      `strings.TrimSpace(s)` — strip whitespace.
      `strings.HasPrefix(s, "#")` — detect comments.
      Also useful: `Fields`, `Contains`, `Join`.
  - topic: Strconv
    q: How do you convert a string to an int in Go?
    a: >-
      `n, err := strconv.Atoi("42")`. Always check the error — invalid input returns
      `0, error`. The reverse is `strconv.Itoa(42)` which returns `"42"`.

"1":
  - topic: Slice Basics
    q: What three things does a Go slice header contain?
    a: >-
      A pointer to the backing array, a length (number of elements), and a capacity (total slots before
      reallocation). Use `len(s)` and `cap(s)` to inspect them.
  - topic: Append Gotcha
    q: What is the most common slice bug with `append`?
    a: >-
      Forgetting to reassign: `append(s, x)` returns a new slice — it does not modify `s`.
      You must write `s = append(s, x)`. The compiler won't warn you.
  - topic: Range Copy
    q: Why does `for _, v := range nums { v = v * 10 }` leave `nums` unchanged?
    a: >-
      `v` is a copy of the element, not a reference. Modifying it does nothing to the slice.
      To mutate in place, use the index form: `for i := range nums { nums[i] *= 10 }`.
  - topic: Range Length Lock
    q: What happens if you `append` to a slice during a `range` loop?
    a: >-
      The new elements won't be visited. `range` locks the iteration count at loop start.
      The append succeeds (the slice grows), but the loop won't iterate over the new elements.
  - topic: Map Zero Value
    q: What happens when you read a missing key from a Go map?
    a: >-
      You get the zero value for the value type — `0` for int, `""` for string.
      Use the comma-ok pattern to distinguish missing from zero: `val, ok := m["key"]`.
  - topic: Map Counting
    q: Why does `counts[key]++` work even for new keys?
    a: >-
      The zero value of `int` is `0`. Reading a missing key returns `0`,
      then `++` increments to `1`. No initialization or existence check needed.
  - topic: Map Iteration
    q: Is map iteration order guaranteed in Go?
    a: >-
      No. Go randomizes map iteration order intentionally. If you need deterministic output, collect keys
      into a slice, `sort.Strings(keys)`, then iterate the sorted slice.
  - topic: Write-Index Filter
    q: How do you filter a slice in place without allocating a new one?
    a: >-
      Use a write-index: `n := 0; for _, v := range items { if keep(v) { items[n] = v; n++ } };
      items = items[:n]`. Read position advances every iteration, write position only on keepers.
  - topic: sort.Slice Comparator
    q: How does `sort.Slice`'s comparator function work?
    a: >-
      `sort.Slice(s, func(i, j int) bool { return s[i] < s[j] })`. Return `true`
      if element `i` should come before `j`. Use `<` for ascending,
      `>` for descending.
  - topic: Sorted Keys Pattern
    q: How do you print map entries in sorted order?
    a: >-
      Collect keys into a slice, sort, iterate: `keys := ...; sort.Strings(keys); for _, k :=
      range keys { fmt.Println(k, m[k]) }`. This is the Go equivalent of Python's
      `for k in sorted(d)`.
  - topic: SplitN
    q: When should you use `strings.SplitN` instead of `strings.Split`?
    a: >-
      When the value might contain the delimiter. `SplitN("key=a=b", "=", 2)` gives
      `["key", "a=b"]`. Without the limit, `Split` would give three pieces.
      Always use `SplitN(s, sep, 2)` for key=value parsing.
  - topic: Pre-allocation
    q: What is the difference between `make([]string, 0, n)` and `make([]string, n)`?
    a: >-
      `make([]string, 0, n)` creates length 0, capacity n — use with `append`.
      `make([]string, n)` creates length AND capacity n — assign by index. Both avoid
      repeated array growth.
