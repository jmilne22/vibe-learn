# Syntax Quick-Reference — keyed by exercise concept name
# Auto-matched to exercises via the concept field

Variable Declaration:
  - label: "Short declaration"
    code: "x := 42"
  - label: "Var with type"
    code: "var x int = 42"
  - label: "Var (zero value)"
    code: "var x int    // 0"
  - label: "Constants & iota"
    code: |
      const Pi = 3.14
      const (
          A = iota  // 0
          B         // 1
          C         // 2
      )

Type Conversion:
  - label: "Int ↔ Float"
    code: |
      f := float64(42)
      n := int(3.14)    // truncates to 3
  - label: "Int → String"
    code: 's := strconv.Itoa(42)   // "42"'
  - label: "String → Int"
    code: |
      n, err := strconv.Atoi("42")
      if err != nil { /* handle */ }
  - label: "Sprintf"
    code: 's := fmt.Sprintf("%d items", n)'

Function Basics:
  - label: "Basic function"
    code: |
      func add(a, b int) int {
          return a + b
      }
  - label: "Multiple params same type"
    code: "func greet(first, last string) string { ... }"
  - label: "No return value"
    code: |
      func log(msg string) {
          fmt.Println(msg)
      }

Multiple Returns:
  - label: "(value, error) pattern"
    code: |
      func divide(a, b float64) (float64, error) {
          if b == 0 {
              return 0, fmt.Errorf("division by zero")
          }
          return a / b, nil
      }
  - label: "Calling with error check"
    code: |
      result, err := divide(10, 3)
      if err != nil {
          log.Fatal(err)
      }
  - label: "Comma-ok idiom"
    code: |
      val, ok := m["key"]
      if !ok { /* key not found */ }

For Loops:
  - label: "Classic for"
    code: |
      for i := 0; i < 10; i++ {
          fmt.Println(i)
      }
  - label: "While-style"
    code: |
      for n > 0 {
          n--
      }
  - label: "Range over slice"
    code: |
      for i, v := range items {
          fmt.Println(i, v)
      }
  - label: "Range (value only)"
    code: |
      for _, v := range items {
          fmt.Println(v)
      }

If/Else:
  - label: "Basic if/else"
    code: |
      if x > 0 {
          fmt.Println("positive")
      } else {
          fmt.Println("non-positive")
      }
  - label: "If with init statement"
    code: |
      if err := doThing(); err != nil {
          log.Fatal(err)
      }
  - label: "Switch (value)"
    code: |
      switch day {
      case "Mon", "Tue":
          fmt.Println("early week")
      default:
          fmt.Println("other")
      }
  - label: "Switch (expressionless)"
    code: |
      switch {
      case score >= 90:
          grade = "A"
      case score >= 80:
          grade = "B"
      }

Slice Operations:
  - label: "Indexing"
    code: |
      first := nums[0]
      third := nums[2]
      last  := nums[len(nums)-1]
  - label: "Slicing ranges"
    code: |
      first3  := nums[:3]           // index 0, 1, 2
      middle  := nums[1:4]          // index 1, 2, 3
      last2   := nums[len(nums)-2:] // last two
      allButFirst := nums[1:]
      allButLast  := nums[:len(nums)-1]
  - label: "Mutating"
    code: |
      s[i] = 99                          // overwrite
      s[i], s[j] = s[j], s[i]           // swap
      s = append(s[:i], s[i+1:]...)      // remove at i
      s = append(s, elem)                // push back
      s = append([]T{elem}, s...)        // push front
  - label: "make + append"
    code: |
      s := make([]int, 0, 10)
      s = append(s, 42)
      all := append(a, b...)  // spread
  - label: "Length"
    code: "fmt.Println(len(nums))"

Building Slices:
  - label: "Literal"
    code: 'nums := []int{1, 2, 3}'
  - label: "Indexing"
    code: |
      first := nums[0]
      last  := nums[len(nums)-1]
  - label: "Slicing ranges"
    code: |
      first3  := nums[:3]           // index 0, 1, 2
      middle  := nums[1:4]          // index 1, 2, 3
      last2   := nums[len(nums)-2:] // last two
  - label: "make + append"
    code: |
      s := make([]int, 0, 10)
      s = append(s, 42)
      all := append(a, b...)  // spread

Map Basics:
  - label: "Make a map"
    code: "m := make(map[string]int)"
  - label: "Map literal"
    code: |
      m := map[string]int{
          "a": 1,
          "b": 2,
      }
  - label: "Set / increment"
    code: |
      m["key"] = 42
      m["count"]++
  - label: "Comma-ok lookup"
    code: |
      val, ok := m["key"]
      if !ok { /* missing */ }
  - label: "Delete & range"
    code: |
      delete(m, "key")
      for k, v := range m {
          fmt.Println(k, v)
      }

Strings & Runes:
  - label: "len vs rune count"
    code: |
      len(s)            // byte length (not chars!)
      len([]rune(s))    // character count
  - label: "Indexing runes"
    code: |
      runes := []rune(s)
      first := runes[0]
      third := runes[2]
      last  := runes[len(runes)-1]
      // s[2] gives a BYTE, not a character!
  - label: "Substring by rune position"
    code: |
      runes := []rune(s)
      first3 := string(runes[:3])
      middle := string(runes[1:4])
      lastN  := string(runes[len(runes)-2:])
  - label: "Range over runes"
    code: |
      for i, r := range s {
          fmt.Printf("%d: %c\n", i, r)
      }
  - label: "strings package"
    code: |
      strings.Fields("a b c")      // ["a","b","c"]
      strings.Contains(s, "sub")   // bool
      strings.ToLower(s)
      strings.Join(parts, ", ")

Go Fundamentals Combined:
  - label: "fmt.Sprintf"
    code: |
      msg := fmt.Sprintf("Hello, %s! You are %d.", name, age)
  - label: "strings.Join"
    code: |
      result := strings.Join(words, " ")
  - label: "sort.Strings"
    code: |
      sort.Strings(names)  // sorts in-place
  - label: "Putting it together"
    code: |
      words := strings.Fields(input)
      sort.Strings(words)
      result := strings.Join(words, " ")
