conceptLinks:
  Custom Errors: "#lesson-custom-errors"
  errors.As: "#lesson-errors-as"
  errors.Is: "#lesson-errors-is"
  Error Interface: "#lesson-error-interface"
  fmt.Errorf: "#lesson-errorf"
  Error Wrapping: "#lesson-error-wrapping"
  Sentinel Errors: "#lesson-sentinel-errors"
sharedContent: {}
variants:
  warmups:
    - id: warmup_1
      concept: Custom Errors
      variants:
        - id: v1
          title: Validation Error
          description: >-
            Create a <code>ValidationError</code> struct with <code>Field</code> and <code>Message</code> string fields.
            Implement the <code>error</code> interface. Write a <code>validateAge</code> function that returns a
            <code>*ValidationError</code> if age is negative. Use <code>errors.As</code> to extract the error.
          hints:
            - >-
              Implement <code>Error() string</code> on a pointer receiver: <code>func (e *ValidationError) Error()
              string</code>.
            - "Return <code>&amp;ValidationError{Field: \"age\", Message: \"must be non-negative\"}</code> for invalid input."
            - Use <code>var ve *ValidationError; errors.As(err, &amp;ve)</code> to extract the typed error.
          solution: |-
            type ValidationError struct {
                Field   string
                Message string
            }

            func (e *ValidationError) Error() string {
                return fmt.Sprintf("%s: %s", e.Field, e.Message)
            }

            func validateAge(age int) error {
                if age < 0 {
                    return &ValidationError{Field: "age", Message: "must be non-negative"}
                }
                return nil
            }

            // Usage:
            err := validateAge(-1)
            var ve *ValidationError
            if errors.As(err, &ve) {
                fmt.Println("Field:", ve.Field)
            }
          annotations:
            - type: idiom
              label: Error Interface
              text: >-
                Any type with an <code>Error() string</code> method satisfies the <code>error</code> interface. Use
                pointer receivers so the struct can be extracted with <code>errors.As</code>.
            - type: gotcha
              label: Pointer Receiver
              text: >-
                If <code>Error()</code> is defined on <code>*ValidationError</code>, you must return
                <code>&ValidationError{}</code> (a pointer), not <code>ValidationError{}</code> (a value).
        - id: v2
          title: Not Found Error
          description: >-
            Create a <code>NotFoundError</code> struct with <code>Resource</code> and <code>ID</code> string fields.
            Implement the <code>error</code> interface. Write a <code>findUser</code> function that returns this error
            when the user is not found.
          hints:
            - "Format the error message as <code>\"resource not found: users/123\"</code>."
            - "Return <code>&amp;NotFoundError{Resource: \"users\", ID: id}</code>."
            - Test with <code>errors.As</code> to verify you can extract the Resource and ID fields.
          solution: |-
            type NotFoundError struct {
                Resource string
                ID       string
            }

            func (e *NotFoundError) Error() string {
                return fmt.Sprintf("not found: %s/%s", e.Resource, e.ID)
            }

            func findUser(id string) (string, error) {
                users := map[string]string{"1": "Alice", "2": "Bob"}
                if name, ok := users[id]; ok {
                    return name, nil
                }
                return "", &NotFoundError{Resource: "users", ID: id}
            }

            // Usage:
            _, err := findUser("99")
            var nfe *NotFoundError
            if errors.As(err, &nfe) {
                fmt.Println(nfe.Resource, nfe.ID)
            }
          annotations:
            - type: idiom
              label: Typed Error Fields
              text: >-
                Custom error types carry structured data (Resource, ID) that callers can inspect programmatically,
                unlike plain error strings.
            - type: pattern
              label: Lookup with Error
              text: >-
                Returning (value, error) is the standard Go pattern. When the lookup fails, return the zero value and a
                descriptive error.
        - id: v3
          title: Rate Limit Error
          description: >-
            Create a <code>RateLimitError</code> struct with <code>RetryAfter time.Duration</code>. Implement the
            <code>error</code> interface. Write a function that returns this error, and use <code>errors.As</code> to
            read the retry duration.
          hints:
            - Import <code>time</code> for <code>time.Duration</code>.
            - "Format: <code>\"rate limited: retry after 5s\"</code> using <code>e.RetryAfter</code>."
            - After extraction with <code>errors.As</code>, use <code>rle.RetryAfter</code> to access the duration.
          solution: |-
            type RateLimitError struct {
                RetryAfter time.Duration
            }

            func (e *RateLimitError) Error() string {
                return fmt.Sprintf("rate limited: retry after %s", e.RetryAfter)
            }

            func callAPI() error {
                return &RateLimitError{RetryAfter: 5 * time.Second}
            }

            // Usage:
            err := callAPI()
            var rle *RateLimitError
            if errors.As(err, &rle) {
                fmt.Println("Wait:", rle.RetryAfter)
            }
          annotations:
            - type: idiom
              label: Actionable Errors
              text: >-
                Custom errors should carry information the caller can act on. <code>RetryAfter</code> tells the caller
                exactly how long to wait.
            - type: stdlib
              label: time.Duration
              text: >-
                <code>time.Duration</code> is an <code>int64</code> nanosecond count. Constants like <code>5 *
                time.Second</code> make durations readable.
        - id: v4
          title: Multi-Field Validation Error
          description: >-
            Create a <code>ValidationErrors</code> type (a slice of <code>ValidationError</code>) that implements the
            <code>error</code> interface. Write a <code>validateUser</code> function that collects multiple validation
            errors and returns them all at once.
          hints:
            - Define <code>type ValidationErrors []ValidationError</code> as a named slice type.
            - Implement <code>Error()</code> to join all error messages with <code>"; "</code>.
            - Collect errors into the slice, then return nil if empty or the slice if not.
          solution: |-
            type ValidationError struct {
                Field   string
                Message string
            }

            type ValidationErrors []ValidationError

            func (ve ValidationErrors) Error() string {
                msgs := make([]string, len(ve))
                for i, e := range ve {
                    msgs[i] = fmt.Sprintf("%s: %s", e.Field, e.Message)
                }
                return strings.Join(msgs, "; ")
            }

            func validateUser(name string, age int) error {
                var errs ValidationErrors
                if name == "" {
                    errs = append(errs, ValidationError{Field: "name", Message: "required"})
                }
                if age < 0 {
                    errs = append(errs, ValidationError{Field: "age", Message: "must be non-negative"})
                }
                if len(errs) > 0 {
                    return errs
                }
                return nil
            }
          annotations:
            - type: idiom
              label: Named Slice Type
              text: >-
                Defining <code>type ValidationErrors []ValidationError</code> lets you attach methods to a slice,
                including satisfying the <code>error</code> interface.
            - type: gotcha
              label: Return nil, Not Empty Slice
              text: >-
                Return <code>nil</code> (not an empty slice) for no errors. An empty non-nil slice assigned to an
                <code>error</code> interface is non-nil, which would incorrectly indicate an error.
  challenges:
    - id: challenge_1
      concept: Error Wrapping
      difficulty: 2
      block: 1
      docLinks:
        - label: fmt.Errorf
          url: https://pkg.go.dev/fmt#Errorf
        - label: errors package
          url: https://pkg.go.dev/errors
      variants:
        - id: v1
          title: Wrap a Database Error
          description: >-
            Write a <code>queryUser</code> function that simulates a database lookup. Define a sentinel
            <code>ErrConnRefused</code> using <code>errors.New</code>. When the lookup fails, wrap the sentinel with
            context using <code>fmt.Errorf("queryUser %s: %w", id, ErrConnRefused)</code>. Then demonstrate that
            <code>errors.Is</code> can detect the original sentinel through the wrapping.
          functionSignature: "func queryUser(id string) (string, error)"
          testCases:
            - input: "\"42\""
              expected: "errors.Is(err, ErrConnRefused) == true"
            - input: "\"1\""
              expected: "\"Alice\", nil"
          hints:
            - Define <code>var ErrConnRefused = errors.New("connection refused")</code> at package level.
            - >-
              Use <code>fmt.Errorf("queryUser %s: %w", id, ErrConnRefused)</code> to wrap the sentinel with context.
              The <code>%w</code> verb is what creates the wrapping chain.
            - >-
              Use <code>errors.Is(err, ErrConnRefused)</code> to check if the wrapped error contains the sentinel
              anywhere in its chain. This works regardless of how many layers of wrapping exist.
          solution: |-
            var ErrConnRefused = errors.New("connection refused")

            func queryUser(id string) (string, error) {
                users := map[string]string{"1": "Alice", "2": "Bob"}
                if name, ok := users[id]; ok {
                    return name, nil
                }
                return "", fmt.Errorf("queryUser %s: %w", id, ErrConnRefused)
            }

            // Usage:
            _, err := queryUser("42")
            if errors.Is(err, ErrConnRefused) {
                fmt.Println("database is down")
            }
          difficulty: 2
          annotations:
            - type: idiom
              label: Error Wrapping
              text: >-
                The <code>%w</code> verb in <code>fmt.Errorf</code> wraps an error, preserving the chain so
                <code>errors.Is</code> and <code>errors.As</code> can still find the original cause.
            - type: pattern
              label: Context Wrapping
              text: >-
                Always add context when wrapping: <code>fmt.Errorf("queryUser %s: %w", id, err)</code>. This
                produces messages like <code>"queryUser 42: connection refused"</code> which are easy to trace.
        - id: v2
          title: Wrap a File Error
          description: >-
            Write a <code>readConfig</code> function that attempts to open a file. If the file does not exist, wrap
            the error with context using <code>fmt.Errorf</code> and the <code>%w</code> verb. Then use
            <code>errors.Is(err, os.ErrNotExist)</code> to check whether the underlying cause is a missing file.
          functionSignature: "func readConfig(path string) ([]byte, error)"
          testCases:
            - input: "\"/no/such/file.yaml\""
              expected: "errors.Is(err, os.ErrNotExist) == true"
            - input: "valid path"
              expected: "file contents, nil"
          hints:
            - >-
              Use <code>os.ReadFile(path)</code> to attempt reading. It returns <code>*os.PathError</code> which
              wraps <code>os.ErrNotExist</code> when the file is missing.
            - >-
              Wrap the returned error: <code>fmt.Errorf("readConfig %s: %w", path, err)</code>. This adds your
              context while preserving the original error chain.
            - >-
              <code>errors.Is(err, os.ErrNotExist)</code> traverses the full chain&mdash;your wrapper, then
              <code>*os.PathError</code>, then the sentinel&mdash;and finds the match.
          solution: |-
            func readConfig(path string) ([]byte, error) {
                data, err := os.ReadFile(path)
                if err != nil {
                    return nil, fmt.Errorf("readConfig %s: %w", path, err)
                }
                return data, nil
            }

            // Usage:
            _, err := readConfig("/no/such/file.yaml")
            if errors.Is(err, os.ErrNotExist) {
                fmt.Println("config file missing, using defaults")
            }
          difficulty: 2
          annotations:
            - type: stdlib
              label: os.ErrNotExist
              text: >-
                <code>os.ErrNotExist</code> is the standard sentinel for missing files. The <code>os</code> package
                wraps it inside <code>*os.PathError</code>, so <code>errors.Is</code> is the correct way to check.
            - type: idiom
              label: Wrap Then Check
              text: >-
                Even after wrapping with <code>fmt.Errorf("...: %w", err)</code>, callers can still use
                <code>errors.Is</code> to match sentinels deep in the chain. This is the key benefit of <code>%w</code>.
        - id: v3
          title: Unwrap a Custom Typed Error
          description: >-
            Define a <code>DBError</code> struct with <code>Code int</code> and <code>Message string</code> fields.
            Write a <code>runQuery</code> function that returns a <code>*DBError</code> wrapped with context via
            <code>fmt.Errorf</code>. Then use <code>errors.As</code> to extract the <code>*DBError</code> from the
            wrapped chain and inspect its <code>Code</code> field.
          functionSignature: "func runQuery(sql string) error"
          testCases:
            - input: "\"DROP TABLE\""
              expected: "errors.As(err, &dbe) == true && dbe.Code == 1045"
            - input: "\"SELECT 1\""
              expected: "nil"
          hints:
            - >-
              Define <code>DBError</code> with an <code>Error() string</code> method on the pointer receiver.
              Return <code>&amp;DBError{Code: 1045, Message: "access denied"}</code>.
            - >-
              Wrap it: <code>fmt.Errorf("runQuery: %w", &amp;DBError{Code: 1045, Message: "access denied"})</code>.
            - >-
              Extract with <code>var dbe *DBError; errors.As(err, &amp;dbe)</code>. This searches the chain for
              any error matching <code>*DBError</code> and populates <code>dbe</code> with it.
          solution: |-
            type DBError struct {
                Code    int
                Message string
            }

            func (e *DBError) Error() string {
                return fmt.Sprintf("db error %d: %s", e.Code, e.Message)
            }

            func runQuery(sql string) error {
                if sql == "SELECT 1" {
                    return nil
                }
                return fmt.Errorf("runQuery: %w", &DBError{Code: 1045, Message: "access denied"})
            }

            // Usage:
            err := runQuery("DROP TABLE")
            var dbe *DBError
            if errors.As(err, &dbe) {
                fmt.Println("DB error code:", dbe.Code)
            }
          difficulty: 2
          annotations:
            - type: pattern
              label: errors.As Extraction
              text: >-
                <code>errors.As</code> searches the error chain for a matching type and populates the target.
                Use it when you need to inspect fields of a custom error type, not just check identity.
            - type: gotcha
              label: Pointer to Pointer
              text: >-
                <code>errors.As</code> requires a <code>**DBError</code> (pointer to the pointer target):
                <code>var dbe *DBError; errors.As(err, &amp;dbe)</code>. Passing <code>&amp;DBError{}</code>
                directly will not compile.
        - id: v4
          title: Multi-Layer Wrapping
          description: >-
            Define a sentinel <code>ErrTimeout</code>. Write three functions that form a call chain:
            <code>handler</code> calls <code>service</code> calls <code>repository</code>. Each wraps the error
            from the layer below with its own context using <code>fmt.Errorf("...: %w", err)</code>. Verify that
            <code>errors.Is(err, ErrTimeout)</code> still finds the root sentinel through three layers of wrapping.
          functionSignature: "func handler() error"
          testCases:
            - input: "(call handler)"
              expected: "errors.Is(err, ErrTimeout) == true"
            - input: "(call handler)"
              expected: "err.Error() contains all three layers of context"
          hints:
            - Define <code>var ErrTimeout = errors.New("operation timed out")</code> at package level.
            - >-
              <code>repository</code> returns <code>ErrTimeout</code>. <code>service</code> wraps it:
              <code>fmt.Errorf("service: %w", err)</code>. <code>handler</code> wraps again:
              <code>fmt.Errorf("handler: %w", err)</code>.
            - >-
              <code>errors.Is</code> walks the entire chain via successive <code>Unwrap()</code> calls. Three layers
              deep is no problem&mdash;it will find <code>ErrTimeout</code> at the root.
          solution: |-
            var ErrTimeout = errors.New("operation timed out")

            func repository() error {
                return ErrTimeout
            }

            func service() error {
                err := repository()
                if err != nil {
                    return fmt.Errorf("service: %w", err)
                }
                return nil
            }

            func handler() error {
                err := service()
                if err != nil {
                    return fmt.Errorf("handler: %w", err)
                }
                return nil
            }

            // Usage:
            err := handler()
            fmt.Println(err)
            // Output: handler: service: operation timed out
            fmt.Println(errors.Is(err, ErrTimeout))
            // Output: true
          difficulty: 2
          annotations:
            - type: idiom
              label: Layered Wrapping
              text: >-
                Each layer adds context: <code>"handler: service: operation timed out"</code>. This produces a
                readable breadcrumb trail without losing the ability to match the root cause.
            - type: pattern
              label: errors.Is Chain Walk
              text: >-
                <code>errors.Is</code> calls <code>Unwrap()</code> repeatedly until it finds a match or reaches
                the end. This works through any number of <code>fmt.Errorf("...: %w")</code> layers.
    - id: challenge_2
      concept: Sentinel Errors
      difficulty: 2
      block: 1
      docLinks:
        - label: errors.New
          url: https://pkg.go.dev/errors#New
        - label: errors.Is
          url: https://pkg.go.dev/errors#Is
      variants:
        - id: v1
          title: HTTP Sentinel Errors
          description: >-
            Define two sentinel errors: <code>ErrNotFound</code> and <code>ErrUnauthorized</code> using
            <code>errors.New</code>. Write a <code>getResource</code> function that returns
            <code>ErrNotFound</code> for unknown IDs and <code>ErrUnauthorized</code> for ID <code>"secret"</code>.
            Use <code>errors.Is</code> to distinguish between them.
          functionSignature: "func getResource(id string) (string, error)"
          testCases:
            - input: "\"secret\""
              expected: "errors.Is(err, ErrUnauthorized) == true"
            - input: "\"unknown\""
              expected: "errors.Is(err, ErrNotFound) == true"
            - input: "\"1\""
              expected: "\"resource-1\", nil"
          hints:
            - >-
              Define sentinels at package level: <code>var ErrNotFound = errors.New("not found")</code> and
              <code>var ErrUnauthorized = errors.New("unauthorized")</code>.
            - >-
              Use a switch or if-else chain on <code>id</code>. Return the appropriate sentinel for each case.
            - >-
              Callers use <code>errors.Is(err, ErrNotFound)</code> to check which sentinel was returned. Never
              compare error strings&mdash;always use <code>errors.Is</code>.
          solution: |-
            var (
                ErrNotFound     = errors.New("not found")
                ErrUnauthorized = errors.New("unauthorized")
            )

            func getResource(id string) (string, error) {
                if id == "secret" {
                    return "", ErrUnauthorized
                }
                resources := map[string]string{"1": "resource-1", "2": "resource-2"}
                if res, ok := resources[id]; ok {
                    return res, nil
                }
                return "", ErrNotFound
            }

            // Usage:
            _, err := getResource("unknown")
            if errors.Is(err, ErrNotFound) {
                fmt.Println("resource does not exist")
            }
          difficulty: 2
          annotations:
            - type: idiom
              label: Sentinel Declaration
              text: >-
                Sentinels are package-level <code>var</code> values created with <code>errors.New</code>. By convention
                they start with <code>Err</code>: <code>ErrNotFound</code>, <code>ErrUnauthorized</code>.
            - type: gotcha
              label: Never Compare Strings
              text: >-
                Never check <code>err.Error() == "not found"</code>. Error messages can change. Always use
                <code>errors.Is(err, ErrNotFound)</code> for reliable sentinel comparison.
        - id: v2
          title: Stack with Sentinel
          description: >-
            Define a sentinel <code>ErrEmpty</code> using <code>errors.New</code>. Implement a simple integer
            stack with a <code>Pop</code> method that returns <code>ErrEmpty</code> when the stack has no elements.
            Use <code>errors.Is</code> to check for the empty condition.
          functionSignature: "func (s *Stack) Pop() (int, error)"
          testCases:
            - input: "(pop from empty stack)"
              expected: "errors.Is(err, ErrEmpty) == true"
            - input: "(push 42 then pop)"
              expected: "42, nil"
          hints:
            - Define <code>var ErrEmpty = errors.New("stack is empty")</code> at package level.
            - >-
              Define <code>type Stack struct { items []int }</code> with <code>Push(v int)</code> and
              <code>Pop() (int, error)</code> methods.
            - >-
              In <code>Pop</code>, check <code>len(s.items) == 0</code> and return <code>0, ErrEmpty</code>.
              Otherwise pop from the end of the slice.
          solution: |-
            var ErrEmpty = errors.New("stack is empty")

            type Stack struct {
                items []int
            }

            func (s *Stack) Push(v int) {
                s.items = append(s.items, v)
            }

            func (s *Stack) Pop() (int, error) {
                if len(s.items) == 0 {
                    return 0, ErrEmpty
                }
                v := s.items[len(s.items)-1]
                s.items = s.items[:len(s.items)-1]
                return v, nil
            }

            // Usage:
            var st Stack
            _, err := st.Pop()
            if errors.Is(err, ErrEmpty) {
                fmt.Println("nothing to pop")
            }
          difficulty: 2
          annotations:
            - type: pattern
              label: Data Structure Sentinels
              text: >-
                Sentinels signal expected boundary conditions. <code>ErrEmpty</code> tells the caller the operation
                could not proceed because of state, not because of a bug.
            - type: idiom
              label: Slice as Stack
              text: >-
                Use <code>append</code> to push and slice the last element to pop. This is the standard Go
                pattern for a stack backed by a slice.
        - id: v3
          title: Sentinel With Wrapping
          description: >-
            Define a sentinel <code>ErrInvalidInput</code>. Write a <code>validateEmail</code> function that wraps
            the sentinel with specific context using <code>fmt.Errorf("email %q: %w", email, ErrInvalidInput)</code>.
            Verify that <code>errors.Is</code> still matches the sentinel even after wrapping.
          functionSignature: "func validateEmail(email string) error"
          testCases:
            - input: "\"not-an-email\""
              expected: "errors.Is(err, ErrInvalidInput) == true"
            - input: "\"user@example.com\""
              expected: "nil"
            - input: "\"\""
              expected: "errors.Is(err, ErrInvalidInput) == true"
          hints:
            - Define <code>var ErrInvalidInput = errors.New("invalid input")</code> at package level.
            - >-
              Check for a basic validity rule, such as whether the email contains <code>"@"</code>. If invalid,
              return <code>fmt.Errorf("email %q: %w", email, ErrInvalidInput)</code>.
            - >-
              The wrapped error message will be <code>"email \"not-an-email\": invalid input"</code>, but
              <code>errors.Is(err, ErrInvalidInput)</code> still returns true because <code>%w</code> preserves the chain.
          solution: |-
            var ErrInvalidInput = errors.New("invalid input")

            func validateEmail(email string) error {
                if email == "" || !strings.Contains(email, "@") {
                    return fmt.Errorf("email %q: %w", email, ErrInvalidInput)
                }
                return nil
            }

            // Usage:
            err := validateEmail("not-an-email")
            if errors.Is(err, ErrInvalidInput) {
                fmt.Println("bad input:", err)
            }
            // Output: bad input: email "not-an-email": invalid input
          difficulty: 2
          annotations:
            - type: pattern
              label: Sentinel + Context
              text: >-
                Wrapping a sentinel with <code>%w</code> gives callers the best of both worlds: they can match the
                sentinel with <code>errors.Is</code> and read the full context from <code>err.Error()</code>.
            - type: idiom
              label: Quoting with %q
              text: >-
                Use <code>%q</code> in error messages to quote user input. This makes values like empty strings
                visible: <code>email "": invalid input</code> is clearer than <code>email : invalid input</code>.
        - id: v4
          title: File Processor Sentinels
          description: >-
            Define two sentinels for a file processor: <code>ErrTooLarge</code> and <code>ErrUnsupportedFormat</code>.
            Write a <code>processFile</code> function that checks file size and extension, returning the appropriate
            sentinel. Use <code>errors.Is</code> to handle each case differently.
          functionSignature: "func processFile(name string, sizeBytes int) error"
          testCases:
            - input: "\"photo.bmp\", 100"
              expected: "errors.Is(err, ErrUnsupportedFormat) == true"
            - input: "\"photo.png\", 20_000_000"
              expected: "errors.Is(err, ErrTooLarge) == true"
            - input: "\"photo.png\", 100"
              expected: "nil"
          hints:
            - >-
              Define both sentinels in a <code>var ( ... )</code> block:
              <code>ErrTooLarge = errors.New("file too large")</code> and
              <code>ErrUnsupportedFormat = errors.New("unsupported format")</code>.
            - >-
              Check the extension with <code>filepath.Ext(name)</code> or a simple suffix check. Allow
              <code>.png</code>, <code>.jpg</code>, and <code>.jpeg</code>. Reject everything else.
            - >-
              Check size first (e.g., over 10 MB), then format. Return the matching sentinel. Callers use
              <code>errors.Is</code> to decide whether to show "file too big" or "wrong format" messages.
          solution: |-
            var (
                ErrTooLarge          = errors.New("file too large")
                ErrUnsupportedFormat = errors.New("unsupported format")
            )

            func processFile(name string, sizeBytes int) error {
                const maxSize = 10_000_000 // 10 MB
                if sizeBytes > maxSize {
                    return ErrTooLarge
                }
                ext := filepath.Ext(name)
                switch ext {
                case ".png", ".jpg", ".jpeg":
                    // supported
                default:
                    return ErrUnsupportedFormat
                }
                return nil
            }

            // Usage:
            err := processFile("photo.bmp", 100)
            switch {
            case errors.Is(err, ErrUnsupportedFormat):
                fmt.Println("try png or jpg")
            case errors.Is(err, ErrTooLarge):
                fmt.Println("file must be under 10 MB")
            }
          difficulty: 2
          annotations:
            - type: pattern
              label: Multiple Sentinels
              text: >-
                Group related sentinels in a <code>var ( ... )</code> block. This signals to callers exactly which
                error conditions the function can produce, like a mini error contract.
            - type: idiom
              label: Switch on Sentinels
              text: >-
                Use <code>switch</code> with <code>errors.Is</code> cases to handle each sentinel differently. This
                is cleaner than nested if-else chains and makes the error handling exhaustive.
