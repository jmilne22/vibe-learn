conceptLinks:
  Stacks: "#lesson-stacks"
  Binary Search: "#lesson-binary-search"
  Hash Maps: "#lesson-hash-maps"
  Linked Lists: "#lesson-linked-lists"
  Big O Notation: "#lesson-big-o"
  Two Pointers: "#lesson-two-pointers"
  Sliding Window: "#lesson-sliding-window"
sharedContent: {}
variants:
  warmups:
    - id: warmup_1
      concept: Stacks
      variants:
        - id: v1
          title: Stack with a Slice
          description: >-
            Implement a stack of integers using a Go slice. Write functions <code>push</code>,
            <code>pop</code>, <code>peek</code>, and <code>isEmpty</code> that operate on
            a <code>*[]int</code>. Pop and peek should return <code>(int, bool)</code> to handle
            the empty case.
          hints:
            - "Push appends to the slice: <code>*s = append(*s, val)</code>"
            - "Pop reads the last element, then reslices: <code>*s = (*s)[:len(*s)-1]</code>"
            - Check <code>len(*s) == 0</code> before pop or peek to avoid panics.
          solution: |-
            func push(s *[]int, val int) {
                *s = append(*s, val)
            }

            func pop(s *[]int) (int, bool) {
                if len(*s) == 0 {
                    return 0, false
                }
                val := (*s)[len(*s)-1]
                *s = (*s)[:len(*s)-1]
                return val, true
            }

            func peek(s *[]int) (int, bool) {
                if len(*s) == 0 {
                    return 0, false
                }
                return (*s)[len(*s)-1], true
            }

            func isEmpty(s *[]int) bool {
                return len(*s) == 0
            }
          annotations:
            - type: idiom
              label: Slice as Stack
              text: "Go slices are natural stacks: append to push, reslice to pop. No extra library needed."
            - type: gotcha
              label: Bounds Check
              text: Always check length before indexing the last element. An empty pop without a guard causes a panic.
        - id: v2
          title: Generic Stack Struct
          description: >-
            Build a <code>Stack[T any]</code> generic struct with methods <code>Push(val T)</code>,
            <code>Pop() (T, bool)</code>, <code>Peek() (T, bool)</code>, and <code>Len() int</code>.
            Use a slice internally.
          hints:
            - "Declare with <code>type Stack[T any] struct { items []T }</code>"
            - Methods use the pointer receiver <code>(s *Stack[T])</code>.
            - "For the zero value on empty pop: <code>var zero T; return zero, false</code>"
          solution: |-
            type Stack[T any] struct {
                items []T
            }

            func (s *Stack[T]) Push(val T) {
                s.items = append(s.items, val)
            }

            func (s *Stack[T]) Pop() (T, bool) {
                if len(s.items) == 0 {
                    var zero T
                    return zero, false
                }
                val := s.items[len(s.items)-1]
                s.items = s.items[:len(s.items)-1]
                return val, true
            }

            func (s *Stack[T]) Peek() (T, bool) {
                if len(s.items) == 0 {
                    var zero T
                    return zero, false
                }
                return s.items[len(s.items)-1], true
            }

            func (s *Stack[T]) Len() int {
                return len(s.items)
            }
          annotations:
            - type: idiom
              label: Generic Zero Value
              text: "Use <code>var zero T</code> to get the zero value of any generic type parameter."
            - type: pattern
              label: Generics for Data Structures
              text: Go generics make type-safe reusable data structures possible without interface{} casts.
        - id: v3
          title: Min Stack
          description: >-
            Implement a <code>MinStack</code> that supports <code>Push(val int)</code>,
            <code>Pop() int</code>, <code>Top() int</code>, and <code>GetMin() int</code>,
            all in O(1) time. Use two internal slices — one for values, one to track the current minimum.
          hints:
            - Keep a parallel <code>mins</code> slice. On push, append the min of the new value and the current min.
            - "On pop, pop from both slices."
            - "GetMin returns the top of the mins slice."
          solution: |-
            type MinStack struct {
                vals []int
                mins []int
            }

            func (s *MinStack) Push(val int) {
                s.vals = append(s.vals, val)
                if len(s.mins) == 0 || val <= s.mins[len(s.mins)-1] {
                    s.mins = append(s.mins, val)
                } else {
                    s.mins = append(s.mins, s.mins[len(s.mins)-1])
                }
            }

            func (s *MinStack) Pop() int {
                val := s.vals[len(s.vals)-1]
                s.vals = s.vals[:len(s.vals)-1]
                s.mins = s.mins[:len(s.mins)-1]
                return val
            }

            func (s *MinStack) Top() int {
                return s.vals[len(s.vals)-1]
            }

            func (s *MinStack) GetMin() int {
                return s.mins[len(s.mins)-1]
            }
          annotations:
            - type: pattern
              label: Parallel Tracking
              text: A second stack tracking minimums at each level gives O(1) GetMin without scanning.
            - type: complexity
              label: O(1) All Operations
              text: Push, pop, top, and getMin all run in constant time at the cost of O(n) extra space.
        - id: v4
          title: Stack-Based Reversal
          description: >-
            Write a function <code>reverseString(s string) string</code> that uses a stack
            (slice of runes) to reverse the input. Push each character, then pop them all off.
          hints:
            - Convert the string to runes and push each one onto a <code>[]rune</code> stack.
            - Pop all runes off the stack into a result slice.
            - Convert the result back to a string.
          solution: |-
            func reverseString(s string) string {
                stack := []rune{}
                for _, ch := range s {
                    stack = append(stack, ch)
                }
                result := make([]rune, 0, len(stack))
                for len(stack) > 0 {
                    top := stack[len(stack)-1]
                    stack = stack[:len(stack)-1]
                    result = append(result, top)
                }
                return string(result)
            }
          annotations:
            - type: idiom
              label: Rune Conversion
              text: "Range over a string yields runes, handling multi-byte UTF-8 correctly."
            - type: alternative
              label: Two-Pointer Reverse
              text: A two-pointer swap on []rune is more efficient — this exercise demonstrates the stack concept.
    - id: warmup_2
      concept: Binary Search
      variants:
        - id: v1
          title: Classic Binary Search
          description: >-
            Write a function <code>binarySearch(nums []int, target int) int</code> that returns
            the index of <code>target</code> in a sorted slice, or <code>-1</code> if not found.
            Use the standard <code>lo</code>/<code>hi</code> pointer approach.
          hints:
            - "Initialize <code>lo, hi := 0, len(nums)-1</code>"
            - "Calculate mid as <code>lo + (hi-lo)/2</code> to avoid integer overflow."
            - "Compare nums[mid] to target: equal → return, less → move lo up, greater → move hi down."
          solution: |-
            func binarySearch(nums []int, target int) int {
                lo, hi := 0, len(nums)-1
                for lo <= hi {
                    mid := lo + (hi-lo)/2
                    if nums[mid] == target {
                        return mid
                    } else if nums[mid] < target {
                        lo = mid + 1
                    } else {
                        hi = mid - 1
                    }
                }
                return -1
            }
          annotations:
            - type: complexity
              label: O(log n)
              text: Each iteration halves the search space, giving logarithmic time complexity.
            - type: gotcha
              label: Off-by-One
              text: "Use <code>lo <= hi</code> (not <code><</code>) to ensure the single-element case is checked."
        - id: v2
          title: Search Insert Position
          description: >-
            Write a function <code>searchInsert(nums []int, target int) int</code> that returns
            the index where <code>target</code> is found, or the index where it would be inserted
            to keep the slice sorted.
          hints:
            - "This is a left-bisect: find the leftmost position where target could go."
            - "Initialize <code>lo, hi := 0, len(nums)</code> — note hi is len, not len-1."
            - "If <code>nums[mid] < target</code>, move lo up. Otherwise move hi down."
          solution: |-
            func searchInsert(nums []int, target int) int {
                lo, hi := 0, len(nums)
                for lo < hi {
                    mid := lo + (hi-lo)/2
                    if nums[mid] < target {
                        lo = mid + 1
                    } else {
                        hi = mid
                    }
                }
                return lo
            }
          annotations:
            - type: idiom
              label: Left Bisect Pattern
              text: "Setting hi = len(nums) and using <code>lo < hi</code> finds the insertion point cleanly."
            - type: stdlib
              label: sort.SearchInts
              text: Go's sort.SearchInts does exactly this — but implementing it teaches the bisect pattern.
        - id: v3
          title: First and Last Position
          description: >-
            Write a function <code>searchRange(nums []int, target int) (int, int)</code> that returns
            the first and last index of <code>target</code> in a sorted slice. Return <code>(-1, -1)</code>
            if not found.
          hints:
            - Run binary search twice — once to find the leftmost occurrence, once for the rightmost.
            - "For leftmost: when you find target, keep searching left (<code>hi = mid</code>)."
            - "For rightmost: when you find target, keep searching right (<code>lo = mid + 1</code>)."
          solution: |-
            func searchRange(nums []int, target int) (int, int) {
                left := findLeft(nums, target)
                if left == -1 {
                    return -1, -1
                }
                right := findRight(nums, target)
                return left, right
            }

            func findLeft(nums []int, target int) int {
                lo, hi := 0, len(nums)-1
                result := -1
                for lo <= hi {
                    mid := lo + (hi-lo)/2
                    if nums[mid] == target {
                        result = mid
                        hi = mid - 1
                    } else if nums[mid] < target {
                        lo = mid + 1
                    } else {
                        hi = mid - 1
                    }
                }
                return result
            }

            func findRight(nums []int, target int) int {
                lo, hi := 0, len(nums)-1
                result := -1
                for lo <= hi {
                    mid := lo + (hi-lo)/2
                    if nums[mid] == target {
                        result = mid
                        lo = mid + 1
                    } else if nums[mid] < target {
                        lo = mid + 1
                    } else {
                        hi = mid - 1
                    }
                }
                return result
            }
          annotations:
            - type: pattern
              label: Dual Binary Search
              text: Finding a range in sorted data requires two passes — one for each boundary.
            - type: complexity
              label: O(log n)
              text: Two binary searches is still O(log n) — constant factor doesn't change the class.
        - id: v4
          title: Square Root via Binary Search
          description: >-
            Write a function <code>mySqrt(x int) int</code> that returns the integer square root of
            <code>x</code> (the largest integer <code>n</code> where <code>n*n <= x</code>). Use
            binary search on the answer space.
          hints:
            - "Search the range [0, x]. The answer is the largest mid where mid*mid <= x."
            - "If mid*mid <= x, record mid as a candidate and search higher."
            - "If mid*mid > x, search lower."
          solution: |-
            func mySqrt(x int) int {
                if x < 2 {
                    return x
                }
                lo, hi := 1, x/2
                result := 1
                for lo <= hi {
                    mid := lo + (hi-lo)/2
                    if mid <= x/mid {
                        result = mid
                        lo = mid + 1
                    } else {
                        hi = mid - 1
                    }
                }
                return result
            }
          annotations:
            - type: pattern
              label: Binary Search on Answer
              text: "Binary search works on answer spaces too — not just arrays. Search for the value that satisfies a condition."
            - type: gotcha
              label: Overflow Prevention
              text: "Use <code>mid <= x/mid</code> instead of <code>mid*mid <= x</code> to avoid integer overflow."
    - id: warmup_3
      concept: Hash Maps
      variants:
        - id: v1
          title: Count Frequencies with a Map
          description: >-
            Write a function <code>frequencies(nums []int) map[int]int</code> that returns a map
            where each key is a number from the input and the value is how many times it appears.
          hints:
            - "Create a map with <code>make(map[int]int)</code>."
            - "Range over nums and increment: <code>freq[n]++</code>"
            - "Missing keys in a Go map return the zero value (0 for int), so no need to check existence."
          solution: |-
            func frequencies(nums []int) map[int]int {
                freq := make(map[int]int)
                for _, n := range nums {
                    freq[n]++
                }
                return freq
            }
          annotations:
            - type: idiom
              label: Zero Value Increment
              text: "Go maps return the zero value for missing keys. <code>freq[n]++</code> works even if n hasn't been seen."
            - type: complexity
              label: O(n)
              text: Single pass through the slice, O(1) map operations. Total O(n) time and space.
        - id: v2
          title: Word Frequency Counter
          description: >-
            Write a function <code>wordFreq(text string) map[string]int</code> that splits text
            on whitespace and counts occurrences of each word. Convert words to lowercase first.
          hints:
            - "Use <code>strings.Fields(text)</code> to split on whitespace."
            - "Use <code>strings.ToLower(word)</code> before counting."
            - "The pattern is the same as number frequencies — just with string keys."
          solution: |-
            func wordFreq(text string) map[string]int {
                freq := make(map[string]int)
                for _, word := range strings.Fields(text) {
                    freq[strings.ToLower(word)]++
                }
                return freq
            }
          annotations:
            - type: stdlib
              label: strings.Fields
              text: "strings.Fields splits on any whitespace and handles multiple spaces, unlike strings.Split."
            - type: idiom
              label: Normalize Keys
              text: Always normalize map keys (lowercase, trim) to avoid duplicates from case differences.
        - id: v3
          title: Find Duplicates
          description: >-
            Write a function <code>findDuplicates(nums []int) []int</code> that returns all values
            that appear more than once. Use a map to track what you've seen.
          hints:
            - "Track seen values in a <code>map[int]bool</code>."
            - "If you see a value that's already in the map, it's a duplicate."
            - "Use a second map or set to avoid adding the same duplicate twice."
          solution: |-
            func findDuplicates(nums []int) []int {
                seen := make(map[int]bool)
                added := make(map[int]bool)
                var result []int
                for _, n := range nums {
                    if seen[n] && !added[n] {
                        result = append(result, n)
                        added[n] = true
                    }
                    seen[n] = true
                }
                return result
            }
          annotations:
            - type: pattern
              label: Seen Set
              text: "A map[T]bool as a set is the Go idiom for tracking membership. Check with <code>if seen[val]</code>."
            - type: complexity
              label: O(n)
              text: "Single pass with O(1) map lookups. Compare to the O(n²) nested-loop brute force."
        - id: v4
          title: Group Anagrams
          description: >-
            Write a function <code>groupAnagrams(words []string) [][]string</code> that groups words
            that are anagrams of each other. Two words are anagrams if they have the same characters
            in a different order.
          hints:
            - "Sort the characters of each word to create a canonical key."
            - "Use a <code>map[string][]string</code> to group words by their sorted key."
            - "Convert to []rune, sort, convert back to string for the key."
          solution: |-
            func groupAnagrams(words []string) [][]string {
                groups := make(map[string][]string)
                for _, word := range words {
                    runes := []rune(word)
                    sort.Slice(runes, func(i, j int) bool {
                        return runes[i] < runes[j]
                    })
                    key := string(runes)
                    groups[key] = append(groups[key], word)
                }
                result := make([][]string, 0, len(groups))
                for _, group := range groups {
                    result = append(result, group)
                }
                return result
            }
          annotations:
            - type: pattern
              label: Canonical Key
              text: "Sorting characters creates a canonical form — all anagrams produce the same sorted string."
            - type: complexity
              label: O(n * k log k)
              text: "n words, each of length k sorted in O(k log k). Map operations are O(1) amortized."
    - id: warmup_4
      concept: Two Pointers
      variants:
        - id: v1
          title: Palindrome Check
          description: >-
            Write a function <code>isPalindrome(s string) bool</code> that checks if a string reads the same
            forwards and backwards. Use two pointers converging from both ends. Ignore case — convert to lowercase
            first.
          hints:
            - Convert to a <code>[]rune</code> slice and use <code>strings.ToLower</code> for case insensitivity.
            - "Initialize <code>left, right := 0, len(runes)-1</code> and move inward."
            - "If <code>runes[left] != runes[right]</code> at any point, return false."
          solution: |-
            func isPalindrome(s string) bool {
                runes := []rune(strings.ToLower(s))
                left, right := 0, len(runes)-1
                for left < right {
                    if runes[left] != runes[right] {
                        return false
                    }
                    left++
                    right--
                }
                return true
            }
          annotations:
            - type: pattern
              label: Converging Pointers
              text: >-
                Two pointers starting from opposite ends is the classic approach for symmetry checks.
                O(n) time, O(1) extra space (after the rune conversion).
            - type: gotcha
              label: Rune vs Byte
              text: >-
                Always convert to <code>[]rune</code> before doing character-level comparisons. Indexing a string
                directly gives bytes, which breaks for multi-byte characters like accented letters.
        - id: v2
          title: Two Sum Sorted
          description: >-
            Given a sorted slice of integers <code>nums</code> and a <code>target</code>, write
            <code>func twoSumSorted(nums []int, target int) (int, int)</code> that returns the indices of the
            two numbers that add up to target. Return <code>(-1, -1)</code> if no pair exists. Use the
            two-pointer approach (not a hash map).
          hints:
            - "Start with <code>left, right := 0, len(nums)-1</code>."
            - "If <code>nums[left]+nums[right] == target</code>, return the indices."
            - "If the sum is too small, move left up. If too large, move right down."
          solution: |-
            func twoSumSorted(nums []int, target int) (int, int) {
                left, right := 0, len(nums)-1
                for left < right {
                    sum := nums[left] + nums[right]
                    if sum == target {
                        return left, right
                    } else if sum < target {
                        left++
                    } else {
                        right--
                    }
                }
                return -1, -1
            }
          annotations:
            - type: pattern
              label: Sorted Two Pointer
              text: >-
                On a sorted array, two pointers from the ends find a target sum in O(n). Moving left increases
                the sum, moving right decreases it.
            - type: complexity
              label: O(n) Time, O(1) Space
              text: >-
                Single pass with no extra data structures. Compare to the hash map approach which is also O(n)
                time but uses O(n) space.
        - id: v3
          title: Remove Duplicates Sorted
          description: >-
            Write <code>func removeDuplicates(nums []int) []int</code> that removes duplicate values from a
            sorted slice in-place and returns the deduplicated slice. Use a slow/fast pointer approach where
            slow tracks the write position and fast scans ahead.
          hints:
            - "Handle the empty case: if <code>len(nums) == 0</code>, return the empty slice."
            - "Slow pointer stays at the last unique element. Fast pointer scans forward."
            - "When <code>nums[fast] != nums[slow]</code>, advance slow and copy the value."
          solution: |-
            func removeDuplicates(nums []int) []int {
                if len(nums) == 0 {
                    return nums
                }
                slow := 0
                for fast := 1; fast < len(nums); fast++ {
                    if nums[fast] != nums[slow] {
                        slow++
                        nums[slow] = nums[fast]
                    }
                }
                return nums[:slow+1]
            }
          annotations:
            - type: pattern
              label: Slow/Fast Pointer
              text: >-
                The slow pointer marks the boundary of processed output. The fast pointer scans ahead looking for
                new values. This pattern works for in-place removal of any condition.
            - type: idiom
              label: Reslice for Result
              text: >-
                <code>nums[:slow+1]</code> returns a slice of just the unique elements. The underlying array still
                has the old values past that point, but they're invisible to the caller.
        - id: v4
          title: Move Zeros
          description: >-
            Write <code>func moveZeros(nums []int) []int</code> that moves all zeros to the end of the slice
            while maintaining the relative order of non-zero elements. Modify in-place and return the slice.
            Use a slow pointer to track where the next non-zero should go.
          hints:
            - "Slow pointer marks the next position for a non-zero value."
            - "Fast pointer scans through the array. When it finds a non-zero, swap with slow position."
            - "After the loop, all positions from slow onward should be zero."
          solution: |-
            func moveZeros(nums []int) []int {
                slow := 0
                for fast := 0; fast < len(nums); fast++ {
                    if nums[fast] != 0 {
                        nums[slow], nums[fast] = nums[fast], nums[slow]
                        slow++
                    }
                }
                return nums
            }
          annotations:
            - type: pattern
              label: Partition Pattern
              text: >-
                This is a partition operation: non-zeros go left, zeros go right. The swap approach maintains
                relative order of non-zero elements.
            - type: complexity
              label: O(n) Time, O(1) Space
              text: Single pass, in-place. Each element is visited exactly once.
    - id: warmup_5
      concept: Sliding Window
      variants:
        - id: v1
          title: Max Sum of K Elements
          description: >-
            Write <code>func maxSumK(nums []int, k int) int</code> that returns the maximum sum of any
            contiguous subarray of length <code>k</code>. Use a fixed-size sliding window — compute the first
            window's sum, then slide by adding the new element and subtracting the old one.
          hints:
            - "Compute the sum of the first k elements as your initial window."
            - "Slide: add <code>nums[i]</code>, subtract <code>nums[i-k]</code>."
            - "Track the maximum sum seen so far."
          solution: |-
            func maxSumK(nums []int, k int) int {
                if len(nums) < k {
                    return 0
                }
                windowSum := 0
                for i := 0; i < k; i++ {
                    windowSum += nums[i]
                }
                maxSum := windowSum
                for i := k; i < len(nums); i++ {
                    windowSum += nums[i] - nums[i-k]
                    if windowSum > maxSum {
                        maxSum = windowSum
                    }
                }
                return maxSum
            }
          annotations:
            - type: pattern
              label: Fixed Sliding Window
              text: >-
                A fixed window of size k slides one step at a time. Instead of recomputing the sum from scratch
                (O(k) per step), add the new element and subtract the old one (O(1) per step).
            - type: complexity
              label: O(n) Time
              text: >-
                Single pass after the initial window setup. Compare to the brute force O(n*k) approach of
                summing each subarray independently.
        - id: v2
          title: Longest Substring Without Repeating
          description: >-
            Write <code>func lengthOfLongestSubstring(s string) int</code> that returns the length of the longest
            substring without repeating characters. Use a variable-size sliding window with a map to track character
            positions.
          hints:
            - "Use a <code>map[byte]int</code> to store the last index of each character."
            - "Left pointer jumps forward when a duplicate is found inside the current window."
            - "Track the maximum <code>right - left + 1</code> at each step."
          solution: |-
            func lengthOfLongestSubstring(s string) int {
                lastSeen := make(map[byte]int)
                maxLen := 0
                left := 0
                for right := 0; right < len(s); right++ {
                    if idx, ok := lastSeen[s[right]]; ok && idx >= left {
                        left = idx + 1
                    }
                    lastSeen[s[right]] = right
                    if right-left+1 > maxLen {
                        maxLen = right - left + 1
                    }
                }
                return maxLen
            }
          annotations:
            - type: pattern
              label: Variable Sliding Window
              text: >-
                The window expands (right++) every step but only shrinks (left jumps) when the window condition
                is violated. The map tracks where characters were last seen.
            - type: gotcha
              label: Check idx >= left
              text: >-
                A character might be in the map but outside the current window. Check <code>idx >= left</code>
                to avoid shrinking the window unnecessarily.
        - id: v3
          title: Minimum Window Substring
          description: >-
            Write <code>func minWindow(s, t string) string</code> that finds the minimum window in <code>s</code>
            that contains all characters of <code>t</code>. Return <code>""</code> if no such window exists. Use
            a variable-size sliding window with frequency maps.
          hints:
            - "Build a frequency map of characters needed from <code>t</code>."
            - "Expand right to include characters. When all needed characters are covered, shrink from left."
            - "Track the minimum window size and its start position."
          solution: |-
            func minWindow(s, t string) string {
                if len(t) > len(s) {
                    return ""
                }
                need := make(map[byte]int)
                for i := 0; i < len(t); i++ {
                    need[t[i]]++
                }
                have := make(map[byte]int)
                formed := 0
                required := len(need)
                minLen := len(s) + 1
                minStart := 0
                left := 0
                for right := 0; right < len(s); right++ {
                    ch := s[right]
                    have[ch]++
                    if have[ch] == need[ch] {
                        formed++
                    }
                    for formed == required {
                        if right-left+1 < minLen {
                            minLen = right - left + 1
                            minStart = left
                        }
                        out := s[left]
                        have[out]--
                        if have[out] < need[out] {
                            formed--
                        }
                        left++
                    }
                }
                if minLen > len(s) {
                    return ""
                }
                return s[minStart : minStart+minLen]
            }
          annotations:
            - type: pattern
              label: Shrinkable Window
              text: >-
                This is the most complex sliding window variant: expand to satisfy the condition, then shrink
                to minimize. The <code>formed</code> counter avoids re-scanning the frequency maps.
            - type: complexity
              label: O(n) Time
              text: >-
                Each character is added and removed from the window at most once. The inner while loop
                across all iterations of the outer loop runs at most n times total.
        - id: v4
          title: Average of K Elements
          description: >-
            Write <code>func avgOfK(nums []float64, k int) []float64</code> that returns a slice of averages
            for every contiguous subarray of length <code>k</code>. Use a fixed sliding window.
          hints:
            - "Compute the sum of the first k elements."
            - "The first average is <code>sum / float64(k)</code>."
            - "Slide the window: add the new element, subtract the leaving element, compute average."
          solution: |-
            func avgOfK(nums []float64, k int) []float64 {
                if len(nums) < k {
                    return nil
                }
                result := make([]float64, 0, len(nums)-k+1)
                windowSum := 0.0
                for i := 0; i < k; i++ {
                    windowSum += nums[i]
                }
                result = append(result, windowSum/float64(k))
                for i := k; i < len(nums); i++ {
                    windowSum += nums[i] - nums[i-k]
                    result = append(result, windowSum/float64(k))
                }
                return result
            }
          annotations:
            - type: pattern
              label: Fixed Window Accumulation
              text: >-
                Same sliding window pattern as max sum, but collecting all window values instead of tracking
                a maximum. Pre-allocating with <code>cap: len(nums)-k+1</code> avoids reallocations.
            - type: idiom
              label: Float Division
              text: >-
                Use <code>float64(k)</code> to convert the integer divisor. Go won't auto-convert int to float64
                in arithmetic — you must be explicit.
  challenges:
    - id: challenge_1
      block: 1
      difficulty: 2
      concept: Linked Lists
      variants:
        - id: v1
          title: Reverse a Linked List
          description: >-
            Given a singly linked list node type <code>type ListNode struct { Val int; Next *ListNode }</code>,
            write a function <code>reverseList(head *ListNode) *ListNode</code> that reverses the list
            in place and returns the new head.
          hints:
            - "Use three pointers: prev (starts nil), curr (starts at head), next (temp save)."
            - "On each step: save next, point curr.Next to prev, advance prev and curr."
            - "When curr is nil, prev is the new head."
          solution: |-
            type ListNode struct {
                Val  int
                Next *ListNode
            }

            func reverseList(head *ListNode) *ListNode {
                var prev *ListNode
                curr := head
                for curr != nil {
                    next := curr.Next
                    curr.Next = prev
                    prev = curr
                    curr = next
                }
                return prev
            }
          annotations:
            - type: pattern
              label: Three-Pointer Reversal
              text: "The prev/curr/next pattern is the standard linked list reversal. Memorize it — it shows up everywhere."
            - type: gotcha
              label: Save Next First
              text: You must save curr.Next before overwriting it. Otherwise you lose the rest of the list.
        - id: v2
          title: Find Middle Node
          description: >-
            Write a function <code>middleNode(head *ListNode) *ListNode</code> that returns the
            middle node of a linked list. If there are two middle nodes, return the second one.
            Use the fast/slow pointer technique.
          hints:
            - "Slow pointer moves 1 step, fast pointer moves 2 steps."
            - "When fast reaches the end, slow is at the middle."
            - "Loop condition: <code>fast != nil && fast.Next != nil</code>"
          solution: |-
            func middleNode(head *ListNode) *ListNode {
                slow, fast := head, head
                for fast != nil && fast.Next != nil {
                    slow = slow.Next
                    fast = fast.Next.Next
                }
                return slow
            }
          annotations:
            - type: pattern
              label: Fast/Slow Pointers
              text: "The tortoise and hare technique finds midpoints and detects cycles in O(n) time, O(1) space."
            - type: complexity
              label: O(n) Time, O(1) Space
              text: "Single pass with two pointers — no extra data structures."
        - id: v3
          title: Detect Cycle
          description: >-
            Write a function <code>hasCycle(head *ListNode) bool</code> that returns true if the
            linked list has a cycle. Use Floyd's cycle detection (fast/slow pointers).
          hints:
            - "If fast and slow ever point to the same node, there's a cycle."
            - "If fast reaches nil, there's no cycle."
            - "Start both at head. Move slow by 1, fast by 2."
          solution: |-
            func hasCycle(head *ListNode) bool {
                slow, fast := head, head
                for fast != nil && fast.Next != nil {
                    slow = slow.Next
                    fast = fast.Next.Next
                    if slow == fast {
                        return true
                    }
                }
                return false
            }
          annotations:
            - type: pattern
              label: Floyd's Algorithm
              text: "If there's a cycle, the fast pointer will eventually lap the slow pointer."
            - type: gotcha
              label: Nil Checks
              text: "Check both fast != nil and fast.Next != nil to avoid nil pointer dereference."
        - id: v4
          title: Merge Two Sorted Lists
          description: >-
            Write a function <code>mergeTwoLists(l1, l2 *ListNode) *ListNode</code> that merges
            two sorted linked lists into one sorted list. Return the head of the merged list.
          hints:
            - "Use a dummy head node to simplify the merge logic."
            - "Compare the current nodes of both lists, append the smaller one."
            - "When one list is exhausted, append the rest of the other."
          solution: |-
            func mergeTwoLists(l1, l2 *ListNode) *ListNode {
                dummy := &ListNode{}
                curr := dummy
                for l1 != nil && l2 != nil {
                    if l1.Val <= l2.Val {
                        curr.Next = l1
                        l1 = l1.Next
                    } else {
                        curr.Next = l2
                        l2 = l2.Next
                    }
                    curr = curr.Next
                }
                if l1 != nil {
                    curr.Next = l1
                } else {
                    curr.Next = l2
                }
                return dummy.Next
            }
          annotations:
            - type: pattern
              label: Dummy Head
              text: "A dummy node eliminates special-case logic for the first element. Return dummy.Next."
            - type: complexity
              label: O(n + m)
              text: "Visits each node exactly once. This is the same merge used in merge sort."
