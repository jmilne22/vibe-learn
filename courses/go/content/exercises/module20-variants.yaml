conceptLinks:
  Stacks: "#lesson-stacks"
  Binary Search: "#lesson-binary-search"
  Hash Maps: "#lesson-hash-maps"
  Linked Lists: "#lesson-linked-lists"
  Big O Notation: "#lesson-big-o"
  Two Pointers: "#lesson-two-pointers"
  Sliding Window: "#lesson-sliding-window"
sharedContent: {}
variants:
  warmups:
    - id: warmup_1
      concept: Stacks
      variants:
        - id: v1
          title: Stack with a Slice
          description: >-
            Implement a stack of integers using a Go slice. Write functions <code>push</code>,
            <code>pop</code>, <code>peek</code>, and <code>isEmpty</code> that operate on
            a <code>*[]int</code>. Pop and peek should return <code>(int, bool)</code> to handle
            the empty case.
          hints:
            - "Push appends to the slice: <code>*s = append(*s, val)</code>"
            - "Pop reads the last element, then reslices: <code>*s = (*s)[:len(*s)-1]</code>"
            - Check <code>len(*s) == 0</code> before pop or peek to avoid panics.
          solution: |-
            func push(s *[]int, val int) {
                *s = append(*s, val)
            }

            func pop(s *[]int) (int, bool) {
                if len(*s) == 0 {
                    return 0, false
                }
                val := (*s)[len(*s)-1]
                *s = (*s)[:len(*s)-1]
                return val, true
            }

            func peek(s *[]int) (int, bool) {
                if len(*s) == 0 {
                    return 0, false
                }
                return (*s)[len(*s)-1], true
            }

            func isEmpty(s *[]int) bool {
                return len(*s) == 0
            }
          annotations:
            - type: idiom
              label: Slice as Stack
              text: "Go slices are natural stacks: append to push, reslice to pop. No extra library needed."
            - type: gotcha
              label: Bounds Check
              text: Always check length before indexing the last element. An empty pop without a guard causes a panic.
        - id: v2
          title: Generic Stack Struct
          description: >-
            Build a <code>Stack[T any]</code> generic struct with methods <code>Push(val T)</code>,
            <code>Pop() (T, bool)</code>, <code>Peek() (T, bool)</code>, and <code>Len() int</code>.
            Use a slice internally.
          hints:
            - "Declare with <code>type Stack[T any] struct { items []T }</code>"
            - Methods use the pointer receiver <code>(s *Stack[T])</code>.
            - "For the zero value on empty pop: <code>var zero T; return zero, false</code>"
          solution: |-
            type Stack[T any] struct {
                items []T
            }

            func (s *Stack[T]) Push(val T) {
                s.items = append(s.items, val)
            }

            func (s *Stack[T]) Pop() (T, bool) {
                if len(s.items) == 0 {
                    var zero T
                    return zero, false
                }
                val := s.items[len(s.items)-1]
                s.items = s.items[:len(s.items)-1]
                return val, true
            }

            func (s *Stack[T]) Peek() (T, bool) {
                if len(s.items) == 0 {
                    var zero T
                    return zero, false
                }
                return s.items[len(s.items)-1], true
            }

            func (s *Stack[T]) Len() int {
                return len(s.items)
            }
          annotations:
            - type: idiom
              label: Generic Zero Value
              text: "Use <code>var zero T</code> to get the zero value of any generic type parameter."
            - type: pattern
              label: Generics for Data Structures
              text: Go generics make type-safe reusable data structures possible without interface{} casts.
        - id: v3
          title: Min Stack
          description: >-
            Implement a <code>MinStack</code> that supports <code>Push(val int)</code>,
            <code>Pop() int</code>, <code>Top() int</code>, and <code>GetMin() int</code>,
            all in O(1) time. Use two internal slices — one for values, one to track the current minimum.
          hints:
            - Keep a parallel <code>mins</code> slice. On push, append the min of the new value and the current min.
            - "On pop, pop from both slices."
            - "GetMin returns the top of the mins slice."
          solution: |-
            type MinStack struct {
                vals []int
                mins []int
            }

            func (s *MinStack) Push(val int) {
                s.vals = append(s.vals, val)
                if len(s.mins) == 0 || val <= s.mins[len(s.mins)-1] {
                    s.mins = append(s.mins, val)
                } else {
                    s.mins = append(s.mins, s.mins[len(s.mins)-1])
                }
            }

            func (s *MinStack) Pop() int {
                val := s.vals[len(s.vals)-1]
                s.vals = s.vals[:len(s.vals)-1]
                s.mins = s.mins[:len(s.mins)-1]
                return val
            }

            func (s *MinStack) Top() int {
                return s.vals[len(s.vals)-1]
            }

            func (s *MinStack) GetMin() int {
                return s.mins[len(s.mins)-1]
            }
          annotations:
            - type: pattern
              label: Parallel Tracking
              text: A second stack tracking minimums at each level gives O(1) GetMin without scanning.
            - type: complexity
              label: O(1) All Operations
              text: Push, pop, top, and getMin all run in constant time at the cost of O(n) extra space.
        - id: v4
          title: Stack-Based Reversal
          description: >-
            Write a function <code>reverseString(s string) string</code> that uses a stack
            (slice of runes) to reverse the input. Push each character, then pop them all off.
          hints:
            - Convert the string to runes and push each one onto a <code>[]rune</code> stack.
            - Pop all runes off the stack into a result slice.
            - Convert the result back to a string.
          solution: |-
            func reverseString(s string) string {
                stack := []rune{}
                for _, ch := range s {
                    stack = append(stack, ch)
                }
                result := make([]rune, 0, len(stack))
                for len(stack) > 0 {
                    top := stack[len(stack)-1]
                    stack = stack[:len(stack)-1]
                    result = append(result, top)
                }
                return string(result)
            }
          annotations:
            - type: idiom
              label: Rune Conversion
              text: "Range over a string yields runes, handling multi-byte UTF-8 correctly."
            - type: alternative
              label: Two-Pointer Reverse
              text: A two-pointer swap on []rune is more efficient — this exercise demonstrates the stack concept.
    - id: warmup_2
      concept: Binary Search
      variants:
        - id: v1
          title: Classic Binary Search
          description: >-
            Write a function <code>binarySearch(nums []int, target int) int</code> that returns
            the index of <code>target</code> in a sorted slice, or <code>-1</code> if not found.
            Use the standard <code>lo</code>/<code>hi</code> pointer approach.
          hints:
            - "Initialize <code>lo, hi := 0, len(nums)-1</code>"
            - "Calculate mid as <code>lo + (hi-lo)/2</code> to avoid integer overflow."
            - "Compare nums[mid] to target: equal → return, less → move lo up, greater → move hi down."
          solution: |-
            func binarySearch(nums []int, target int) int {
                lo, hi := 0, len(nums)-1
                for lo <= hi {
                    mid := lo + (hi-lo)/2
                    if nums[mid] == target {
                        return mid
                    } else if nums[mid] < target {
                        lo = mid + 1
                    } else {
                        hi = mid - 1
                    }
                }
                return -1
            }
          annotations:
            - type: complexity
              label: O(log n)
              text: Each iteration halves the search space, giving logarithmic time complexity.
            - type: gotcha
              label: Off-by-One
              text: "Use <code>lo <= hi</code> (not <code><</code>) to ensure the single-element case is checked."
        - id: v2
          title: Search Insert Position
          description: >-
            Write a function <code>searchInsert(nums []int, target int) int</code> that returns
            the index where <code>target</code> is found, or the index where it would be inserted
            to keep the slice sorted.
          hints:
            - "This is a left-bisect: find the leftmost position where target could go."
            - "Initialize <code>lo, hi := 0, len(nums)</code> — note hi is len, not len-1."
            - "If <code>nums[mid] < target</code>, move lo up. Otherwise move hi down."
          solution: |-
            func searchInsert(nums []int, target int) int {
                lo, hi := 0, len(nums)
                for lo < hi {
                    mid := lo + (hi-lo)/2
                    if nums[mid] < target {
                        lo = mid + 1
                    } else {
                        hi = mid
                    }
                }
                return lo
            }
          annotations:
            - type: idiom
              label: Left Bisect Pattern
              text: "Setting hi = len(nums) and using <code>lo < hi</code> finds the insertion point cleanly."
            - type: stdlib
              label: sort.SearchInts
              text: Go's sort.SearchInts does exactly this — but implementing it teaches the bisect pattern.
        - id: v3
          title: First and Last Position
          description: >-
            Write a function <code>searchRange(nums []int, target int) (int, int)</code> that returns
            the first and last index of <code>target</code> in a sorted slice. Return <code>(-1, -1)</code>
            if not found.
          hints:
            - Run binary search twice — once to find the leftmost occurrence, once for the rightmost.
            - "For leftmost: when you find target, keep searching left (<code>hi = mid</code>)."
            - "For rightmost: when you find target, keep searching right (<code>lo = mid + 1</code>)."
          solution: |-
            func searchRange(nums []int, target int) (int, int) {
                left := findLeft(nums, target)
                if left == -1 {
                    return -1, -1
                }
                right := findRight(nums, target)
                return left, right
            }

            func findLeft(nums []int, target int) int {
                lo, hi := 0, len(nums)-1
                result := -1
                for lo <= hi {
                    mid := lo + (hi-lo)/2
                    if nums[mid] == target {
                        result = mid
                        hi = mid - 1
                    } else if nums[mid] < target {
                        lo = mid + 1
                    } else {
                        hi = mid - 1
                    }
                }
                return result
            }

            func findRight(nums []int, target int) int {
                lo, hi := 0, len(nums)-1
                result := -1
                for lo <= hi {
                    mid := lo + (hi-lo)/2
                    if nums[mid] == target {
                        result = mid
                        lo = mid + 1
                    } else if nums[mid] < target {
                        lo = mid + 1
                    } else {
                        hi = mid - 1
                    }
                }
                return result
            }
          annotations:
            - type: pattern
              label: Dual Binary Search
              text: Finding a range in sorted data requires two passes — one for each boundary.
            - type: complexity
              label: O(log n)
              text: Two binary searches is still O(log n) — constant factor doesn't change the class.
        - id: v4
          title: Square Root via Binary Search
          description: >-
            Write a function <code>mySqrt(x int) int</code> that returns the integer square root of
            <code>x</code> (the largest integer <code>n</code> where <code>n*n <= x</code>). Use
            binary search on the answer space.
          hints:
            - "Search the range [0, x]. The answer is the largest mid where mid*mid <= x."
            - "If mid*mid <= x, record mid as a candidate and search higher."
            - "If mid*mid > x, search lower."
          solution: |-
            func mySqrt(x int) int {
                if x < 2 {
                    return x
                }
                lo, hi := 1, x/2
                result := 1
                for lo <= hi {
                    mid := lo + (hi-lo)/2
                    if mid <= x/mid {
                        result = mid
                        lo = mid + 1
                    } else {
                        hi = mid - 1
                    }
                }
                return result
            }
          annotations:
            - type: pattern
              label: Binary Search on Answer
              text: "Binary search works on answer spaces too — not just arrays. Search for the value that satisfies a condition."
            - type: gotcha
              label: Overflow Prevention
              text: "Use <code>mid <= x/mid</code> instead of <code>mid*mid <= x</code> to avoid integer overflow."
    - id: warmup_3
      concept: Hash Maps
      variants:
        - id: v1
          title: Count Frequencies with a Map
          description: >-
            Write a function <code>frequencies(nums []int) map[int]int</code> that returns a map
            where each key is a number from the input and the value is how many times it appears.
          hints:
            - "Create a map with <code>make(map[int]int)</code>."
            - "Range over nums and increment: <code>freq[n]++</code>"
            - "Missing keys in a Go map return the zero value (0 for int), so no need to check existence."
          solution: |-
            func frequencies(nums []int) map[int]int {
                freq := make(map[int]int)
                for _, n := range nums {
                    freq[n]++
                }
                return freq
            }
          annotations:
            - type: idiom
              label: Zero Value Increment
              text: "Go maps return the zero value for missing keys. <code>freq[n]++</code> works even if n hasn't been seen."
            - type: complexity
              label: O(n)
              text: Single pass through the slice, O(1) map operations. Total O(n) time and space.
        - id: v2
          title: Word Frequency Counter
          description: >-
            Write a function <code>wordFreq(text string) map[string]int</code> that splits text
            on whitespace and counts occurrences of each word. Convert words to lowercase first.
          hints:
            - "Use <code>strings.Fields(text)</code> to split on whitespace."
            - "Use <code>strings.ToLower(word)</code> before counting."
            - "The pattern is the same as number frequencies — just with string keys."
          solution: |-
            func wordFreq(text string) map[string]int {
                freq := make(map[string]int)
                for _, word := range strings.Fields(text) {
                    freq[strings.ToLower(word)]++
                }
                return freq
            }
          annotations:
            - type: stdlib
              label: strings.Fields
              text: "strings.Fields splits on any whitespace and handles multiple spaces, unlike strings.Split."
            - type: idiom
              label: Normalize Keys
              text: Always normalize map keys (lowercase, trim) to avoid duplicates from case differences.
        - id: v3
          title: Find Duplicates
          description: >-
            Write a function <code>findDuplicates(nums []int) []int</code> that returns all values
            that appear more than once. Use a map to track what you've seen.
          hints:
            - "Track seen values in a <code>map[int]bool</code>."
            - "If you see a value that's already in the map, it's a duplicate."
            - "Use a second map or set to avoid adding the same duplicate twice."
          solution: |-
            func findDuplicates(nums []int) []int {
                seen := make(map[int]bool)
                added := make(map[int]bool)
                var result []int
                for _, n := range nums {
                    if seen[n] && !added[n] {
                        result = append(result, n)
                        added[n] = true
                    }
                    seen[n] = true
                }
                return result
            }
          annotations:
            - type: pattern
              label: Seen Set
              text: "A map[T]bool as a set is the Go idiom for tracking membership. Check with <code>if seen[val]</code>."
            - type: complexity
              label: O(n)
              text: "Single pass with O(1) map lookups. Compare to the O(n²) nested-loop brute force."
        - id: v4
          title: Group Anagrams
          description: >-
            Write a function <code>groupAnagrams(words []string) [][]string</code> that groups words
            that are anagrams of each other. Two words are anagrams if they have the same characters
            in a different order.
          hints:
            - "Sort the characters of each word to create a canonical key."
            - "Use a <code>map[string][]string</code> to group words by their sorted key."
            - "Convert to []rune, sort, convert back to string for the key."
          solution: |-
            func groupAnagrams(words []string) [][]string {
                groups := make(map[string][]string)
                for _, word := range words {
                    runes := []rune(word)
                    sort.Slice(runes, func(i, j int) bool {
                        return runes[i] < runes[j]
                    })
                    key := string(runes)
                    groups[key] = append(groups[key], word)
                }
                result := make([][]string, 0, len(groups))
                for _, group := range groups {
                    result = append(result, group)
                }
                return result
            }
          annotations:
            - type: pattern
              label: Canonical Key
              text: "Sorting characters creates a canonical form — all anagrams produce the same sorted string."
            - type: complexity
              label: O(n * k log k)
              text: "n words, each of length k sorted in O(k log k). Map operations are O(1) amortized."
  challenges:
    - id: challenge_1
      block: 1
      difficulty: 2
      concept: Linked Lists
      variants:
        - id: v1
          title: Reverse a Linked List
          description: >-
            Given a singly linked list node type <code>type ListNode struct { Val int; Next *ListNode }</code>,
            write a function <code>reverseList(head *ListNode) *ListNode</code> that reverses the list
            in place and returns the new head.
          hints:
            - "Use three pointers: prev (starts nil), curr (starts at head), next (temp save)."
            - "On each step: save next, point curr.Next to prev, advance prev and curr."
            - "When curr is nil, prev is the new head."
          solution: |-
            type ListNode struct {
                Val  int
                Next *ListNode
            }

            func reverseList(head *ListNode) *ListNode {
                var prev *ListNode
                curr := head
                for curr != nil {
                    next := curr.Next
                    curr.Next = prev
                    prev = curr
                    curr = next
                }
                return prev
            }
          annotations:
            - type: pattern
              label: Three-Pointer Reversal
              text: "The prev/curr/next pattern is the standard linked list reversal. Memorize it — it shows up everywhere."
            - type: gotcha
              label: Save Next First
              text: You must save curr.Next before overwriting it. Otherwise you lose the rest of the list.
        - id: v2
          title: Find Middle Node
          description: >-
            Write a function <code>middleNode(head *ListNode) *ListNode</code> that returns the
            middle node of a linked list. If there are two middle nodes, return the second one.
            Use the fast/slow pointer technique.
          hints:
            - "Slow pointer moves 1 step, fast pointer moves 2 steps."
            - "When fast reaches the end, slow is at the middle."
            - "Loop condition: <code>fast != nil && fast.Next != nil</code>"
          solution: |-
            func middleNode(head *ListNode) *ListNode {
                slow, fast := head, head
                for fast != nil && fast.Next != nil {
                    slow = slow.Next
                    fast = fast.Next.Next
                }
                return slow
            }
          annotations:
            - type: pattern
              label: Fast/Slow Pointers
              text: "The tortoise and hare technique finds midpoints and detects cycles in O(n) time, O(1) space."
            - type: complexity
              label: O(n) Time, O(1) Space
              text: "Single pass with two pointers — no extra data structures."
        - id: v3
          title: Detect Cycle
          description: >-
            Write a function <code>hasCycle(head *ListNode) bool</code> that returns true if the
            linked list has a cycle. Use Floyd's cycle detection (fast/slow pointers).
          hints:
            - "If fast and slow ever point to the same node, there's a cycle."
            - "If fast reaches nil, there's no cycle."
            - "Start both at head. Move slow by 1, fast by 2."
          solution: |-
            func hasCycle(head *ListNode) bool {
                slow, fast := head, head
                for fast != nil && fast.Next != nil {
                    slow = slow.Next
                    fast = fast.Next.Next
                    if slow == fast {
                        return true
                    }
                }
                return false
            }
          annotations:
            - type: pattern
              label: Floyd's Algorithm
              text: "If there's a cycle, the fast pointer will eventually lap the slow pointer."
            - type: gotcha
              label: Nil Checks
              text: "Check both fast != nil and fast.Next != nil to avoid nil pointer dereference."
        - id: v4
          title: Merge Two Sorted Lists
          description: >-
            Write a function <code>mergeTwoLists(l1, l2 *ListNode) *ListNode</code> that merges
            two sorted linked lists into one sorted list. Return the head of the merged list.
          hints:
            - "Use a dummy head node to simplify the merge logic."
            - "Compare the current nodes of both lists, append the smaller one."
            - "When one list is exhausted, append the rest of the other."
          solution: |-
            func mergeTwoLists(l1, l2 *ListNode) *ListNode {
                dummy := &ListNode{}
                curr := dummy
                for l1 != nil && l2 != nil {
                    if l1.Val <= l2.Val {
                        curr.Next = l1
                        l1 = l1.Next
                    } else {
                        curr.Next = l2
                        l2 = l2.Next
                    }
                    curr = curr.Next
                }
                if l1 != nil {
                    curr.Next = l1
                } else {
                    curr.Next = l2
                }
                return dummy.Next
            }
          annotations:
            - type: pattern
              label: Dummy Head
              text: "A dummy node eliminates special-case logic for the first element. Return dummy.Next."
            - type: complexity
              label: O(n + m)
              text: "Visits each node exactly once. This is the same merge used in merge sort."
