conceptLinks:
  Building Slices: "#slices"
  Slice Operations: "#indexing--slice-expressions"
  Map Basics: "#maps"
  Comma-Ok Pattern: "#maps"
  Strings & Runes: "#strings-bytes--runes"
  Go Fundamentals Combined: "#slices"
  Slices & Range: "#slices"
  Maps: "#maps"

sharedContent: {}

variants:
  warmups:
    # ── warmup_1: Slices & Range ─────────────────────────────────────────
    - id: warmup_1
      concept: Slices & Range
      variants:
        - id: v1
          title: Print Container Names
          description: >-
            Given <code>containers := []string{"nginx", "postgres", "redis", "grafana"}</code>,
            iterate with <code>range</code> and print each name with its index:
            <code>"0: nginx"</code>, etc.
          hints:
            - "Use <code>for i, name := range containers</code>"
            - "Print with <code>fmt.Printf(\"%d: %s\\n\", i, name)</code>"
          solution: |-
            containers := []string{"nginx", "postgres", "redis", "grafana"}
            for i, name := range containers {
                fmt.Printf("%d: %s\n", i, name)
            }

        - id: v2
          title: Collect Failed Tests
          description: >-
            Given test results <code>tests := []string{"PASS", "FAIL", "PASS", "FAIL", "FAIL"}</code>,
            use <code>append</code> to collect the indices of all <code>"FAIL"</code> entries into
            a new slice and print it.
          hints:
            - "Start with <code>var failed []int</code>"
            - "In the loop: <code>if tests[i] == \"FAIL\" { failed = append(failed, i) }</code>"
          solution: |-
            tests := []string{"PASS", "FAIL", "PASS", "FAIL", "FAIL"}
            var failed []int
            for i, result := range tests {
                if result == "FAIL" {
                    failed = append(failed, i)
                }
            }
            fmt.Println(failed)

        - id: v3
          title: Last 3 Git Commits
          description: >-
            Given <code>commits := []string{"fix typo", "add auth", "refactor DB", "update deps", "init"}</code>,
            use slice syntax to grab the last 3 and print them.
          hints:
            - "Use <code>commits[len(commits)-3:]</code>"
          solution: |-
            commits := []string{"fix typo", "add auth", "refactor DB", "update deps", "init"}
            last3 := commits[len(commits)-3:]
            fmt.Println(last3)

        - id: v4
          title: Build a Playlist
          description: >-
            Start with an empty slice. Append 5 songs one at a time using <code>append</code>.
            Print the playlist after each addition to show the slice growing.
          hints:
            - "Use <code>var playlist []string</code> then <code>playlist = append(playlist, song)</code>"
          solution: |-
            var playlist []string
            songs := []string{"Bohemian Rhapsody", "Stairway to Heaven", "Hotel California", "Imagine", "Smells Like Teen Spirit"}
            for _, song := range songs {
                playlist = append(playlist, song)
                fmt.Println(playlist)
            }

        - id: v5
          title: Filter Error Codes
          description: >-
            Given <code>codes := []int{200, 301, 404, 200, 500, 403, 200, 502}</code>,
            collect all codes >= 400 into a new slice and print it.
          hints:
            - "Use the filter-and-collect pattern: <code>var errors []int</code> + conditional append"
          solution: |-
            codes := []int{200, 301, 404, 200, 500, 403, 200, 502}
            var errors []int
            for _, code := range codes {
                if code >= 400 {
                    errors = append(errors, code)
                }
            }
            fmt.Println(errors)

        - id: v6
          title: Reverse Log Lines
          description: >-
            Given <code>logs := []string{"boot", "connect", "query", "disconnect", "shutdown"}</code>,
            build a new slice with the elements in reverse order and print it.
          hints:
            - "Create a result slice with <code>make([]string, len(logs))</code>"
            - "Use <code>result[i] = logs[len(logs)-1-i]</code>"
          solution: |-
            logs := []string{"boot", "connect", "query", "disconnect", "shutdown"}
            reversed := make([]string, len(logs))
            for i := 0; i < len(logs); i++ {
                reversed[i] = logs[len(logs)-1-i]
            }
            fmt.Println(reversed)

        - id: v7
          title: Sum Sensor Readings
          description: >-
            Given <code>readings := []float64{23.1, 24.5, 22.8, 25.0, 23.7}</code>,
            compute the sum and average. Print both formatted to 2 decimal places.
          hints:
            - "Sum in a loop, then divide by <code>float64(len(readings))</code>"
            - "Use <code>fmt.Printf(\"avg: %.2f\\n\", avg)</code>"
          solution: |-
            readings := []float64{23.1, 24.5, 22.8, 25.0, 23.7}
            sum := 0.0
            for _, r := range readings {
                sum += r
            }
            avg := sum / float64(len(readings))
            fmt.Printf("sum: %.2f\navg: %.2f\n", sum, avg)

        - id: v8
          title: Pre-Allocate Benchmark IDs
          description: >-
            Use <code>make([]string, 0, 100)</code> to pre-allocate a slice with capacity 100.
            Append 100 strings like <code>"bench-0"</code> through <code>"bench-99"</code>.
            Print the final length and capacity.
          hints:
            - "<code>make([]T, length, capacity)</code> — length 0, capacity 100"
            - "Use <code>fmt.Sprintf(\"bench-%d\", i)</code> to build each string"
          solution: |-
            ids := make([]string, 0, 100)
            for i := 0; i < 100; i++ {
                ids = append(ids, fmt.Sprintf("bench-%d", i))
            }
            fmt.Printf("len=%d cap=%d\n", len(ids), cap(ids))

        - id: v9
          title: Zip Two Slices
          description: >-
            Given <code>keys := []string{"host", "port", "db"}</code> and
            <code>vals := []string{"localhost", "5432", "myapp"}</code>,
            print them zipped: <code>"host=localhost"</code>, <code>"port=5432"</code>, etc.
          hints:
            - "Loop with an index, access both slices at the same position"
            - "Use <code>fmt.Printf(\"%s=%s\\n\", keys[i], vals[i])</code>"
          solution: |-
            keys := []string{"host", "port", "db"}
            vals := []string{"localhost", "5432", "myapp"}
            for i := 0; i < len(keys); i++ {
                fmt.Printf("%s=%s\n", keys[i], vals[i])
            }

        - id: v10
          title: Rotate Left
          description: >-
            Given <code>items := []string{"a", "b", "c", "d", "e"}</code>, rotate the slice
            left by 2 positions so it becomes <code>["c", "d", "e", "a", "b"]</code>.
            Use slice concatenation with <code>append</code>.
          hints:
            - "Left rotate by n: <code>append(items[n:], items[:n]...)</code>"
          solution: |-
            items := []string{"a", "b", "c", "d", "e"}
            n := 2
            rotated := append(items[n:], items[:n]...)
            fmt.Println(rotated)

        - id: v11
          title: Deduplicate Tags
          description: >-
            Given <code>tags := []string{"go", "docker", "go", "k8s", "docker", "linux", "go"}</code>,
            remove duplicates while preserving order. Use a map as a "seen" set.
          hints:
            - "Use <code>seen := make(map[string]bool)</code>"
            - "Only append if <code>!seen[tag]</code>, then mark as seen"
          solution: |-
            tags := []string{"go", "docker", "go", "k8s", "docker", "linux", "go"}
            seen := make(map[string]bool)
            var unique []string
            for _, tag := range tags {
                if !seen[tag] {
                    seen[tag] = true
                    unique = append(unique, tag)
                }
            }
            fmt.Println(unique)

        - id: v12
          title: Chunk Into Batches
          description: >-
            Given <code>items := []int{1,2,3,4,5,6,7,8,9,10}</code> and batch size 3,
            split into chunks: <code>[1,2,3]</code>, <code>[4,5,6]</code>, <code>[7,8,9]</code>,
            <code>[10]</code>. Print each chunk.
          hints:
            - "Loop with step size: <code>for i := 0; i &lt; len(items); i += batchSize</code>"
            - "Clamp the end: <code>end := i + batchSize; if end > len(items) { end = len(items) }</code>"
          solution: |-
            items := []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}
            batchSize := 3
            for i := 0; i < len(items); i += batchSize {
                end := i + batchSize
                if end > len(items) {
                    end = len(items)
                }
                fmt.Println(items[i:end])
            }

        - id: v13
          title: Longest String
          description: >-
            Given <code>repos := []string{"cli", "kubernetes", "go", "prometheus", "etcd"}</code>,
            find and print the longest string. If there's a tie, return the first one found.
            Also print its length.
          hints:
            - "Track <code>longest</code> and update when <code>len(s) > len(longest)</code>"
          solution: |-
            repos := []string{"cli", "kubernetes", "go", "prometheus", "etcd"}
            longest := ""
            for _, s := range repos {
                if len(s) > len(longest) {
                    longest = s
                }
            }
            fmt.Printf("%s (len %d)\n", longest, len(longest))

    # ── warmup_2: Maps ───────────────────────────────────────────────────
    - id: warmup_2
      concept: Maps
      variants:
        - id: v1
          title: HTTP Method Lookup
          description: >-
            Create a map literal mapping HTTP methods to descriptions:
            <code>"GET"→"read"</code>, <code>"POST"→"create"</code>,
            <code>"PUT"→"update"</code>, <code>"DELETE"→"remove"</code>.
            Iterate with <code>range</code> and print each pair.
          hints:
            - "Use <code>methods := map[string]string{\"GET\": \"read\", ...}</code>"
            - "Use <code>for k, v := range methods</code>"
          solution: |-
            methods := map[string]string{
                "GET":    "read",
                "POST":   "create",
                "PUT":    "update",
                "DELETE": "remove",
            }
            for k, v := range methods {
                fmt.Printf("%s: %s\n", k, v)
            }

        - id: v2
          title: Word Frequency
          description: >-
            Given <code>words := []string{"go", "is", "fun", "go", "is", "great", "go"}</code>,
            count the frequency of each word using a map. Print the map.
          hints:
            - "Use <code>freq := make(map[string]int)</code>"
            - "<code>freq[word]++</code> works because zero value of int is 0"
          solution: |-
            words := []string{"go", "is", "fun", "go", "is", "great", "go"}
            freq := make(map[string]int)
            for _, word := range words {
                freq[word]++
            }
            fmt.Println(freq)

        - id: v3
          title: Environment Variable Map
          description: >-
            Build a map from these key-value pairs:
            <code>"HOME"→"/home/gopher"</code>, <code>"GOPATH"→"/home/gopher/go"</code>,
            <code>"EDITOR"→"vim"</code>. Look up <code>"SHELL"</code> using the comma-ok
            pattern. Print <code>"not set"</code> if missing.
          hints:
            - "Use <code>val, ok := env[\"SHELL\"]</code>"
            - "Check <code>if !ok</code> for missing keys"
          solution: |-
            env := map[string]string{
                "HOME":   "/home/gopher",
                "GOPATH": "/home/gopher/go",
                "EDITOR": "vim",
            }
            val, ok := env["SHELL"]
            if !ok {
                fmt.Println("not set")
            } else {
                fmt.Println(val)
            }

        - id: v4
          title: DNS Cache
          description: >-
            Simulate a DNS cache: create a <code>map[string]string</code> mapping domains to IPs.
            Add 3 entries, then "resolve" a domain by looking it up. If not cached, print
            <code>"cache miss"</code>.
          hints:
            - "Use comma-ok pattern: <code>ip, ok := cache[domain]</code>"
          solution: |-
            cache := map[string]string{
                "google.com":  "142.250.80.46",
                "github.com":  "140.82.121.4",
                "go.dev":      "216.239.38.21",
            }
            domain := "rust-lang.org"
            ip, ok := cache[domain]
            if !ok {
                fmt.Printf("%s: cache miss\n", domain)
            } else {
                fmt.Printf("%s: %s\n", domain, ip)
            }

        - id: v5
          title: Inventory Counter
          description: >-
            Given <code>items := []string{"apple", "banana", "apple", "cherry", "banana", "apple"}</code>,
            count each item. Then print all items that have a count of 2 or more.
          hints:
            - "First pass: count with <code>counts[item]++</code>"
            - "Second pass: iterate the map and filter by count"
          solution: |-
            items := []string{"apple", "banana", "apple", "cherry", "banana", "apple"}
            counts := make(map[string]int)
            for _, item := range items {
                counts[item]++
            }
            for item, count := range counts {
                if count >= 2 {
                    fmt.Printf("%s: %d\n", item, count)
                }
            }

        - id: v6
          title: Username Set
          description: >-
            Use a <code>map[string]bool</code> as a set to track registered usernames.
            Add <code>"alice"</code>, <code>"bob"</code>, <code>"charlie"</code>.
            Check if <code>"dave"</code> is registered. Print the result.
          hints:
            - "Add: <code>users[\"alice\"] = true</code>"
            - "Check: <code>if users[\"dave\"]</code> — missing keys return false (zero value)"
          solution: |-
            users := map[string]bool{
                "alice":   true,
                "bob":     true,
                "charlie": true,
            }
            if users["dave"] {
                fmt.Println("dave is registered")
            } else {
                fmt.Println("dave is not registered")
            }

        - id: v7
          title: Merge Config Maps
          description: >-
            Given a <code>defaults</code> map and an <code>overrides</code> map, merge them so
            overrides take priority. Start by copying defaults, then apply overrides on top.
          hints:
            - "Copy defaults first: <code>for k, v := range defaults { merged[k] = v }</code>"
            - "Then apply overrides the same way — they'll overwrite matching keys"
          solution: |-
            defaults := map[string]string{"host": "localhost", "port": "3000", "debug": "false"}
            overrides := map[string]string{"port": "8080", "debug": "true"}
            merged := make(map[string]string)
            for k, v := range defaults {
                merged[k] = v
            }
            for k, v := range overrides {
                merged[k] = v
            }
            fmt.Println(merged)

        - id: v8
          title: Delete Stale Entries
          description: >-
            Create a cache map with 5 entries. Delete all entries whose keys start with
            <code>"temp_"</code>. Print the map before and after.
          hints:
            - "Use <code>delete(m, key)</code> to remove entries"
            - "Use <code>strings.HasPrefix(key, \"temp_\")</code> to check the prefix"
          solution: |-
            cache := map[string]string{
                "user_1":    "Alice",
                "temp_sess": "abc123",
                "config":    "prod",
                "temp_data": "xyz",
                "user_2":    "Bob",
            }
            fmt.Println("before:", cache)
            for key := range cache {
                if strings.HasPrefix(key, "temp_") {
                    delete(cache, key)
                }
            }
            fmt.Println("after:", cache)

        - id: v9
          title: API Hit Counter
          description: >-
            Simulate an API hit counter. Given a list of endpoint hits
            <code>[]string{"/api/users", "/api/posts", "/api/users", "/api/users", "/api/posts", "/healthz"}</code>,
            count hits per endpoint and print the results.
          hints:
            - "Same frequency count pattern: <code>hits[endpoint]++</code>"
          solution: |-
            requests := []string{"/api/users", "/api/posts", "/api/users", "/api/users", "/api/posts", "/healthz"}
            hits := make(map[string]int)
            for _, endpoint := range requests {
                hits[endpoint]++
            }
            for endpoint, count := range hits {
                fmt.Printf("%s: %d hits\n", endpoint, count)
            }

        - id: v10
          title: Group Files by Extension
          description: >-
            Given <code>files := []string{"main.go", "test.go", "README.md", "Dockerfile", "config.yaml", "utils.go"}</code>,
            group them by extension into a <code>map[string][]string</code>. Files without an
            extension go under <code>"none"</code>.
          hints:
            - "Use <code>strings.LastIndex(f, \".\")</code> to find the extension"
            - "Append to the slice for that key: <code>groups[ext] = append(groups[ext], f)</code>"
          solution: |-
            files := []string{"main.go", "test.go", "README.md", "Dockerfile", "config.yaml", "utils.go"}
            groups := make(map[string][]string)
            for _, f := range files {
                dot := strings.LastIndex(f, ".")
                ext := "none"
                if dot >= 0 {
                    ext = f[dot+1:]
                }
                groups[ext] = append(groups[ext], f)
            }
            for ext, names := range groups {
                fmt.Printf("%s: %v\n", ext, names)
            }

        - id: v11
          title: Error Code Translator
          description: >-
            Create a map translating error codes to messages:
            <code>1→"not found"</code>, <code>2→"permission denied"</code>,
            <code>3→"timeout"</code>, <code>4→"rate limited"</code>.
            Look up a code and print the message, or <code>"unknown error"</code> if not found.
          hints:
            - "Use comma-ok: <code>msg, ok := errors[code]</code>"
          solution: |-
            errors := map[int]string{
                1: "not found",
                2: "permission denied",
                3: "timeout",
                4: "rate limited",
            }
            code := 5
            msg, ok := errors[code]
            if !ok {
                msg = "unknown error"
            }
            fmt.Printf("code %d: %s\n", code, msg)

        - id: v12
          title: Invert a Map
          description: >-
            Given <code>abbrevs := map[string]string{"US": "United States", "UK": "United Kingdom", "JP": "Japan"}</code>,
            create a new map that maps values back to keys (e.g. <code>"Japan"→"JP"</code>).
            Print the inverted map.
          hints:
            - "Create a new map, loop over the original, swap key and value"
          solution: |-
            abbrevs := map[string]string{"US": "United States", "UK": "United Kingdom", "JP": "Japan"}
            inverted := make(map[string]string)
            for k, v := range abbrevs {
                inverted[v] = k
            }
            fmt.Println(inverted)

        - id: v13
          title: Two-Map Join
          description: >-
            Given <code>names := map[int]string{1: "Alice", 2: "Bob", 3: "Charlie"}</code> and
            <code>scores := map[int]int{1: 95, 2: 82, 3: 71}</code>, join them by key and print
            <code>"Alice: 95"</code>, etc. Only print entries that exist in both maps.
          hints:
            - "Iterate one map, look up the key in the other with comma-ok"
            - "Only print if both lookups succeed"
          solution: |-
            names := map[int]string{1: "Alice", 2: "Bob", 3: "Charlie"}
            scores := map[int]int{1: 95, 2: 82, 3: 71}
            for id, name := range names {
                score, ok := scores[id]
                if ok {
                    fmt.Printf("%s: %d\n", name, score)
                }
            }

  challenges:
    # ── challenge_1: Building Slices ─────────────────────────────────────
    - id: challenge_1
      block: 1
      difficulty: 1
      concept: Building Slices
      docLinks:
        - url: https://go.dev/blog/slices-intro
          title: "Go Slices: usage and internals"
          note: how slices work under the hood
        - url: https://pkg.go.dev/builtin#append
          title: "builtin.append"
          note: append function
      variants:
        - id: v1
          title: Sequence of Squares
          description: >-
            Write <code>func squares(n int) []int</code> that returns a slice
            containing the squares of 1 through n. For example,
            <code>squares(5)</code> returns <code>[1, 4, 9, 16, 25]</code>.
          functionSignature: func squares(n int) []int
          difficulty: 1
          testCases:
            - input: "squares(5)"
              output: "[1, 4, 9, 16, 25]"
            - input: "squares(1)"
              output: "[1]"
            - input: "squares(0)"
              output: "[]"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                You need to build a slice one element at a time. What operation
                adds an element to the end of a slice?
            - title: "\U0001F4A1 Hint"
              content: >-
                Use <code>append</code> in a loop from 1 to n. Each element is
                <code>i * i</code>.
          solution: |-
            func squares(n int) []int {
                result := make([]int, 0, n)
                for i := 1; i <= n; i++ {
                    result = append(result, i*i)
                }
                return result
            }
          annotations:
            - type: idiom
              label: Pre-allocate with make
              text: >-
                Using <code>make([]int, 0, n)</code> pre-allocates capacity so
                append never needs to reallocate during the loop.

        - id: v2
          title: Collect Even Numbers
          description: >-
            Write <code>func collectEvens(lo, hi int) []int</code> that returns
            a slice of all even numbers in the range [lo, hi] inclusive.
            For example, <code>collectEvens(3, 10)</code> returns
            <code>[4, 6, 8, 10]</code>.
          functionSignature: func collectEvens(lo, hi int) []int
          difficulty: 1
          testCases:
            - input: "collectEvens(3, 10)"
              output: "[4, 6, 8, 10]"
            - input: "collectEvens(2, 2)"
              output: "[2]"
            - input: "collectEvens(1, 1)"
              output: "[]"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                How do you test whether a number is even? Loop through the range
                and selectively collect.
            - title: "\U0001F4A1 Hint"
              content: >-
                Use <code>i % 2 == 0</code> to check evenness, and
                <code>append</code> to collect matches.
          solution: |-
            func collectEvens(lo, hi int) []int {
                var evens []int
                for i := lo; i <= hi; i++ {
                    if i%2 == 0 {
                        evens = append(evens, i)
                    }
                }
                return evens
            }
          annotations:
            - type: idiom
              label: Filter-collect pattern
              text: >-
                The loop-and-conditionally-append pattern is Go's standard way
                to filter elements into a new slice.

        - id: v3
          title: Build Server Names
          description: >-
            Write <code>func serverNames(prefix string, count int) []string</code>
            that returns names like <code>["web-01", "web-02", "web-03"]</code>
            when called as <code>serverNames("web", 3)</code>. Numbers are
            zero-padded to 2 digits.
          functionSignature: func serverNames(prefix string, count int) []string
          difficulty: 1
          testCases:
            - input: 'serverNames("web", 3)'
              output: '["web-01", "web-02", "web-03"]'
            - input: 'serverNames("db", 1)'
              output: '["db-01"]'
            - input: 'serverNames("cache", 0)'
              output: "[]"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                You need formatted strings with zero-padded numbers. Which
                <code>fmt</code> function returns a string instead of printing?
            - title: "\U0001F4A1 Hint"
              content: >-
                Use <code>fmt.Sprintf("%s-%02d", prefix, i)</code> to build each
                name with zero-padding.
          solution: |-
            func serverNames(prefix string, count int) []string {
                names := make([]string, 0, count)
                for i := 1; i <= count; i++ {
                    names = append(names, fmt.Sprintf("%s-%02d", prefix, i))
                }
                return names
            }
          annotations:
            - type: idiom
              label: Sprintf for string building
              text: >-
                <code>fmt.Sprintf</code> is the idiomatic way to build formatted
                strings in Go, similar to printf but returning a string.

        - id: v4
          title: Extract Long Words
          description: >-
            Write <code>func longWords(text string, minLen int) []string</code>
            that splits <code>text</code> on spaces and returns only words with
            length >= <code>minLen</code>.
          functionSignature: func longWords(text string, minLen int) []string
          difficulty: 1
          testCases:
            - input: 'longWords("the quick brown fox jumps over", 4)'
              output: '["quick", "brown", "jumps", "over"]'
            - input: 'longWords("go is fun", 3)'
              output: '["fun"]'
            - input: 'longWords("a b c", 2)'
              output: "[]"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                First split the string into words, then filter by length. Which
                function in the <code>strings</code> package splits on whitespace?
            - title: "\U0001F4A1 Hint"
              content: >-
                Use <code>strings.Fields(text)</code> to split, then filter with
                <code>len(word) >= minLen</code>.
          solution: |-
            func longWords(text string, minLen int) []string {
                words := strings.Fields(text)
                var result []string
                for _, w := range words {
                    if len(w) >= minLen {
                        result = append(result, w)
                    }
                }
                return result
            }
          annotations:
            - type: idiom
              label: strings.Fields vs strings.Split
              text: >-
                <code>strings.Fields</code> splits on any whitespace and skips
                empty strings, making it more robust than
                <code>strings.Split(s, " ")</code>.

        - id: v5
          title: Split CSV Line
          description: >-
            Write <code>func splitCSV(line string) []string</code> that splits a
            CSV line by commas and trims whitespace from each field. For example,
            <code>splitCSV("name, age, city")</code> returns
            <code>["name", "age", "city"]</code>.
          functionSignature: func splitCSV(line string) []string
          difficulty: 2
          testCases:
            - input: 'splitCSV("name, age, city")'
              output: '["name", "age", "city"]'
            - input: 'splitCSV("a,b,c")'
              output: '["a", "b", "c"]'
            - input: 'splitCSV("  hello  ")'
              output: '["hello"]'
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                Split by comma first, then clean up each piece. What function
                removes leading and trailing whitespace?
            - title: "\U0001F4A1 Hint"
              content: >-
                Use <code>strings.Split(line, ",")</code> then
                <code>strings.TrimSpace</code> on each field.
          solution: |-
            func splitCSV(line string) []string {
                parts := strings.Split(line, ",")
                result := make([]string, len(parts))
                for i, p := range parts {
                    result[i] = strings.TrimSpace(p)
                }
                return result
            }
          annotations:
            - type: idiom
              label: Transform in place with index
              text: >-
                When you know the output has the same length as input, use
                <code>make([]T, len(input))</code> and assign by index instead
                of append.

        - id: v6
          title: Flatten Nested Slices
          description: >-
            Write <code>func flatten(nested [][]int) []int</code> that takes a
            slice of int slices and returns a single flat slice with all elements.
            For example, <code>flatten([][]int{{1,2},{3},{4,5,6}})</code> returns
            <code>[1,2,3,4,5,6]</code>.
          functionSignature: func flatten(nested [][]int) []int
          difficulty: 2
          testCases:
            - input: "flatten([][]int{{1,2},{3},{4,5,6}})"
              output: "[1, 2, 3, 4, 5, 6]"
            - input: "flatten([][]int{{},{1},{}})"
              output: "[1]"
            - input: "flatten([][]int{})"
              output: "[]"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                You need to iterate through the outer slice and collect all inner
                elements. Can you use the variadic form of append?
            - title: "\U0001F4A1 Hint"
              content: >-
                Use <code>result = append(result, inner...)</code> to append an
                entire inner slice at once.
          solution: |-
            func flatten(nested [][]int) []int {
                var result []int
                for _, inner := range nested {
                    result = append(result, inner...)
                }
                return result
            }
          annotations:
            - type: idiom
              label: Variadic append
              text: >-
                The <code>...</code> operator unpacks a slice into individual
                arguments, letting you append an entire slice in one call.

        - id: v7
          title: Generate IP Range
          description: >-
            Write <code>func ipRange(base string, start, end int) []string</code>
            that generates IPs like <code>["192.168.1.10", "192.168.1.11", ...]</code>
            given base <code>"192.168.1"</code>, start 10, end 12.
          functionSignature: func ipRange(base string, start, end int) []string
          difficulty: 2
          testCases:
            - input: 'ipRange("192.168.1", 10, 12)'
              output: '["192.168.1.10", "192.168.1.11", "192.168.1.12"]'
            - input: 'ipRange("10.0.0", 1, 1)'
              output: '["10.0.0.1"]'
            - input: 'ipRange("172.16.0", 254, 255)'
              output: '["172.16.0.254", "172.16.0.255"]'
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                Each IP is the base string plus a dot and a number. Loop through
                the range and format each one.
            - title: "\U0001F4A1 Hint"
              content: >-
                Use <code>fmt.Sprintf("%s.%d", base, i)</code> inside a loop from
                start to end inclusive.
          solution: |-
            func ipRange(base string, start, end int) []string {
                ips := make([]string, 0, end-start+1)
                for i := start; i <= end; i++ {
                    ips = append(ips, fmt.Sprintf("%s.%d", base, i))
                }
                return ips
            }
          annotations:
            - type: pattern
              label: Builder pattern with Sprintf
              text: >-
                Combining a loop with <code>fmt.Sprintf</code> is a common
                pattern for generating structured string sequences.

        - id: v8
          title: Unique Characters
          description: >-
            Write <code>func uniqueChars(s string) []rune</code> that returns
            the unique characters from string <code>s</code> in the order they
            first appear. For example, <code>uniqueChars("abracadabra")</code>
            returns <code>['a','b','r','c','d']</code>.
          functionSignature: func uniqueChars(s string) []rune
          difficulty: 2
          testCases:
            - input: 'uniqueChars("abracadabra")'
              output: "[97, 98, 114, 99, 100]"
            - input: 'uniqueChars("hello")'
              output: "[104, 101, 108, 111]"
            - input: 'uniqueChars("")'
              output: "[]"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                You need to track which characters you have already seen. What
                data structure lets you check membership in O(1)?
            - title: "\U0001F4A1 Hint"
              content: >-
                Use a <code>map[rune]bool</code> as a "seen" set. Range over the
                string to get runes, append only if not seen.
          solution: |-
            func uniqueChars(s string) []rune {
                seen := make(map[rune]bool)
                var result []rune
                for _, ch := range s {
                    if !seen[ch] {
                        seen[ch] = true
                        result = append(result, ch)
                    }
                }
                return result
            }
          annotations:
            - type: idiom
              label: Map as set
              text: >-
                Using <code>map[T]bool</code> as a set is idiomatic Go. The zero
                value false means "not seen" without explicit initialization.

        - id: v9
          title: Build Fibonacci Slice
          description: >-
            Write <code>func fibonacci(n int) []int</code> that returns the first
            n Fibonacci numbers. <code>fibonacci(7)</code> returns
            <code>[0, 1, 1, 2, 3, 5, 8]</code>.
          functionSignature: func fibonacci(n int) []int
          difficulty: 2
          testCases:
            - input: "fibonacci(7)"
              output: "[0, 1, 1, 2, 3, 5, 8]"
            - input: "fibonacci(1)"
              output: "[0]"
            - input: "fibonacci(2)"
              output: "[0, 1]"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                Each Fibonacci number is the sum of the previous two. You can
                reference earlier elements in the slice you are building.
            - title: "\U0001F4A1 Hint"
              content: >-
                Seed with <code>[0, 1]</code>, then loop appending
                <code>fib[i-1] + fib[i-2]</code>.
          solution: |-
            func fibonacci(n int) []int {
                if n == 0 {
                    return []int{}
                }
                fib := make([]int, 0, n)
                fib = append(fib, 0)
                if n == 1 {
                    return fib
                }
                fib = append(fib, 1)
                for i := 2; i < n; i++ {
                    fib = append(fib, fib[i-1]+fib[i-2])
                }
                return fib
            }
          annotations:
            - type: pattern
              label: Self-referential slice building
              text: >-
                You can index into a slice while still appending to it. The
                Fibonacci builder reads previous elements to compute the next.

        - id: v10
          title: Filter Log Lines by Severity
          description: >-
            Write <code>func filterLogs(lines []string, severity string) []string</code>
            that returns only lines containing the given severity prefix like
            <code>"ERROR"</code> or <code>"WARN"</code>. A line matches if it
            starts with <code>[SEVERITY]</code>.
          functionSignature: func filterLogs(lines []string, severity string) []string
          difficulty: 2
          testCases:
            - input: 'filterLogs([]string{"[ERROR] disk full", "[INFO] started", "[ERROR] timeout"}, "ERROR")'
              output: '["[ERROR] disk full", "[ERROR] timeout"]'
            - input: 'filterLogs([]string{"[WARN] slow query", "[INFO] ok"}, "DEBUG")'
              output: "[]"
            - input: 'filterLogs([]string{}, "ERROR")'
              output: "[]"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                You need to check if each line starts with a specific prefix
                pattern. Build the prefix string first, then filter.
            - title: "\U0001F4A1 Hint"
              content: >-
                Build <code>prefix := "[" + severity + "]"</code> and use
                <code>strings.HasPrefix(line, prefix)</code>.
          solution: |-
            func filterLogs(lines []string, severity string) []string {
                prefix := "[" + severity + "]"
                var result []string
                for _, line := range lines {
                    if strings.HasPrefix(line, prefix) {
                        result = append(result, line)
                    }
                }
                return result
            }
          annotations:
            - type: idiom
              label: String prefix matching
              text: >-
                <code>strings.HasPrefix</code> is clearer than manual slicing
                and handles edge cases like short strings safely.

        - id: v11
          title: Interleave Two Slices
          description: >-
            Write <code>func interleave(a, b []int) []int</code> that merges two
            slices by alternating elements. If one is longer, append the remaining
            elements. <code>interleave([1,2,3], [10,20])</code> returns
            <code>[1,10,2,20,3]</code>.
          functionSignature: func interleave(a, b []int) []int
          difficulty: 3
          testCases:
            - input: "interleave([]int{1,2,3}, []int{10,20})"
              output: "[1, 10, 2, 20, 3]"
            - input: "interleave([]int{1}, []int{2,3,4})"
              output: "[1, 2, 3, 4]"
            - input: "interleave([]int{}, []int{5,6})"
              output: "[5, 6]"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                Process both slices in parallel up to the shorter length, then
                handle the leftover tail.
            - title: "\U0001F4A1 Hint"
              content: >-
                Loop to <code>max(len(a), len(b))</code>, appending from each
                slice only if the index is in bounds.
          solution: |-
            func interleave(a, b []int) []int {
                result := make([]int, 0, len(a)+len(b))
                maxLen := len(a)
                if len(b) > maxLen {
                    maxLen = len(b)
                }
                for i := 0; i < maxLen; i++ {
                    if i < len(a) {
                        result = append(result, a[i])
                    }
                    if i < len(b) {
                        result = append(result, b[i])
                    }
                }
                return result
            }
          annotations:
            - type: pattern
              label: Parallel iteration with bounds checking
              text: >-
                When interleaving slices of different lengths, always guard index
                access with a bounds check to avoid panics.

        - id: v12
          title: Partition by Predicate
          description: >-
            Write <code>func partition(nums []int, pred func(int) bool) (pass []int, fail []int)</code>
            that splits a slice into two: elements where pred returns true and
            elements where it returns false.
          functionSignature: "func partition(nums []int, pred func(int) bool) ([]int, []int)"
          difficulty: 3
          testCases:
            - input: "partition([]int{1,2,3,4,5,6}, func(n int) bool { return n%2 == 0 })"
              output: "[2, 4, 6], [1, 3, 5]"
            - input: "partition([]int{10,20,30}, func(n int) bool { return n > 15 })"
              output: "[20, 30], [10]"
            - input: "partition([]int{}, func(n int) bool { return true })"
              output: "[], []"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                You need two output slices. For each element, call the predicate
                and route to the appropriate slice.
            - title: "\U0001F4A1 Hint"
              content: >-
                Use named return values or two local slices. Append to
                <code>pass</code> if <code>pred(n)</code>, else <code>fail</code>.
          solution: |-
            func partition(nums []int, pred func(int) bool) ([]int, []int) {
                var pass, fail []int
                for _, n := range nums {
                    if pred(n) {
                        pass = append(pass, n)
                    } else {
                        fail = append(fail, n)
                    }
                }
                return pass, fail
            }
          annotations:
            - type: idiom
              label: Function values as parameters
              text: >-
                Go functions are first-class values. Passing a predicate function
                makes partition reusable for any condition.

        - id: v13
          title: Multiplication Table as Flat Slice
          description: >-
            Write <code>func mulTable(n int) []int</code> that returns a flat
            slice representing an n×n multiplication table in row-major order.
            <code>mulTable(3)</code> returns <code>[1,2,3,2,4,6,3,6,9]</code>.
          functionSignature: func mulTable(n int) []int
          difficulty: 3
          testCases:
            - input: "mulTable(3)"
              output: "[1, 2, 3, 2, 4, 6, 3, 6, 9]"
            - input: "mulTable(1)"
              output: "[1]"
            - input: "mulTable(2)"
              output: "[1, 2, 2, 4]"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                A multiplication table has n rows and n columns. Row i, column j
                holds the product i*j. How do you linearize a 2D structure?
            - title: "\U0001F4A1 Hint"
              content: >-
                Use nested loops: outer for row 1..n, inner for col 1..n. Append
                <code>row * col</code> to a single flat slice.
          solution: |-
            func mulTable(n int) []int {
                table := make([]int, 0, n*n)
                for r := 1; r <= n; r++ {
                    for c := 1; c <= n; c++ {
                        table = append(table, r*c)
                    }
                }
                return table
            }
          annotations:
            - type: pattern
              label: Flattening 2D data
              text: >-
                Storing a 2D structure as a flat slice with row-major order is
                common in Go for cache-friendly access and simpler APIs.

    # ── challenge_2: Slice Operations ────────────────────────────────────
    - id: challenge_2
      block: 1
      difficulty: 2
      concept: Slice Operations
      docLinks:
        - url: https://go.dev/blog/slices-intro
          title: "Go Slices: usage and internals"
          note: how slices work under the hood
        - url: https://pkg.go.dev/sort
          title: "sort package"
          note: sorting slices
      variants:
        - id: v1
          title: Count Matching Elements
          description: >-
            Write <code>func countIf(nums []int, pred func(int) bool) int</code>
            that returns the number of elements for which <code>pred</code>
            returns true.
          functionSignature: func countIf(nums []int, pred func(int) bool) int
          difficulty: 1
          testCases:
            - input: "countIf([]int{1,2,3,4,5,6}, func(n int) bool { return n%2 == 0 })"
              output: "3"
            - input: "countIf([]int{10,20,30}, func(n int) bool { return n > 25 })"
              output: "1"
            - input: "countIf([]int{}, func(n int) bool { return true })"
              output: "0"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                Keep a running counter. For each element, call the predicate and
                increment if it returns true.
            - title: "\U0001F4A1 Hint"
              content: >-
                Initialize <code>count := 0</code>, loop with range, and
                <code>if pred(n) { count++ }</code>.
          solution: |-
            func countIf(nums []int, pred func(int) bool) int {
                count := 0
                for _, n := range nums {
                    if pred(n) {
                        count++
                    }
                }
                return count
            }
          annotations:
            - type: idiom
              label: Predicate counting
              text: >-
                Passing a predicate function makes the counter generic. This
                pattern avoids writing a new function for each condition.

        - id: v2
          title: Filter-Transform Pipeline
          description: >-
            Write <code>func filterMap(nums []int, keep func(int) bool, transform func(int) int) []int</code>
            that first filters elements where <code>keep</code> is true, then
            applies <code>transform</code> to each surviving element.
          functionSignature: "func filterMap(nums []int, keep func(int) bool, transform func(int) int) []int"
          difficulty: 1
          testCases:
            - input: "filterMap([]int{1,2,3,4,5}, func(n int) bool { return n%2 != 0 }, func(n int) int { return n * 10 })"
              output: "[10, 30, 50]"
            - input: "filterMap([]int{1,2,3}, func(n int) bool { return true }, func(n int) int { return n + 1 })"
              output: "[2, 3, 4]"
            - input: "filterMap([]int{1,2,3}, func(n int) bool { return false }, func(n int) int { return n })"
              output: "[]"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                Process elements in one pass: check the filter, then transform
                and append only the ones that pass.
            - title: "\U0001F4A1 Hint"
              content: >-
                <code>if keep(n) { result = append(result, transform(n)) }</code>
                combines both steps.
          solution: |-
            func filterMap(nums []int, keep func(int) bool, transform func(int) int) []int {
                var result []int
                for _, n := range nums {
                    if keep(n) {
                        result = append(result, transform(n))
                    }
                }
                return result
            }
          annotations:
            - type: pattern
              label: Single-pass filter-map
              text: >-
                Combining filter and transform in one loop avoids allocating an
                intermediate slice, which is both faster and more memory efficient.

        - id: v3
          title: Last N Elements Safely
          description: >-
            Write <code>func lastN(s []int, n int) []int</code> that returns the
            last n elements of s. If n > len(s), return the entire slice. Never
            panic.
          functionSignature: func lastN(s []int, n int) []int
          difficulty: 1
          testCases:
            - input: "lastN([]int{1,2,3,4,5}, 3)"
              output: "[3, 4, 5]"
            - input: "lastN([]int{1,2}, 5)"
              output: "[1, 2]"
            - input: "lastN([]int{}, 3)"
              output: "[]"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                The tricky part is not panicking when n is larger than the slice.
                Clamp n to the slice length before slicing.
            - title: "\U0001F4A1 Hint"
              content: >-
                <code>if n > len(s) { n = len(s) }</code>, then return
                <code>s[len(s)-n:]</code>.
          solution: |-
            func lastN(s []int, n int) []int {
                if n > len(s) {
                    n = len(s)
                }
                return s[len(s)-n:]
            }
          annotations:
            - type: gotcha
              label: Bounds clamping
              text: >-
                Always clamp indices before slicing. Accessing <code>s[len(s)-n:]</code>
                with n > len(s) causes a runtime panic.

        - id: v4
          title: Find Duplicates
          description: >-
            Write <code>func duplicates(nums []int) []int</code> that returns a
            slice of elements that appear more than once, in the order of their
            second occurrence. No element should appear twice in the output.
          functionSignature: func duplicates(nums []int) []int
          difficulty: 1
          testCases:
            - input: "duplicates([]int{1,2,3,2,4,1,5})"
              output: "[2, 1]"
            - input: "duplicates([]int{1,1,1})"
              output: "[1]"
            - input: "duplicates([]int{1,2,3})"
              output: "[]"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                You need to know when you see an element for the second time. A
                count map can track how many times each value has appeared so far.
            - title: "\U0001F4A1 Hint"
              content: >-
                Use a <code>map[int]int</code> to count occurrences. Append to
                result only when <code>counts[n] == 2</code> (exactly the second
                time).
          solution: |-
            func duplicates(nums []int) []int {
                counts := make(map[int]int)
                var result []int
                for _, n := range nums {
                    counts[n]++
                    if counts[n] == 2 {
                        result = append(result, n)
                    }
                }
                return result
            }
          annotations:
            - type: idiom
              label: Count-based duplicate detection
              text: >-
                Checking <code>counts[n] == 2</code> ensures each duplicate is
                reported exactly once, at the moment of its second occurrence.

        - id: v5
          title: Remove Element at Index
          description: >-
            Write <code>func removeAt(s []int, i int) []int</code> that returns
            a new slice with the element at index i removed, preserving order.
            Return the original slice if i is out of bounds.
          functionSignature: func removeAt(s []int, i int) []int
          difficulty: 2
          testCases:
            - input: "removeAt([]int{10,20,30,40,50}, 2)"
              output: "[10, 20, 40, 50]"
            - input: "removeAt([]int{1,2,3}, 0)"
              output: "[2, 3]"
            - input: "removeAt([]int{1,2,3}, 5)"
              output: "[1, 2, 3]"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                You need to combine the part before index i with the part after.
                Be careful about modifying the original slice.
            - title: "\U0001F4A1 Hint"
              content: >-
                Use <code>append([]int{}, s[:i]...)</code> to copy the prefix,
                then <code>append(..., s[i+1:]...)</code> for the suffix.
          solution: |-
            func removeAt(s []int, i int) []int {
                if i < 0 || i >= len(s) {
                    return s
                }
                result := make([]int, 0, len(s)-1)
                result = append(result, s[:i]...)
                result = append(result, s[i+1:]...)
                return result
            }
          annotations:
            - type: gotcha
              label: Slice mutation trap
              text: >-
                Using <code>append(s[:i], s[i+1:]...)</code> directly modifies
                the underlying array. Allocating a new slice avoids surprising
                the caller.

        - id: v6
          title: Sliding Window Averages
          description: >-
            Write <code>func windowAvg(nums []float64, k int) []float64</code>
            that computes the average of each sliding window of size k. For
            <code>[1,2,3,4,5]</code> with k=3, return <code>[2.0, 3.0, 4.0]</code>.
          functionSignature: func windowAvg(nums []float64, k int) []float64
          difficulty: 2
          testCases:
            - input: "windowAvg([]float64{1,2,3,4,5}, 3)"
              output: "[2, 3, 4]"
            - input: "windowAvg([]float64{10,20,30,40}, 2)"
              output: "[15, 25, 35]"
            - input: "windowAvg([]float64{5}, 1)"
              output: "[5]"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                For each starting position from 0 to len-k, compute the average
                of k consecutive elements. Can you optimize by maintaining a
                running sum?
            - title: "\U0001F4A1 Hint"
              content: >-
                Compute the sum of the first window, then slide: subtract the
                element leaving, add the element entering.
          solution: |-
            func windowAvg(nums []float64, k int) []float64 {
                if k > len(nums) {
                    return nil
                }
                sum := 0.0
                for i := 0; i < k; i++ {
                    sum += nums[i]
                }
                result := []float64{sum / float64(k)}
                for i := k; i < len(nums); i++ {
                    sum += nums[i] - nums[i-k]
                    result = append(result, sum/float64(k))
                }
                return result
            }
          annotations:
            - type: pattern
              label: Sliding window technique
              text: >-
                Instead of recalculating the sum for each window (O(nk)), maintain
                a running sum by adding/subtracting at the edges (O(n)).

        - id: v7
          title: Rotate Right by K
          description: >-
            Write <code>func rotateRight(s []int, k int) []int</code> that
            rotates a slice to the right by k positions.
            <code>rotateRight([1,2,3,4,5], 2)</code> returns <code>[4,5,1,2,3]</code>.
            Handle k > len(s).
          functionSignature: func rotateRight(s []int, k int) []int
          difficulty: 2
          testCases:
            - input: "rotateRight([]int{1,2,3,4,5}, 2)"
              output: "[4, 5, 1, 2, 3]"
            - input: "rotateRight([]int{1,2,3}, 5)"
              output: "[2, 3, 1]"
            - input: "rotateRight([]int{1}, 100)"
              output: "[1]"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                Right rotation by k is the same as splitting at position len-k
                and swapping the two halves. What if k is larger than the slice?
            - title: "\U0001F4A1 Hint"
              content: >-
                Normalize with <code>k = k % len(s)</code>, then split at
                <code>len(s)-k</code> and concatenate with append.
          solution: |-
            func rotateRight(s []int, k int) []int {
                if len(s) == 0 {
                    return s
                }
                k = k % len(s)
                if k == 0 {
                    return s
                }
                pivot := len(s) - k
                result := make([]int, 0, len(s))
                result = append(result, s[pivot:]...)
                result = append(result, s[:pivot]...)
                return result
            }
          annotations:
            - type: gotcha
              label: Modulo normalization
              text: >-
                Always use <code>k % len(s)</code> to handle rotations larger
                than the slice length. Without this, you get an out-of-bounds panic.

        - id: v8
          title: Binary Search
          description: >-
            Write <code>func binarySearch(sorted []int, target int) int</code>
            that returns the index of target in a sorted slice, or -1 if not
            found. Implement it manually (do not use <code>sort.Search</code>).
          functionSignature: func binarySearch(sorted []int, target int) int
          difficulty: 2
          testCases:
            - input: "binarySearch([]int{1,3,5,7,9,11}, 7)"
              output: "3"
            - input: "binarySearch([]int{2,4,6,8}, 5)"
              output: "-1"
            - input: "binarySearch([]int{42}, 42)"
              output: "0"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                Maintain low and high bounds. Check the middle element and narrow
                the search space by half each iteration.
            - title: "\U0001F4A1 Hint"
              content: >-
                <code>mid := lo + (hi-lo)/2</code> avoids integer overflow.
                Compare <code>sorted[mid]</code> with target to decide which
                half to search next.
          solution: |-
            func binarySearch(sorted []int, target int) int {
                lo, hi := 0, len(sorted)-1
                for lo <= hi {
                    mid := lo + (hi-lo)/2
                    if sorted[mid] == target {
                        return mid
                    } else if sorted[mid] < target {
                        lo = mid + 1
                    } else {
                        hi = mid - 1
                    }
                }
                return -1
            }
          annotations:
            - type: gotcha
              label: "Overflow-safe midpoint"
              text: >-
                Use <code>lo + (hi-lo)/2</code> instead of <code>(lo+hi)/2</code>
                to avoid integer overflow when lo and hi are large.

        - id: v9
          title: Merge Two Sorted Slices
          description: >-
            Write <code>func mergeSorted(a, b []int) []int</code> that merges
            two already-sorted slices into one sorted slice in O(n+m) time.
          functionSignature: func mergeSorted(a, b []int) []int
          difficulty: 2
          testCases:
            - input: "mergeSorted([]int{1,3,5}, []int{2,4,6})"
              output: "[1, 2, 3, 4, 5, 6]"
            - input: "mergeSorted([]int{1,1,1}, []int{1,1})"
              output: "[1, 1, 1, 1, 1]"
            - input: "mergeSorted([]int{}, []int{3,4})"
              output: "[3, 4]"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                Use two pointers, one for each slice. Always take the smaller of
                the two current elements.
            - title: "\U0001F4A1 Hint"
              content: >-
                Loop while both pointers are in bounds, appending the smaller.
                Then append whatever remains from either slice.
          solution: |-
            func mergeSorted(a, b []int) []int {
                result := make([]int, 0, len(a)+len(b))
                i, j := 0, 0
                for i < len(a) && j < len(b) {
                    if a[i] <= b[j] {
                        result = append(result, a[i])
                        i++
                    } else {
                        result = append(result, b[j])
                        j++
                    }
                }
                result = append(result, a[i:]...)
                result = append(result, b[j:]...)
                return result
            }
          annotations:
            - type: pattern
              label: Two-pointer merge
              text: >-
                The two-pointer merge runs in O(n+m) time and is the core of
                merge sort. Appending remaining elements handles unequal lengths.

        - id: v10
          title: Partition Around Pivot
          description: >-
            Write <code>func partitionPivot(nums []int, pivot int) (less, equal, greater []int)</code>
            that splits a slice into three groups: elements less than, equal to,
            and greater than the pivot (Dutch national flag).
          functionSignature: "func partitionPivot(nums []int, pivot int) ([]int, []int, []int)"
          difficulty: 2
          testCases:
            - input: "partitionPivot([]int{3,1,4,1,5,9,2,6}, 4)"
              output: "[3, 1, 1, 2], [4], [5, 9, 6]"
            - input: "partitionPivot([]int{5,5,5}, 5)"
              output: "[], [5, 5, 5], []"
            - input: "partitionPivot([]int{1,2,3}, 0)"
              output: "[], [], [1, 2, 3]"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                Three output slices, three conditions. Route each element based
                on its comparison with the pivot.
            - title: "\U0001F4A1 Hint"
              content: >-
                Use a single loop: if <code>n < pivot</code> append to less, if
                <code>n == pivot</code> append to equal, else append to greater.
          solution: |-
            func partitionPivot(nums []int, pivot int) ([]int, []int, []int) {
                var less, equal, greater []int
                for _, n := range nums {
                    switch {
                    case n < pivot:
                        less = append(less, n)
                    case n == pivot:
                        equal = append(equal, n)
                    default:
                        greater = append(greater, n)
                    }
                }
                return less, equal, greater
            }
          annotations:
            - type: pattern
              label: Three-way partition
              text: >-
                The three-way partition (Dutch national flag) is useful for
                quicksort optimizations and grouping data by category.

        - id: v11
          title: Zip Two Slices into Pairs
          description: >-
            Write <code>func zip(a []string, b []int) [][2]interface{}</code>
            that pairs elements from two slices. Stop at the shorter slice's
            length. <code>zip(["x","y","z"], [1,2])</code> returns
            <code>[["x",1],["y",2]]</code>.
          functionSignature: "func zip(a []string, b []int) [][2]interface{}"
          difficulty: 3
          testCases:
            - input: 'zip([]string{"x","y","z"}, []int{1,2})'
              output: '[[x 1] [y 2]]'
            - input: 'zip([]string{"a"}, []int{1,2,3})'
              output: "[[a 1]]"
            - input: 'zip([]string{}, []int{1})'
              output: "[]"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                Determine the shorter length first, then loop to that bound
                creating pairs.
            - title: "\U0001F4A1 Hint"
              content: >-
                Use <code>minLen</code> as the loop bound.
                Each pair is <code>[2]interface{}{a[i], b[i]}</code>.
          solution: |-
            func zip(a []string, b []int) [][2]interface{} {
                minLen := len(a)
                if len(b) < minLen {
                    minLen = len(b)
                }
                result := make([][2]interface{}, minLen)
                for i := 0; i < minLen; i++ {
                    result[i] = [2]interface{}{a[i], b[i]}
                }
                return result
            }
          annotations:
            - type: idiom
              label: "interface{} for generic pairs"
              text: >-
                Before generics (Go 1.18+), <code>interface{}</code> was the
                standard way to hold mixed types. Modern code can use
                <code>any</code> as an alias.

        - id: v12
          title: Run-Length Encode
          description: >-
            Write <code>func rle(s string) []string</code> that run-length
            encodes a string. <code>rle("aaabbc")</code> returns
            <code>["3a", "2b", "1c"]</code>.
          functionSignature: func rle(s string) []string
          difficulty: 3
          testCases:
            - input: 'rle("aaabbc")'
              output: '["3a", "2b", "1c"]'
            - input: 'rle("abc")'
              output: '["1a", "1b", "1c"]'
            - input: 'rle("aaa")'
              output: '["3a"]'
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                Track the current character and its count. When the character
                changes, emit the run and start a new count.
            - title: "\U0001F4A1 Hint"
              content: >-
                Loop through the string. When <code>s[i] != s[i-1]</code>, flush
                the current run with <code>fmt.Sprintf("%d%c", count, ch)</code>.
                Do not forget to flush the last run after the loop.
          solution: |-
            func rle(s string) []string {
                if len(s) == 0 {
                    return nil
                }
                var result []string
                count := 1
                for i := 1; i < len(s); i++ {
                    if s[i] == s[i-1] {
                        count++
                    } else {
                        result = append(result, fmt.Sprintf("%d%c", count, s[i-1]))
                        count = 1
                    }
                }
                result = append(result, fmt.Sprintf("%d%c", count, s[len(s)-1]))
                return result
            }
          annotations:
            - type: gotcha
              label: Flush the last run
              text: >-
                A common bug in run-length encoding is forgetting to emit the
                final run after the loop ends. Always flush after the loop.

        - id: v13
          title: Longest Increasing Subsequence Length
          description: >-
            Write <code>func lisLength(nums []int) int</code> that returns the
            length of the longest strictly increasing subsequence. Use the
            O(n log n) patience sorting approach with <code>sort.SearchInts</code>.
          functionSignature: func lisLength(nums []int) int
          difficulty: 3
          testCases:
            - input: "lisLength([]int{10,9,2,5,3,7,101,18})"
              output: "4"
            - input: "lisLength([]int{0,1,0,3,2,3})"
              output: "4"
            - input: "lisLength([]int{7,7,7,7})"
              output: "1"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                Maintain a slice of the smallest tail element for each subsequence
                length. Use binary search to find where each new element fits.
            - title: "\U0001F4A1 Hint"
              content: >-
                Use <code>sort.SearchInts(tails, num)</code> to find the
                insertion point. If it equals len(tails), append; otherwise
                replace <code>tails[pos]</code>.
          solution: |-
            func lisLength(nums []int) int {
                var tails []int
                for _, num := range nums {
                    pos := sort.SearchInts(tails, num)
                    if pos == len(tails) {
                        tails = append(tails, num)
                    } else {
                        tails[pos] = num
                    }
                }
                return len(tails)
            }
          annotations:
            - type: pattern
              label: Patience sorting
              text: >-
                The patience sorting technique finds LIS length in O(n log n) by
                maintaining sorted tails and using binary search for placement.

    # ── challenge_3: Map Basics ──────────────────────────────────────────
    - id: challenge_3
      block: 2
      difficulty: 2
      concept: Map Basics
      docLinks:
        - url: https://go.dev/blog/maps
          title: "Go maps in action"
          note: map usage patterns
        - url: https://go.dev/tour/moretypes/19
          title: "A Tour of Go: Maps"
          note: interactive map tutorial
      variants:
        - id: v1
          title: Case-Insensitive Word Frequency
          description: >-
            Write <code>func wordFreq(text string) map[string]int</code> that
            counts word frequencies case-insensitively. Convert all words to
            lowercase before counting.
          functionSignature: func wordFreq(text string) map[string]int
          difficulty: 1
          testCases:
            - input: 'wordFreq("Go go GO")'
              output: 'map[go:3]'
            - input: 'wordFreq("Hello World hello")'
              output: 'map[hello:2 world:1]'
            - input: 'wordFreq("")'
              output: 'map[]'
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                Split the text into words, then normalize each word to lowercase
                before using it as a map key.
            - title: "\U0001F4A1 Hint"
              content: >-
                Use <code>strings.Fields(text)</code> to split and
                <code>strings.ToLower(w)</code> before incrementing the count.
          solution: |-
            func wordFreq(text string) map[string]int {
                freq := make(map[string]int)
                for _, w := range strings.Fields(text) {
                    freq[strings.ToLower(w)]++
                }
                return freq
            }
          annotations:
            - type: idiom
              label: Normalize before keying
              text: >-
                Always normalize map keys (lowercase, trim, etc.) before insertion
                to avoid duplicate entries that differ only in case.

        - id: v2
          title: Find Most Common Element
          description: >-
            Write <code>func mostCommon(items []string) string</code> that
            returns the most frequently occurring string. If there is a tie,
            return the one that appeared first.
          functionSignature: func mostCommon(items []string) string
          difficulty: 1
          testCases:
            - input: 'mostCommon([]string{"a","b","a","c","b","a"})'
              output: '"a"'
            - input: 'mostCommon([]string{"x","y","x","y"})'
              output: '"x"'
            - input: 'mostCommon([]string{"solo"})'
              output: '"solo"'
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                Count frequencies first, then find the max. To break ties by
                first appearance, iterate the original slice, not the map.
            - title: "\U0001F4A1 Hint"
              content: >-
                Build a frequency map, then loop through <code>items</code> again
                checking if <code>freq[item] > maxCount</code>.
          solution: |-
            func mostCommon(items []string) string {
                freq := make(map[string]int)
                for _, item := range items {
                    freq[item]++
                }
                best := ""
                maxCount := 0
                for _, item := range items {
                    if freq[item] > maxCount {
                        maxCount = freq[item]
                        best = item
                    }
                }
                return best
            }
          annotations:
            - type: gotcha
              label: Map iteration order
              text: >-
                Map iteration in Go is randomized. To break ties deterministically,
                iterate the original slice instead of the map.

        - id: v3
          title: Group Items by Category
          description: >-
            Write <code>func groupBy(items []string, categorize func(string) string) map[string][]string</code>
            that groups items using the categorize function as the key.
          functionSignature: "func groupBy(items []string, categorize func(string) string) map[string][]string"
          difficulty: 1
          testCases:
            - input: 'groupBy([]string{"go","py","js","ts","rb"}, func(s string) string { if len(s) > 2 { return "long" }; return "short" })'
              output: 'map[long:[js] short:[go py ts rb]]'
            - input: 'groupBy([]string{"a","b","c"}, func(s string) string { return "all" })'
              output: 'map[all:[a b c]]'
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                For each item, compute its category and append it to the slice
                stored under that key in the map.
            - title: "\U0001F4A1 Hint"
              content: >-
                <code>groups[categorize(item)] = append(groups[categorize(item)], item)</code>
                works because appending to a nil slice is safe in Go.
          solution: |-
            func groupBy(items []string, categorize func(string) string) map[string][]string {
                groups := make(map[string][]string)
                for _, item := range items {
                    key := categorize(item)
                    groups[key] = append(groups[key], item)
                }
                return groups
            }
          annotations:
            - type: idiom
              label: Append to nil slice in map
              text: >-
                In Go, appending to a nil slice works fine. You do not need to
                initialize <code>map[key]</code> before appending to it.

        - id: v4
          title: Grade Distribution Histogram
          description: >-
            Write <code>func gradeHist(scores []int) map[string]int</code> that
            maps letter grades to counts. A=90-100, B=80-89, C=70-79, D=60-69,
            F=0-59.
          functionSignature: func gradeHist(scores []int) map[string]int
          difficulty: 1
          testCases:
            - input: "gradeHist([]int{95, 82, 73, 61, 55, 90, 88})"
              output: 'map[A:2 B:2 C:1 D:1 F:1]'
            - input: "gradeHist([]int{100, 0})"
              output: 'map[A:1 F:1]'
            - input: "gradeHist([]int{})"
              output: 'map[]'
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                Convert each numeric score to a letter grade, then count. A
                switch or chain of if-else works well for the grade boundaries.
            - title: "\U0001F4A1 Hint"
              content: >-
                Use <code>switch { case s >= 90: grade = "A" ... }</code> to
                classify, then <code>hist[grade]++</code>.
          solution: |-
            func gradeHist(scores []int) map[string]int {
                hist := make(map[string]int)
                for _, s := range scores {
                    var grade string
                    switch {
                    case s >= 90:
                        grade = "A"
                    case s >= 80:
                        grade = "B"
                    case s >= 70:
                        grade = "C"
                    case s >= 60:
                        grade = "D"
                    default:
                        grade = "F"
                    }
                    hist[grade]++
                }
                return hist
            }
          annotations:
            - type: idiom
              label: Expressionless switch
              text: >-
                Go's <code>switch {}</code> without an expression acts like an
                if-else chain but is cleaner for multiple range checks.

        - id: v5
          title: Anagram Detector
          description: >-
            Write <code>func areAnagrams(a, b string) bool</code> that returns
            true if two strings are anagrams (same letters, same counts,
            case-insensitive).
          functionSignature: func areAnagrams(a, b string) bool
          difficulty: 2
          testCases:
            - input: 'areAnagrams("Listen", "Silent")'
              output: "true"
            - input: 'areAnagrams("hello", "world")'
              output: "false"
            - input: 'areAnagrams("Astronomer", "Moon starer")'
              output: "false"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                Two strings are anagrams if they have the same character frequency
                distribution. Build a frequency map for each and compare.
            - title: "\U0001F4A1 Hint"
              content: >-
                Build frequency maps for both lowercase strings. Compare by
                checking length and that every key-value pair matches.
          solution: |-
            func areAnagrams(a, b string) bool {
                freqA := make(map[rune]int)
                freqB := make(map[rune]int)
                for _, ch := range strings.ToLower(a) {
                    freqA[ch]++
                }
                for _, ch := range strings.ToLower(b) {
                    freqB[ch]++
                }
                if len(freqA) != len(freqB) {
                    return false
                }
                for k, v := range freqA {
                    if freqB[k] != v {
                        return false
                    }
                }
                return true
            }
          annotations:
            - type: pattern
              label: Frequency map comparison
              text: >-
                Comparing two frequency maps is O(n) and works for any
                character-counting problem like anagrams, permutations, etc.

        - id: v6
          title: Two-Sum with Map Lookup
          description: >-
            Write <code>func twoSum(nums []int, target int) [2]int</code> that
            returns the indices of two numbers that add up to target. Return
            <code>[2]int{-1, -1}</code> if no pair exists.
          functionSignature: func twoSum(nums []int, target int) [2]int
          difficulty: 2
          testCases:
            - input: "twoSum([]int{2, 7, 11, 15}, 9)"
              output: "[0, 1]"
            - input: "twoSum([]int{3, 2, 4}, 6)"
              output: "[1, 2]"
            - input: "twoSum([]int{1, 2, 3}, 10)"
              output: "[-1, -1]"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                For each number, you need its complement (target - num). A map
                can store previously seen numbers and their indices for O(1) lookup.
            - title: "\U0001F4A1 Hint"
              content: >-
                Use <code>seen := map[int]int{}</code> mapping value to index.
                For each num, check if <code>target-num</code> exists in seen.
          solution: |-
            func twoSum(nums []int, target int) [2]int {
                seen := make(map[int]int)
                for i, num := range nums {
                    complement := target - num
                    if j, ok := seen[complement]; ok {
                        return [2]int{j, i}
                    }
                    seen[num] = i
                }
                return [2]int{-1, -1}
            }
          annotations:
            - type: pattern
              label: Complement lookup
              text: >-
                The two-sum pattern uses a map to check for complements in O(1),
                reducing the brute-force O(n^2) to O(n).

        - id: v7
          title: Build Word Index
          description: >-
            Write <code>func buildIndex(lines []string) map[string][]int</code>
            that maps each word to the line numbers (0-based) where it appears.
            Words are case-insensitive.
          functionSignature: func buildIndex(lines []string) map[string][]int
          difficulty: 2
          testCases:
            - input: 'buildIndex([]string{"Go is great", "Go is fast", "Python is great"})'
              output: 'map[fast:[1] go:[0 1] great:[0 2] is:[0 1 2] python:[2]]'
            - input: 'buildIndex([]string{"hello", "hello"})'
              output: 'map[hello:[0 1]]'
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                For each line, split into words and record the line number for
                each word. The map value is a slice of line numbers.
            - title: "\U0001F4A1 Hint"
              content: >-
                Use <code>strings.Fields</code> to split, <code>strings.ToLower</code>
                to normalize, and append the line index to the word's slice.
          solution: |-
            func buildIndex(lines []string) map[string][]int {
                index := make(map[string][]int)
                for lineNum, line := range lines {
                    for _, word := range strings.Fields(line) {
                        w := strings.ToLower(word)
                        index[w] = append(index[w], lineNum)
                    }
                }
                return index
            }
          annotations:
            - type: idiom
              label: Inverted index
              text: >-
                An inverted index mapping terms to document locations is the
                foundation of search engines and full-text search.

        - id: v8
          title: Invert a One-to-Many Map
          description: >-
            Write <code>func invertMap(m map[string][]string) map[string][]string</code>
            that inverts a one-to-many map. If <code>m["fruit"] = ["apple","banana"]</code>,
            the result has <code>"apple" → ["fruit"]</code> and <code>"banana" → ["fruit"]</code>.
          functionSignature: func invertMap(m map[string][]string) map[string][]string
          difficulty: 2
          testCases:
            - input: 'invertMap(map[string][]string{"fruit": {"apple","banana"}, "veg": {"carrot","apple"}})'
              output: 'map[apple:[fruit veg] banana:[fruit] carrot:[veg]]'
            - input: 'invertMap(map[string][]string{"a": {"x"}})'
              output: 'map[x:[a]]'
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                Iterate the original map. For each key-values pair, each value
                becomes a key in the inverted map with the original key appended
                to its slice.
            - title: "\U0001F4A1 Hint"
              content: >-
                Nested range: outer over the map, inner over the values slice.
                <code>inv[val] = append(inv[val], key)</code>.
          solution: |-
            func invertMap(m map[string][]string) map[string][]string {
                inv := make(map[string][]string)
                for key, vals := range m {
                    for _, val := range vals {
                        inv[val] = append(inv[val], key)
                    }
                }
                return inv
            }
          annotations:
            - type: pattern
              label: Map inversion
              text: >-
                Inverting a one-to-many map requires a nested loop. The result is
                always many-to-many since multiple keys can share values.

        - id: v9
          title: Merge Frequency Maps
          description: >-
            Write <code>func mergeFreq(maps ...map[string]int) map[string]int</code>
            that merges multiple frequency maps by summing counts for shared keys.
          functionSignature: func mergeFreq(maps ...map[string]int) map[string]int
          difficulty: 2
          testCases:
            - input: 'mergeFreq(map[string]int{"a":1,"b":2}, map[string]int{"b":3,"c":4})'
              output: 'map[a:1 b:5 c:4]'
            - input: 'mergeFreq(map[string]int{"x":10})'
              output: 'map[x:10]'
            - input: "mergeFreq()"
              output: "map[]"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                Create a result map and iterate through all input maps, adding
                each count to the running total.
            - title: "\U0001F4A1 Hint"
              content: >-
                Use variadic <code>...map[string]int</code> and nested loops.
                <code>result[k] += v</code> works because zero value of int is 0.
          solution: |-
            func mergeFreq(maps ...map[string]int) map[string]int {
                result := make(map[string]int)
                for _, m := range maps {
                    for k, v := range m {
                        result[k] += v
                    }
                }
                return result
            }
          annotations:
            - type: idiom
              label: Variadic map merging
              text: >-
                Using <code>...</code> for variadic parameters lets callers pass
                any number of maps. The zero-value addition trick avoids checking
                if a key exists.

        - id: v10
          title: Set Operations
          description: >-
            Write <code>func setOps(a, b []string) (union, intersect, diff []string)</code>
            that computes the union, intersection, and difference (a - b) of two
            string slices treated as sets.
          functionSignature: "func setOps(a, b []string) ([]string, []string, []string)"
          difficulty: 3
          testCases:
            - input: 'setOps([]string{"go","py","js"}, []string{"py","rs","js"})'
              output: '["go","js","py","rs"], ["js","py"], ["go"]'
            - input: 'setOps([]string{"a"}, []string{"a"})'
              output: '["a"], ["a"], []'
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                Convert both slices to maps for O(1) lookup, then compute each
                set operation by checking membership.
            - title: "\U0001F4A1 Hint"
              content: >-
                Build <code>setA</code> and <code>setB</code> as <code>map[string]bool</code>.
                Union = all keys from both. Intersection = keys in both.
                Difference = keys in A not in B.
          solution: |-
            func setOps(a, b []string) ([]string, []string, []string) {
                setA := make(map[string]bool)
                setB := make(map[string]bool)
                for _, s := range a {
                    setA[s] = true
                }
                for _, s := range b {
                    setB[s] = true
                }
                all := make(map[string]bool)
                for k := range setA {
                    all[k] = true
                }
                for k := range setB {
                    all[k] = true
                }
                var union, intersect, diff []string
                for k := range all {
                    union = append(union, k)
                }
                sort.Strings(union)
                for k := range setA {
                    if setB[k] {
                        intersect = append(intersect, k)
                    } else {
                        diff = append(diff, k)
                    }
                }
                sort.Strings(intersect)
                sort.Strings(diff)
                return union, intersect, diff
            }
          annotations:
            - type: pattern
              label: Map-based set operations
              text: >-
                Using <code>map[T]bool</code> for sets gives O(1) membership
                tests. Sort the results for deterministic output since map
                iteration order is random.

        - id: v11
          title: Build Adjacency List
          description: >-
            Write <code>func adjacencyList(edges [][2]string) map[string][]string</code>
            that builds an adjacency list from a list of undirected edges. Each
            edge connects two nodes in both directions.
          functionSignature: "func adjacencyList(edges [][2]string) map[string][]string"
          difficulty: 3
          testCases:
            - input: 'adjacencyList([][2]string{{"a","b"},{"b","c"},{"a","c"}})'
              output: 'map[a:[b c] b:[a c] c:[b a]]'
            - input: 'adjacencyList([][2]string{{"x","y"}})'
              output: 'map[x:[y] y:[x]]'
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                For each edge, add the connection in both directions since the
                graph is undirected.
            - title: "\U0001F4A1 Hint"
              content: >-
                For edge [u, v]: <code>graph[u] = append(graph[u], v)</code> and
                <code>graph[v] = append(graph[v], u)</code>.
          solution: |-
            func adjacencyList(edges [][2]string) map[string][]string {
                graph := make(map[string][]string)
                for _, edge := range edges {
                    u, v := edge[0], edge[1]
                    graph[u] = append(graph[u], v)
                    graph[v] = append(graph[v], u)
                }
                return graph
            }
          annotations:
            - type: pattern
              label: Adjacency list representation
              text: >-
                An adjacency list using <code>map[string][]string</code> is the
                standard way to represent sparse graphs in Go. It supports O(1)
                neighbor lookup.

        - id: v12
          title: Character Frequency Comparison
          description: >-
            Write <code>func canRearrange(s, t string) bool</code> that returns
            true if string s can be rearranged to form string t (they are
            anagrams of equal length, case-sensitive).
          functionSignature: func canRearrange(s, t string) bool
          difficulty: 3
          testCases:
            - input: 'canRearrange("listen", "silent")'
              output: "true"
            - input: 'canRearrange("hello", "bello")'
              output: "false"
            - input: 'canRearrange("aab", "aba")'
              output: "true"
            - input: 'canRearrange("ab", "abc")'
              output: "false"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                If two strings can be rearranged into each other, they must have
                exactly the same character counts. A single frequency map can
                check this efficiently.
            - title: "\U0001F4A1 Hint"
              content: >-
                Increment counts for s, decrement for t. If all counts are zero
                at the end, they are anagrams. Check lengths first as a fast path.
          solution: |-
            func canRearrange(s, t string) bool {
                if len(s) != len(t) {
                    return false
                }
                freq := make(map[rune]int)
                for _, ch := range s {
                    freq[ch]++
                }
                for _, ch := range t {
                    freq[ch]--
                }
                for _, count := range freq {
                    if count != 0 {
                        return false
                    }
                }
                return true
            }
          annotations:
            - type: idiom
              label: Single-map anagram check
              text: >-
                Using one map with increment/decrement is more efficient than
                building two separate maps. Any non-zero count means mismatch.

        - id: v13
          title: Top-K Frequent Elements
          description: >-
            Write <code>func topK(items []string, k int) []string</code> that
            returns the k most frequent strings, ordered from most to least
            frequent. Break ties alphabetically.
          functionSignature: func topK(items []string, k int) []string
          difficulty: 3
          testCases:
            - input: 'topK([]string{"a","b","a","c","b","a","c","c","b"}, 2)'
              output: '["a", "b"]'
            - input: 'topK([]string{"x","y","z"}, 1)'
              output: '["x"]'
            - input: 'topK([]string{"a","a","b","b"}, 2)'
              output: '["a", "b"]'
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                Count frequencies first, then sort unique keys by frequency
                (descending) and alphabetically for ties. Take the first k.
            - title: "\U0001F4A1 Hint"
              content: >-
                Build a frequency map, extract unique keys into a slice, sort
                with <code>sort.Slice</code> using a custom less function that
                compares counts then strings.
          solution: |-
            func topK(items []string, k int) []string {
                freq := make(map[string]int)
                for _, item := range items {
                    freq[item]++
                }
                keys := make([]string, 0, len(freq))
                for key := range freq {
                    keys = append(keys, key)
                }
                sort.Slice(keys, func(i, j int) bool {
                    if freq[keys[i]] != freq[keys[j]] {
                        return freq[keys[i]] > freq[keys[j]]
                    }
                    return keys[i] < keys[j]
                })
                if k > len(keys) {
                    k = len(keys)
                }
                return keys[:k]
            }
          annotations:
            - type: pattern
              label: Sort by derived value
              text: >-
                <code>sort.Slice</code> with a custom comparator lets you sort by
                any criteria. Sorting map keys by their values is a common pattern
                for ranking and top-K problems.

    # ── challenge_4: Comma-Ok Pattern ─────────────────────────────────────
    - id: challenge_4
      block: 2
      difficulty: 2
      concept: Comma-Ok Pattern
      docLinks:
        - url: https://go.dev/blog/maps
          title: "Go maps in action"
          note: map lookup patterns including comma-ok
        - url: https://go.dev/tour/moretypes/22
          title: "A Tour of Go: Mutating Maps"
          note: map operations and comma-ok idiom
      variants:
        - id: v1
          title: Safe Map Lookup With Default
          description: >-
            Write <code>func getOrDefault(m map[string]string, key, fallback string) string</code>
            that returns the value for <code>key</code> if it exists in the map,
            otherwise returns <code>fallback</code>.
          functionSignature: func getOrDefault(m map[string]string, key, fallback string) string
          difficulty: 1
          testCases:
            - input: 'getOrDefault(map[string]string{"a":"1"}, "a", "x")'
              output: '"1"'
            - input: 'getOrDefault(map[string]string{"a":"1"}, "b", "x")'
              output: '"x"'
            - input: 'getOrDefault(map[string]string{}, "a", "default")'
              output: '"default"'
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                How do you distinguish between a key that maps to the empty string
                and a key that does not exist at all?
            - title: "\U0001F4A1 Hint"
              content: >-
                Use the comma-ok pattern: <code>val, ok := m[key]</code>. If
                <code>ok</code> is false, return the fallback.
          solution: |-
            func getOrDefault(m map[string]string, key, fallback string) string {
                val, ok := m[key]
                if !ok {
                    return fallback
                }
                return val
            }
          annotations:
            - type: idiom
              label: Comma-ok for safe lookup
              text: >-
                The comma-ok pattern <code>val, ok := m[key]</code> is the
                idiomatic way to distinguish missing keys from zero values in Go.

        - id: v2
          title: Config With Fallback Values
          description: >-
            Write <code>func resolveConfig(config, defaults map[string]string) map[string]string</code>
            that returns a new map with all keys from <code>defaults</code>, overridden
            by any matching keys in <code>config</code>.
          functionSignature: func resolveConfig(config, defaults map[string]string) map[string]string
          difficulty: 1
          testCases:
            - input: 'resolveConfig(map[string]string{"port":"9090"}, map[string]string{"host":"localhost","port":"8080"})'
              output: 'map[host:localhost port:9090]'
            - input: 'resolveConfig(map[string]string{}, map[string]string{"a":"1"})'
              output: 'map[a:1]'
            - input: 'resolveConfig(map[string]string{"x":"y"}, map[string]string{})'
              output: 'map[x:y]'
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                Start with defaults and layer config on top. Which values should
                win when both maps have the same key?
            - title: "\U0001F4A1 Hint"
              content: >-
                Copy defaults into a new map first, then iterate config and
                overwrite. The comma-ok pattern is not needed here since you
                want all config keys regardless.
          solution: |-
            func resolveConfig(config, defaults map[string]string) map[string]string {
                result := make(map[string]string)
                for k, v := range defaults {
                    result[k] = v
                }
                for k, v := range config {
                    result[k] = v
                }
                return result
            }
          annotations:
            - type: idiom
              label: Merge maps with priority
              text: >-
                Copying a defaults map then overwriting with overrides is a
                common configuration pattern. The last write wins.

        - id: v3
          title: Feature Flag Checker
          description: >-
            Write <code>func isEnabled(flags map[string]bool, feature string) bool</code>
            that returns true only if the feature exists in the map AND is set
            to true. A missing feature is treated as disabled.
          functionSignature: func isEnabled(flags map[string]bool, feature string) bool
          difficulty: 1
          testCases:
            - input: 'isEnabled(map[string]bool{"darkMode":true,"beta":false}, "darkMode")'
              output: "true"
            - input: 'isEnabled(map[string]bool{"darkMode":true,"beta":false}, "beta")'
              output: "false"
            - input: 'isEnabled(map[string]bool{"darkMode":true}, "gamma")'
              output: "false"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                With a <code>map[string]bool</code>, a missing key returns
                false (zero value). Do you even need comma-ok here?
            - title: "\U0001F4A1 Hint"
              content: >-
                For bool maps, <code>m[key]</code> returns false for missing
                keys, which is exactly what you want. A simple
                <code>return flags[feature]</code> works.
          solution: |-
            func isEnabled(flags map[string]bool, feature string) bool {
                return flags[feature]
            }
          annotations:
            - type: insight
              label: Bool maps as sets
              text: >-
                When using <code>map[string]bool</code> as a set, the zero
                value (false) for missing keys is convenient — you can skip
                the comma-ok pattern entirely.

        - id: v4
          title: Permission Lookup
          description: >-
            Write <code>func checkPermission(perms map[string]string, user string) string</code>
            that looks up a user's permission level. Return <code>"guest"</code>
            if the user is not found.
          functionSignature: func checkPermission(perms map[string]string, user string) string
          difficulty: 1
          testCases:
            - input: 'checkPermission(map[string]string{"alice":"admin","bob":"editor"}, "alice")'
              output: '"admin"'
            - input: 'checkPermission(map[string]string{"alice":"admin","bob":"editor"}, "charlie")'
              output: '"guest"'
            - input: 'checkPermission(map[string]string{}, "anyone")'
              output: '"guest"'
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                You need to distinguish between a user who is not in the map
                and a user whose permission is the empty string.
            - title: "\U0001F4A1 Hint"
              content: >-
                Use <code>perm, ok := perms[user]</code> and return
                <code>"guest"</code> when <code>!ok</code>.
          solution: |-
            func checkPermission(perms map[string]string, user string) string {
                perm, ok := perms[user]
                if !ok {
                    return "guest"
                }
                return perm
            }
          annotations:
            - type: idiom
              label: Default for missing key
              text: >-
                The comma-ok pattern followed by a default assignment is
                the standard Go way to provide fallback values for map lookups.

        - id: v5
          title: Cache Hit/Miss Counter
          description: >-
            Write <code>func cacheStats(cache map[string]string, queries []string) (int, int)</code>
            that returns the number of cache hits and misses for the given queries.
          functionSignature: func cacheStats(cache map[string]string, queries []string) (int, int)
          difficulty: 1
          testCases:
            - input: 'cacheStats(map[string]string{"a":"1","b":"2"}, []string{"a","c","b","d"})'
              output: "2, 2"
            - input: 'cacheStats(map[string]string{}, []string{"x","y"})'
              output: "0, 2"
            - input: 'cacheStats(map[string]string{"x":"1"}, []string{"x","x","x"})'
              output: "3, 0"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                For each query, check if the key exists. You only need the
                <code>ok</code> part of the comma-ok result.
            - title: "\U0001F4A1 Hint"
              content: >-
                Use <code>_, ok := cache[q]</code> — discard the value with
                blank identifier since you only care whether the key exists.
          solution: |-
            func cacheStats(cache map[string]string, queries []string) (int, int) {
                hits, misses := 0, 0
                for _, q := range queries {
                    _, ok := cache[q]
                    if ok {
                        hits++
                    } else {
                        misses++
                    }
                }
                return hits, misses
            }
          annotations:
            - type: idiom
              label: Blank identifier with comma-ok
              text: >-
                Use <code>_, ok := m[key]</code> when you only need to know
                if a key exists but don't need its value.

        - id: v6
          title: Environment Variable With Default
          description: >-
            Write <code>func envOrDefault(env map[string]string, key, fallback string) string</code>
            that returns the environment variable value if it exists and is non-empty,
            otherwise returns the fallback. An empty string value should also trigger
            the fallback.
          functionSignature: func envOrDefault(env map[string]string, key, fallback string) string
          difficulty: 2
          testCases:
            - input: 'envOrDefault(map[string]string{"HOME":"/root"}, "HOME", "/tmp")'
              output: '"/root"'
            - input: 'envOrDefault(map[string]string{"HOME":""}, "HOME", "/tmp")'
              output: '"/tmp"'
            - input: 'envOrDefault(map[string]string{}, "PATH", "/usr/bin")'
              output: '"/usr/bin"'
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                The zero value of string is the empty string. So just checking
                the value is not enough — you also need comma-ok. Or do you?
            - title: "\U0001F4A1 Hint"
              content: >-
                Use comma-ok to check existence, then also check if the value
                is non-empty: <code>if ok && val != ""</code>.
          solution: |-
            func envOrDefault(env map[string]string, key, fallback string) string {
                val, ok := env[key]
                if ok && val != "" {
                    return val
                }
                return fallback
            }
          annotations:
            - type: idiom
              label: Comma-ok plus value check
              text: >-
                Sometimes a key exists but its value is the zero value. Combining
                comma-ok with an additional value check handles both missing
                keys and empty values.

        - id: v7
          title: Multilingual Greeting
          description: >-
            Write <code>func greet(greetings map[string]string, locale string) string</code>
            that looks up a greeting by locale code (e.g. <code>"en"</code>,
            <code>"es"</code>). If the locale is not found, return the greeting
            for <code>"en"</code>. If <code>"en"</code> is also missing, return
            <code>"Hello"</code>.
          functionSignature: func greet(greetings map[string]string, locale string) string
          difficulty: 2
          testCases:
            - input: 'greet(map[string]string{"en":"Hello","es":"Hola","fr":"Bonjour"}, "es")'
              output: '"Hola"'
            - input: 'greet(map[string]string{"en":"Hello","es":"Hola"}, "de")'
              output: '"Hello"'
            - input: 'greet(map[string]string{"es":"Hola"}, "de")'
              output: '"Hello"'
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                This is a chain of fallbacks: try the locale, then try "en",
                then use a hardcoded default. Each step uses comma-ok.
            - title: "\U0001F4A1 Hint"
              content: >-
                Check <code>greetings[locale]</code> first, then
                <code>greetings["en"]</code>, then return <code>"Hello"</code>.
          solution: |-
            func greet(greetings map[string]string, locale string) string {
                if msg, ok := greetings[locale]; ok {
                    return msg
                }
                if msg, ok := greetings["en"]; ok {
                    return msg
                }
                return "Hello"
            }
          annotations:
            - type: idiom
              label: Fallback chain with comma-ok
              text: >-
                Chaining multiple comma-ok lookups creates a clean fallback
                hierarchy. Each <code>if val, ok := m[key]; ok</code> block
                tries one level before falling through.

        - id: v8
          title: Safe Type Assertion Pattern
          description: >-
            Write <code>func safeString(val interface{}) string</code> that attempts
            a type assertion to string. If the value is a string, return it.
            Otherwise, return <code>fmt.Sprintf("%v", val)</code>.
          functionSignature: func safeString(val interface{}) string
          difficulty: 2
          testCases:
            - input: 'safeString("hello")'
              output: '"hello"'
            - input: "safeString(42)"
              output: '"42"'
            - input: "safeString(true)"
              output: '"true"'
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                Type assertions in Go also support the comma-ok pattern,
                just like map lookups. How does <code>val.(string)</code>
                differ from <code>val, ok := val.(string)</code>?
            - title: "\U0001F4A1 Hint"
              content: >-
                Use <code>s, ok := val.(string)</code> to safely assert.
                If <code>!ok</code>, use <code>fmt.Sprintf</code> as fallback.
          solution: |-
            func safeString(val interface{}) string {
                s, ok := val.(string)
                if ok {
                    return s
                }
                return fmt.Sprintf("%v", val)
            }
          annotations:
            - type: idiom
              label: Comma-ok type assertion
              text: >-
                The comma-ok pattern works with type assertions too:
                <code>s, ok := val.(string)</code> avoids panics when the
                type does not match. Always use this form in production code.

        - id: v9
          title: Nested Map Lookup
          description: >-
            Write <code>func nestedGet(m map[string]map[string]string, outer, inner string) string</code>
            that safely looks up a value in a nested map. Return <code>""</code>
            if either the outer or inner key is missing.
          functionSignature: func nestedGet(m map[string]map[string]string, outer, inner string) string
          difficulty: 2
          testCases:
            - input: 'nestedGet(map[string]map[string]string{"db":{"host":"localhost"}}, "db", "host")'
              output: '"localhost"'
            - input: 'nestedGet(map[string]map[string]string{"db":{"host":"localhost"}}, "db", "port")'
              output: '""'
            - input: 'nestedGet(map[string]map[string]string{}, "db", "host")'
              output: '""'
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                With nested maps, you need two comma-ok checks. What happens if
                you try to look up a key in a nil map?
            - title: "\U0001F4A1 Hint"
              content: >-
                First check <code>innerMap, ok := m[outer]</code>, then
                check <code>val, ok := innerMap[inner]</code>. Both must succeed.
          solution: |-
            func nestedGet(m map[string]map[string]string, outer, inner string) string {
                innerMap, ok := m[outer]
                if !ok {
                    return ""
                }
                val, ok := innerMap[inner]
                if !ok {
                    return ""
                }
                return val
            }
          annotations:
            - type: idiom
              label: Chained comma-ok for nested maps
              text: >-
                Each level of map nesting requires its own comma-ok check.
                Accessing a nil map does not panic (it returns the zero value),
                but using comma-ok makes intent explicit.

        - id: v10
          title: Rate Limit Checker
          description: >-
            Write <code>func isRateLimited(counters map[string]int, user string, limit int) bool</code>
            that checks if a user has exceeded their rate limit. If the user has
            no entry, they are not limited. Also increment their counter.
          functionSignature: func isRateLimited(counters map[string]int, user string, limit int) bool
          difficulty: 2
          testCases:
            - input: 'isRateLimited(map[string]int{"alice":5}, "alice", 5)'
              output: "true"
            - input: 'isRateLimited(map[string]int{"alice":3}, "alice", 5)'
              output: "false"
            - input: 'isRateLimited(map[string]int{}, "bob", 10)'
              output: "false"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                For int maps, the zero value is 0, so a missing user
                automatically starts at 0. Do you need comma-ok here?
            - title: "\U0001F4A1 Hint"
              content: >-
                Check if <code>counters[user] >= limit</code> first, then
                increment with <code>counters[user]++</code>.
          solution: |-
            func isRateLimited(counters map[string]int, user string, limit int) bool {
                if counters[user] >= limit {
                    return true
                }
                counters[user]++
                return false
            }
          annotations:
            - type: insight
              label: Zero value advantage with int maps
              text: >-
                For <code>map[string]int</code>, missing keys return 0.
                This means <code>counters[user]++</code> works even for
                new users without initialization.

        - id: v11
          title: Router Dispatch
          description: >-
            Write <code>func dispatch(routes map[string]string, path string) string</code>
            that looks up a handler name for a given URL path. If no route matches,
            return <code>"404 Not Found"</code>. Also try a wildcard route <code>"*"</code>
            before returning 404.
          functionSignature: func dispatch(routes map[string]string, path string) string
          difficulty: 2
          testCases:
            - input: 'dispatch(map[string]string{"/":"home","/about":"about","*":"fallback"}, "/about")'
              output: '"about"'
            - input: 'dispatch(map[string]string{"/":"home","*":"fallback"}, "/missing")'
              output: '"fallback"'
            - input: 'dispatch(map[string]string{"/":"home"}, "/missing")'
              output: '"404 Not Found"'
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                You need two comma-ok checks: first the exact path, then the
                wildcard. This creates a lookup chain.
            - title: "\U0001F4A1 Hint"
              content: >-
                Try <code>routes[path]</code> first, then
                <code>routes["*"]</code>, then return the 404 string.
          solution: |-
            func dispatch(routes map[string]string, path string) string {
                if handler, ok := routes[path]; ok {
                    return handler
                }
                if handler, ok := routes["*"]; ok {
                    return handler
                }
                return "404 Not Found"
            }
          annotations:
            - type: pattern
              label: Multi-level lookup chain
              text: >-
                Chaining comma-ok lookups for exact match then wildcard match
                is a common pattern in routers, config resolvers, and i18n
                systems.

        - id: v12
          title: DNS Resolver With TTL Check
          description: >-
            Write <code>func resolve(cache map[string]int, domain string, currentTime int) string</code>
            that checks if a domain is in the cache and its TTL (stored as expiry
            timestamp) has not passed. Return <code>"HIT"</code> if cached and
            valid, <code>"EXPIRED"</code> if cached but expired, or
            <code>"MISS"</code> if not cached.
          functionSignature: func resolve(cache map[string]int, domain string, currentTime int) string
          difficulty: 3
          testCases:
            - input: 'resolve(map[string]int{"go.dev":1000}, "go.dev", 500)'
              output: '"HIT"'
            - input: 'resolve(map[string]int{"go.dev":1000}, "go.dev", 1500)'
              output: '"EXPIRED"'
            - input: 'resolve(map[string]int{"go.dev":1000}, "rust-lang.org", 500)'
              output: '"MISS"'
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                Use comma-ok to check existence, then compare the expiry
                timestamp against currentTime.
            - title: "\U0001F4A1 Hint"
              content: >-
                <code>expiry, ok := cache[domain]</code> — if <code>!ok</code>
                return "MISS", if <code>currentTime > expiry</code> return
                "EXPIRED", else "HIT".
          solution: |-
            func resolve(cache map[string]int, domain string, currentTime int) string {
                expiry, ok := cache[domain]
                if !ok {
                    return "MISS"
                }
                if currentTime > expiry {
                    return "EXPIRED"
                }
                return "HIT"
            }
          annotations:
            - type: pattern
              label: Comma-ok plus value validation
              text: >-
                After confirming a key exists with comma-ok, you often need
                to validate the value itself. This two-step check (exists +
                valid) is common in caching and expiry logic.

        - id: v13
          title: Circuit Breaker State Machine
          description: >-
            Write <code>func circuitAction(states map[string]string, service string) string</code>
            that implements a simple circuit breaker. Look up the service state:
            <code>"closed"</code> means allow (return <code>"ALLOW"</code>),
            <code>"open"</code> means block (return <code>"BLOCK"</code>),
            <code>"half-open"</code> means allow with caution (return
            <code>"PROBE"</code>). If the service is not in the map, treat it
            as closed (allow).
          functionSignature: func circuitAction(states map[string]string, service string) string
          difficulty: 3
          testCases:
            - input: 'circuitAction(map[string]string{"api":"open","db":"closed"}, "api")'
              output: '"BLOCK"'
            - input: 'circuitAction(map[string]string{"api":"half-open"}, "api")'
              output: '"PROBE"'
            - input: 'circuitAction(map[string]string{}, "unknown")'
              output: '"ALLOW"'
            - input: 'circuitAction(map[string]string{"db":"closed"}, "db")'
              output: '"ALLOW"'
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                Use comma-ok to get the state, default to "closed" if missing,
                then use a switch or if-else chain to map states to actions.
            - title: "\U0001F4A1 Hint"
              content: >-
                After lookup, use <code>switch state { case "open": ...
                case "half-open": ... default: ... }</code> to map each
                state to its action.
          solution: |-
            func circuitAction(states map[string]string, service string) string {
                state, ok := states[service]
                if !ok {
                    state = "closed"
                }
                switch state {
                case "open":
                    return "BLOCK"
                case "half-open":
                    return "PROBE"
                default:
                    return "ALLOW"
                }
            }
          annotations:
            - type: pattern
              label: Comma-ok with state machine
              text: >-
                Combining comma-ok with a switch statement is a clean way
                to implement state-driven behavior. The default branch
                handles both the "closed" state and any unexpected values.

    # ── challenge_5: Strings & Runes ──────────────────────────────────────
    - id: challenge_5
      block: 2
      difficulty: 2
      concept: Strings & Runes
      docLinks:
        - url: https://go.dev/blog/strings
          title: "Strings, bytes, runes and characters in Go"
          note: essential reading on string internals
        - url: https://pkg.go.dev/unicode/utf8
          title: "Package utf8"
          note: UTF-8 encoding utilities
      variants:
        - id: v1
          title: Count Runes vs Bytes
          description: >-
            Write <code>func countRunesAndBytes(s string) (int, int)</code> that
            returns the number of runes and the number of bytes in the string.
          functionSignature: func countRunesAndBytes(s string) (int, int)
          difficulty: 1
          testCases:
            - input: 'countRunesAndBytes("Hello")'
              output: "5, 5"
            - input: 'countRunesAndBytes("日本語")'
              output: "3, 9"
            - input: 'countRunesAndBytes("")'
              output: "0, 0"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                In Go, <code>len(s)</code> gives bytes, not characters. Which
                function from <code>unicode/utf8</code> counts runes?
            - title: "\U0001F4A1 Hint"
              content: >-
                Use <code>utf8.RuneCountInString(s)</code> for rune count
                and <code>len(s)</code> for byte count.
          solution: |-
            func countRunesAndBytes(s string) (int, int) {
                return utf8.RuneCountInString(s), len(s)
            }
          annotations:
            - type: insight
              label: Bytes vs runes
              text: >-
                In Go, strings are byte slices. <code>len(s)</code> returns
                bytes, not characters. Use <code>utf8.RuneCountInString</code>
                for the true character count.

        - id: v2
          title: Safe Character Substring
          description: >-
            Write <code>func runeSubstring(s string, start, end int) string</code>
            that returns a substring from rune index <code>start</code> to
            <code>end</code> (exclusive). Clamp indices to valid bounds.
          functionSignature: func runeSubstring(s string, start, end int) string
          difficulty: 1
          testCases:
            - input: 'runeSubstring("Hello, 世界!", 7, 9)'
              output: '"世界"'
            - input: 'runeSubstring("abc", 0, 2)'
              output: '"ab"'
            - input: 'runeSubstring("abc", 0, 100)'
              output: '"abc"'
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                Converting a string to a rune slice gives you indexable
                characters. What happens when you slice a rune slice?
            - title: "\U0001F4A1 Hint"
              content: >-
                Convert to runes: <code>runes := []rune(s)</code>, clamp
                bounds, then return <code>string(runes[start:end])</code>.
          solution: |-
            func runeSubstring(s string, start, end int) string {
                runes := []rune(s)
                if start < 0 {
                    start = 0
                }
                if end > len(runes) {
                    end = len(runes)
                }
                if start >= end {
                    return ""
                }
                return string(runes[start:end])
            }
          annotations:
            - type: idiom
              label: Rune slice for character indexing
              text: >-
                Converting to <code>[]rune</code> is the simplest way to
                index by character position. It allocates a new slice but
                makes character operations straightforward.

        - id: v3
          title: Count Non-ASCII Characters
          description: >-
            Write <code>func countNonASCII(s string) int</code> that returns the
            number of characters (runes) with a code point above 127.
          functionSignature: func countNonASCII(s string) int
          difficulty: 1
          testCases:
            - input: 'countNonASCII("Hello, 世界!")'
              output: "2"
            - input: 'countNonASCII("ASCII only")'
              output: "0"
            - input: 'countNonASCII("café")'
              output: "1"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                Ranging over a string in Go gives you runes. How do you
                check if a rune is outside the ASCII range?
            - title: "\U0001F4A1 Hint"
              content: >-
                Use <code>for _, r := range s</code> and count runes where
                <code>r > 127</code>.
          solution: |-
            func countNonASCII(s string) int {
                count := 0
                for _, r := range s {
                    if r > 127 {
                        count++
                    }
                }
                return count
            }
          annotations:
            - type: insight
              label: Range over string yields runes
              text: >-
                <code>for _, r := range s</code> decodes UTF-8 on the fly,
                yielding each rune. This is safer than indexing bytes directly.

        - id: v4
          title: Reverse a String (Rune-Safe)
          description: >-
            Write <code>func reverseString(s string) string</code> that reverses
            a string correctly, even when it contains multi-byte UTF-8 characters.
          functionSignature: func reverseString(s string) string
          difficulty: 1
          testCases:
            - input: 'reverseString("Hello")'
              output: '"olleH"'
            - input: 'reverseString("日本語")'
              output: '"語本日"'
            - input: 'reverseString("")'
              output: '""'
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                Reversing bytes would break multi-byte characters. You need
                to reverse at the rune level.
            - title: "\U0001F4A1 Hint"
              content: >-
                Convert to <code>[]rune</code>, reverse the rune slice with
                a two-pointer swap, then convert back to string.
          solution: |-
            func reverseString(s string) string {
                runes := []rune(s)
                for i, j := 0, len(runes)-1; i < j; i, j = i+1, j-1 {
                    runes[i], runes[j] = runes[j], runes[i]
                }
                return string(runes)
            }
          annotations:
            - type: idiom
              label: Two-pointer rune reversal
              text: >-
                Converting to <code>[]rune</code> then swapping from both
                ends is the idiomatic way to reverse a string in Go while
                preserving Unicode correctness.

        - id: v5
          title: Title Case a Sentence
          description: >-
            Write <code>func titleCase(s string) string</code> that capitalizes
            the first letter of each word. Words are separated by spaces.
            For example, <code>"hello world"</code> becomes <code>"Hello World"</code>.
          functionSignature: func titleCase(s string) string
          difficulty: 2
          testCases:
            - input: 'titleCase("hello world")'
              output: '"Hello World"'
            - input: 'titleCase("go is great")'
              output: '"Go Is Great"'
            - input: 'titleCase("")'
              output: '""'
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                Split into words, capitalize the first rune of each word,
                then rejoin. Which function uppercases a rune?
            - title: "\U0001F4A1 Hint"
              content: >-
                Use <code>strings.Fields</code> to split, then for each word
                convert to runes, apply <code>unicode.ToUpper</code> to the
                first rune, and rejoin with <code>strings.Join</code>.
          solution: |-
            func titleCase(s string) string {
                words := strings.Fields(s)
                for i, word := range words {
                    runes := []rune(word)
                    runes[0] = unicode.ToUpper(runes[0])
                    words[i] = string(runes)
                }
                return strings.Join(words, " ")
            }
          annotations:
            - type: idiom
              label: Rune manipulation for case
              text: >-
                Use <code>unicode.ToUpper</code> and <code>unicode.ToLower</code>
                on individual runes for Unicode-correct case conversion.

        - id: v6
          title: Palindrome Check (Unicode-Safe)
          description: >-
            Write <code>func isPalindrome(s string) bool</code> that checks if a
            string is a palindrome, ignoring case. Works correctly with Unicode.
            For example, <code>"Abba"</code> is a palindrome.
          functionSignature: func isPalindrome(s string) bool
          difficulty: 2
          testCases:
            - input: 'isPalindrome("Abba")'
              output: "true"
            - input: 'isPalindrome("racecar")'
              output: "true"
            - input: 'isPalindrome("hello")'
              output: "false"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                Lowercase the entire string first, then compare runes from
                both ends moving inward.
            - title: "\U0001F4A1 Hint"
              content: >-
                Use <code>strings.ToLower(s)</code>, convert to runes, then
                compare <code>runes[i]</code> with <code>runes[len-1-i]</code>.
          solution: |-
            func isPalindrome(s string) bool {
                runes := []rune(strings.ToLower(s))
                for i, j := 0, len(runes)-1; i < j; i, j = i+1, j-1 {
                    if runes[i] != runes[j] {
                        return false
                    }
                }
                return true
            }
          annotations:
            - type: idiom
              label: Normalize then compare
              text: >-
                Lowercasing before comparison handles case insensitivity.
                Working with runes ensures multi-byte characters are compared
                correctly.

        - id: v7
          title: Count Vowels in Multilingual Text
          description: >-
            Write <code>func countVowels(s string) int</code> that counts English
            vowels (a, e, i, o, u) case-insensitively in the given string.
          functionSignature: func countVowels(s string) int
          difficulty: 2
          testCases:
            - input: 'countVowels("Hello World")'
              output: "3"
            - input: 'countVowels("AEIOU aeiou")'
              output: "10"
            - input: 'countVowels("bcdfg")'
              output: "0"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                Use a set (map or string) of vowels and check each rune
                against it after lowercasing.
            - title: "\U0001F4A1 Hint"
              content: >-
                Use <code>strings.ContainsRune("aeiou", unicode.ToLower(r))</code>
                to check if each rune is a vowel.
          solution: |-
            func countVowels(s string) int {
                count := 0
                for _, r := range s {
                    if strings.ContainsRune("aeiou", unicode.ToLower(r)) {
                        count++
                    }
                }
                return count
            }
          annotations:
            - type: idiom
              label: Set membership with ContainsRune
              text: >-
                Using <code>strings.ContainsRune</code> with a string of
                characters is a concise alternative to a map-based set for
                small character sets.

        - id: v8
          title: Truncate at Word Boundary
          description: >-
            Write <code>func truncate(s string, maxRunes int) string</code> that
            truncates a string to at most <code>maxRunes</code> runes. If truncated,
            cut at the last space before the limit and append <code>"..."</code>.
            If no space is found, hard-cut at the limit.
          functionSignature: func truncate(s string, maxRunes int) string
          difficulty: 2
          testCases:
            - input: 'truncate("The quick brown fox jumps over", 15)'
              output: '"The quick brown..."'
            - input: 'truncate("Short", 10)'
              output: '"Short"'
            - input: 'truncate("Superlongword here", 8)'
              output: '"Superlon..."'
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                Convert to runes to respect character boundaries. After
                slicing, look backwards for a space to break at a word.
            - title: "\U0001F4A1 Hint"
              content: >-
                Slice runes to maxRunes, then search backward for a space
                using a loop. If found, cut there and add "...".
          solution: |-
            func truncate(s string, maxRunes int) string {
                runes := []rune(s)
                if len(runes) <= maxRunes {
                    return s
                }
                cut := maxRunes
                for i := maxRunes - 1; i >= 0; i-- {
                    if runes[i] == ' ' {
                        cut = i
                        break
                    }
                }
                return string(runes[:cut]) + "..."
            }
          annotations:
            - type: pattern
              label: Word-boundary truncation
              text: >-
                Truncating at word boundaries produces cleaner output. Searching
                backward from the limit for a space is a simple approach that
                avoids splitting words.

        - id: v9
          title: Mask Credit Card Number
          description: >-
            Write <code>func maskCard(card string) string</code> that replaces all
            but the last 4 characters with <code>'*'</code>. Works with any string
            length. If the string has 4 or fewer characters, return it unchanged.
          functionSignature: func maskCard(card string) string
          difficulty: 2
          testCases:
            - input: 'maskCard("4111111111111111")'
              output: '"************1111"'
            - input: 'maskCard("1234")'
              output: '"1234"'
            - input: 'maskCard("12345")'
              output: '"*2345"'
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                Convert to runes so you handle any character set. Replace
                runes at indices 0 through len-5 with '*'.
            - title: "\U0001F4A1 Hint"
              content: >-
                Use <code>runes := []rune(card)</code>, loop from 0 to
                <code>len(runes)-4</code>, set each to <code>'*'</code>,
                then return <code>string(runes)</code>.
          solution: |-
            func maskCard(card string) string {
                runes := []rune(card)
                if len(runes) <= 4 {
                    return card
                }
                for i := 0; i < len(runes)-4; i++ {
                    runes[i] = '*'
                }
                return string(runes)
            }
          annotations:
            - type: pattern
              label: In-place rune modification
              text: >-
                Converting to <code>[]rune</code>, modifying in place, then
                converting back is efficient for character-level transformations.

        - id: v10
          title: Extract Hashtags
          description: >-
            Write <code>func extractHashtags(tweet string) []string</code> that
            returns all hashtags (words starting with <code>#</code>) from a tweet.
            Return the tags without the <code>#</code> prefix, lowercased.
          functionSignature: func extractHashtags(tweet string) []string
          difficulty: 2
          testCases:
            - input: 'extractHashtags("Love #Go and #OpenSource!")'
              output: '["go", "opensource"]'
            - input: 'extractHashtags("No tags here")'
              output: "[]"
            - input: 'extractHashtags("#Hello #WORLD #test")'
              output: '["hello", "world", "test"]'
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                Split into words, filter those starting with "#", then strip
                the prefix and lowercase.
            - title: "\U0001F4A1 Hint"
              content: >-
                Use <code>strings.Fields</code>, check
                <code>strings.HasPrefix(word, "#")</code>, then use
                <code>strings.ToLower(word[1:])</code>.
          solution: |-
            func extractHashtags(tweet string) []string {
                words := strings.Fields(tweet)
                var tags []string
                for _, word := range words {
                    if strings.HasPrefix(word, "#") && len(word) > 1 {
                        tag := strings.ToLower(word[1:])
                        tag = strings.TrimRight(tag, "!.,;:?")
                        tags = append(tags, tag)
                    }
                }
                return tags
            }
          annotations:
            - type: pattern
              label: String prefix filtering
              text: >-
                Combining <code>strings.HasPrefix</code> with slicing
                (<code>word[1:]</code>) is a clean way to detect and strip
                prefixes from strings.

        - id: v11
          title: Slug Generator
          description: >-
            Write <code>func slugify(title string) string</code> that converts a
            title to a URL slug: lowercase, replace spaces with hyphens, remove
            non-alphanumeric characters (except hyphens).
          functionSignature: func slugify(title string) string
          difficulty: 3
          testCases:
            - input: 'slugify("Hello, World!")'
              output: '"hello-world"'
            - input: 'slugify("Go is #1 Language")'
              output: '"go-is-1-language"'
            - input: 'slugify("  Multiple   Spaces  ")'
              output: '"multiple-spaces"'
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                Process rune by rune: keep letters and digits (lowercased),
                convert spaces to hyphens, skip everything else. Then clean
                up consecutive hyphens.
            - title: "\U0001F4A1 Hint"
              content: >-
                Use <code>unicode.IsLetter</code> and <code>unicode.IsDigit</code>
                to filter characters. Use <code>strings.Builder</code> for
                efficient string building.
          solution: |-
            func slugify(title string) string {
                var b strings.Builder
                prevHyphen := false
                for _, r := range strings.ToLower(strings.TrimSpace(title)) {
                    if unicode.IsLetter(r) || unicode.IsDigit(r) {
                        b.WriteRune(r)
                        prevHyphen = false
                    } else if r == ' ' && !prevHyphen {
                        b.WriteRune('-')
                        prevHyphen = true
                    }
                }
                return strings.TrimRight(b.String(), "-")
            }
          annotations:
            - type: idiom
              label: strings.Builder for efficiency
              text: >-
                <code>strings.Builder</code> avoids repeated string
                concatenation allocations. Use it when building strings
                character by character.

        - id: v12
          title: ROT13 Cipher
          description: >-
            Write <code>func rot13(s string) string</code> that applies ROT13
            encoding: shift each letter by 13 positions in the alphabet. Non-letter
            characters remain unchanged. Works for both upper and lowercase.
          functionSignature: func rot13(s string) string
          difficulty: 3
          testCases:
            - input: 'rot13("Hello")'
              output: '"Uryyb"'
            - input: 'rot13("Uryyb")'
              output: '"Hello"'
            - input: 'rot13("Go 1.21!")'
              output: '"Tb 1.21!"'
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                For each letter, determine if it's A-Z or a-z, shift by 13,
                and wrap around using modular arithmetic.
            - title: "\U0001F4A1 Hint"
              content: >-
                For a rune in 'A'-'Z': <code>'A' + (r - 'A' + 13) % 26</code>.
                Same pattern for lowercase with <code>'a'</code>.
          solution: |-
            func rot13(s string) string {
                runes := []rune(s)
                for i, r := range runes {
                    switch {
                    case r >= 'A' && r <= 'Z':
                        runes[i] = 'A' + (r-'A'+13)%26
                    case r >= 'a' && r <= 'z':
                        runes[i] = 'a' + (r-'a'+13)%26
                    }
                }
                return string(runes)
            }
          annotations:
            - type: pattern
              label: Modular arithmetic for wrapping
              text: >-
                The <code>(r - base + shift) % 26</code> pattern wraps
                characters around the alphabet. This is the foundation
                of many simple ciphers.

        - id: v13
          title: Caesar Cipher With Unicode Awareness
          description: >-
            Write <code>func caesarCipher(s string, shift int) string</code> that
            shifts only ASCII letters by <code>shift</code> positions (wrapping
            around). Non-ASCII runes and non-letter characters remain unchanged.
            Shift can be negative.
          functionSignature: func caesarCipher(s string, shift int) string
          difficulty: 3
          testCases:
            - input: 'caesarCipher("Hello, 世界!", 3)'
              output: '"Khoor, 世界!"'
            - input: 'caesarCipher("Khoor", -3)'
              output: '"Hello"'
            - input: 'caesarCipher("XYZ", 3)'
              output: '"ABC"'
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                Handle negative shifts by normalizing: add 26 and take mod 26.
                Only transform ASCII letters; leave everything else untouched.
            - title: "\U0001F4A1 Hint"
              content: >-
                Normalize shift: <code>shift = ((shift % 26) + 26) % 26</code>.
                Then for ASCII letters, apply the shift with modular wrapping.
          solution: |-
            func caesarCipher(s string, shift int) string {
                shift = ((shift % 26) + 26) % 26
                runes := []rune(s)
                for i, r := range runes {
                    switch {
                    case r >= 'A' && r <= 'Z':
                        runes[i] = 'A' + (r-'A'+rune(shift))%26
                    case r >= 'a' && r <= 'z':
                        runes[i] = 'a' + (r-'a'+rune(shift))%26
                    }
                }
                return string(runes)
            }
          annotations:
            - type: pattern
              label: Shift normalization
              text: >-
                The <code>((shift % 26) + 26) % 26</code> pattern normalizes
                any integer (including negative) to a valid shift in [0, 25].
                This is a standard modular arithmetic trick.

    # ── challenge_6: Go Fundamentals Combined ─────────────────────────────
    - id: challenge_6
      block: 3
      difficulty: 3
      concept: Go Fundamentals Combined
      docLinks:
        - url: https://go.dev/doc/effective_go
          title: "Effective Go"
          note: comprehensive guide to idiomatic Go
        - url: https://pkg.go.dev/fmt#Sprintf
          title: "fmt.Sprintf"
          note: formatted string building
      variants:
        - id: v1
          title: Run-Length Encoding
          description: >-
            Write <code>func rleEncode(s string) string</code> that compresses a
            string using run-length encoding. Consecutive identical characters are
            replaced with the character followed by the count. Single characters
            have no count suffix. Example: <code>"aaabbc"</code> becomes
            <code>"a3b2c"</code>.
          functionSignature: func rleEncode(s string) string
          difficulty: 1
          testCases:
            - input: 'rleEncode("aaabbc")'
              output: '"a3b2c"'
            - input: 'rleEncode("abc")'
              output: '"abc"'
            - input: 'rleEncode("aaa")'
              output: '"a3"'
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                Walk through the runes, counting consecutive duplicates.
                When the character changes, emit the character and its count
                (if greater than 1).
            - title: "\U0001F4A1 Hint"
              content: >-
                Convert to runes. Track the current rune and count. When the
                rune changes (or at end), write the rune and conditionally the
                count using <code>strconv.Itoa</code>.
          solution: |-
            func rleEncode(s string) string {
                runes := []rune(s)
                if len(runes) == 0 {
                    return ""
                }
                var b strings.Builder
                count := 1
                for i := 1; i <= len(runes); i++ {
                    if i < len(runes) && runes[i] == runes[i-1] {
                        count++
                    } else {
                        b.WriteRune(runes[i-1])
                        if count > 1 {
                            b.WriteString(strconv.Itoa(count))
                        }
                        count = 1
                    }
                }
                return b.String()
            }
          annotations:
            - type: pattern
              label: Run-length encoding
              text: >-
                RLE is a simple compression that replaces consecutive duplicates
                with a count. The sentinel pattern (looping to <code>len+1</code>
                or checking at end) avoids special-casing the last group.

        - id: v2
          title: Inventory Report With Sorted Output
          description: >-
            Write <code>func inventoryReport(items map[string]int) string</code>
            that returns a sorted inventory report. Each line is
            <code>"item: count"</code>, sorted alphabetically by item name.
            Lines are separated by newlines.
          functionSignature: func inventoryReport(items map[string]int) string
          difficulty: 1
          testCases:
            - input: 'inventoryReport(map[string]int{"banana":3,"apple":5,"cherry":1})'
              output: '"apple: 5\nbanana: 3\ncherry: 1"'
            - input: 'inventoryReport(map[string]int{"x":1})'
              output: '"x: 1"'
            - input: 'inventoryReport(map[string]int{})'
              output: '""'
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                Maps have no guaranteed iteration order. You need to extract
                keys, sort them, then iterate in sorted order.
            - title: "\U0001F4A1 Hint"
              content: >-
                Extract keys into a slice, use <code>sort.Strings</code>,
                then build the report string with <code>fmt.Sprintf</code>.
          solution: |-
            func inventoryReport(items map[string]int) string {
                keys := make([]string, 0, len(items))
                for k := range items {
                    keys = append(keys, k)
                }
                sort.Strings(keys)
                var lines []string
                for _, k := range keys {
                    lines = append(lines, fmt.Sprintf("%s: %d", k, items[k]))
                }
                return strings.Join(lines, "\n")
            }
          annotations:
            - type: idiom
              label: Sorted map iteration
              text: >-
                Extract keys, sort, then iterate — this is the standard Go
                pattern for deterministic map traversal since map iteration
                order is randomized.

        - id: v3
          title: Contact Search With Multi-Field Filter
          description: >-
            Write <code>func searchContacts(contacts []map[string]string, query string) []string</code>
            that returns names of contacts where <code>query</code> appears
            (case-insensitive) in any field value. Return names sorted alphabetically.
          functionSignature: func searchContacts(contacts []map[string]string, query string) []string
          difficulty: 1
          testCases:
            - input: 'searchContacts([]map[string]string{{"name":"Alice","email":"alice@go.dev"},{"name":"Bob","email":"bob@rust.dev"}}, "go")'
              output: '["Alice"]'
            - input: 'searchContacts([]map[string]string{{"name":"Alice","city":"Gopher Town"},{"name":"Bob","city":"Gopher City"}}, "gopher")'
              output: '["Alice", "Bob"]'
            - input: 'searchContacts([]map[string]string{{"name":"Alice"}}, "xyz")'
              output: "[]"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                For each contact, check every field value for a case-insensitive
                match. If any field matches, include that contact's name.
            - title: "\U0001F4A1 Hint"
              content: >-
                Use <code>strings.Contains(strings.ToLower(val), strings.ToLower(query))</code>
                to check each field. Collect matching names and sort.
          solution: |-
            func searchContacts(contacts []map[string]string, query string) []string {
                q := strings.ToLower(query)
                var names []string
                for _, c := range contacts {
                    for _, val := range c {
                        if strings.Contains(strings.ToLower(val), q) {
                            names = append(names, c["name"])
                            break
                        }
                    }
                }
                sort.Strings(names)
                return names
            }
          annotations:
            - type: pattern
              label: Multi-field search
              text: >-
                Iterating all map values for a substring match creates a
                simple but flexible search. The <code>break</code> after
                the first match avoids duplicate results per contact.

        - id: v4
          title: CSV Parser and Aggregator
          description: >-
            Write <code>func csvSum(csv string, col int) float64</code> that parses
            a CSV string (newline-separated rows, comma-separated columns) and
            returns the sum of the numeric values in the given column index
            (0-based). Skip the header row. Non-numeric values are treated as 0.
          functionSignature: func csvSum(csv string, col int) float64
          difficulty: 2
          testCases:
            - input: 'csvSum("name,score\nAlice,90\nBob,85\nCharlie,95", 1)'
              output: "270"
            - input: 'csvSum("x,y\n1,2\n3,4", 0)'
              output: "4"
            - input: 'csvSum("a,b\nx,y\nz,w", 1)'
              output: "0"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                Split by newlines to get rows, split each row by commas.
                Skip row 0 (header). Parse the target column with
                <code>strconv.ParseFloat</code>.
            - title: "\U0001F4A1 Hint"
              content: >-
                Use <code>strings.Split(csv, "\n")</code> for rows, then
                <code>strings.Split(row, ",")</code> for columns. Use
                <code>strconv.ParseFloat(field, 64)</code> and ignore errors.
          solution: |-
            func csvSum(csv string, col int) float64 {
                rows := strings.Split(csv, "\n")
                sum := 0.0
                for i := 1; i < len(rows); i++ {
                    fields := strings.Split(rows[i], ",")
                    if col < len(fields) {
                        val, err := strconv.ParseFloat(strings.TrimSpace(fields[col]), 64)
                        if err == nil {
                            sum += val
                        }
                    }
                }
                return sum
            }
          annotations:
            - type: pattern
              label: Graceful error handling with strconv
              text: >-
                Using <code>strconv.ParseFloat</code> and checking <code>err</code>
                lets you skip non-numeric values cleanly rather than crashing
                on bad input.

        - id: v5
          title: Simple Expression Evaluator
          description: >-
            Write <code>func evalExpr(expr string) int</code> that evaluates a
            simple expression with two integers and one operator (+, -, *).
            The format is always <code>"a op b"</code> with spaces. Example:
            <code>"3 + 5"</code> returns <code>8</code>.
          functionSignature: func evalExpr(expr string) int
          difficulty: 2
          testCases:
            - input: 'evalExpr("3 + 5")'
              output: "8"
            - input: 'evalExpr("10 - 3")'
              output: "7"
            - input: 'evalExpr("4 * 6")'
              output: "24"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                Split the expression into three parts. Parse the two numbers
                and switch on the operator.
            - title: "\U0001F4A1 Hint"
              content: >-
                Use <code>strings.Fields(expr)</code> to get 3 parts. Parse
                numbers with <code>strconv.Atoi</code>. Use a switch on
                the operator string.
          solution: |-
            func evalExpr(expr string) int {
                parts := strings.Fields(expr)
                a, _ := strconv.Atoi(parts[0])
                b, _ := strconv.Atoi(parts[2])
                switch parts[1] {
                case "+":
                    return a + b
                case "-":
                    return a - b
                case "*":
                    return a * b
                }
                return 0
            }
          annotations:
            - type: pattern
              label: Parse-and-dispatch
              text: >-
                Splitting input into tokens, parsing values, and switching
                on the operator is the foundation of expression evaluation
                and command processing.

        - id: v6
          title: Markdown Link Extractor
          description: >-
            Write <code>func extractLinks(md string) []string</code> that extracts
            all URLs from markdown links in the format <code>[text](url)</code>.
            Return only the URLs.
          functionSignature: func extractLinks(md string) []string
          difficulty: 2
          testCases:
            - input: 'extractLinks("Visit [Go](https://go.dev) and [Rust](https://rust-lang.org)")'
              output: '["https://go.dev", "https://rust-lang.org"]'
            - input: 'extractLinks("No links here")'
              output: "[]"
            - input: 'extractLinks("[a](b)[c](d)")'
              output: '["b", "d"]'
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                Look for the pattern <code>](</code> as the separator between
                link text and URL. Then find the closing <code>)</code>.
            - title: "\U0001F4A1 Hint"
              content: >-
                Scan for <code>](</code>, then find the next <code>)</code>.
                Extract the substring between them. Use a loop with
                <code>strings.Index</code>.
          solution: |-
            func extractLinks(md string) []string {
                var links []string
                s := md
                for {
                    idx := strings.Index(s, "](")
                    if idx < 0 {
                        break
                    }
                    s = s[idx+2:]
                    end := strings.Index(s, ")")
                    if end < 0 {
                        break
                    }
                    links = append(links, s[:end])
                    s = s[end+1:]
                }
                return links
            }
          annotations:
            - type: pattern
              label: Manual string scanning
              text: >-
                Using <code>strings.Index</code> in a loop for simple
                pattern extraction is often cleaner than importing
                <code>regexp</code> for straightforward patterns.

        - id: v7
          title: Log File Analyzer
          description: >-
            Write <code>func analyzeLogs(logs string) (int, string)</code> that
            takes newline-separated log lines in format <code>"LEVEL: message"</code>.
            Return the total count of ERROR lines and the most common log level.
          functionSignature: func analyzeLogs(logs string) (int, string)
          difficulty: 2
          testCases:
            - input: 'analyzeLogs("INFO: start\nERROR: fail\nINFO: ok\nERROR: crash\nINFO: done")'
              output: '2, "INFO"'
            - input: 'analyzeLogs("ERROR: a\nERROR: b")'
              output: '2, "ERROR"'
            - input: 'analyzeLogs("WARN: x")'
              output: '0, "WARN"'
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                Split by newlines, extract the level from each line (text
                before the colon), count ERRORs and track level frequencies.
            - title: "\U0001F4A1 Hint"
              content: >-
                Use <code>strings.SplitN(line, ":", 2)</code> to separate
                level from message. Count levels in a map, then find the
                max.
          solution: |-
            func analyzeLogs(logs string) (int, string) {
                lines := strings.Split(logs, "\n")
                freq := make(map[string]int)
                errorCount := 0
                for _, line := range lines {
                    parts := strings.SplitN(line, ":", 2)
                    level := strings.TrimSpace(parts[0])
                    freq[level]++
                    if level == "ERROR" {
                        errorCount++
                    }
                }
                mostCommon := ""
                maxCount := 0
                for level, count := range freq {
                    if count > maxCount {
                        maxCount = count
                        mostCommon = level
                    }
                }
                return errorCount, mostCommon
            }
          annotations:
            - type: pattern
              label: Frequency analysis
              text: >-
                Counting occurrences in a map and then finding the maximum
                is a fundamental pattern for log analysis, text processing,
                and data aggregation.

        - id: v8
          title: Frequency-Sorted Word Cloud
          description: >-
            Write <code>func wordCloud(text string) string</code> that returns words
            sorted by frequency (descending), then alphabetically for ties. Format
            each as <code>"word(count)"</code>, joined by spaces. Convert to
            lowercase first.
          functionSignature: func wordCloud(text string) string
          difficulty: 2
          testCases:
            - input: 'wordCloud("go Go GO is is fun")'
              output: '"go(3) is(2) fun(1)"'
            - input: 'wordCloud("a b c")'
              output: '"a(1) b(1) c(1)"'
            - input: 'wordCloud("x x y y z")'
              output: '"x(2) y(2) z(1)"'
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                Count word frequencies, extract unique words, sort by count
                (descending) then alphabetically. Format each entry.
            - title: "\U0001F4A1 Hint"
              content: >-
                Use a frequency map, extract keys, sort with
                <code>sort.Slice</code> using a custom comparator, then
                format with <code>fmt.Sprintf</code>.
          solution: |-
            func wordCloud(text string) string {
                words := strings.Fields(strings.ToLower(text))
                freq := make(map[string]int)
                for _, w := range words {
                    freq[w]++
                }
                keys := make([]string, 0, len(freq))
                for k := range freq {
                    keys = append(keys, k)
                }
                sort.Slice(keys, func(i, j int) bool {
                    if freq[keys[i]] != freq[keys[j]] {
                        return freq[keys[i]] > freq[keys[j]]
                    }
                    return keys[i] < keys[j]
                })
                parts := make([]string, len(keys))
                for i, k := range keys {
                    parts[i] = fmt.Sprintf("%s(%d)", k, freq[k])
                }
                return strings.Join(parts, " ")
            }
          annotations:
            - type: pattern
              label: Sort by frequency
              text: >-
                Building a frequency map then sorting keys by their counts
                is the standard approach for word clouds, leaderboards,
                and ranking problems.

        - id: v9
          title: Simple Stack With Slice
          description: >-
            Write <code>func evalRPN(tokens []string) int</code> that evaluates
            a Reverse Polish Notation expression using a stack implemented with a
            slice. Supports +, -, and *. Tokens are either integers or operators.
          functionSignature: func evalRPN(tokens []string) int
          difficulty: 2
          testCases:
            - input: 'evalRPN([]string{"2","3","+"})'
              output: "5"
            - input: 'evalRPN([]string{"5","1","2","+","4","*","+","3","-"})'
              output: "14"
            - input: 'evalRPN([]string{"3","4","*"})'
              output: "12"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                Push numbers onto the stack. When you see an operator, pop
                two values, apply the operator, push the result. A Go slice
                works as a stack with append and reslicing.
            - title: "\U0001F4A1 Hint"
              content: >-
                Push: <code>stack = append(stack, val)</code>. Pop:
                <code>val = stack[len(stack)-1]; stack = stack[:len(stack)-1]</code>.
          solution: |-
            func evalRPN(tokens []string) int {
                var stack []int
                for _, tok := range tokens {
                    switch tok {
                    case "+", "-", "*":
                        b := stack[len(stack)-1]
                        a := stack[len(stack)-2]
                        stack = stack[:len(stack)-2]
                        switch tok {
                        case "+":
                            stack = append(stack, a+b)
                        case "-":
                            stack = append(stack, a-b)
                        case "*":
                            stack = append(stack, a*b)
                        }
                    default:
                        n, _ := strconv.Atoi(tok)
                        stack = append(stack, n)
                    }
                }
                return stack[0]
            }
          annotations:
            - type: idiom
              label: Slice as stack
              text: >-
                Go slices naturally support stack operations: push with
                <code>append</code>, pop by reslicing. No need for a
                separate stack data structure.

        - id: v10
          title: Queue With Rate Limiting
          description: >-
            Write <code>func processQueue(tasks []string, maxPerBatch int) []string</code>
            that processes tasks in batches of <code>maxPerBatch</code>. Return a
            slice of strings where each entry is <code>"Batch N: [tasks]"</code>.
          functionSignature: func processQueue(tasks []string, maxPerBatch int) []string
          difficulty: 3
          testCases:
            - input: 'processQueue([]string{"a","b","c","d","e"}, 2)'
              output: '["Batch 1: a, b", "Batch 2: c, d", "Batch 3: e"]'
            - input: 'processQueue([]string{"x"}, 3)'
              output: '["Batch 1: x"]'
            - input: 'processQueue([]string{"a","b","c"}, 3)'
              output: '["Batch 1: a, b, c"]'
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                Chunk the tasks slice into groups of maxPerBatch, then format
                each batch as a string.
            - title: "\U0001F4A1 Hint"
              content: >-
                Loop with step <code>maxPerBatch</code>, slice
                <code>tasks[i:end]</code>, join with comma-space, and
                format with batch number.
          solution: |-
            func processQueue(tasks []string, maxPerBatch int) []string {
                var batches []string
                batchNum := 1
                for i := 0; i < len(tasks); i += maxPerBatch {
                    end := i + maxPerBatch
                    if end > len(tasks) {
                        end = len(tasks)
                    }
                    batch := strings.Join(tasks[i:end], ", ")
                    batches = append(batches, fmt.Sprintf("Batch %d: %s", batchNum, batch))
                    batchNum++
                }
                return batches
            }
          annotations:
            - type: pattern
              label: Batch processing with chunking
              text: >-
                Chunking a slice with a step-based loop is a common pattern
                for rate limiting, pagination, and batch processing. Clamping
                the end index prevents out-of-bounds access.

        - id: v11
          title: Text Diff (Find Added/Removed Lines)
          description: >-
            Write <code>func diff(old, new string) string</code> that compares two
            newline-separated texts and returns lines prefixed with
            <code>"+ "</code> (added) or <code>"- "</code> (removed). Lines present
            in both are omitted. Output lines in the order they appear.
          functionSignature: func diff(old, new string) string
          difficulty: 3
          testCases:
            - input: 'diff("a\nb\nc", "a\nc\nd")'
              output: '"- b\n+ d"'
            - input: 'diff("x\ny", "x\ny")'
              output: '""'
            - input: 'diff("", "a\nb")'
              output: '"+ a\n+ b"'
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                Build sets from both old and new lines. Lines in old but not
                new are removed; lines in new but not old are added.
            - title: "\U0001F4A1 Hint"
              content: >-
                Use <code>map[string]bool</code> sets. Iterate old lines
                first (marking removals), then new lines (marking additions).
          solution: |-
            func diff(old, new string) string {
                oldLines := strings.Split(old, "\n")
                newLines := strings.Split(new, "\n")
                oldSet := make(map[string]bool)
                newSet := make(map[string]bool)
                for _, l := range oldLines {
                    if l != "" { oldSet[l] = true }
                }
                for _, l := range newLines {
                    if l != "" { newSet[l] = true }
                }
                var result []string
                for _, l := range oldLines {
                    if l != "" && !newSet[l] {
                        result = append(result, "- "+l)
                    }
                }
                for _, l := range newLines {
                    if l != "" && !oldSet[l] {
                        result = append(result, "+ "+l)
                    }
                }
                return strings.Join(result, "\n")
            }
          annotations:
            - type: pattern
              label: Set-based diff
              text: >-
                Using sets to find additions and removals is a simplified
                diff algorithm. Real diff tools use LCS (longest common
                subsequence) but set-based diff works for unordered changes.

        - id: v12
          title: Tournament Bracket Simulator
          description: >-
            Write <code>func tournament(teams []string) string</code> that simulates
            single-elimination rounds. In each round, the first team in each pair
            advances (simulated winner). Return the final winner. If odd number of
            teams, last team gets a bye.
          functionSignature: func tournament(teams []string) string
          difficulty: 3
          testCases:
            - input: 'tournament([]string{"A","B","C","D"})'
              output: '"A"'
            - input: 'tournament([]string{"X","Y","Z"})'
              output: '"X"'
            - input: 'tournament([]string{"Solo"})'
              output: '"Solo"'
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                Repeatedly halve the teams: pair them up, advance winners.
                Continue until one team remains.
            - title: "\U0001F4A1 Hint"
              content: >-
                Loop while <code>len(teams) > 1</code>. Build a new slice
                of winners by taking every other team (index 0, 2, 4...).
                Handle odd count by including the last team automatically.
          solution: |-
            func tournament(teams []string) string {
                for len(teams) > 1 {
                    var next []string
                    for i := 0; i < len(teams); i += 2 {
                        next = append(next, teams[i])
                    }
                    teams = next
                }
                return teams[0]
            }
          annotations:
            - type: pattern
              label: Iterative halving
              text: >-
                Repeatedly halving a collection until one element remains
                is a common pattern in tournament brackets, merge operations,
                and divide-and-conquer algorithms.

        - id: v13
          title: Mini Key-Value Store
          description: >-
            Write <code>func kvStore(commands []string) []string</code> that
            processes commands: <code>"SET key value"</code>,
            <code>"GET key"</code>, <code>"DELETE key"</code>, and
            <code>"LIST"</code>. GET returns <code>"key=value"</code> or
            <code>"key not found"</code>. LIST returns all keys sorted,
            comma-separated. Return all output lines.
          functionSignature: func kvStore(commands []string) []string
          difficulty: 3
          testCases:
            - input: 'kvStore([]string{"SET a 1","SET b 2","GET a","GET c","LIST","DELETE a","LIST"})'
              output: '["a=1", "c not found", "a, b", "b"]'
            - input: 'kvStore([]string{"SET x hello","GET x","DELETE x","GET x"})'
              output: '["x=hello", "x not found"]'
            - input: 'kvStore([]string{"LIST"})'
              output: '[""]'
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                Use a map as the store. Parse each command by splitting on
                spaces. Switch on the first word to determine the operation.
            - title: "\U0001F4A1 Hint"
              content: >-
                Split each command with <code>strings.Fields</code>. Use
                <code>switch parts[0]</code> for SET/GET/DELETE/LIST. For
                LIST, extract and sort keys.
          solution: |-
            func kvStore(commands []string) []string {
                store := make(map[string]string)
                var output []string
                for _, cmd := range commands {
                    parts := strings.Fields(cmd)
                    switch parts[0] {
                    case "SET":
                        store[parts[1]] = parts[2]
                    case "GET":
                        val, ok := store[parts[1]]
                        if ok {
                            output = append(output, parts[1]+"="+val)
                        } else {
                            output = append(output, parts[1]+" not found")
                        }
                    case "DELETE":
                        delete(store, parts[1])
                    case "LIST":
                        keys := make([]string, 0, len(store))
                        for k := range store {
                            keys = append(keys, k)
                        }
                        sort.Strings(keys)
                        output = append(output, strings.Join(keys, ", "))
                    }
                }
                return output
            }
          annotations:
            - type: pattern
              label: Command dispatcher
              text: >-
                Parsing commands into tokens and dispatching with a switch
                is the foundation of CLIs, REPLs, and protocol handlers.
                Maps provide O(1) storage operations.
