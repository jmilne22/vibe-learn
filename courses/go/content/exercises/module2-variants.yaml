conceptLinks:
  Building Slices: "#lesson-slices"
  Slice Operations: "#lesson-slices"
  Map Basics: "#lesson-maps"
  Comma-Ok Pattern: "#lesson-comma-ok"
  Strings & Runes: "#lesson-variables"
  Go Fundamentals Combined: "#lesson-variables"

sharedContent: {}

variants:
  warmups:
    # ‚îÄ‚îÄ warmup_1: Building Slices ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    - id: warmup_1
      concept: Building Slices
      variants:
        - id: v1
          title: Print Log Levels
          description: >-
            Declare a slice literal containing the strings <code>"INFO"</code>,
            <code>"WARN"</code>, <code>"ERROR"</code>, <code>"DEBUG"</code>.
            Iterate over it with <code>range</code> and print each level.
          hints:
            - "Use <code>levels := []string{\"INFO\", \"WARN\", \"ERROR\", \"DEBUG\"}</code>"
            - "Use <code>for _, level := range levels</code> to iterate"
          solution: |-
            levels := []string{"INFO", "WARN", "ERROR", "DEBUG"}
            for _, level := range levels {
                fmt.Println(level)
            }

        - id: v2
          title: Collect Even Numbers
          description: >-
            Write a program that loops from 1 to 20 and uses <code>append</code> to collect
            all even numbers into a slice. Print the final slice.
          hints:
            - "Start with an empty slice: <code>var evens []int</code>"
            - "Inside the loop, use <code>if i % 2 == 0 { evens = append(evens, i) }</code>"
          solution: |-
            var evens []int
            for i := 1; i <= 20; i++ {
                if i%2 == 0 {
                    evens = append(evens, i)
                }
            }
            fmt.Println(evens)

        - id: v3
          title: Last Three Lines
          description: >-
            Given <code>lines := []string{"line1", "line2", "line3", "line4", "line5"}</code>,
            use slice syntax to grab the last 3 elements and print them.
          hints:
            - "Use <code>lines[len(lines)-3:]</code> to get the last 3 elements"
          solution: |-
            lines := []string{"line1", "line2", "line3", "line4", "line5"}
            last3 := lines[len(lines)-3:]
            fmt.Println(last3)

        - id: v4
          title: Pre-Allocate with make
          description: >-
            Use <code>make([]int, 5)</code> to create a slice of 5 integers.
            Fill each element with its index squared (<code>i*i</code>), then print the slice.
          hints:
            - "Use <code>squares := make([]int, 5)</code> to pre-allocate"
            - "Fill with <code>for i := 0; i &lt; len(squares); i++ { squares[i] = i * i }</code>"
          solution: |-
            squares := make([]int, 5)
            for i := 0; i < len(squares); i++ {
                squares[i] = i * i
            }
            fmt.Println(squares)

    # ‚îÄ‚îÄ warmup_2: Map Basics ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    - id: warmup_2
      concept: Map Basics
      variants:
        - id: v1
          title: Iterate a Map
          description: >-
            Create a map literal mapping HTTP methods to descriptions:
            <code>"GET"</code> ‚Üí <code>"read"</code>,
            <code>"POST"</code> ‚Üí <code>"create"</code>,
            <code>"DELETE"</code> ‚Üí <code>"remove"</code>.
            Iterate with <code>range</code> and print each key-value pair.
          hints:
            - "Use <code>methods := map[string]string{\"GET\": \"read\", ...}</code>"
            - "Use <code>for k, v := range methods</code> to iterate"
          solution: |-
            methods := map[string]string{
                "GET":    "read",
                "POST":   "create",
                "DELETE": "remove",
            }
            for k, v := range methods {
                fmt.Printf("%s: %s\n", k, v)
            }

        - id: v2
          title: Build a Map from Slices
          description: >-
            Given <code>keys := []string{"a", "b", "c"}</code> and
            <code>values := []int{1, 2, 3}</code>, build a
            <code>map[string]int</code> by looping over the slices, then print the map.
          hints:
            - "Create the map first: <code>m := make(map[string]int)</code>"
            - "Use <code>for i := 0; i &lt; len(keys); i++ { m[keys[i]] = values[i] }</code>"
          solution: |-
            keys := []string{"a", "b", "c"}
            values := []int{1, 2, 3}
            m := make(map[string]int)
            for i := 0; i < len(keys); i++ {
                m[keys[i]] = values[i]
            }
            fmt.Println(m)

        - id: v3
          title: Comma-Ok Lookup
          description: >-
            Given <code>config := map[string]string{"host": "localhost", "port": "8080"}</code>,
            look up the key <code>"timeout"</code> using the comma-ok pattern. If missing,
            print <code>"not set"</code>; otherwise print the value.
          hints:
            - "Use <code>val, ok := config[\"timeout\"]</code>"
            - "Check <code>if !ok { fmt.Println(\"not set\") }</code>"
          solution: |-
            config := map[string]string{"host": "localhost", "port": "8080"}
            val, ok := config["timeout"]
            if !ok {
                fmt.Println("not set")
            } else {
                fmt.Println(val)
            }

        - id: v4
          title: Count Word Frequency
          description: >-
            Given <code>words := []string{"go", "is", "fun", "go", "is", "great", "go"}</code>,
            count the frequency of each word using a map. Print the resulting map.
          hints:
            - "Create <code>freq := make(map[string]int)</code>"
            - "For each word, <code>freq[word]++</code> increments the count (zero value for int is 0)"
          solution: |-
            words := []string{"go", "is", "fun", "go", "is", "great", "go"}
            freq := make(map[string]int)
            for _, word := range words {
                freq[word]++
            }
            fmt.Println(freq)

    # ‚îÄ‚îÄ warmup_3: Strings & Runes ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    - id: warmup_3
      concept: Strings & Runes
      variants:
        - id: v1
          title: Bytes vs Characters
          description: >-
            Given <code>s := "caf√©"</code>, print <code>len(s)</code> (byte length) and
            <code>len([]rune(s))</code> (character count). They're different! Then print
            each rune using <code>range</code> to see the byte index jumps.
          hints:
            - "<code>len(\"caf√©\")</code> is 5 (bytes), not 4 ‚Äî the <code>√©</code> is 2 bytes in UTF-8"
            - "<code>range</code> over a string yields runes, not bytes: <code>for i, ch := range s</code>"
          solution: |-
            s := "caf√©"
            fmt.Println("bytes:", len(s))           // 5
            fmt.Println("runes:", len([]rune(s)))    // 4
            for i, ch := range s {
                fmt.Printf("index %d: %c\n", i, ch)
            }
            // index 0: c, index 1: a, index 2: f, index 3: √©
          annotations:
            - type: gotcha
              label: Strings Are Bytes
              text: >-
                Go strings are byte sequences, not character sequences. <code>len(s)</code> returns
                bytes, and <code>s[i]</code> gives a byte. Use <code>[]rune(s)</code> or <code>range</code>
                for Unicode-safe character work.

        - id: v2
          title: Safe Character Slicing
          description: >-
            Write a program that safely extracts the first 3 <em>characters</em> from
            <code>"Êó•Êú¨Ë™û„ÉÜ„Çπ„Éà"</code> (Japanese for "Japanese test"). Using <code>s[:3]</code>
            would slice bytes and produce garbage. Convert to <code>[]rune</code>, slice, and
            convert back to a string.
          hints:
            - "Convert first: <code>runes := []rune(s)</code>"
            - "Slice runes, then convert back: <code>string(runes[:3])</code>"
          solution: |-
            s := "Êó•Êú¨Ë™û„ÉÜ„Çπ„Éà"
            runes := []rune(s)
            first3 := string(runes[:3])
            fmt.Println(first3)  // Êó•Êú¨Ë™û
          annotations:
            - type: pattern
              label: Rune Round-Trip
              text: >-
                The pattern <code>[]rune(s)</code> ‚Üí manipulate ‚Üí <code>string(runes)</code> is how
                you safely work with characters in Go. Use it whenever you need to index or slice
                by character position rather than byte position.

        - id: v3
          title: Count Non-ASCII Characters
          description: >-
            Write a program that counts how many characters in <code>"Hello, ‰∏ñÁïå! üåç"</code>
            are non-ASCII (byte value > 127). Use <code>range</code> to iterate by rune and
            check if each rune is greater than 127.
          hints:
            - "Use <code>for _, ch := range s</code> ‚Äî <code>ch</code> is a <code>rune</code> (int32)"
            - "Check <code>if ch > 127</code> to detect non-ASCII characters"
          solution: |-
            s := "Hello, ‰∏ñÁïå! üåç"
            count := 0
            for _, ch := range s {
                if ch > 127 {
                    count++
                }
            }
            fmt.Println(count)  // 3 (‰∏ñ, Áïå, üåç)

  challenges:
    # ‚îÄ‚îÄ challenge_1: Slice Operations (Log Parser) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    - id: challenge_1
      block: 2
      difficulty: 2
      concept: Slice Operations
      docLinks:
        - url: https://go.dev/blog/slices-intro
          title: "Go Slices: usage and internals"
          note: how slices work under the hood
        - url: https://pkg.go.dev/strings#Contains
          title: "strings.Contains"
          note: check if a string contains a substring
      variants:
        - id: v1
          title: Count Errors
          description: >-
            Write <code>func countErrors(lines []string) int</code>. Loop through the log lines
            and count how many contain the substring <code>"ERROR"</code>. Use
            <code>strings.Contains</code>.
          functionSignature: func countErrors(lines []string) int
          difficulty: 1
          testCases:
            - input: "countErrors([]string{\"2024-01-15 10:30:45 ERROR timeout\", \"2024-01-15 10:30:46 INFO ok\", \"2024-01-15 10:30:47 ERROR disk full\"})"
              output: "2"
            - input: "countErrors([]string{\"2024-01-15 10:30:45 INFO ok\"})"
              output: "0"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                Initialize a counter to 0. Loop through lines with range. For each line, check if it contains "ERROR" and increment the counter.
            - title: "\U0001F4A1 Hint"
              content: >-
                Use <code>strings.Contains(line, "ERROR")</code> inside the loop.
          solution: |-
            func countErrors(lines []string) int {
                count := 0
                for _, line := range lines {
                    if strings.Contains(line, "ERROR") {
                        count++
                    }
                }
                return count
            }

        - id: v2
          title: Filter by Level
          description: >-
            Write <code>func filterByLevel(lines []string, level string) []string</code>. Return
            only the log lines that contain the given level string. Use <code>strings.Contains</code>.
          functionSignature: func filterByLevel(lines []string, level string) []string
          difficulty: 2
          testCases:
            - input: "filterByLevel([]string{\"2024-01-15 10:30:45 ERROR timeout\", \"2024-01-15 10:30:46 INFO ok\", \"2024-01-15 10:30:47 ERROR disk full\"}, \"ERROR\")"
              output: "[\"2024-01-15 10:30:45 ERROR timeout\", \"2024-01-15 10:30:47 ERROR disk full\"]"
            - input: "filterByLevel([]string{\"2024-01-15 10:30:45 INFO ok\"}, \"ERROR\")"
              output: "[]"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                This is the filter-and-collect pattern: create an empty result slice, loop, and append matching items.
            - title: "\U0001F4A1 Hint"
              content: >-
                <code>var result []string</code>, then in the loop: <code>if strings.Contains(line, level) { result = append(result, line) }</code>
          solution: |-
            func filterByLevel(lines []string, level string) []string {
                var result []string
                for _, line := range lines {
                    if strings.Contains(line, level) {
                        result = append(result, line)
                    }
                }
                return result
            }
          annotations:
            - type: pattern
              label: Filter & Collect
              text: >-
                The filter-and-collect pattern ‚Äî <code>var result []T</code> + loop + conditional <code>append</code> ‚Äî
                is one of Go's most common idioms. It's clear, efficient, and hard to get wrong.

        - id: v3
          title: Last N Entries
          description: >-
            Write <code>func lastN(lines []string, n int) []string</code>. Return the last
            <code>n</code> log entries. If <code>n</code> is greater than the number of lines,
            return all lines.
          functionSignature: func lastN(lines []string, n int) []string
          difficulty: 2
          testCases:
            - input: "lastN([]string{\"a\", \"b\", \"c\", \"d\", \"e\"}, 3)"
              output: "[\"c\", \"d\", \"e\"]"
            - input: "lastN([]string{\"a\", \"b\"}, 5)"
              output: "[\"a\", \"b\"]"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                Use slice syntax <code>lines[start:]</code>. Calculate the start index as <code>len(lines) - n</code>,
                but make sure it doesn't go below 0.
            - title: "\U0001F4A1 Hint"
              content: >-
                <code>if n > len(lines) { n = len(lines) }</code> then <code>return lines[len(lines)-n:]</code>
          solution: |-
            func lastN(lines []string, n int) []string {
                if n > len(lines) {
                    n = len(lines)
                }
                return lines[len(lines)-n:]
            }
          annotations:
            - type: idiom
              label: Defensive Slicing
              text: >-
                Always clamp your index before slicing. <code>lines[len(lines)-n:]</code> panics if
                <code>n > len(lines)</code>. A simple bounds check prevents runtime panics.

        - id: v4
          title: Unique Levels
          description: >-
            Write <code>func uniqueLevels(lines []string) []string</code>. Extract the log level
            from each line (third field via <code>strings.Fields</code>) and return a deduplicated
            slice of all levels found.
          functionSignature: func uniqueLevels(lines []string) []string
          difficulty: 3
          testCases:
            - input: "uniqueLevels([]string{\"2024-01-15 10:30:45 ERROR timeout\", \"2024-01-15 10:30:46 INFO ok\", \"2024-01-15 10:30:47 ERROR disk full\"})"
              output: "[\"ERROR\", \"INFO\"] (order may vary)"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                Use a <code>map[string]bool</code> as a set to track which levels you've already seen.
                Then collect the map keys into a slice.
            - title: "\U0001F4A1 Hint"
              content: >-
                For each line, split with <code>strings.Fields</code>, take the third field as the level,
                add it to a <code>seen</code> map. After the loop, collect the keys.
          solution: |-
            func uniqueLevels(lines []string) []string {
                seen := make(map[string]bool)
                for _, line := range lines {
                    fields := strings.Fields(line)
                    if len(fields) >= 3 {
                        seen[fields[2]] = true
                    }
                }
                var levels []string
                for level := range seen {
                    levels = append(levels, level)
                }
                return levels
            }
          annotations:
            - type: pattern
              label: Map as Set
              text: >-
                Go doesn't have a built-in set type. The idiomatic approach is <code>map[T]bool</code> ‚Äî
                use <code>m[key] = true</code> to add, and <code>if m[key]</code> to check membership.

        - id: v5
          title: First and Last
          description: >-
            Write <code>func firstAndLast(items []string) (string, string)</code>. Return the first
            and last elements of a slice. If the slice is empty, return two empty strings.
            If the slice has one element, return it as both first and last.
          functionSignature: func firstAndLast(items []string) (string, string)
          difficulty: 1
          testCases:
            - input: "firstAndLast([]string{\"a\", \"b\", \"c\", \"d\"})"
              output: "\"a\", \"d\""
            - input: "firstAndLast([]string{\"only\"})"
              output: "\"only\", \"only\""
            - input: "firstAndLast([]string{})"
              output: "\"\", \"\""
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                The first element is <code>items[0]</code>. The last element is
                <code>items[len(items)-1]</code>. But what if the slice is empty?
            - title: "\U0001F4A1 Hint"
              content: >-
                Check <code>if len(items) == 0</code> first. Otherwise, access
                <code>items[0]</code> and <code>items[len(items)-1]</code>.
          solution: |-
            func firstAndLast(items []string) (string, string) {
                if len(items) == 0 {
                    return "", ""
                }
                return items[0], items[len(items)-1]
            }
          annotations:
            - type: gotcha
              label: No Negative Indexing
              text: >-
                Go has no <code>items[-1]</code>. Use <code>items[len(items)-1]</code> for the last
                element. Always check <code>len(items) == 0</code> first ‚Äî accessing index 0 or
                <code>len-1</code> on an empty slice panics.

        - id: v6
          title: Second to Last
          description: >-
            Write <code>func secondToLast(items []string) (string, bool)</code>. Return the
            second-to-last element and <code>true</code>. If the slice has fewer than 2 elements,
            return <code>""</code> and <code>false</code>.
          functionSignature: func secondToLast(items []string) (string, bool)
          difficulty: 1
          testCases:
            - input: "secondToLast([]string{\"a\", \"b\", \"c\", \"d\"})"
              output: "\"c\", true"
            - input: "secondToLast([]string{\"only\"})"
              output: "\"\", false"
            - input: "secondToLast([]string{})"
              output: "\"\", false"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                The second-to-last element is at index <code>len(items)-2</code>. When is that
                index invalid?
            - title: "\U0001F4A1 Hint"
              content: >-
                Check <code>if len(items) &lt; 2</code> first. Then return
                <code>items[len(items)-2], true</code>.
          solution: |-
            func secondToLast(items []string) (string, bool) {
                if len(items) < 2 {
                    return "", false
                }
                return items[len(items)-2], true
            }

        - id: v7
          title: Reverse a Slice
          description: >-
            Write <code>func reverseStrings(items []string) []string</code>. Return a new slice
            with the elements in reverse order. Use index math from both ends ‚Äî
            access elements with <code>items[len(items)-1-i]</code>.
          functionSignature: func reverseStrings(items []string) []string
          difficulty: 2
          testCases:
            - input: "reverseStrings([]string{\"a\", \"b\", \"c\", \"d\"})"
              output: "[\"d\", \"c\", \"b\", \"a\"]"
            - input: "reverseStrings([]string{})"
              output: "[]"
            - input: "reverseStrings([]string{\"only\"})"
              output: "[\"only\"]"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                Create a new slice with <code>make</code>. The element at index <code>i</code> in the
                result should be the element at index <code>len(items)-1-i</code> in the original.
            - title: "\U0001F4A1 Hint"
              content: >-
                <code>result := make([]string, len(items))</code>, then loop with
                <code>result[i] = items[len(items)-1-i]</code>.
          solution: |-
            func reverseStrings(items []string) []string {
                result := make([]string, len(items))
                for i := 0; i < len(items); i++ {
                    result[i] = items[len(items)-1-i]
                }
                return result
            }
          annotations:
            - type: pattern
              label: Mirror Index
              text: >-
                <code>len(s)-1-i</code> gives you the mirror position from the end. When <code>i=0</code>
                you get the last element, when <code>i=1</code> the second-to-last, etc.

        - id: v8
          title: Find Adjacent Duplicates
          description: >-
            Write <code>func adjacentDuplicates(lines []string) []string</code>. Return lines that
            are identical to the line immediately before them. Use a classic index loop starting
            at <code>i=1</code> and compare <code>lines[i]</code> with <code>lines[i-1]</code>.
          functionSignature: func adjacentDuplicates(lines []string) []string
          difficulty: 2
          testCases:
            - input: "adjacentDuplicates([]string{\"ERROR timeout\", \"ERROR timeout\", \"INFO ok\", \"INFO ok\", \"INFO ok\", \"ERROR disk full\"})"
              output: "[\"ERROR timeout\", \"INFO ok\", \"INFO ok\"]"
            - input: "adjacentDuplicates([]string{\"a\", \"b\", \"c\"})"
              output: "[]"
            - input: "adjacentDuplicates([]string{})"
              output: "[]"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                Start the loop at index 1, not 0. Compare each element with the one before it.
                What would happen if you started at 0 and tried to access <code>lines[-1]</code>?
            - title: "\U0001F4A1 Hint"
              content: >-
                <code>for i := 1; i &lt; len(lines); i++ { if lines[i] == lines[i-1] { ... } }</code>.
                Starting at 1 guarantees <code>i-1</code> is always valid.
          solution: |-
            func adjacentDuplicates(lines []string) []string {
                var result []string
                for i := 1; i < len(lines); i++ {
                    if lines[i] == lines[i-1] {
                        result = append(result, lines[i])
                    }
                }
                return result
            }
          annotations:
            - type: gotcha
              label: Off-By-One
              text: >-
                When comparing adjacent elements, start your loop at index 1 (not 0) to avoid
                an out-of-bounds access on <code>lines[i-1]</code>. This is the most common
                source of index panics in Go.

        - id: v9
          title: Safe Slice Access
          description: >-
            Write <code>func safeGet(items []string, index int) (string, bool)</code>. Return the
            element at the given index and <code>true</code>, or <code>""</code> and <code>false</code>
            if the index is out of bounds. Handle negative indices, zero-length slices, and indices
            beyond the end.
          functionSignature: func safeGet(items []string, index int) (string, bool)
          difficulty: 2
          testCases:
            - input: "safeGet([]string{\"a\", \"b\", \"c\"}, 1)"
              output: "\"b\", true"
            - input: "safeGet([]string{\"a\", \"b\", \"c\"}, 5)"
              output: "\"\", false"
            - input: "safeGet([]string{\"a\", \"b\", \"c\"}, -1)"
              output: "\"\", false"
            - input: "safeGet([]string{}, 0)"
              output: "\"\", false"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                What are all the ways an index can be invalid? It could be negative, or it could be
                >= the length of the slice. Check both before accessing.
            - title: "\U0001F4A1 Hint"
              content: >-
                <code>if index &lt; 0 || index >= len(items) { return "", false }</code>
          solution: |-
            func safeGet(items []string, index int) (string, bool) {
                if index < 0 || index >= len(items) {
                    return "", false
                }
                return items[index], true
            }
          annotations:
            - type: pattern
              label: Bounds Checking
              text: >-
                Go panics on out-of-bounds access ‚Äî there's no fallback like Python's negative indexing.
                Always validate indices with <code>index &lt; 0 || index >= len(s)</code> before accessing.
                This is especially important when indices come from user input or calculations.

        - id: v10
          title: Window Over Log Lines
          description: >-
            Write <code>func windows(lines []string, size int) [][]string</code>. Return all
            contiguous sub-slices of the given size. For example, with size 3 and 5 lines, return
            3 windows: lines[0:3], lines[1:4], lines[2:5]. Return an empty slice if the input is
            shorter than the window size.
          functionSignature: func windows(lines []string, size int) [][]string
          difficulty: 3
          testCases:
            - input: "windows([]string{\"a\", \"b\", \"c\", \"d\", \"e\"}, 3)"
              output: "[[\"a\",\"b\",\"c\"], [\"b\",\"c\",\"d\"], [\"c\",\"d\",\"e\"]]"
            - input: "windows([]string{\"a\", \"b\"}, 3)"
              output: "[]"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                How many windows of size <code>k</code> fit in a slice of length <code>n</code>?
                The answer is <code>n - k + 1</code>. Your loop runs from <code>i = 0</code> to
                <code>i &lt;= len(lines) - size</code>.
            - title: "\U0001F4A1 Hint"
              content: >-
                <code>for i := 0; i &lt;= len(lines)-size; i++ { result = append(result, lines[i:i+size]) }</code>.
                If <code>len(lines) &lt; size</code>, the loop body never executes.
          solution: |-
            func windows(lines []string, size int) [][]string {
                var result [][]string
                for i := 0; i <= len(lines)-size; i++ {
                    result = append(result, lines[i:i+size])
                }
                return result
            }
          annotations:
            - type: pattern
              label: Sliding Window
              text: >-
                The sliding window pattern ‚Äî <code>lines[i:i+size]</code> for <code>i</code> from
                0 to <code>len-size</code> ‚Äî is fundamental for analyzing sequential data. The
                bounds math (<code>len - size + 1</code> iterations) comes up constantly.

    # ‚îÄ‚îÄ challenge_2: Maps & Aggregation (Log Parser) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    - id: challenge_2
      block: 2
      difficulty: 2
      concept: Map Basics
      docLinks:
        - url: https://go.dev/blog/maps
          title: "Go maps in action"
          note: map usage patterns
        - url: https://go.dev/tour/moretypes/19
          title: "Go Tour: Maps"
          note: map basics
      variants:
        - id: v1
          title: Count by Level
          description: >-
            Write <code>func countByLevel(lines []string) map[string]int</code>. Extract the log
            level from each line (third field) and return a map counting occurrences of each level.
          functionSignature: func countByLevel(lines []string) map[string]int
          difficulty: 1
          testCases:
            - input: "countByLevel([]string{\"2024-01-15 10:30:45 ERROR timeout\", \"2024-01-15 10:30:46 INFO ok\", \"2024-01-15 10:30:47 ERROR disk full\"})"
              output: "map[ERROR:2 INFO:1]"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                Create a <code>map[string]int</code>. For each line, extract the level and increment:
                <code>counts[level]++</code>. The zero value of int makes this work without initialization.
            - title: "\U0001F4A1 Hint"
              content: >-
                Split each line with <code>strings.Fields</code>, take <code>fields[2]</code> as the level,
                and <code>counts[level]++</code>.
          solution: |-
            func countByLevel(lines []string) map[string]int {
                counts := make(map[string]int)
                for _, line := range lines {
                    fields := strings.Fields(line)
                    if len(fields) >= 3 {
                        counts[fields[2]]++
                    }
                }
                return counts
            }
          annotations:
            - type: idiom
              label: Frequency Map
              text: >-
                <code>m[key]++</code> works because Go map values default to their zero value.
                For <code>int</code>, that's 0 ‚Äî so the first increment gives 1. No need to check if the key exists.

        - id: v2
          title: Most Common Level
          description: >-
            Write <code>func mostCommonLevel(lines []string) string</code>. Find and return the log
            level that appears most frequently. If there are no lines, return an empty string.
          functionSignature: func mostCommonLevel(lines []string) string
          difficulty: 2
          testCases:
            - input: "mostCommonLevel([]string{\"2024-01-15 10:30:45 ERROR timeout\", \"2024-01-15 10:30:46 INFO ok\", \"2024-01-15 10:30:47 ERROR disk full\", \"2024-01-15 10:30:48 INFO started\", \"2024-01-15 10:30:49 ERROR retry\"})"
              output: "\"ERROR\""
            - input: "mostCommonLevel([]string{})"
              output: "\"\""
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                First build a frequency map (like challenge_6 v1), then iterate the map to find the key with the highest count.
            - title: "\U0001F4A1 Hint"
              content: >-
                Track <code>maxCount</code> and <code>maxLevel</code> while iterating the frequency map.
                Update them when you find a count larger than the current max.
          solution: |-
            func mostCommonLevel(lines []string) string {
                counts := make(map[string]int)
                for _, line := range lines {
                    fields := strings.Fields(line)
                    if len(fields) >= 3 {
                        counts[fields[2]]++
                    }
                }
                maxLevel := ""
                maxCount := 0
                for level, count := range counts {
                    if count > maxCount {
                        maxCount = count
                        maxLevel = level
                    }
                }
                return maxLevel
            }

        - id: v3
          title: Error Message Counts
          description: >-
            Write <code>func errorMessages(lines []string) map[string]int</code>. For lines with
            level <code>"ERROR"</code>, extract the message (everything after the level) and count
            how many times each unique error message appears.
          functionSignature: func errorMessages(lines []string) map[string]int
          difficulty: 2
          testCases:
            - input: "errorMessages([]string{\"2024-01-15 10:30:45 ERROR timeout\", \"2024-01-15 10:30:46 INFO ok\", \"2024-01-15 10:30:47 ERROR timeout\", \"2024-01-15 10:30:48 ERROR disk full\"})"
              output: "map[timeout:2 disk full:1]"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                Split each line into fields. Check if <code>fields[2] == "ERROR"</code>. If so, reconstruct the message
                from <code>fields[3:]</code> and count it.
            - title: "\U0001F4A1 Hint"
              content: >-
                Use <code>strings.Join(fields[3:], " ")</code> to get the message, then <code>counts[msg]++</code>.
          solution: |-
            func errorMessages(lines []string) map[string]int {
                counts := make(map[string]int)
                for _, line := range lines {
                    fields := strings.Fields(line)
                    if len(fields) >= 4 && fields[2] == "ERROR" {
                        msg := strings.Join(fields[3:], " ")
                        counts[msg]++
                    }
                }
                return counts
            }

        - id: v4
          title: Hourly Breakdown
          description: >-
            Write <code>func hourlyBreakdown(lines []string) map[string]int</code>. Extract the
            hour from each log line's timestamp (characters 11-12, e.g., <code>"10"</code> from
            <code>"2024-01-15 10:30:45"</code>) and return a map counting entries per hour.
          functionSignature: func hourlyBreakdown(lines []string) map[string]int
          difficulty: 3
          testCases:
            - input: "hourlyBreakdown([]string{\"2024-01-15 10:30:45 ERROR timeout\", \"2024-01-15 10:45:00 INFO ok\", \"2024-01-15 14:00:00 WARN slow\"})"
              output: "map[10:2 14:1]"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                The timestamp starts at position 0 and the hour is at positions 11-12 (inclusive).
                Use <code>line[11:13]</code> to extract the two-digit hour.
            - title: "\U0001F4A1 Hint"
              content: >-
                Check <code>len(line) >= 13</code> first, then <code>hour := line[11:13]</code> and <code>counts[hour]++</code>.
          solution: |-
            func hourlyBreakdown(lines []string) map[string]int {
                counts := make(map[string]int)
                for _, line := range lines {
                    if len(line) >= 13 {
                        hour := line[11:13]
                        counts[hour]++
                    }
                }
                return counts
            }
          annotations:
            - type: gotcha
              label: String Indexing
              text: >-
                <code>line[11:13]</code> gives bytes, not characters. This works for ASCII digits but would
                break with multi-byte UTF-8 characters. For timestamps with ASCII digits, byte indexing is fine.

    # ‚îÄ‚îÄ challenge_3: Go Fundamentals Combined (Log Parser Capstone) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    - id: challenge_3
      block: 3
      difficulty: 3
      concept: Go Fundamentals Combined
      docLinks:
        - url: https://go.dev/doc/effective_go
          title: "Effective Go"
          note: idiomatic Go patterns
        - url: https://pkg.go.dev/fmt#Sprintf
          title: "fmt.Sprintf"
          note: string formatting
      variants:
        - id: v1
          title: Log Summary Counts
          description: >-
            Write <code>func logSummary(lines []string) (int, int, int)</code>. Return the count of
            <code>INFO</code>, <code>WARN</code>, and <code>ERROR</code> entries (in that order).
            Extract the level from the third field of each log line.
          functionSignature: func logSummary(lines []string) (int, int, int)
          difficulty: 2
          testCases:
            - input: "logSummary([]string{\"2024-01-15 10:30:45 ERROR timeout\", \"2024-01-15 10:30:46 INFO ok\", \"2024-01-15 10:30:47 WARN slow\", \"2024-01-15 10:30:48 INFO started\", \"2024-01-15 10:30:49 ERROR retry\"})"
              output: "2, 1, 2"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                Declare three counters. Loop through lines, extract the level, and increment the appropriate counter.
            - title: "\U0001F4A1 Hint"
              content: >-
                Use a switch or if/else chain on <code>fields[2]</code> to increment the right counter.
          solution: |-
            func logSummary(lines []string) (int, int, int) {
                infoCount, warnCount, errorCount := 0, 0, 0
                for _, line := range lines {
                    fields := strings.Fields(line)
                    if len(fields) < 3 {
                        continue
                    }
                    switch fields[2] {
                    case "INFO":
                        infoCount++
                    case "WARN":
                        warnCount++
                    case "ERROR":
                        errorCount++
                    }
                }
                return infoCount, warnCount, errorCount
            }
          annotations:
            - type: idiom
              label: Switch Statement
              text: >-
                Go's <code>switch</code> doesn't need <code>break</code> ‚Äî each case automatically breaks.
                Use switch for clean multi-way branching on a single value.

        - id: v2
          title: Log Report
          description: >-
            Write <code>func logReport(lines []string) string</code>. Build a formatted report
            string containing: the total number of entries, the count per level, and the most common level.
            Format:<br><code>Total: 5<br>INFO: 2<br>WARN: 1<br>ERROR: 2<br>Most common: ERROR</code><br>
            If multiple levels tie, return any one of them.
          functionSignature: func logReport(lines []string) string
          difficulty: 3
          testCases:
            - input: "logReport([]string{\"2024-01-15 10:30:45 ERROR timeout\", \"2024-01-15 10:30:46 INFO ok\", \"2024-01-15 10:30:47 WARN slow\", \"2024-01-15 10:30:48 INFO started\", \"2024-01-15 10:30:49 ERROR retry\"})"
              output: "\"Total: 5\\nINFO: 2\\nWARN: 1\\nERROR: 2\\nMost common: INFO\""
              note: "If INFO and ERROR tie, either is acceptable"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                Build a frequency map first, then find the max, then format the output string.
                This combines maps, loops, and string formatting.
            - title: "\U0001F4A1 Hint"
              content: >-
                Use <code>fmt.Sprintf</code> to build each line of the report and concatenate with <code>\n</code>.
          solution: |-
            func logReport(lines []string) string {
                counts := make(map[string]int)
                for _, line := range lines {
                    fields := strings.Fields(line)
                    if len(fields) >= 3 {
                        counts[fields[2]]++
                    }
                }
                maxLevel := ""
                maxCount := 0
                for level, count := range counts {
                    if count > maxCount {
                        maxCount = count
                        maxLevel = level
                    }
                }
                report := fmt.Sprintf("Total: %d", len(lines))
                for _, level := range []string{"INFO", "WARN", "ERROR"} {
                    report += fmt.Sprintf("\n%s: %d", level, counts[level])
                }
                report += fmt.Sprintf("\nMost common: %s", maxLevel)
                return report
            }
          annotations:
            - type: pattern
              label: Ordered Iteration
              text: >-
                Map iteration order is random in Go. When you need a specific order (like INFO, WARN, ERROR),
                iterate over a predefined slice of keys instead of ranging over the map directly.

        - id: v3
          title: Find Anomalies
          description: >-
            Write <code>func findAnomalies(lines []string, threshold int) []string</code>. Find
            error messages that appear more than <code>threshold</code> times. Return a slice of
            those messages (just the message text, not the full log line).
          functionSignature: func findAnomalies(lines []string, threshold int) []string
          difficulty: 3
          testCases:
            - input: "findAnomalies([]string{\"2024-01-15 10:30:45 ERROR timeout\", \"2024-01-15 10:30:46 ERROR timeout\", \"2024-01-15 10:30:47 ERROR timeout\", \"2024-01-15 10:30:48 ERROR disk full\", \"2024-01-15 10:30:49 INFO ok\"}, 2)"
              output: "[\"timeout\"]"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                First build a frequency map of error messages (like challenge_6 v3). Then filter the map
                for entries exceeding the threshold.
            - title: "\U0001F4A1 Hint"
              content: >-
                Two passes: (1) count error messages, (2) collect messages where <code>count > threshold</code>.
          solution: |-
            func findAnomalies(lines []string, threshold int) []string {
                counts := make(map[string]int)
                for _, line := range lines {
                    fields := strings.Fields(line)
                    if len(fields) >= 4 && fields[2] == "ERROR" {
                        msg := strings.Join(fields[3:], " ")
                        counts[msg]++
                    }
                }
                var anomalies []string
                for msg, count := range counts {
                    if count > threshold {
                        anomalies = append(anomalies, msg)
                    }
                }
                return anomalies
            }
          annotations:
            - type: pattern
              label: Two-Pass Processing
              text: >-
                Many aggregation problems need two passes: one to collect data, one to analyze it.
                This is cleaner than trying to do everything in a single loop.

        - id: v4
          title: Parse and Filter
          description: >-
            Write <code>func parseAndFilter(lines []string, level string, keyword string) []string</code>.
            Filter log lines that match both the given level AND contain the keyword in the message.
            Return the matching lines formatted as <code>"[LEVEL] message"</code> (without the timestamp).
          functionSignature: func parseAndFilter(lines []string, level string, keyword string) []string
          difficulty: 3
          testCases:
            - input: "parseAndFilter([]string{\"2024-01-15 10:30:45 ERROR connection timeout\", \"2024-01-15 10:30:46 ERROR disk full\", \"2024-01-15 10:30:47 INFO connection ok\", \"2024-01-15 10:30:48 ERROR connection refused\"}, \"ERROR\", \"connection\")"
              output: "[\"[ERROR] connection timeout\", \"[ERROR] connection refused\"]"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                Split each line, check the level matches, reconstruct the message, check for the keyword,
                then format the output. This combines parsing, filtering, and formatting.
            - title: "\U0001F4A1 Hint"
              content: >-
                Use <code>strings.Fields</code> to split, check <code>fields[2] == level</code>,
                join <code>fields[3:]</code> for the message, check <code>strings.Contains(msg, keyword)</code>,
                then format with <code>fmt.Sprintf("[%s] %s", level, msg)</code>.
          solution: |-
            func parseAndFilter(lines []string, level string, keyword string) []string {
                var result []string
                for _, line := range lines {
                    fields := strings.Fields(line)
                    if len(fields) < 4 {
                        continue
                    }
                    if fields[2] != level {
                        continue
                    }
                    msg := strings.Join(fields[3:], " ")
                    if !strings.Contains(msg, keyword) {
                        continue
                    }
                    result = append(result, fmt.Sprintf("[%s] %s", level, msg))
                }
                return result
            }
          annotations:
            - type: idiom
              label: Early Continue
              text: >-
                Use <code>continue</code> to skip non-matching items early. This keeps the "happy path"
                at the lowest indentation level, making the code easier to read than nested if statements.
