conceptLinks:
  Pointer Basics: "#lesson-pointers"
  Dereferencing: "#lesson-dereferencing"
  Pointer Parameters: "#lesson-pointer-params"
  Nil Pointers: "#lesson-nil"
  Pointer Receivers: "#lesson-pointer-receivers"
  Structs & Pointers: "#lesson-structs-pointers"
  Linked Structures: "#lesson-linked-structures"
sharedContent: {}
variants:
  warmups:
    - id: warmup_1
      concept: Pointer Basics
      quickRef: |
        <code>var p *int</code> &nbsp; <code>p = &amp;x</code> (address of)<br>
                <code>*p</code> (dereference) &nbsp; Zero value is <code>nil</code>
      variants:
        - id: v1
          title: Get an Address
          description: >-
            Create an integer variable, get its address using <code>&amp;</code>, and print both the value and the
            address.
          hints:
            - Use <code>&amp;x</code> to get the address of variable <code>x</code>
            - The pointer will print as a hex memory address like <code>0xc0000b6010</code>
          solution: |-
            x := 42
            ptr := &x
            fmt.Println("Value:", x)
            fmt.Println("Address:", ptr)
          annotations:
            - type: idiom
              label: Address-of Operator
              text: >-
                The <code>&</code> operator returns a pointer to the variable's memory location. In Go, you cannot take
                the address of a constant or literal.
            - type: gotcha
              label: Pointer Formatting
              text: >-
                Printing a pointer with <code>fmt.Println</code> displays the hex address. Use <code>%p</code> with
                <code>fmt.Printf</code> for explicit formatting.
        - id: v2
          title: Address of a String
          description: >-
            Create a string variable holding your name. Get a pointer to it and print the pointer's type using
            <code>fmt.Sprintf("%T", ptr)</code>.
          hints:
            - Use <code>&amp;name</code> to get the pointer
            - <code>%T</code> prints the type, which should be <code>*string</code>
          solution: |-
            name := "Gopher"
            ptr := &name
            fmt.Printf("Type: %T\n", ptr)   // *string
            fmt.Printf("Value: %s\n", name) // Gopher
          annotations:
            - type: idiom
              label: Pointer Types
              text: >-
                A pointer to a <code>string</code> has type <code>*string</code>. The asterisk prefix denotes a pointer
                type in Go's type system.
        - id: v3
          title: Two Pointers, One Variable
          description: >-
            Create an integer variable and two pointers that both point to it. Print the value through both pointers to
            show they reference the same data.
          hints:
            - Both <code>p1 := &amp;x</code> and <code>p2 := &amp;x</code> will point to the same memory
            - Dereference with <code>*p1</code> and <code>*p2</code>
          solution: |-
            x := 100
            p1 := &x
            p2 := &x
            fmt.Println(*p1, *p2) // 100 100
            fmt.Println(p1 == p2) // true
          annotations:
            - type: idiom
              label: Pointer Equality
              text: >-
                Two pointers are equal (<code>==</code>) when they point to the same memory address. This is identity
                comparison, not value comparison.
        - id: v4
          title: Pointer to a Boolean
          description: >-
            Create a <code>bool</code> variable set to <code>false</code>. Get a pointer to it, print the dereferenced
            value, then explain what <code>*ptr</code> gives you.
          hints:
            - "Declare: <code>flag := false</code>"
            - Use <code>*ptr</code> to read the value through the pointer
          solution: |-
            flag := false
            ptr := &flag
            fmt.Println(*ptr) // false
            *ptr = true
            fmt.Println(flag) // true
          annotations:
            - type: gotcha
              label: Zero Values
              text: >-
                In Go, <code>bool</code> defaults to <code>false</code>, <code>int</code> defaults to <code>0</code>,
                and <code>string</code> defaults to <code>""</code>. A pointer itself defaults to <code>nil</code>.
    - id: warmup_2
      concept: Dereferencing
      quickRef: |
        <code>*p = 42</code> (write through pointer)<br>
                <code>v := *p</code> (read through pointer)
      variants:
        - id: v1
          title: Modify Through Pointer
          description: >-
            Create a variable, get a pointer to it, then change the value using <code>*ptr = newValue</code>. Print
            before and after.
          hints:
            - Use <code>*ptr = 50</code> to write through the pointer
            - The original variable changes because the pointer references its memory
          solution: |-
            x := 10
            fmt.Println("Before:", x)
            ptr := &x
            *ptr = 50
            fmt.Println("After:", x) // 50
          annotations:
            - type: idiom
              label: Dereference Assignment
              text: >-
                Writing <code>*ptr = value</code> modifies the variable the pointer points to. This is how Go achieves
                pass-by-reference semantics.
        - id: v2
          title: Increment Via Pointer
          description: >-
            Create an integer set to <code>0</code>. Get a pointer and use it to increment the value 3 times. Print the
            final result.
          hints:
            - Use <code>*ptr++</code> or <code>*ptr = *ptr + 1</code> to increment
            - After 3 increments, the value should be 3
          solution: |-
            count := 0
            ptr := &count
            *ptr++
            *ptr++
            *ptr++
            fmt.Println(count) // 3
          annotations:
            - type: gotcha
              label: Operator Precedence
              text: >-
                In Go, <code>*ptr++</code> works as <code>(*ptr)++</code> because the dereference binds tighter. This
                differs from C where you might need explicit parentheses.
        - id: v3
          title: Swap Two Variables
          description: >-
            Create two variables <code>a</code> and <code>b</code>. Using only pointers, swap their values. Print to
            verify.
          hints:
            - "Get pointers to both: <code>pa, pb := &amp;a, &amp;b</code>"
            - "Swap with: <code>*pa, *pb = *pb, *pa</code>"
          solution: |-
            a, b := 10, 20
            pa, pb := &a, &b
            *pa, *pb = *pb, *pa
            fmt.Println(a, b) // 20 10
          annotations:
            - type: idiom
              label: Parallel Assignment
              text: >-
                Go supports parallel assignment: <code>*a, *b = *b, *a</code>. No temporary variable needed because Go
                evaluates the right side fully before assigning.
        - id: v4
          title: Double a Float
          description: >-
            Create a <code>float64</code> variable set to <code>3.14</code>. Get a pointer and use it to double the
            value. Print the result.
          hints:
            - "Dereference to read and write: <code>*ptr = *ptr * 2</code>"
            - Or use <code>*ptr *= 2</code>
          solution: |-
            pi := 3.14
            ptr := &pi
            *ptr *= 2
            fmt.Println(pi) // 6.28
          annotations:
            - type: idiom
              label: Compound Assignment
              text: >-
                Go supports compound assignment through pointers: <code>*ptr *= 2</code> is shorthand for <code>*ptr =
                *ptr * 2</code>.
    - id: warmup_3
      concept: Pointer Parameters
      quickRef: |
        <code>func f(p *int) { *p = 42 }</code><br>
                Call with: <code>f(&amp;x)</code> &nbsp; Modifies original value
      variants:
        - id: v1
          title: Double Function
          description: Write <code>func double(n *int)</code> that doubles the value at the pointer.
          hints:
            - "Dereference the pointer to get and set the value: <code>*n = *n * 2</code>"
            - Call it with <code>double(&amp;x)</code>
          solution: |-
            func double(n *int) {
                *n = *n * 2
            }

            // Test:
            x := 5
            double(&x)
            fmt.Println(x) // 10
          annotations:
            - type: idiom
              label: Pointer Parameters
              text: >-
                Passing a pointer parameter lets functions modify the caller's variable. This is Go's way of simulating
                pass-by-reference.
            - type: gotcha
              label: Don't Forget &
              text: >-
                When calling a function that takes <code>*int</code>, you must pass <code>&x</code> (the address), not
                <code>x</code> itself.
        - id: v2
          title: Negate In Place
          description: Write <code>func negate(n *int)</code> that negates the integer (positive becomes negative, and vice versa).
          hints:
            - Use <code>*n = -*n</code> to flip the sign
            - Call with <code>negate(&amp;x)</code>
          solution: |-
            func negate(n *int) {
                *n = -*n
            }

            // Test:
            x := 7
            negate(&x)
            fmt.Println(x) // -7
            negate(&x)
            fmt.Println(x) // 7
          annotations:
            - type: idiom
              label: In-Place Mutation
              text: >-
                Functions that modify values in place via pointers typically return nothing. The side effect IS the
                result.
        - id: v3
          title: Set to Zero
          description: Write <code>func reset(n *int)</code> that sets the pointed-to value to zero.
          hints:
            - "Simply assign: <code>*n = 0</code>"
          solution: |-
            func reset(n *int) {
                *n = 0
            }

            // Test:
            x := 999
            reset(&x)
            fmt.Println(x) // 0
          annotations:
            - type: alternative
              label: Value vs Pointer
              text: >-
                Without pointers, <code>func reset(n int)</code> would only modify a local copy. The pointer version
                modifies the original.
        - id: v4
          title: Add To Variable
          description: >-
            Write <code>func addTo(n *int, amount int)</code> that adds <code>amount</code> to the value pointed to by
            <code>n</code>.
          hints:
            - Use <code>*n += amount</code> to add in place
            - The second parameter is a plain int, not a pointer
          solution: |-
            func addTo(n *int, amount int) {
                *n += amount
            }

            // Test:
            balance := 100
            addTo(&balance, 50)
            fmt.Println(balance) // 150
            addTo(&balance, -30)
            fmt.Println(balance) // 120
          annotations:
            - type: idiom
              label: Mixed Parameters
              text: It is common to mix pointer and value parameters. Only use pointers for values you intend to modify.
    - id: warmup_4
      concept: Nil Pointers
      quickRef: |
        <code>if p != nil { *p }</code> &nbsp; Always check before dereferencing<br>
                Zero value of any pointer type is <code>nil</code>
      variants:
        - id: v1
          title: Check for Nil
          description: >-
            Write a function <code>func printValue(p *int)</code> that prints the value if p is not nil, or prints
            "pointer is nil" if it is.
          hints:
            - Check <code>if p != nil</code> before dereferencing
            - Dereferencing a nil pointer causes a runtime panic
          solution: |-
            func printValue(p *int) {
                if p != nil {
                    fmt.Println("Value:", *p)
                } else {
                    fmt.Println("pointer is nil")
                }
            }
          annotations:
            - type: gotcha
              label: Nil Panic
              text: >-
                Dereferencing a nil pointer (<code>*p</code> when <code>p == nil</code>) causes a runtime panic. Always
                check for nil before dereferencing.
            - type: idiom
              label: Guard Clause
              text: Checking for nil at the top of a function is a common Go pattern called a guard clause.
        - id: v2
          title: Safe String Length
          description: >-
            Write <code>func safeLen(s *string) int</code> that returns the length of the string if s is not nil, or
            <code>-1</code> if it is nil.
          hints:
            - Check <code>if s == nil</code> and return <code>-1</code>
            - Otherwise return <code>len(*s)</code>
          solution: |-
            func safeLen(s *string) int {
                if s == nil {
                    return -1
                }
                return len(*s)
            }
          annotations:
            - type: idiom
              label: Sentinel Values
              text: >-
                Returning <code>-1</code> as a sentinel for 'no value' is common in Go. Alternatively, return
                <code>(int, bool)</code> or <code>(int, error)</code>.
        - id: v3
          title: Default Value on Nil
          description: >-
            Write <code>func valueOrDefault(p *int, fallback int) int</code> that returns <code>*p</code> if p is not
            nil, or <code>fallback</code> otherwise.
          hints:
            - This is a simple nil check with a fallback
            - Return <code>*p</code> only when <code>p != nil</code>
          solution: |-
            func valueOrDefault(p *int, fallback int) int {
                if p != nil {
                    return *p
                }
                return fallback
            }
          annotations:
            - type: pattern
              label: Default Pattern
              text: >-
                The 'value-or-default' pattern is used throughout the Go standard library, especially in configuration
                structs where nil means 'use default'.
        - id: v4
          title: Compare Optional Values
          description: >-
            Write <code>func bothEqual(a, b *int) bool</code> that returns true if both pointers are non-nil and point
            to equal values, or both are nil.
          hints:
            - Handle the case where both are nil first
            - Then check if exactly one is nil
            - Finally compare <code>*a == *b</code>
          solution: |-
            func bothEqual(a, b *int) bool {
                if a == nil && b == nil {
                    return true
                }
                if a == nil || b == nil {
                    return false
                }
                return *a == *b
            }
          annotations:
            - type: gotcha
              label: Pointer vs Value Equality
              text: >-
                Comparing pointers with <code>==</code> checks if they point to the same address. To compare the values
                they point to, you must dereference: <code>*a == *b</code>.
            - type: pattern
              label: Nil-safe Comparison
              text: >-
                This three-step pattern (both nil, one nil, compare values) is the standard way to safely compare
                optional/nullable values.
  challenges:
    - id: challenge_1
      block: 1
      difficulty: 2
      concept: Pointer Parameters
      docLinks:
        - url: https://go.dev/ref/spec#Pointer_types
          title: "Go Spec: Pointer types"
          note: pointer type declarations
        - url: https://go.dev/doc/effective_go#pointers_vs_values
          title: "Effective Go: Pointers vs. Values"
          note: when to use pointer parameters
      quickRef: |
        <code>func f(p *int) { *p = 42 }</code><br>
                Call with: <code>f(&amp;x)</code> &nbsp; Modifies original value
      variants:
        - id: v1
          title: Swap Two Integers
          description: Write a function <code>func swap(a, b *int)</code> that swaps two integers using pointers.
          functionSignature: func swap(a, b *int)
          testCases:
            - input: x, y := 5, 10; swap(&x, &y)
              output: x == 10, y == 5
            - input: x, y := -1, 1; swap(&x, &y)
              output: x == 1, y == -1
            - input: x, y := 0, 0; swap(&x, &y)
              output: x == 0, y == 0
          hints:
            - title: ðŸ¤” Think about it
              content: >-
                How do you swap two values in any language? You usually need a temporary variable -- but Go has a
                shortcut.
            - title: ðŸ’¡ Hint
              content: >-
                Go supports parallel assignment: <code>*a, *b = *b, *a</code>. Both sides are evaluated before
                assignment.
            - title: ðŸ”§ Pattern
              content: |-
                <pre>1. Dereference both pointers
                2. Assign in parallel: *a, *b = *b, *a
                   (or use a temp variable)</pre>
          solution: |-
            func swap(a, b *int) {
                *a, *b = *b, *a
            }
          difficulty: 1
          annotations:
            - type: idiom
              label: Parallel Assignment
              text: >-
                Go evaluates the entire right-hand side before assigning, making swaps a one-liner without a temp
                variable.
            - type: complexity
              label: O(1)
              text: Constant time and space. Only pointer dereferences and assignments.
        - id: v2
          title: Swap Two Strings
          description: Write a function <code>func swapStrings(a, b *string)</code> that swaps two strings using pointers.
          functionSignature: func swapStrings(a, b *string)
          testCases:
            - input: a, b := "hello", "world"; swapStrings(&a, &b)
              output: a == "world", b == "hello"
            - input: a, b := "", "Go"; swapStrings(&a, &b)
              output: a == "Go", b == ""
          hints:
            - title: ðŸ¤” Think about it
              content: Swapping strings works exactly the same as swapping ints with pointers.
            - title: ðŸ’¡ Hint
              content: "Use parallel assignment: <code>*a, *b = *b, *a</code>"
            - title: ðŸ”§ Pattern
              content: |-
                <pre>1. Dereference both string pointers
                2. Parallel assign: *a, *b = *b, *a</pre>
          solution: |-
            func swapStrings(a, b *string) {
                *a, *b = *b, *a
            }
          difficulty: 1
          annotations:
            - type: idiom
              label: Generic Pattern
              text: >-
                The pointer swap pattern works identically for any type. Before Go generics, you needed separate
                functions per type.
        - id: v3
          title: Conditional Swap
          description: >-
            Write <code>func sortPair(a, b *int)</code> that ensures <code>*a &lt;= *b</code> after the call. Swap only
            if needed.
          functionSignature: func sortPair(a, b *int)
          testCases:
            - input: a, b := 10, 5; sortPair(&a, &b)
              output: a == 5, b == 10
            - input: a, b := 3, 7; sortPair(&a, &b)
              output: a == 3, b == 7
            - input: a, b := 4, 4; sortPair(&a, &b)
              output: a == 4, b == 4
          hints:
            - title: ðŸ¤” Think about it
              content: When should you swap? Only when the first value is greater than the second.
            - title: ðŸ’¡ Hint
              content: Check <code>if *a > *b</code> before swapping.
            - title: ðŸ”§ Pattern
              content: |-
                <pre>1. Compare *a and *b
                2. If *a > *b, swap them
                3. Otherwise do nothing</pre>
          solution: |-
            func sortPair(a, b *int) {
                if *a > *b {
                    *a, *b = *b, *a
                }
            }
          difficulty: 2
          annotations:
            - type: pattern
              label: Conditional Mutation
              text: >-
                Only mutate through pointers when a condition is met. This is the building block of in-place sorting
                algorithms.
            - type: complexity
              label: O(1)
              text: Single comparison and at most one swap.
        - id: v4
          title: Rotate Three Values
          description: >-
            Write <code>func rotateRight(a, b, c *int)</code> that rotates three values to the right: a gets c's value,
            b gets a's value, c gets b's value.
          functionSignature: func rotateRight(a, b, c *int)
          testCases:
            - input: a, b, c := 1, 2, 3; rotateRight(&a, &b, &c)
              output: a == 3, b == 1, c == 2
            - input: a, b, c := 10, 20, 30; rotateRight(&a, &b, &c)
              output: a == 30, b == 10, c == 20
          hints:
            - title: ðŸ¤” Think about it
              content: A right rotation means each element takes the value of the one before it (wrapping around).
            - title: ðŸ’¡ Hint
              content: "Use Go's parallel assignment with three variables: <code>*a, *b, *c = *c, *a, *b</code>"
            - title: ðŸ”§ Pattern
              content: |-
                <pre>Right rotate: each gets its left neighbor
                *a, *b, *c = *c, *a, *b</pre>
          solution: |-
            func rotateRight(a, b, c *int) {
                *a, *b, *c = *c, *a, *b
            }
          difficulty: 2
          annotations:
            - type: idiom
              label: Multi-way Parallel Assignment
              text: Go's parallel assignment extends to any number of variables, making rotations elegant one-liners.
            - type: gotcha
              label: Direction Matters
              text: >-
                Right rotation vs left rotation is easy to confuse. Right rotation: each position gets the value from
                its left neighbor.
    - id: challenge_2
      block: 1
      difficulty: 2
      concept: Pointer Receivers
      docLinks:
        - url: https://go.dev/doc/effective_go#pointers_vs_values
          title: "Effective Go: Pointers vs. Values"
          note: pointer receivers modify the receiver
        - url: https://go.dev/ref/spec#Method_declarations
          title: "Go Spec: Method declarations"
          note: method syntax with receivers
      quickRef: |
        <code>func (s *MyStruct) Method() { s.field = v }</code><br>
                Pointer receiver can modify the struct
      variants:
        - id: v1
          title: Counter Struct
          description: >-
            Create a <code>Counter</code> struct with an <code>int</code> value. Add methods <code>Increment()</code>,
            <code>Decrement()</code>, and <code>Value() int</code>.
          functionSignature: |-
            func (c *Counter) Increment()
            func (c *Counter) Decrement()
            func (c Counter) Value() int
          testCases:
            - input: c := Counter{}; c.Increment(); c.Increment(); c.Decrement()
              output: c.Value() == 1
            - input: c := Counter{}; c.Decrement()
              output: c.Value() == -1
          hints:
            - title: ðŸ¤” Think about it
              content: Which methods need to modify the struct? Those need pointer receivers.
            - title: ðŸ’¡ Hint
              content: Increment and Decrement need <code>*Counter</code> receivers. Value can use a value receiver.
            - title: ðŸ”§ Pattern
              content: |-
                <pre>type Counter struct { value int }
                func (c *Counter) Increment() { c.value++ }
                func (c *Counter) Decrement() { c.value-- }
                func (c Counter) Value() int { return c.value }</pre>
          solution: |-
            type Counter struct {
                value int
            }

            func (c *Counter) Increment() {
                c.value++
            }

            func (c *Counter) Decrement() {
                c.value--
            }

            func (c Counter) Value() int {
                return c.value
            }
          difficulty: 2
          annotations:
            - type: idiom
              label: Pointer Receivers
              text: >-
                Methods that modify struct state must use pointer receivers (<code>*Counter</code>). Value receivers get
                a copy and cannot mutate the original.
            - type: gotcha
              label: Value Receiver Trap
              text: >-
                If <code>Increment</code> used a value receiver <code>(c Counter)</code>, it would increment a copy. The
                original counter would never change.
        - id: v2
          title: Stack Struct
          description: >-
            Create a <code>Stack</code> struct backed by a slice of <code>int</code>. Add <code>Push(val int)</code>,
            <code>Pop() (int, bool)</code>, and <code>Size() int</code>.
          functionSignature: |-
            func (s *Stack) Push(val int)
            func (s *Stack) Pop() (int, bool)
            func (s Stack) Size() int
          testCases:
            - input: s := Stack{}; s.Push(10); s.Push(20); val, ok := s.Pop()
              output: val == 20, ok == true, s.Size() == 1
            - input: s := Stack{}; val, ok := s.Pop()
              output: val == 0, ok == false
          hints:
            - title: ðŸ¤” Think about it
              content: A stack is last-in-first-out (LIFO). Which end of a slice is cheapest to add/remove from?
            - title: ðŸ’¡ Hint
              content: >-
                Use <code>append</code> for Push. For Pop, grab the last element and reslice: <code>s.items =
                s.items[:len(s.items)-1]</code>
            - title: ðŸ”§ Pattern
              content: |-
                <pre>Push: s.items = append(s.items, val)
                Pop: get last, shrink slice
                Return (0, false) if empty</pre>
          solution: |-
            type Stack struct {
                items []int
            }

            func (s *Stack) Push(val int) {
                s.items = append(s.items, val)
            }

            func (s *Stack) Pop() (int, bool) {
                if len(s.items) == 0 {
                    return 0, false
                }
                val := s.items[len(s.items)-1]
                s.items = s.items[:len(s.items)-1]
                return val, true
            }

            func (s Stack) Size() int {
                return len(s.items)
            }
          difficulty: 2
          annotations:
            - type: idiom
              label: Comma-ok Pattern
              text: >-
                Returning <code>(int, bool)</code> from Pop follows Go's comma-ok idiom: the second return signals
                whether the operation succeeded.
            - type: gotcha
              label: Slice Append Receiver
              text: >-
                Push must use a pointer receiver because <code>append</code> may allocate a new underlying array,
                changing the slice header.
        - id: v3
          title: Toggle Switch
          description: >-
            Create a <code>Toggle</code> struct with a <code>bool</code> state. Add <code>Flip()</code> to toggle the
            state and <code>IsOn() bool</code> to read it.
          functionSignature: |-
            func (t *Toggle) Flip()
            func (t Toggle) IsOn() bool
          testCases:
            - input: t := Toggle{}; t.Flip()
              output: t.IsOn() == true
            - input: t := Toggle{}; t.Flip(); t.Flip()
              output: t.IsOn() == false
          hints:
            - title: ðŸ¤” Think about it
              content: How do you toggle a boolean? Think about the NOT operator.
            - title: ðŸ’¡ Hint
              content: Use <code>t.on = !t.on</code> in the Flip method with a pointer receiver.
            - title: ðŸ”§ Pattern
              content: |-
                <pre>type Toggle struct { on bool }
                func (t *Toggle) Flip() { t.on = !t.on }
                func (t Toggle) IsOn() bool { return t.on }</pre>
          solution: |-
            type Toggle struct {
                on bool
            }

            func (t *Toggle) Flip() {
                t.on = !t.on
            }

            func (t Toggle) IsOn() bool {
                return t.on
            }
          difficulty: 1
          annotations:
            - type: idiom
              label: Encapsulation
              text: >-
                Lowercase field <code>on</code> is unexported. Only the struct's methods can access it, providing
                encapsulation.
        - id: v4
          title: Accumulator Struct
          description: >-
            Create an <code>Accumulator</code> struct that tracks a running sum. Add <code>Add(n int)</code>,
            <code>Reset()</code>, and <code>Total() int</code>.
          functionSignature: |-
            func (a *Accumulator) Add(n int)
            func (a *Accumulator) Reset()
            func (a Accumulator) Total() int
          testCases:
            - input: a := Accumulator{}; a.Add(5); a.Add(3)
              output: a.Total() == 8
            - input: a := Accumulator{}; a.Add(10); a.Reset()
              output: a.Total() == 0
          hints:
            - title: ðŸ¤” Think about it
              content: This is like Counter but with arbitrary additions and a reset capability.
            - title: ðŸ’¡ Hint
              content: Add increments by n, Reset sets to 0, Total returns the current sum.
            - title: ðŸ”§ Pattern
              content: |-
                <pre>type Accumulator struct { sum int }
                Add: a.sum += n
                Reset: a.sum = 0
                Total: return a.sum</pre>
          solution: |-
            type Accumulator struct {
                sum int
            }

            func (a *Accumulator) Add(n int) {
                a.sum += n
            }

            func (a *Accumulator) Reset() {
                a.sum = 0
            }

            func (a Accumulator) Total() int {
                return a.sum
            }
          difficulty: 2
          annotations:
            - type: idiom
              label: Consistent Receivers
              text: >-
                Go convention: if any method needs a pointer receiver, use pointer receivers for all methods on that
                type for consistency.
            - type: alternative
              label: Functional Approach
              text: >-
                An alternative is a closure: <code>func NewAccumulator() func(int) int</code>. Structs with methods are
                more idiomatic in Go.
    - id: challenge_3
      block: 2
      difficulty: 2
      concept: Nil Pointers
      docLinks:
        - url: https://go.dev/ref/spec#The_zero_value
          title: "Go Spec: The zero value"
          note: nil is the zero value for pointers
        - url: https://go.dev/doc/effective_go#pointers_vs_values
          title: "Effective Go: Pointers vs. Values"
          note: nil checks and safe dereferencing
      quickRef: |
        <code>if p != nil { *p }</code> &nbsp; Always check before dereferencing<br>
                Zero value of any pointer type is <code>nil</code>
      variants:
        - id: v1
          title: Safe Dereference
          description: >-
            Write <code>func safeDeref(p *string) string</code> that returns the string value if p is not nil, or
            <code>"&lt;nil&gt;"</code> if it is.
          functionSignature: func safeDeref(p *string) string
          testCases:
            - input: s := "hello"; safeDeref(&s)
              output: "\"hello\""
            - input: safeDeref(nil)
              output: "\"<nil>\""
          hints:
            - title: ðŸ¤” Think about it
              content: What happens if you dereference a nil pointer? You need to guard against that.
            - title: ðŸ’¡ Hint
              content: Check <code>p == nil</code> before dereferencing. Return the fallback string if nil.
            - title: ðŸ”§ Pattern
              content: |-
                <pre>1. Check if p == nil
                2. If nil, return "<nil>"
                3. Otherwise return *p</pre>
          solution: |-
            func safeDeref(p *string) string {
                if p == nil {
                    return "<nil>"
                }
                return *p
            }
          difficulty: 1
          annotations:
            - type: idiom
              label: Nil Guard
              text: Always check for nil before dereferencing. This is the most basic pointer safety pattern in Go.
            - type: stdlib
              label: Optional Values
              text: Go doesn't have an Option/Maybe type. Nil pointers serve as the 'absent value' convention.
        - id: v2
          title: Coalesce Values
          description: >-
            Write <code>func coalesce(ptrs ...*int) (int, bool)</code> that returns the first non-nil value among the
            given pointers, or <code>(0, false)</code> if all are nil.
          functionSignature: func coalesce(ptrs ...*int) (int, bool)
          testCases:
            - input: a := 5; coalesce(nil, &a, nil)
              output: 5, true
            - input: coalesce(nil, nil)
              output: 0, false
            - input: a, b := 1, 2; coalesce(&a, &b)
              output: 1, true
          hints:
            - title: ðŸ¤” Think about it
              content: You need to iterate through the pointers and find the first non-nil one.
            - title: ðŸ’¡ Hint
              content: Use a range loop over the variadic parameter. Check each for nil.
            - title: ðŸ”§ Pattern
              content: |-
                <pre>1. For each pointer in ptrs:
                   - If not nil, return *ptr, true
                2. All nil: return 0, false</pre>
          solution: |-
            func coalesce(ptrs ...*int) (int, bool) {
                for _, p := range ptrs {
                    if p != nil {
                        return *p, true
                    }
                }
                return 0, false
            }
          difficulty: 2
          annotations:
            - type: idiom
              label: Variadic + Pointers
              text: >-
                Variadic pointer parameters let you pass a flexible number of optional values, similar to SQL's COALESCE
                function.
            - type: complexity
              label: O(n)
              text: Linear in the number of pointers. Exits early on first non-nil value.
        - id: v3
          title: Safe Add
          description: >-
            Write <code>func safeAdd(a, b *int) (int, error)</code> that adds the values if both are non-nil. Return an
            error if either is nil.
          functionSignature: func safeAdd(a, b *int) (int, error)
          testCases:
            - input: x, y := 3, 4; safeAdd(&x, &y)
              output: 7, nil
            - input: x := 3; safeAdd(&x, nil)
              output: 0, error
            - input: safeAdd(nil, nil)
              output: 0, error
          hints:
            - title: ðŸ¤” Think about it
              content: You need to validate both inputs before operating on them.
            - title: ðŸ’¡ Hint
              content: Check <code>a == nil || b == nil</code> and return an error using <code>fmt.Errorf</code>.
            - title: ðŸ”§ Pattern
              content: |-
                <pre>1. Check if either pointer is nil
                2. If yes, return 0 and an error
                3. Otherwise return *a + *b, nil</pre>
          solution: |-
            func safeAdd(a, b *int) (int, error) {
                if a == nil || b == nil {
                    return 0, fmt.Errorf("nil pointer argument")
                }
                return *a + *b, nil
            }
          difficulty: 2
          annotations:
            - type: idiom
              label: Error Returns
              text: >-
                Returning <code>(value, error)</code> is the canonical Go error handling pattern. The caller decides how
                to handle the error.
            - type: gotcha
              label: Check Both
              text: >-
                A common mistake is checking only one pointer. Both <code>a</code> and <code>b</code> could
                independently be nil.
        - id: v4
          title: Nil-safe Max
          description: >-
            Write <code>func safeMax(a, b *int) *int</code> that returns a pointer to the larger value. If one is nil,
            return the other. If both nil, return nil.
          functionSignature: func safeMax(a, b *int) *int
          testCases:
            - input: x, y := 5, 10; safeMax(&x, &y)
              output: "*result == 10"
            - input: x := 5; safeMax(&x, nil)
              output: "*result == 5"
            - input: safeMax(nil, nil)
              output: result == nil
          hints:
            - title: ðŸ¤” Think about it
              content: Handle the nil cases first, then compare the dereferenced values.
            - title: ðŸ’¡ Hint
              content: If a is nil, return b (and vice versa). If neither is nil, compare <code>*a</code> and <code>*b</code>.
            - title: ðŸ”§ Pattern
              content: |-
                <pre>1. If a == nil, return b
                2. If b == nil, return a
                3. If *a >= *b, return a
                4. Else return b</pre>
          solution: |-
            func safeMax(a, b *int) *int {
                if a == nil {
                    return b
                }
                if b == nil {
                    return a
                }
                if *a >= *b {
                    return a
                }
                return b
            }
          difficulty: 3
          annotations:
            - type: pattern
              label: Returning Pointers
              text: >-
                Returning one of the input pointers means the caller gets a reference to the original variable, not a
                copy.
            - type: gotcha
              label: Pointer Aliasing
              text: >-
                The returned pointer aliases one of the inputs. Modifying through the returned pointer changes the
                original variable.
    - id: challenge_4
      block: 2
      difficulty: 3
      concept: Linked Structures
      docLinks:
        - url: https://go.dev/ref/spec#Pointer_types
          title: "Go Spec: Pointer types"
          note: self-referential struct pointers
        - url: https://go.dev/ref/spec#Struct_types
          title: "Go Spec: Struct types"
          note: defining linked node structs
        - url: https://pkg.go.dev/container/list
          title: Package container/list
          note: stdlib doubly linked list for reference
      quickRef: |
        <code>type Node struct { Val int; Next *Node }</code><br>
                Traverse: <code>for n := head; n != nil; n = n.Next { }</code>
      variants:
        - id: v1
          title: "Linked List: Build and Traverse"
          description: >-
            Define a <code>Node</code> struct with <code>Value int</code> and <code>Next *Node</code>. Write <code>func
            buildList(values []int) *Node</code> and <code>func traverse(head *Node) []int</code>.
          functionSignature: |-
            func buildList(values []int) *Node
            func traverse(head *Node) []int
          testCases:
            - input: traverse(buildList([]int{1, 2, 3}))
              output: "[]int{1, 2, 3}"
            - input: traverse(buildList([]int{}))
              output: "[]int{}"
            - input: traverse(buildList([]int{42}))
              output: "[]int{42}"
          hints:
            - title: ðŸ¤” Think about it
              content: >-
                To build a list preserving order, consider building from the back. To traverse, follow Next pointers
                until nil.
            - title: ðŸ’¡ Hint
              content: >-
                Build in reverse: start from the last element. Each new node's Next points to the previous head.
                Traverse with <code>for node != nil</code>.
            - title: ðŸ”§ Pattern
              content: |-
                <pre>Build:
                  var head *Node
                  for i := len(values)-1; i >= 0; i--
                    head = &Node{values[i], head}

                Traverse:
                  for node := head; node != nil; node = node.Next
                    append to result</pre>
          solution: |-
            type Node struct {
                Value int
                Next  *Node
            }

            func buildList(values []int) *Node {
                var head *Node
                for i := len(values) - 1; i >= 0; i-- {
                    head = &Node{Value: values[i], Next: head}
                }
                return head
            }

            func traverse(head *Node) []int {
                var result []int
                for node := head; node != nil; node = node.Next {
                    result = append(result, node.Value)
                }
                return result
            }
          difficulty: 2
          annotations:
            - type: idiom
              label: Self-referential Structs
              text: >-
                A struct can contain a pointer to its own type (<code>Next *Node</code>). This enables linked data
                structures like lists and trees.
            - type: complexity
              label: O(n)
              text: Both build and traverse are O(n) where n is the number of elements.
        - id: v2
          title: "Linked List: Length"
          description: >-
            Given the <code>Node</code> struct, write <code>func listLength(head *Node) int</code> that returns the
            number of nodes in the linked list.
          functionSignature: func listLength(head *Node) int
          testCases:
            - input: listLength(buildList([]int{1, 2, 3}))
              output: "3"
            - input: listLength(nil)
              output: "0"
            - input: listLength(buildList([]int{42}))
              output: "1"
          hints:
            - title: ðŸ¤” Think about it
              content: Walk the list, counting each node until you hit nil.
            - title: ðŸ’¡ Hint
              content: Initialize a counter. Loop with <code>for node != nil</code>, incrementing each iteration.
            - title: ðŸ”§ Pattern
              content: |-
                <pre>count := 0
                for node := head; node != nil; node = node.Next {
                    count++
                }
                return count</pre>
          solution: |-
            func listLength(head *Node) int {
                count := 0
                for node := head; node != nil; node = node.Next {
                    count++
                }
                return count
            }
          difficulty: 1
          annotations:
            - type: idiom
              label: Nil-terminated Traversal
              text: >-
                Linked list traversal uses <code>node != nil</code> as the loop condition. The nil at the end acts as a
                natural terminator.
        - id: v3
          title: "Linked List: Search"
          description: >-
            Write <code>func contains(head *Node, target int) bool</code> that returns true if any node in the list has
            the given value.
          functionSignature: func contains(head *Node, target int) bool
          testCases:
            - input: contains(buildList([]int{1, 2, 3}), 2)
              output: "true"
            - input: contains(buildList([]int{1, 2, 3}), 5)
              output: "false"
            - input: contains(nil, 1)
              output: "false"
          hints:
            - title: ðŸ¤” Think about it
              content: Traverse the list, comparing each node's value to the target.
            - title: ðŸ’¡ Hint
              content: Return true immediately when you find a match. If the loop ends, the value wasn't found.
            - title: ðŸ”§ Pattern
              content: |-
                <pre>for node := head; node != nil; node = node.Next {
                    if node.Value == target { return true }
                }
                return false</pre>
          solution: |-
            func contains(head *Node, target int) bool {
                for node := head; node != nil; node = node.Next {
                    if node.Value == target {
                        return true
                    }
                }
                return false
            }
          difficulty: 2
          annotations:
            - type: idiom
              label: Early Return
              text: >-
                Returning early when the condition is met avoids unnecessary traversal. This is idiomatic Go -- don't
                use a found variable.
            - type: complexity
              label: O(n)
              text: Worst case traverses all nodes. Average case exits early when found.
        - id: v4
          title: "Linked List: Reverse"
          description: >-
            Write <code>func reverse(head *Node) *Node</code> that reverses a linked list in place and returns the new
            head.
          functionSignature: func reverse(head *Node) *Node
          testCases:
            - input: traverse(reverse(buildList([]int{1, 2, 3})))
              output: "[]int{3, 2, 1}"
            - input: traverse(reverse(buildList([]int{1})))
              output: "[]int{1}"
            - input: reverse(nil)
              output: nil
          hints:
            - title: ðŸ¤” Think about it
              content: You need to reverse all the Next pointers. What pointers do you need to track to avoid losing nodes?
            - title: ðŸ’¡ Hint
              content: >-
                Use three pointers: <code>prev</code> (starts nil), <code>current</code>, and <code>next</code>. For
                each node, save next, point current.Next to prev, advance prev and current.
            - title: ðŸ”§ Pattern
              content: |-
                <pre>var prev *Node
                current := head
                for current != nil {
                    next := current.Next
                    current.Next = prev
                    prev = current
                    current = next
                }
                return prev</pre>
          solution: |-
            func reverse(head *Node) *Node {
                var prev *Node
                current := head
                for current != nil {
                    next := current.Next
                    current.Next = prev
                    prev = current
                    current = next
                }
                return prev
            }
          difficulty: 3
          annotations:
            - type: pattern
              label: Three-pointer Reversal
              text: >-
                The prev/current/next pattern is the classic iterative linked list reversal. It's O(n) time and O(1)
                space.
            - type: complexity
              label: O(n) time, O(1) space
              text: Traverses each node exactly once. Only uses a constant number of extra pointer variables.
            - type: gotcha
              label: Save Next First
              text: You must save <code>current.Next</code> before overwriting it, or you lose the rest of the list.
