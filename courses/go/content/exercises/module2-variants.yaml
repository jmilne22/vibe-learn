conceptLinks:
  Building Slices: "#lesson-slices"
  Slice Operations: "#lesson-slices"
  Map Basics: "#lesson-maps"
  Comma-Ok Pattern: "#lesson-comma-ok"
  Strings & Runes: "#lesson-variables"
  Go Fundamentals Combined: "#lesson-variables"

sharedContent: {}

variants:
  warmups:
    # ‚îÄ‚îÄ warmup_1: Building Slices ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    - id: warmup_1
      concept: Building Slices
      variants:
        - id: v1
          title: Print Planet Names
          description: >-
            Declare a slice literal containing the strings <code>"Mercury"</code>,
            <code>"Venus"</code>, <code>"Earth"</code>, <code>"Mars"</code>.
            Iterate over it with <code>range</code> and print each planet.
          hints:
            - "Use <code>planets := []string{\"Mercury\", \"Venus\", \"Earth\", \"Mars\"}</code>"
            - "Use <code>for _, p := range planets</code> to iterate"
          solution: |-
            planets := []string{"Mercury", "Venus", "Earth", "Mars"}
            for _, p := range planets {
                fmt.Println(p)
            }

        - id: v2
          title: Collect Even Numbers
          description: >-
            Write a program that loops from 1 to 20 and uses <code>append</code> to collect
            all even numbers into a slice. Print the final slice.
          hints:
            - "Start with an empty slice: <code>var evens []int</code>"
            - "Inside the loop, use <code>if i % 2 == 0 { evens = append(evens, i) }</code>"
          solution: |-
            var evens []int
            for i := 1; i <= 20; i++ {
                if i%2 == 0 {
                    evens = append(evens, i)
                }
            }
            fmt.Println(evens)

        - id: v3
          title: Last Three Lines
          description: >-
            Given <code>lines := []string{"line1", "line2", "line3", "line4", "line5"}</code>,
            use slice syntax to grab the last 3 elements and print them.
          hints:
            - "Use <code>lines[len(lines)-3:]</code> to get the last 3 elements"
          solution: |-
            lines := []string{"line1", "line2", "line3", "line4", "line5"}
            last3 := lines[len(lines)-3:]
            fmt.Println(last3)

        - id: v4
          title: Pre-Allocate with make
          description: >-
            Use <code>make([]int, 5)</code> to create a slice of 5 integers.
            Fill each element with its index squared (<code>i*i</code>), then print the slice.
          hints:
            - "Use <code>squares := make([]int, 5)</code> to pre-allocate"
            - "Fill with <code>for i := 0; i &lt; len(squares); i++ { squares[i] = i * i }</code>"
          solution: |-
            squares := make([]int, 5)
            for i := 0; i < len(squares); i++ {
                squares[i] = i * i
            }
            fmt.Println(squares)

    # ‚îÄ‚îÄ warmup_2: Map Basics ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    - id: warmup_2
      concept: Map Basics
      variants:
        - id: v1
          title: Iterate a Map
          description: >-
            Create a map literal mapping HTTP methods to descriptions:
            <code>"GET"</code> ‚Üí <code>"read"</code>,
            <code>"POST"</code> ‚Üí <code>"create"</code>,
            <code>"DELETE"</code> ‚Üí <code>"remove"</code>.
            Iterate with <code>range</code> and print each key-value pair.
          hints:
            - "Use <code>methods := map[string]string{\"GET\": \"read\", ...}</code>"
            - "Use <code>for k, v := range methods</code> to iterate"
          solution: |-
            methods := map[string]string{
                "GET":    "read",
                "POST":   "create",
                "DELETE": "remove",
            }
            for k, v := range methods {
                fmt.Printf("%s: %s\n", k, v)
            }

        - id: v2
          title: Build a Map from Slices
          description: >-
            Given <code>keys := []string{"a", "b", "c"}</code> and
            <code>values := []int{1, 2, 3}</code>, build a
            <code>map[string]int</code> by looping over the slices, then print the map.
          hints:
            - "Create the map first: <code>m := make(map[string]int)</code>"
            - "Use <code>for i := 0; i &lt; len(keys); i++ { m[keys[i]] = values[i] }</code>"
          solution: |-
            keys := []string{"a", "b", "c"}
            values := []int{1, 2, 3}
            m := make(map[string]int)
            for i := 0; i < len(keys); i++ {
                m[keys[i]] = values[i]
            }
            fmt.Println(m)

        - id: v3
          title: Comma-Ok Lookup
          description: >-
            Given <code>config := map[string]string{"host": "localhost", "port": "8080"}</code>,
            look up the key <code>"timeout"</code> using the comma-ok pattern. If missing,
            print <code>"not set"</code>; otherwise print the value.
          hints:
            - "Use <code>val, ok := config[\"timeout\"]</code>"
            - "Check <code>if !ok { fmt.Println(\"not set\") }</code>"
          solution: |-
            config := map[string]string{"host": "localhost", "port": "8080"}
            val, ok := config["timeout"]
            if !ok {
                fmt.Println("not set")
            } else {
                fmt.Println(val)
            }

        - id: v4
          title: Count Word Frequency
          description: >-
            Given <code>words := []string{"go", "is", "fun", "go", "is", "great", "go"}</code>,
            count the frequency of each word using a map. Print the resulting map.
          hints:
            - "Create <code>freq := make(map[string]int)</code>"
            - "For each word, <code>freq[word]++</code> increments the count (zero value for int is 0)"
          solution: |-
            words := []string{"go", "is", "fun", "go", "is", "great", "go"}
            freq := make(map[string]int)
            for _, word := range words {
                freq[word]++
            }
            fmt.Println(freq)

    # ‚îÄ‚îÄ warmup_3: Strings & Runes ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    - id: warmup_3
      concept: Strings & Runes
      variants:
        - id: v1
          title: Bytes vs Characters
          description: >-
            Given <code>s := "caf√©"</code>, print <code>len(s)</code> (byte length) and
            <code>len([]rune(s))</code> (character count). They're different! Then print
            each rune using <code>range</code> to see the byte index jumps.
          hints:
            - "<code>len(\"caf√©\")</code> is 5 (bytes), not 4 ‚Äî the <code>√©</code> is 2 bytes in UTF-8"
            - "<code>range</code> over a string yields runes, not bytes: <code>for i, ch := range s</code>"
          solution: |-
            s := "caf√©"
            fmt.Println("bytes:", len(s))           // 5
            fmt.Println("runes:", len([]rune(s)))    // 4
            for i, ch := range s {
                fmt.Printf("index %d: %c\n", i, ch)
            }
            // index 0: c, index 1: a, index 2: f, index 3: √©
          annotations:
            - type: gotcha
              label: Strings Are Bytes
              text: >-
                Go strings are byte sequences, not character sequences. <code>len(s)</code> returns
                bytes, and <code>s[i]</code> gives a byte. Use <code>[]rune(s)</code> or <code>range</code>
                for Unicode-safe character work.

        - id: v2
          title: Safe Character Slicing
          description: >-
            Write a program that safely extracts the first 3 <em>characters</em> from
            <code>"Êó•Êú¨Ë™û„ÉÜ„Çπ„Éà"</code> (Japanese for "Japanese test"). Using <code>s[:3]</code>
            would slice bytes and produce garbage. Convert to <code>[]rune</code>, slice, and
            convert back to a string.
          hints:
            - "Convert first: <code>runes := []rune(s)</code>"
            - "Slice runes, then convert back: <code>string(runes[:3])</code>"
          solution: |-
            s := "Êó•Êú¨Ë™û„ÉÜ„Çπ„Éà"
            runes := []rune(s)
            first3 := string(runes[:3])
            fmt.Println(first3)  // Êó•Êú¨Ë™û
          annotations:
            - type: pattern
              label: Rune Round-Trip
              text: >-
                The pattern <code>[]rune(s)</code> ‚Üí manipulate ‚Üí <code>string(runes)</code> is how
                you safely work with characters in Go. Use it whenever you need to index or slice
                by character position rather than byte position.

        - id: v3
          title: Count Non-ASCII Characters
          description: >-
            Write a program that counts how many characters in <code>"Hello, ‰∏ñÁïå! üåç"</code>
            are non-ASCII (byte value > 127). Use <code>range</code> to iterate by rune and
            check if each rune is greater than 127.
          hints:
            - "Use <code>for _, ch := range s</code> ‚Äî <code>ch</code> is a <code>rune</code> (int32)"
            - "Check <code>if ch > 127</code> to detect non-ASCII characters"
          solution: |-
            s := "Hello, ‰∏ñÁïå! üåç"
            count := 0
            for _, ch := range s {
                if ch > 127 {
                    count++
                }
            }
            fmt.Println(count)  // 3 (‰∏ñ, Áïå, üåç)

  challenges:
    # ‚îÄ‚îÄ challenge_1: Slice Operations ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    - id: challenge_1
      block: 2
      difficulty: 2
      concept: Slice Operations
      docLinks:
        - url: https://go.dev/blog/slices-intro
          title: "Go Slices: usage and internals"
          note: how slices work under the hood
        - url: https://pkg.go.dev/strings#Contains
          title: "strings.Contains"
          note: check if a string contains a substring
      variants:
        - id: v1
          title: Count Passing Grades
          description: >-
            Write <code>func countPassing(scores []int) int</code>. Loop through the scores
            and count how many are 60 or above (a passing grade).
          functionSignature: func countPassing(scores []int) int
          difficulty: 1
          testCases:
            - input: "countPassing([]int{85, 42, 91, 55, 73, 38})"
              output: "3"
            - input: "countPassing([]int{10, 20, 30})"
              output: "0"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                Initialize a counter to 0. Loop through scores with range. For each score, check if it's >= 60 and increment the counter.
            - title: "\U0001F4A1 Hint"
              content: >-
                Use <code>if score >= 60 { count++ }</code> inside the loop.
          solution: |-
            func countPassing(scores []int) int {
                count := 0
                for _, score := range scores {
                    if score >= 60 {
                        count++
                    }
                }
                return count
            }

        - id: v2
          title: Filter Long Words
          description: >-
            Write <code>func filterLongWords(words []string, minLen int) []string</code>. Return
            only the words that are at least <code>minLen</code> characters long.
          functionSignature: func filterLongWords(words []string, minLen int) []string
          difficulty: 2
          testCases:
            - input: "filterLongWords([]string{\"go\", \"python\", \"c\", \"javascript\", \"rust\"}, 4)"
              output: "[\"python\", \"javascript\", \"rust\"]"
            - input: "filterLongWords([]string{\"a\", \"bb\"}, 5)"
              output: "[]"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                This is the filter-and-collect pattern: create an empty result slice, loop, and append matching items.
            - title: "\U0001F4A1 Hint"
              content: >-
                <code>var result []string</code>, then in the loop: <code>if len(word) >= minLen { result = append(result, word) }</code>
          solution: |-
            func filterLongWords(words []string, minLen int) []string {
                var result []string
                for _, word := range words {
                    if len(word) >= minLen {
                        result = append(result, word)
                    }
                }
                return result
            }
          annotations:
            - type: pattern
              label: Filter & Collect
              text: >-
                The filter-and-collect pattern ‚Äî <code>var result []T</code> + loop + conditional <code>append</code> ‚Äî
                is one of Go's most common idioms. It's clear, efficient, and hard to get wrong.

        - id: v3
          title: Last N Entries
          description: >-
            Write <code>func lastN(lines []string, n int) []string</code>. Return the last
            <code>n</code> log entries. If <code>n</code> is greater than the number of lines,
            return all lines.
          functionSignature: func lastN(lines []string, n int) []string
          difficulty: 2
          testCases:
            - input: "lastN([]string{\"a\", \"b\", \"c\", \"d\", \"e\"}, 3)"
              output: "[\"c\", \"d\", \"e\"]"
            - input: "lastN([]string{\"a\", \"b\"}, 5)"
              output: "[\"a\", \"b\"]"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                Use slice syntax <code>lines[start:]</code>. Calculate the start index as <code>len(lines) - n</code>,
                but make sure it doesn't go below 0.
            - title: "\U0001F4A1 Hint"
              content: >-
                <code>if n > len(lines) { n = len(lines) }</code> then <code>return lines[len(lines)-n:]</code>
          solution: |-
            func lastN(lines []string, n int) []string {
                if n > len(lines) {
                    n = len(lines)
                }
                return lines[len(lines)-n:]
            }
          annotations:
            - type: idiom
              label: Defensive Slicing
              text: >-
                Always clamp your index before slicing. <code>lines[len(lines)-n:]</code> panics if
                <code>n > len(lines)</code>. A simple bounds check prevents runtime panics.

        - id: v4
          title: Unique Words
          description: >-
            Write <code>func uniqueWords(words []string) []string</code>. Return a deduplicated
            slice ‚Äî each word should appear only once, even if it appeared multiple times in the input.
          functionSignature: func uniqueWords(words []string) []string
          difficulty: 3
          testCases:
            - input: "uniqueWords([]string{\"apple\", \"banana\", \"apple\", \"cherry\", \"banana\"})"
              output: "[\"apple\", \"banana\", \"cherry\"] (order may vary)"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                Use a <code>map[string]bool</code> as a set to track which words you've already seen.
                Only append to the result when you see a word for the first time.
            - title: "\U0001F4A1 Hint"
              content: >-
                Check <code>if !seen[word]</code> before appending ‚Äî this preserves first-occurrence order.
          solution: |-
            func uniqueWords(words []string) []string {
                seen := make(map[string]bool)
                var result []string
                for _, word := range words {
                    if !seen[word] {
                        seen[word] = true
                        result = append(result, word)
                    }
                }
                return result
            }
          annotations:
            - type: pattern
              label: Map as Set
              text: >-
                Go doesn't have a built-in set type. The idiomatic approach is <code>map[T]bool</code> ‚Äî
                use <code>m[key] = true</code> to add, and <code>if m[key]</code> to check membership.

        - id: v5
          title: First and Last
          description: >-
            Write <code>func firstAndLast(items []string) (string, string)</code>. Return the first
            and last elements of a slice. If the slice is empty, return two empty strings.
            If the slice has one element, return it as both first and last.
          functionSignature: func firstAndLast(items []string) (string, string)
          difficulty: 1
          testCases:
            - input: "firstAndLast([]string{\"a\", \"b\", \"c\", \"d\"})"
              output: "\"a\", \"d\""
            - input: "firstAndLast([]string{\"only\"})"
              output: "\"only\", \"only\""
            - input: "firstAndLast([]string{})"
              output: "\"\", \"\""
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                The first element is <code>items[0]</code>. The last element is
                <code>items[len(items)-1]</code>. But what if the slice is empty?
            - title: "\U0001F4A1 Hint"
              content: >-
                Check <code>if len(items) == 0</code> first. Otherwise, access
                <code>items[0]</code> and <code>items[len(items)-1]</code>.
          solution: |-
            func firstAndLast(items []string) (string, string) {
                if len(items) == 0 {
                    return "", ""
                }
                return items[0], items[len(items)-1]
            }
          annotations:
            - type: gotcha
              label: No Negative Indexing
              text: >-
                Go has no <code>items[-1]</code>. Use <code>items[len(items)-1]</code> for the last
                element. Always check <code>len(items) == 0</code> first ‚Äî accessing index 0 or
                <code>len-1</code> on an empty slice panics.

        - id: v6
          title: Remove Adjacent Duplicates
          description: >-
            Write <code>func compact(items []string) []string</code>. Remove adjacent duplicate
            elements, like the Unix <code>uniq</code> command. For example,
            <code>["a","a","b","b","b","a"]</code> becomes <code>["a","b","a"]</code> ‚Äî only
            consecutive duplicates are removed, not all duplicates.
          functionSignature: func compact(items []string) []string
          difficulty: 2
          testCases:
            - input: "compact([]string{\"a\", \"a\", \"b\", \"b\", \"b\", \"a\"})"
              output: "[\"a\", \"b\", \"a\"]"
            - input: "compact([]string{\"x\", \"y\", \"z\"})"
              output: "[\"x\", \"y\", \"z\"]"
            - input: "compact([]string{})"
              output: "[]"
            - input: "compact([]string{\"solo\"})"
              output: "[\"solo\"]"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                Start with the first element, then only append subsequent elements if they differ
                from the last element you appended.
            - title: "\U0001F4A1 Hint"
              content: >-
                Build a result slice. For each element, check if it equals the last element in the
                result: <code>if len(result) == 0 || items[i] != result[len(result)-1]</code>.
          solution: |-
            func compact(items []string) []string {
                var result []string
                for _, item := range items {
                    if len(result) == 0 || item != result[len(result)-1] {
                        result = append(result, item)
                    }
                }
                return result
            }
          annotations:
            - type: pattern
              label: Compact / Uniq
              text: >-
                The compact pattern ‚Äî skip if equal to previous ‚Äî is a building block for many
                algorithms. Compare with the result's last element rather than the input's previous
                element to handle the first-element edge case cleanly.

        - id: v7
          title: Reverse a Slice
          description: >-
            Write <code>func reverseStrings(items []string) []string</code>. Return a new slice
            with the elements in reverse order. Use index math from both ends ‚Äî
            access elements with <code>items[len(items)-1-i]</code>.
          functionSignature: func reverseStrings(items []string) []string
          difficulty: 2
          testCases:
            - input: "reverseStrings([]string{\"a\", \"b\", \"c\", \"d\"})"
              output: "[\"d\", \"c\", \"b\", \"a\"]"
            - input: "reverseStrings([]string{})"
              output: "[]"
            - input: "reverseStrings([]string{\"only\"})"
              output: "[\"only\"]"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                Create a new slice with <code>make</code>. The element at index <code>i</code> in the
                result should be the element at index <code>len(items)-1-i</code> in the original.
            - title: "\U0001F4A1 Hint"
              content: >-
                <code>result := make([]string, len(items))</code>, then loop with
                <code>result[i] = items[len(items)-1-i]</code>.
          solution: |-
            func reverseStrings(items []string) []string {
                result := make([]string, len(items))
                for i := 0; i < len(items); i++ {
                    result[i] = items[len(items)-1-i]
                }
                return result
            }
          annotations:
            - type: pattern
              label: Mirror Index
              text: >-
                <code>len(s)-1-i</code> gives you the mirror position from the end. When <code>i=0</code>
                you get the last element, when <code>i=1</code> the second-to-last, etc.

        - id: v8
          title: Find Adjacent Duplicates
          description: >-
            Write <code>func adjacentDuplicates(items []string) []string</code>. Return items that
            are identical to the item immediately before them. Use a classic index loop starting
            at <code>i=1</code> and compare <code>items[i]</code> with <code>items[i-1]</code>.
          functionSignature: func adjacentDuplicates(items []string) []string
          difficulty: 2
          testCases:
            - input: "adjacentDuplicates([]string{\"red\", \"red\", \"blue\", \"blue\", \"blue\", \"green\"})"
              output: "[\"red\", \"blue\", \"blue\"]"
            - input: "adjacentDuplicates([]string{\"a\", \"b\", \"c\"})"
              output: "[]"
            - input: "adjacentDuplicates([]string{})"
              output: "[]"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                Start the loop at index 1, not 0. Compare each element with the one before it.
                What would happen if you started at 0 and tried to access <code>lines[-1]</code>?
            - title: "\U0001F4A1 Hint"
              content: >-
                <code>for i := 1; i &lt; len(lines); i++ { if lines[i] == lines[i-1] { ... } }</code>.
                Starting at 1 guarantees <code>i-1</code> is always valid.
          solution: |-
            func adjacentDuplicates(items []string) []string {
                var result []string
                for i := 1; i < len(items); i++ {
                    if items[i] == items[i-1] {
                        result = append(result, items[i])
                    }
                }
                return result
            }
          annotations:
            - type: gotcha
              label: Off-By-One
              text: >-
                When comparing adjacent elements, start your loop at index 1 (not 0) to avoid
                an out-of-bounds access on <code>lines[i-1]</code>. This is the most common
                source of index panics in Go.

        - id: v9
          title: Insert At Index
          description: >-
            Write <code>func insertAt(items []string, index int, value string) []string</code>.
            Insert <code>value</code> at the given <code>index</code>, shifting existing elements
            to the right. If the index is out of range (negative or greater than <code>len(items)</code>),
            return the original slice unchanged. Inserting at <code>len(items)</code> appends to the end.
          functionSignature: func insertAt(items []string, index int, value string) []string
          difficulty: 2
          testCases:
            - input: "insertAt([]string{\"a\", \"b\", \"c\"}, 1, \"x\")"
              output: "[\"a\", \"x\", \"b\", \"c\"]"
            - input: "insertAt([]string{\"a\", \"b\"}, 0, \"x\")"
              output: "[\"x\", \"a\", \"b\"]"
            - input: "insertAt([]string{\"a\", \"b\"}, 2, \"x\")"
              output: "[\"a\", \"b\", \"x\"]"
            - input: "insertAt([]string{\"a\"}, -1, \"x\")"
              output: "[\"a\"]"
            - input: "insertAt([]string{\"a\"}, 5, \"x\")"
              output: "[\"a\"]"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                You can insert by splitting the slice into two parts at the index, then joining
                them back with the new element in between using <code>append</code> and the
                spread operator <code>...</code>.
            - title: "\U0001F4A1 Hint"
              content: >-
                Use <code>append(items[:index], append([]string{value}, items[index:]...)...)</code>.
                Don't forget to bounds-check the index first.
          solution: |-
            func insertAt(items []string, index int, value string) []string {
                if index < 0 || index > len(items) {
                    return items
                }
                return append(items[:index], append([]string{value}, items[index:]...)...)
            }
          annotations:
            - type: idiom
              label: Slice Insert
              text: >-
                The <code>append(s[:i], append([]T{val}, s[i:]...)...)</code> pattern is Go's idiom
                for inserting into a slice. It's a common FAQ because there's no built-in insert function.

        - id: v10
          title: Sliding Window
          description: >-
            Write <code>func windows(items []string, size int) [][]string</code>. Return all
            contiguous sub-slices of the given size. For example, with size 3 and 5 items, return
            3 windows: items[0:3], items[1:4], items[2:5]. Return an empty slice if the input is
            shorter than the window size.
          functionSignature: func windows(lines []string, size int) [][]string
          difficulty: 3
          testCases:
            - input: "windows([]string{\"a\", \"b\", \"c\", \"d\", \"e\"}, 3)"
              output: "[[\"a\",\"b\",\"c\"], [\"b\",\"c\",\"d\"], [\"c\",\"d\",\"e\"]]"
            - input: "windows([]string{\"a\", \"b\"}, 3)"
              output: "[]"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                How many windows of size <code>k</code> fit in a slice of length <code>n</code>?
                The answer is <code>n - k + 1</code>. Your loop runs from <code>i = 0</code> to
                <code>i &lt;= len(lines) - size</code>.
            - title: "\U0001F4A1 Hint"
              content: >-
                <code>for i := 0; i &lt;= len(lines)-size; i++ { result = append(result, lines[i:i+size]) }</code>.
                If <code>len(lines) &lt; size</code>, the loop body never executes.
          solution: |-
            func windows(lines []string, size int) [][]string {
                var result [][]string
                for i := 0; i <= len(lines)-size; i++ {
                    result = append(result, lines[i:i+size])
                }
                return result
            }
          annotations:
            - type: pattern
              label: Sliding Window
              text: >-
                The sliding window pattern ‚Äî <code>lines[i:i+size]</code> for <code>i</code> from
                0 to <code>len-size</code> ‚Äî is fundamental for analyzing sequential data. The
                bounds math (<code>len - size + 1</code> iterations) comes up constantly.

    # ‚îÄ‚îÄ challenge_2: Maps & Aggregation ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    - id: challenge_2
      block: 2
      difficulty: 2
      concept: Map Basics
      docLinks:
        - url: https://go.dev/blog/maps
          title: "Go maps in action"
          note: map usage patterns
        - url: https://go.dev/tour/moretypes/19
          title: "Go Tour: Maps"
          note: map basics
      variants:
        - id: v1
          title: Case-Insensitive Word Frequency
          description: >-
            Write <code>func wordFrequency(sentence string) map[string]int</code>. Split the sentence
            into words using <code>strings.Fields</code>, lowercase each word with
            <code>strings.ToLower</code>, and count the frequency of each lowercased word.
          functionSignature: func wordFrequency(sentence string) map[string]int
          difficulty: 2
          testCases:
            - input: "wordFrequency(\"Go is fun go is GREAT go\")"
              output: "map[go:3 is:2 fun:1 great:1]"
            - input: "wordFrequency(\"Hello hello HELLO\")"
              output: "map[hello:3]"
            - input: "wordFrequency(\"\")"
              output: "map[]"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                <code>strings.Fields</code> splits on any whitespace and handles multiple spaces.
                <code>strings.ToLower</code> normalizes case. Then count with the frequency map pattern.
            - title: "\U0001F4A1 Hint"
              content: >-
                <code>words := strings.Fields(sentence)</code>, then loop: <code>counts[strings.ToLower(word)]++</code>.
          solution: |-
            func wordFrequency(sentence string) map[string]int {
                counts := make(map[string]int)
                for _, word := range strings.Fields(sentence) {
                    counts[strings.ToLower(word)]++
                }
                return counts
            }
          annotations:
            - type: pattern
              label: Normalize Then Count
              text: >-
                When counting text, normalize first (lowercase, trim, etc.) to avoid counting
                <code>"Go"</code> and <code>"go"</code> as different items. <code>strings.Fields</code>
                is preferred over <code>strings.Split(s, " ")</code> because it handles multiple spaces
                and leading/trailing whitespace.

        - id: v2
          title: Most Popular Item
          description: >-
            Write <code>func mostPopular(items []string) string</code>. Find and return the item
            that appears most frequently. If the slice is empty, return an empty string.
          functionSignature: func mostPopular(items []string) string
          difficulty: 2
          testCases:
            - input: "mostPopular([]string{\"pizza\", \"sushi\", \"pizza\", \"tacos\", \"sushi\", \"pizza\"})"
              output: "\"pizza\""
            - input: "mostPopular([]string{})"
              output: "\"\""
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                First build a frequency map, then iterate the map to find the key with the highest count.
            - title: "\U0001F4A1 Hint"
              content: >-
                Track <code>maxCount</code> and <code>maxItem</code> while iterating the frequency map.
                Update them when you find a count larger than the current max.
          solution: |-
            func mostPopular(items []string) string {
                counts := make(map[string]int)
                for _, item := range items {
                    counts[item]++
                }
                maxItem := ""
                maxCount := 0
                for item, count := range counts {
                    if count > maxCount {
                        maxCount = count
                        maxItem = item
                    }
                }
                return maxItem
            }

        - id: v3
          title: Group by Category
          description: >-
            Write <code>func groupByCategory(items []string) map[string]int</code>. Each item is
            formatted as <code>"category:name"</code> (e.g. <code>"fruit:apple"</code>). Count how
            many items belong to each category. Use <code>strings.Cut</code> to split on <code>":"</code>.
          functionSignature: func groupByCategory(items []string) map[string]int
          difficulty: 2
          testCases:
            - input: "groupByCategory([]string{\"fruit:apple\", \"dairy:milk\", \"fruit:banana\", \"fruit:cherry\", \"dairy:cheese\"})"
              output: "map[fruit:3 dairy:2]"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                Split each item on <code>":"</code> to get the category. Then count categories the same way as word frequency.
            - title: "\U0001F4A1 Hint"
              content: >-
                Use <code>category, _, ok := strings.Cut(item, ":")</code>, check <code>ok</code>, then <code>counts[category]++</code>.
          solution: |-
            func groupByCategory(items []string) map[string]int {
                counts := make(map[string]int)
                for _, item := range items {
                    category, _, ok := strings.Cut(item, ":")
                    if ok {
                        counts[category]++
                    }
                }
                return counts
            }

        - id: v4
          title: Grade Distribution
          description: >-
            Write <code>func gradeDistribution(scores []int) map[string]int</code>. Classify each
            score into a letter grade: A (90-100), B (80-89), C (70-79), D (60-69), F (below 60).
            Return a map counting how many scores fall into each grade.
          functionSignature: func gradeDistribution(scores []int) map[string]int
          difficulty: 3
          testCases:
            - input: "gradeDistribution([]int{95, 82, 67, 45, 91, 73, 88})"
              output: "map[A:2 B:2 C:1 D:1 F:1]"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                Use <code>if/else if</code> or <code>switch</code> to classify each score into a grade string,
                then count with the frequency map pattern.
            - title: "\U0001F4A1 Hint"
              content: >-
                Write a helper or use inline logic: <code>if score >= 90 { grade = "A" } else if score >= 80 { grade = "B" } ...</code>
          solution: |-
            func gradeDistribution(scores []int) map[string]int {
                counts := make(map[string]int)
                for _, score := range scores {
                    var grade string
                    switch {
                    case score >= 90:
                        grade = "A"
                    case score >= 80:
                        grade = "B"
                    case score >= 70:
                        grade = "C"
                    case score >= 60:
                        grade = "D"
                    default:
                        grade = "F"
                    }
                    counts[grade]++
                }
                return counts
            }
          annotations:
            - type: idiom
              label: Expressionless Switch
              text: >-
                <code>switch { case condition: ... }</code> (no expression after switch) is Go's clean
                alternative to long if/else if chains. Each case is evaluated in order.

    # ‚îÄ‚îÄ challenge_3: Go Fundamentals Combined ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    - id: challenge_3
      block: 3
      difficulty: 3
      concept: Go Fundamentals Combined
      docLinks:
        - url: https://go.dev/doc/effective_go
          title: "Effective Go"
          note: idiomatic Go patterns
        - url: https://pkg.go.dev/fmt#Sprintf
          title: "fmt.Sprintf"
          note: string formatting
      variants:
        - id: v1
          title: Summarize Runs
          description: >-
            Write <code>func summarizeRuns(items []string) string</code>. Count consecutive runs of
            each element and return a summary string. For example,
            <code>["a","a","b","b","b","c"]</code> returns <code>"a√ó2, b√ó3, c√ó1"</code>.
            Use <code>fmt.Sprintf</code> for formatting and <code>strings.Join</code> to combine parts.
            The √ó character is the Unicode multiplication sign (U+00D7).
          functionSignature: func summarizeRuns(items []string) string
          difficulty: 3
          testCases:
            - input: "summarizeRuns([]string{\"a\", \"a\", \"b\", \"b\", \"b\", \"c\"})"
              output: "\"a√ó2, b√ó3, c√ó1\""
            - input: "summarizeRuns([]string{\"x\"})"
              output: "\"x√ó1\""
            - input: "summarizeRuns([]string{})"
              output: "\"\""
            - input: "summarizeRuns([]string{\"a\", \"b\", \"a\"})"
              output: "\"a√ó1, b√ó1, a√ó1\""
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                Track the current item and its count. When the item changes (or you reach the end),
                emit the run summary and reset. Don't forget to emit the final run.
            - title: "\U0001F4A1 Hint"
              content: >-
                Build a <code>[]string</code> of parts like <code>"a√ó2"</code> using
                <code>fmt.Sprintf("%s√ó%d", current, count)</code>, then join with
                <code>strings.Join(parts, ", ")</code>.
          solution: |-
            func summarizeRuns(items []string) string {
                if len(items) == 0 {
                    return ""
                }
                var parts []string
                current := items[0]
                count := 1
                for i := 1; i < len(items); i++ {
                    if items[i] == current {
                        count++
                    } else {
                        parts = append(parts, fmt.Sprintf("%s√ó%d", current, count))
                        current = items[i]
                        count = 1
                    }
                }
                parts = append(parts, fmt.Sprintf("%s√ó%d", current, count))
                return strings.Join(parts, ", ")
            }
          annotations:
            - type: pattern
              label: Run-Length Encoding
              text: >-
                Tracking runs of consecutive values is a fundamental pattern. The key insight is to
                emit the accumulated run when the value changes and handle the final run after the loop.
                This combines loops, string building, and <code>strings.Join</code>.

        - id: v2
          title: Inventory Report
          description: >-
            Write <code>func inventoryReport(items []string) string</code>. Given a slice of item names
            (with possible repeats), build a formatted report showing total items, count per unique item,
            and the most stocked item.
            Format:<br><code>Total: 6<br>apple: 3<br>banana: 2<br>cherry: 1<br>Most stocked: apple</code><br>
            List items in alphabetical order. If items tie, return any one.
          functionSignature: func inventoryReport(items []string) string
          difficulty: 3
          testCases:
            - input: "inventoryReport([]string{\"apple\", \"banana\", \"apple\", \"cherry\", \"banana\", \"apple\"})"
              output: "\"Total: 6\\napple: 3\\nbanana: 2\\ncherry: 1\\nMost stocked: apple\""
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                Build a frequency map first, then find the max, then format the output string.
                For alphabetical order, collect the keys into a sorted slice.
            - title: "\U0001F4A1 Hint"
              content: >-
                Use <code>sort.Strings(keys)</code> to sort the keys, then iterate in that order
                with <code>fmt.Sprintf</code> to build the report.
          solution: |-
            func inventoryReport(items []string) string {
                counts := make(map[string]int)
                for _, item := range items {
                    counts[item]++
                }
                var keys []string
                for k := range counts {
                    keys = append(keys, k)
                }
                sort.Strings(keys)
                maxItem := ""
                maxCount := 0
                for item, count := range counts {
                    if count > maxCount {
                        maxCount = count
                        maxItem = item
                    }
                }
                report := fmt.Sprintf("Total: %d", len(items))
                for _, item := range keys {
                    report += fmt.Sprintf("\n%s: %d", item, counts[item])
                }
                report += fmt.Sprintf("\nMost stocked: %s", maxItem)
                return report
            }
          annotations:
            - type: pattern
              label: Ordered Map Iteration
              text: >-
                Map iteration order is random in Go. When you need a specific order, collect the keys
                into a slice, sort it, then iterate the sorted keys.

        - id: v3
          title: Find Bestsellers
          description: >-
            Write <code>func findBestsellers(sales []string, threshold int) []string</code>. Count
            how many times each product name appears in the sales list. Return a slice of product names
            that were sold more than <code>threshold</code> times.
          functionSignature: func findBestsellers(sales []string, threshold int) []string
          difficulty: 3
          testCases:
            - input: "findBestsellers([]string{\"widget\", \"gadget\", \"widget\", \"widget\", \"gizmo\", \"gadget\"}, 2)"
              output: "[\"widget\"]"
            - input: "findBestsellers([]string{\"a\", \"b\", \"c\"}, 1)"
              output: "[]"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                First build a frequency map. Then filter the map for entries exceeding the threshold.
                This is the classic two-pass pattern.
            - title: "\U0001F4A1 Hint"
              content: >-
                Two passes: (1) count product sales, (2) collect products where <code>count > threshold</code>.
          solution: |-
            func findBestsellers(sales []string, threshold int) []string {
                counts := make(map[string]int)
                for _, product := range sales {
                    counts[product]++
                }
                var bestsellers []string
                for product, count := range counts {
                    if count > threshold {
                        bestsellers = append(bestsellers, product)
                    }
                }
                return bestsellers
            }
          annotations:
            - type: pattern
              label: Two-Pass Processing
              text: >-
                Many aggregation problems need two passes: one to collect data, one to analyze it.
                This is cleaner than trying to do everything in a single loop.

        - id: v4
          title: Search Contacts
          description: >-
            Write <code>func searchContacts(contacts []string, city string, keyword string) []string</code>.
            Each contact is formatted as <code>"name,city,email"</code>. Return contacts that match
            the given city AND whose name contains the keyword. Format results as
            <code>"name &lt;email&gt;"</code>.
          functionSignature: func searchContacts(contacts []string, city string, keyword string) []string
          difficulty: 3
          testCases:
            - input: "searchContacts([]string{\"Alice Smith,NYC,alice@mail.com\", \"Bob Jones,LA,bob@mail.com\", \"Alice Wong,NYC,awong@mail.com\", \"Charlie Smith,NYC,charlie@mail.com\"}, \"NYC\", \"Smith\")"
              output: "[\"Alice Smith <alice@mail.com>\", \"Charlie Smith <charlie@mail.com>\"]"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                Split each contact on <code>","</code>, check the city matches, check the name contains
                the keyword, then format the output. Use <code>strings.Split</code> and <code>strings.Contains</code>.
            - title: "\U0001F4A1 Hint"
              content: >-
                <code>parts := strings.Split(contact, ",")</code>, check <code>parts[1] == city</code>,
                check <code>strings.Contains(parts[0], keyword)</code>, format with
                <code>fmt.Sprintf("%s <%s>", parts[0], parts[2])</code>.
          solution: |-
            func searchContacts(contacts []string, city string, keyword string) []string {
                var result []string
                for _, contact := range contacts {
                    parts := strings.Split(contact, ",")
                    if len(parts) < 3 {
                        continue
                    }
                    if parts[1] != city {
                        continue
                    }
                    if !strings.Contains(parts[0], keyword) {
                        continue
                    }
                    result = append(result, fmt.Sprintf("%s <%s>", parts[0], parts[2]))
                }
                return result
            }
          annotations:
            - type: idiom
              label: Early Continue
              text: >-
                Use <code>continue</code> to skip non-matching items early. This keeps the "happy path"
                at the lowest indentation level, making the code easier to read than nested if statements.
