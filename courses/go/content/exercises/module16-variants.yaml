conceptLinks:
  Which Clone: "#lesson-exec-lookpath"
  System Info: "#lesson-os-user"
  Process List: "#lesson-exec-command"
  Git Status Parser: "#lesson-command-output"
sharedContent: {}
variants:
  warmups:
    - id: warmup_1
      concept: Which Clone
      variants:
        - id: v1
          title: Which Clone
          description: >-
            Write a program that takes a command name as <code>os.Args[1]</code> and prints its full path using
            <code>exec.LookPath</code>. If not found, print an error to stderr and exit with code 1. If no argument is
            given, print usage and exit with code 1.
          hints:
            - Use <code>exec.LookPath(os.Args[1])</code> to find the binary.
            - Check <code>len(os.Args) < 2</code> for missing arguments.
            - Use <code>fmt.Fprintln(os.Stderr, ...)</code> for error output.
          solution: |-
            func main() {
                if len(os.Args) < 2 {
                    fmt.Fprintln(os.Stderr, "usage: which command")
                    os.Exit(1)
                }

                path, err := exec.LookPath(os.Args[1])
                if err != nil {
                    fmt.Fprintf(os.Stderr, "%s: command not found\n", os.Args[1])
                    os.Exit(1)
                }
                fmt.Println(path)
            }
          annotations:
            - type: stdlib
              label: exec.LookPath
              text: >-
                exec.LookPath searches for an executable in the directories listed in the PATH environment variable. It
                returns the full path or an error.
            - type: idiom
              label: Exit Codes
              text: >-
                os.Exit(1) signals failure to the calling shell. Convention: 0 = success, 1 = general error, 2 = misuse.
                Match the behavior of the tool you are cloning.
        - id: v2
          title: Which All
          description: >-
            Write a program that finds ALL matching executables for a command name (not just the first). Split the
            <code>PATH</code> environment variable, check each directory for the executable, and print all matches.
          hints:
            - Use <code>os.Getenv("PATH")</code> and <code>strings.Split(..., ":")</code> to get directories.
            - Use <code>filepath.Join(dir, name)</code> to construct the path.
            - Check if the file exists and is executable with <code>os.Stat</code>.
          solution: |-
            func main() {
                if len(os.Args) < 2 {
                    fmt.Fprintln(os.Stderr, "usage: which-all command")
                    os.Exit(1)
                }

                name := os.Args[1]
                pathDirs := strings.Split(os.Getenv("PATH"), ":")
                found := false

                for _, dir := range pathDirs {
                    full := filepath.Join(dir, name)
                    info, err := os.Stat(full)
                    if err != nil {
                        continue
                    }
                    if info.Mode()&0111 != 0 {
                        fmt.Println(full)
                        found = true
                    }
                }

                if !found {
                    os.Exit(1)
                }
            }
          annotations:
            - type: idiom
              label: File Permissions
              text: >-
                Check executable bits with info.Mode()&0111 != 0. The octal 0111 checks user, group, and other execute
                bits. This is how the shell determines if a file is runnable.
            - type: stdlib
              label: filepath.Join
              text: >-
                filepath.Join correctly joins path components using the OS-specific separator. Always prefer it over
                manual string concatenation for file paths.
        - id: v3
          title: Command Checker
          description: >-
            Write <code>func commandExists(name string) bool</code> that returns true if the given command is available
            on the system. Then write a main function that checks a list of required tools (<code>go</code>,
            <code>git</code>, <code>docker</code>, <code>kubectl</code>) and prints which are available and which are
            missing.
          hints:
            - Use <code>exec.LookPath</code> and check the error.
            - Loop over a slice of tool names and print status for each.
            - Use a boolean return instead of printing directly for testability.
          solution: |-
            func commandExists(name string) bool {
                _, err := exec.LookPath(name)
                return err == nil
            }

            func main() {
                tools := []string{"go", "git", "docker", "kubectl"}
                for _, tool := range tools {
                    if commandExists(tool) {
                        fmt.Printf("[OK]    %s\n", tool)
                    } else {
                        fmt.Printf("[MISS]  %s\n", tool)
                    }
                }
            }
          annotations:
            - type: idiom
              label: Boolean Wrapper
              text: >-
                Wrapping exec.LookPath in a bool function is a common Go pattern. It simplifies the calling code and
                makes the intent clear: does this command exist?
            - type: alternative
              label: Error Details
              text: >-
                For more detail, return (string, error) instead of bool. The string can be the path, and the error
                explains why the lookup failed.
        - id: v4
          title: PATH Inspector
          description: >-
            Write a program that prints each directory in the <code>PATH</code> environment variable on its own line,
            along with how many executables it contains. Skip directories that do not exist.
          hints:
            - Use <code>os.ReadDir(dir)</code> to list directory contents.
            - Count files where <code>info.Type().IsRegular()</code> and executable bits are set.
            - Use <code>strings.Split(os.Getenv("PATH"), ":")</code> to get directories.
          solution: |-
            func main() {
                pathDirs := strings.Split(os.Getenv("PATH"), ":")
                for _, dir := range pathDirs {
                    entries, err := os.ReadDir(dir)
                    if err != nil {
                        continue
                    }
                    count := 0
                    for _, entry := range entries {
                        if !entry.IsDir() {
                            info, err := entry.Info()
                            if err == nil && info.Mode()&0111 != 0 {
                                count++
                            }
                        }
                    }
                    fmt.Printf("%s (%d executables)\n", dir, count)
                }
            }
          annotations:
            - type: stdlib
              label: os.ReadDir
              text: >-
                os.ReadDir reads a directory and returns sorted DirEntry values. It is more efficient than os.ReadFile
                for listing directories and was added in Go 1.16.
            - type: gotcha
              label: Permission Errors
              text: >-
                Some PATH directories may not be readable. Always check errors from os.ReadDir and skip inaccessible
                directories gracefully.
    - id: warmup_2
      concept: System Info
      variants:
        - id: v1
          title: System Info
          description: >-
            Write a program that prints: hostname, current user, home directory, shell (from <code>SHELL</code> env
            var), and whether the current user is root (<code>os.Geteuid() == 0</code>).
          hints:
            - Use <code>os.Hostname()</code> for hostname.
            - Use <code>user.Current()</code> to get user info.
            - Use <code>os.Getenv("SHELL")</code> for the shell.
          solution: |-
            func main() {
                hostname, _ := os.Hostname()
                u, _ := user.Current()
                shell := os.Getenv("SHELL")
                isRoot := os.Geteuid() == 0

                fmt.Println("Hostname:", hostname)
                fmt.Println("User:", u.Username)
                fmt.Println("Home:", u.HomeDir)
                fmt.Println("Shell:", shell)
                fmt.Println("Root:", isRoot)
            }
          annotations:
            - type: stdlib
              label: os/user
              text: >-
                The os/user package provides user.Current() for the current user's info including Username, HomeDir,
                Uid, and Gid.
            - type: gotcha
              label: Cross-Platform
              text: >-
                os.Geteuid() is Unix-only. On Windows, use a different approach. The SHELL env var is also
                Unix-specific; Windows uses COMSPEC.
        - id: v2
          title: Environment Dump
          description: >-
            Write a program that prints all environment variables sorted alphabetically. Format each as
            <code>KEY=VALUE</code>. Also print the total count of environment variables.
          hints:
            - Use <code>os.Environ()</code> to get all env vars as <code>[]string</code>.
            - Use <code>sort.Strings</code> to sort them.
            - Each entry is already in <code>KEY=VALUE</code> format.
          solution: |-
            func main() {
                envs := os.Environ()
                sort.Strings(envs)
                for _, env := range envs {
                    fmt.Println(env)
                }
                fmt.Printf("\nTotal: %d environment variables\n", len(envs))
            }
          annotations:
            - type: stdlib
              label: os.Environ
              text: >-
                os.Environ() returns a copy of all environment variables as a []string in KEY=VALUE format. Modifying
                the returned slice does not affect the environment.
            - type: idiom
              label: Sort Before Display
              text: >-
                Sorting environment variables makes output reproducible and easier to read. sort.Strings sorts in-place,
                which is fine since os.Environ returns a copy.
        - id: v3
          title: Runtime Info
          description: >-
            Write a program that prints Go runtime information: Go version, OS, architecture, number of CPUs, and number
            of goroutines currently running.
          hints:
            - Use <code>runtime.Version()</code>, <code>runtime.GOOS</code>, <code>runtime.GOARCH</code>.
            - Use <code>runtime.NumCPU()</code> for CPU count.
            - Use <code>runtime.NumGoroutine()</code> for active goroutines.
          solution: |-
            func main() {
                fmt.Println("Go Version:", runtime.Version())
                fmt.Println("OS:", runtime.GOOS)
                fmt.Println("Arch:", runtime.GOARCH)
                fmt.Println("CPUs:", runtime.NumCPU())
                fmt.Println("Goroutines:", runtime.NumGoroutine())
            }
          annotations:
            - type: stdlib
              label: runtime Package
              text: >-
                The runtime package exposes Go runtime internals. GOOS and GOARCH are compile-time constants reflecting
                the target platform.
            - type: idiom
              label: Build Constraints
              text: >-
                runtime.GOOS and runtime.GOARCH are set at compile time based on GOOS/GOARCH environment variables or
                build tags. They cannot change at runtime.
        - id: v4
          title: Disk Usage
          description: >-
            Write a program that prints the current working directory and the total size of all files in it
            (non-recursive). Use <code>os.Getwd()</code> and <code>os.ReadDir</code>.
          hints:
            - Use <code>os.Getwd()</code> for the current directory.
            - Use <code>os.ReadDir(".")</code> to list files.
            - Call <code>entry.Info()</code> to get size via <code>info.Size()</code>.
          solution: |-
            func main() {
                cwd, _ := os.Getwd()
                fmt.Println("Directory:", cwd)

                entries, err := os.ReadDir(".")
                if err != nil {
                    fmt.Fprintln(os.Stderr, err)
                    os.Exit(1)
                }

                var totalSize int64
                fileCount := 0
                for _, entry := range entries {
                    if !entry.IsDir() {
                        info, err := entry.Info()
                        if err == nil {
                            totalSize += info.Size()
                            fileCount++
                        }
                    }
                }
                fmt.Printf("Files: %d\n", fileCount)
                fmt.Printf("Total size: %d bytes\n", totalSize)
            }
          annotations:
            - type: stdlib
              label: os.Getwd
              text: >-
                os.Getwd returns the current working directory. It corresponds to the shell's pwd command. The returned
                path is always absolute.
            - type: alternative
              label: filepath.WalkDir
              text: >-
                For recursive directory traversal, use filepath.WalkDir instead of os.ReadDir. It handles nested
                directories and provides the path to each entry.
  challenges:
    - id: challenge_1
      block: 1
      difficulty: 3
      concept: Process List
      docLinks:
        - url: https://pkg.go.dev/os/exec#Command
          title: Package exec.Command
          note: running external commands
        - url: https://pkg.go.dev/strings#Fields
          title: Package strings.Fields
          note: splitting whitespace-delimited output
        - url: https://pkg.go.dev/strconv#ParseFloat
          title: Package strconv.ParseFloat
          note: parsing numeric columns
      variants:
        - id: v1
          title: High CPU Processes
          description: >-
            Write a program that runs <code>ps aux</code>, parses the output, and prints the PID and command name for
            any process using more than 1% CPU. Use <code>strings.Fields</code> to split columns and
            <code>strconv.ParseFloat</code> for CPU%.
          functionSignature: func main()
          testCases:
            - input: ps aux output with chrome at 5.2% CPU
              output: "PID: 1234  CPU: 5.2%  CMD: chrome"
            - input: ps aux output with no high-CPU process
              output: (no output)
          hints:
            - title: ðŸ¤” Think about it
              content: What does each column in ps aux output represent? Which column index is CPU%, PID, and command?
            - title: ðŸ’¡ Hint
              content: >-
                Fields: [0]=USER, [1]=PID, [2]=%CPU, [3]=%MEM, ... [10]=COMMAND. Skip the header line (first line).
                Parse field[2] as float64.
            - title: ðŸ”§ Pattern
              content: |-
                <pre>1. exec.Command("ps", "aux").Output()
                2. Split by newline, skip header
                3. For each line: strings.Fields, parse CPU% at index 2
                4. If > 1.0: print PID and CMD</pre>
          solution: |-
            func main() {
                out, err := exec.Command("ps", "aux").Output()
                if err != nil {
                    fmt.Fprintln(os.Stderr, err)
                    os.Exit(1)
                }
                lines := strings.Split(string(out), "\n")

                for _, line := range lines[1:] {
                    fields := strings.Fields(line)
                    if len(fields) < 11 {
                        continue
                    }
                    cpu, err := strconv.ParseFloat(fields[2], 64)
                    if err != nil {
                        continue
                    }
                    if cpu > 1.0 {
                        fmt.Printf("PID: %s  CPU: %.1f%%  CMD: %s\n",
                            fields[1], cpu, fields[10])
                    }
                }
            }
          difficulty: 3
          annotations:
            - type: stdlib
              label: exec.Command
              text: >-
                exec.Command creates a command to run. Output() runs it and returns combined stdout. For stderr too, use
                CombinedOutput().
            - type: gotcha
              label: Field Parsing
              text: >-
                strings.Fields handles multiple spaces between columns, unlike strings.Split(line, " ") which would
                create empty entries. Always use Fields for columnar output.
        - id: v2
          title: Memory Hogs
          description: >-
            Write a program that runs <code>ps aux</code>, parses output, and prints the top 5 processes by memory usage
            (%MEM column). Sort them in descending order and display PID, %MEM, and command.
          functionSignature: func main()
          testCases:
            - input: ps aux output with various processes
              output: Top 5 processes by memory, sorted descending
            - input: Fewer than 5 processes
              output: All processes sorted by memory
          hints:
            - title: ðŸ¤” Think about it
              content: >-
                How do you sort processes by a parsed numeric field? What data structure can hold the parsed data for
                sorting?
            - title: ðŸ’¡ Hint
              content: >-
                Parse into a struct slice: {pid string, mem float64, cmd string}. Use sort.Slice with a custom less
                function. Take the first 5 (or fewer).
            - title: ðŸ”§ Pattern
              content: |-
                <pre>1. Parse ps aux into []ProcessInfo structs
                2. sort.Slice by mem descending
                3. Print top min(5, len) entries</pre>
          solution: |-
            type ProcessInfo struct {
                pid string
                mem float64
                cmd string
            }

            func main() {
                out, err := exec.Command("ps", "aux").Output()
                if err != nil {
                    fmt.Fprintln(os.Stderr, err)
                    os.Exit(1)
                }

                var procs []ProcessInfo
                lines := strings.Split(string(out), "\n")
                for _, line := range lines[1:] {
                    fields := strings.Fields(line)
                    if len(fields) < 11 {
                        continue
                    }
                    mem, err := strconv.ParseFloat(fields[3], 64)
                    if err != nil {
                        continue
                    }
                    procs = append(procs, ProcessInfo{
                        pid: fields[1], mem: mem, cmd: fields[10],
                    })
                }

                sort.Slice(procs, func(i, j int) bool {
                    return procs[i].mem > procs[j].mem
                })

                limit := 5
                if len(procs) < limit {
                    limit = len(procs)
                }
                for _, p := range procs[:limit] {
                    fmt.Printf("PID: %s  MEM: %.1f%%  CMD: %s\n", p.pid, p.mem, p.cmd)
                }
            }
          difficulty: 3
          annotations:
            - type: stdlib
              label: sort.Slice
              text: >-
                sort.Slice sorts a slice using a custom less function. It modifies the slice in place. For stable
                sorting (preserving equal-element order), use sort.SliceStable.
            - type: complexity
              label: O(n log n)
              text: >-
                Parsing is O(n), sorting is O(n log n). For top-K problems, a heap (container/heap) would be O(n log k)
                but sort.Slice is simpler for small k.
        - id: v3
          title: Process Tree
          description: >-
            Write a program that runs <code>ps -eo pid,ppid,comm</code> and builds a parent-child tree. Print processes
            in a tree format with indentation showing the hierarchy. Start from PID 1 (init/systemd).
          functionSignature: func main()
          testCases:
            - input: ps output with systemd -> sshd -> bash
              output: 1 systemd\n  123 sshd\n    456 bash
            - input: ps output with multiple children
              output: indented tree showing parent-child relationships
          hints:
            - title: ðŸ¤” Think about it
              content: What data structure represents a tree? How do you map parent PIDs to their children?
            - title: ðŸ’¡ Hint
              content: >-
                Use map[string][]string to map PPID to list of child PIDs. Use another map for PID to command name.
                Recursively print from PID 1 with increasing indent.
            - title: ðŸ”§ Pattern
              content: |-
                <pre>1. Parse ps -eo pid,ppid,comm
                2. Build children map: ppid -> []pid
                3. Build names map: pid -> comm
                4. Recursive print: printTree(pid, indent)
                5. Start from PID "1"</pre>
          solution: |-
            func main() {
                out, err := exec.Command("ps", "-eo", "pid,ppid,comm").Output()
                if err != nil {
                    fmt.Fprintln(os.Stderr, err)
                    os.Exit(1)
                }

                children := make(map[string][]string)
                names := make(map[string]string)

                lines := strings.Split(string(out), "\n")
                for _, line := range lines[1:] {
                    fields := strings.Fields(line)
                    if len(fields) < 3 {
                        continue
                    }
                    pid, ppid, comm := fields[0], fields[1], fields[2]
                    names[pid] = comm
                    children[ppid] = append(children[ppid], pid)
                }

                var printTree func(pid string, indent int)
                printTree = func(pid string, indent int) {
                    fmt.Printf("%s%s %s\n", strings.Repeat("  ", indent), pid, names[pid])
                    for _, child := range children[pid] {
                        printTree(child, indent+1)
                    }
                }
                printTree("1", 0)
            }
          difficulty: 3
          annotations:
            - type: pattern
              label: Tree Building
              text: >-
                Building a tree from flat parent-child data is a common pattern. Use a map from parent to children list,
                then traverse recursively from the root.
            - type: idiom
              label: Recursive Closure
              text: >-
                Declaring a function variable before the closure allows recursion: var f func(); f = func() { f() }.
                This is how Go handles anonymous recursive functions.
        - id: v4
          title: Process Monitor
          description: >-
            Write a program that monitors a specific process name. Run <code>ps aux</code> every 2 seconds, find the
            process, and print its CPU and memory usage. Stop after 5 iterations or if the process disappears.
          functionSignature: func main()
          testCases:
            - input: Monitor 'bash' for 5 iterations
              output: 5 lines showing CPU/MEM for bash
            - input: Monitor 'nonexistent'
              output: "'Process not found' and exit"
          hints:
            - title: ðŸ¤” Think about it
              content: How do you repeatedly check for a process? How do you match the process name in ps output?
            - title: ðŸ’¡ Hint
              content: >-
                Use a for loop with time.Sleep(2 * time.Second). In each iteration, run ps aux, scan for the process
                name in the command column. Print CPU/MEM or break if not found.
            - title: ðŸ”§ Pattern
              content: |-
                <pre>1. Get process name from os.Args[1]
                2. Loop 5 times with 2s sleep
                3. Run ps aux, parse lines
                4. Find matching command, print stats
                5. If not found, print message and break</pre>
          solution: |-
            func main() {
                if len(os.Args) < 2 {
                    fmt.Fprintln(os.Stderr, "usage: monitor <process-name>")
                    os.Exit(1)
                }
                target := os.Args[1]

                for i := 0; i < 5; i++ {
                    out, err := exec.Command("ps", "aux").Output()
                    if err != nil {
                        fmt.Fprintln(os.Stderr, err)
                        os.Exit(1)
                    }

                    found := false
                    lines := strings.Split(string(out), "\n")
                    for _, line := range lines[1:] {
                        fields := strings.Fields(line)
                        if len(fields) < 11 {
                            continue
                        }
                        if strings.Contains(fields[10], target) {
                            cpu, _ := strconv.ParseFloat(fields[2], 64)
                            mem, _ := strconv.ParseFloat(fields[3], 64)
                            fmt.Printf("[%d] %s - CPU: %.1f%% MEM: %.1f%%\n",
                                i+1, target, cpu, mem)
                            found = true
                            break
                        }
                    }

                    if !found {
                        fmt.Printf("Process '%s' not found\n", target)
                        break
                    }
                    if i < 4 {
                        time.Sleep(2 * time.Second)
                    }
                }
            }
          difficulty: 3
          annotations:
            - type: alternative
              label: Ticker-Based
              text: >-
                For production monitoring, use time.NewTicker instead of time.Sleep. Tickers account for execution time,
                keeping intervals more consistent.
            - type: gotcha
              label: Self-Matching
              text: >-
                Be aware that the ps command itself or the monitor program may appear in ps output. Real tools use PID
                files or more specific matching to avoid false positives.
    - id: challenge_2
      block: 2
      difficulty: 3
      concept: Git Status Parser
      docLinks:
        - url: https://pkg.go.dev/os/exec#Cmd.Output
          title: Package exec.Cmd.Output
          note: capturing command output
        - url: https://pkg.go.dev/bufio#Scanner
          title: Package bufio.Scanner
          note: line-by-line output processing
      variants:
        - id: v1
          title: Git Status Counter
          description: >-
            Write a program that runs <code>git status --porcelain</code> and prints counts of modified, added, and
            deleted files. Handle the porcelain format where the first two characters indicate status:
            <code>M</code>=modified, <code>A</code> or <code>??</code>=added/new, <code>D</code>=deleted.
          functionSignature: func main()
          testCases:
            - input: git repo with 2 modified, 1 new, 1 deleted
              output: "Modified: 2, Added: 1, Deleted: 1"
            - input: clean git repo
              output: "Modified: 0, Added: 0, Deleted: 0"
            - input: not a git repo
              output: Not a git repo
          hints:
            - title: ðŸ¤” Think about it
              content: >-
                What does each two-character status code mean in porcelain format? How do you distinguish staged vs
                unstaged changes?
            - title: ðŸ’¡ Hint
              content: >-
                Porcelain first two chars: 'M ' or ' M' or 'MM' = modified, 'A ' or '??' = added, 'D ' or ' D' =
                deleted. Check with line[0:2] switch.
            - title: ðŸ”§ Pattern
              content: |-
                <pre>1. Run git status --porcelain
                2. Check error (not a git repo)
                3. Split output by newline
                4. For each line: switch on first 2 chars
                5. Increment counters, print results</pre>
          solution: |-
            func main() {
                out, err := exec.Command("git", "status", "--porcelain").Output()
                if err != nil {
                    fmt.Println("Not a git repo")
                    return
                }

                var modified, added, deleted int
                for _, line := range strings.Split(string(out), "\n") {
                    if len(line) < 2 {
                        continue
                    }
                    switch line[0:2] {
                    case " M", "M ", "MM":
                        modified++
                    case "A ", "??":
                        added++
                    case " D", "D ":
                        deleted++
                    }
                }
                fmt.Printf("Modified: %d, Added: %d, Deleted: %d\n",
                    modified, added, deleted)
            }
          difficulty: 3
          annotations:
            - type: stdlib
              label: exec.Command
              text: >-
                git status --porcelain gives machine-readable output that is stable across Git versions. Always use
                --porcelain for scripting, never the default human-readable format.
            - type: gotcha
              label: Two-Character Status
              text: >-
                The porcelain format uses TWO characters: index status and working tree status. 'M ' means staged
                modification, ' M' means unstaged. Both are valid modifications.
        - id: v2
          title: Git Branch Info
          description: >-
            Write a program that parses <code>git status --porcelain -b</code> to extract the current branch name and
            ahead/behind counts. Also list all changed files grouped by status.
          functionSignature: func main()
          testCases:
            - input: On branch main, 2 ahead, 1 modified file
              output: "Branch: main (ahead 2)\\nModified: file.go"
            - input: On branch feature, clean
              output: "Branch: feature\\nNo changes"
          hints:
            - title: ðŸ¤” Think about it
              content: What does the -b flag add to porcelain output? What does the branch line look like?
            - title: ðŸ’¡ Hint
              content: >-
                With -b, the first line is: ## branch...origin/branch [ahead N, behind M]. Parse this line separately.
                Remaining lines are status lines.
            - title: ðŸ”§ Pattern
              content: |-
                <pre>1. Run git status --porcelain -b
                2. First line: parse branch and ahead/behind
                3. Remaining lines: parse status codes
                4. Group files by status
                5. Print branch info and file groups</pre>
          solution: |-
            func main() {
                out, err := exec.Command("git", "status", "--porcelain", "-b").Output()
                if err != nil {
                    fmt.Println("Not a git repo")
                    return
                }

                lines := strings.Split(strings.TrimSpace(string(out)), "\n")
                if len(lines) == 0 {
                    return
                }

                // Parse branch line: ## main...origin/main [ahead 2]
                branchLine := lines[0][3:] // skip "## "
                branch := branchLine
                if idx := strings.Index(branchLine, "..."); idx != -1 {
                    branch = branchLine[:idx]
                }
                info := branch
                if idx := strings.Index(branchLine, "["); idx != -1 {
                    end := strings.Index(branchLine, "]")
                    info += " (" + branchLine[idx+1:end] + ")"
                }
                fmt.Println("Branch:", info)

                modified := []string{}
                added := []string{}
                deleted := []string{}
                for _, line := range lines[1:] {
                    if len(line) < 3 {
                        continue
                    }
                    file := strings.TrimSpace(line[3:])
                    switch line[0:2] {
                    case " M", "M ", "MM":
                        modified = append(modified, file)
                    case "A ", "??":
                        added = append(added, file)
                    case " D", "D ":
                        deleted = append(deleted, file)
                    }
                }

                if len(modified)+len(added)+len(deleted) == 0 {
                    fmt.Println("No changes")
                    return
                }
                for _, f := range modified { fmt.Println("Modified:", f) }
                for _, f := range added { fmt.Println("Added:", f) }
                for _, f := range deleted { fmt.Println("Deleted:", f) }
            }
          difficulty: 3
          annotations:
            - type: gotcha
              label: Branch Line Format
              text: >-
                The -b branch line format varies: '## main' (no remote), '## main...origin/main' (with remote), '##
                main...origin/main [ahead 1]' (with tracking info).
            - type: idiom
              label: String Slicing
              text: >-
                Go strings can be sliced like line[0:2] or line[3:]. This is efficient as it shares the underlying
                bytes. Be careful with Unicode; use []rune for multi-byte characters.
        - id: v3
          title: Git Diff Stats
          description: >-
            Write a program that runs <code>git diff --stat</code> and parses the output to extract file names and the
            number of insertions/deletions for each. Print a summary showing total files changed, insertions, and
            deletions.
          functionSignature: func main()
          testCases:
            - input: git diff --stat with 3 files, +20 -5
              output: 3 files changed, 20 insertions, 5 deletions
            - input: no changes
              output: No changes
          hints:
            - title: ðŸ¤” Think about it
              content: What does git diff --stat output look like? Where are the numbers for insertions and deletions?
            - title: ðŸ’¡ Hint
              content: >-
                The last line of --stat is a summary like: '3 files changed, 20 insertions(+), 5 deletions(-)'. Parse
                this line, or parse each file line which shows ' file | N +++---'.
            - title: ðŸ”§ Pattern
              content: |-
                <pre>1. Run git diff --stat
                2. Parse the summary line (last non-empty line)
                3. Extract numbers using string parsing or regexp
                4. Print formatted summary</pre>
          solution: |-
            func main() {
                out, err := exec.Command("git", "diff", "--stat").Output()
                if err != nil {
                    fmt.Fprintln(os.Stderr, err)
                    os.Exit(1)
                }

                output := strings.TrimSpace(string(out))
                if output == "" {
                    fmt.Println("No changes")
                    return
                }

                lines := strings.Split(output, "\n")
                // Parse individual file lines
                for _, line := range lines[:len(lines)-1] {
                    parts := strings.Split(line, "|")
                    if len(parts) == 2 {
                        file := strings.TrimSpace(parts[0])
                        changes := strings.TrimSpace(parts[1])
                        fmt.Printf("  %s: %s\n", file, changes)
                    }
                }

                // Print summary line as-is
                summary := lines[len(lines)-1]
                fmt.Println(strings.TrimSpace(summary))
            }
          difficulty: 3
          annotations:
            - type: stdlib
              label: git diff --stat
              text: >-
                git diff --stat produces a human-readable summary of changes. For machine-readable output, use --numstat
                which gives tab-separated insertions/deletions/filename.
            - type: alternative
              label: Use --numstat
              text: >-
                git diff --numstat outputs 'insertions\tdeletions\tfile' per line, which is easier to parse
                programmatically than --stat's visual bars.
        - id: v4
          title: Git Log Parser
          description: >-
            Write a program that runs <code>git log --oneline -10</code> and parses each line into a commit hash and
            message. Group commits by the first word of the message (e.g., "fix", "add", "update") and print the grouped
            results.
          functionSignature: func main()
          testCases:
            - input: "git log with 'fix: bug', 'add: feature', 'fix: typo'"
              output: "fix (2):\\n  abc1234 fix: bug\\n  def5678 fix: typo\\nadd (1):\\n  ghi9012 add: feature"
            - input: empty repo
              output: No commits
          hints:
            - title: ðŸ¤” Think about it
              content: How do you extract the first word from a commit message? What data structure groups items by a key?
            - title: ðŸ’¡ Hint
              content: >-
                Each oneline line is: 'hash message'. Split to get hash and message. Use strings.Fields(message)[0] for
                the first word. Group with map[string][]string.
            - title: ðŸ”§ Pattern
              content: |-
                <pre>1. Run git log --oneline -10
                2. For each line: split into hash and message
                3. Extract first word of message (lowercase)
                4. Group in map[string][]string
                5. Print groups with counts</pre>
          solution: |-
            func main() {
                out, err := exec.Command("git", "log", "--oneline", "-10").Output()
                if err != nil {
                    fmt.Println("Not a git repo or no commits")
                    return
                }

                output := strings.TrimSpace(string(out))
                if output == "" {
                    fmt.Println("No commits")
                    return
                }

                groups := make(map[string][]string)
                var order []string

                for _, line := range strings.Split(output, "\n") {
                    parts := strings.SplitN(line, " ", 2)
                    if len(parts) < 2 {
                        continue
                    }
                    hash := parts[0]
                    message := parts[1]
                    keyword := strings.ToLower(strings.Fields(message)[0])
                    // Remove trailing colon if present
                    keyword = strings.TrimRight(keyword, ":")

                    if _, exists := groups[keyword]; !exists {
                        order = append(order, keyword)
                    }
                    groups[keyword] = append(groups[keyword], hash+" "+message)
                }

                for _, key := range order {
                    commits := groups[key]
                    fmt.Printf("%s (%d):\n", key, len(commits))
                    for _, c := range commits {
                        fmt.Printf("  %s\n", c)
                    }
                }
            }
          difficulty: 3
          annotations:
            - type: idiom
              label: Insertion Order Map
              text: >-
                Go maps do not preserve insertion order. To print groups in the order they were first seen, maintain a
                separate slice of keys.
            - type: stdlib
              label: strings.SplitN
              text: >-
                strings.SplitN(s, sep, n) splits into at most n parts. SplitN(line, " ", 2) splits on the first space
                only, keeping the rest of the message intact.
