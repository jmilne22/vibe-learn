conceptLinks:
  Interface Basics: "#lesson-interfaces"
  fmt.Stringer: "#lesson-stringer"
  io.Writer: "#lesson-writer"
  io.Reader: "#lesson-reader"
  Type Assertions: "#lesson-type-assertions"
  Type Switches: "#lesson-type-switch"
  Implicit Satisfaction: "#lesson-implicit"
  Empty Interface: "#lesson-empty-interface"
sharedContent: {}
variants:
  warmups:
    - id: warmup_1
      concept: fmt.Stringer
      quickRef: |
        <code>func (t T) String() string { return "..." }</code><br>
                Implement <code>fmt.Stringer</code> for custom print output
      variants:
        - id: v1
          title: Person Stringer
          description: >-
            Create a <code>Person</code> struct with <code>Name string</code> and <code>Age int</code>. Implement
            <code>fmt.Stringer</code> so that printing a Person outputs a nice format.
          hints:
            - Implement <code>String() string</code> method
            - Use <code>fmt.Sprintf</code> to format the output
            - "The Stringer interface has just one method: <code>String() string</code>"
          solution: |-
            type Person struct {
                Name string
                Age  int
            }

            func (p Person) String() string {
                return fmt.Sprintf("%s (%d years old)", p.Name, p.Age)
            }
          annotations:
            - type: idiom
              label: Implicit Interfaces
              text: >-
                Go interfaces are satisfied implicitly. Simply defining <code>String() string</code> makes
                <code>Person</code> satisfy <code>fmt.Stringer</code> -- no <code>implements</code> keyword needed.
            - type: stdlib
              label: fmt.Stringer
              text: >-
                The <code>fmt</code> package checks for the <code>Stringer</code> interface when printing values.
                Implementing it controls how your type appears in <code>fmt.Println</code> and <code>%v</code>.
        - id: v2
          title: Color Stringer
          description: >-
            Create a <code>Color</code> struct with <code>R, G, B uint8</code> fields. Implement <code>String()
            string</code> to return the hex format like <code>#FF8800</code>.
          hints:
            - Use <code>fmt.Sprintf("#%02X%02X%02X", c.R, c.G, c.B)</code>
            - <code>%02X</code> formats as uppercase hex with zero-padding
          solution: |-
            type Color struct {
                R, G, B uint8
            }

            func (c Color) String() string {
                return fmt.Sprintf("#%02X%02X%02X", c.R, c.G, c.B)
            }
          annotations:
            - type: idiom
              label: Format Verbs
              text: >-
                <code>%02X</code> means: uppercase hex, at least 2 digits, zero-padded. This is the standard way to
                format colors in Go.
        - id: v3
          title: Coordinate Stringer
          description: >-
            Create a <code>Coordinate</code> struct with <code>Lat, Lon float64</code>. Implement <code>String()
            string</code> to return a format like <code>(40.7128, -74.0060)</code>.
          hints:
            - Use <code>fmt.Sprintf("(%.4f, %.4f)", c.Lat, c.Lon)</code>
            - <code>%.4f</code> formats a float with 4 decimal places
          solution: |-
            type Coordinate struct {
                Lat, Lon float64
            }

            func (c Coordinate) String() string {
                return fmt.Sprintf("(%.4f, %.4f)", c.Lat, c.Lon)
            }
          annotations:
            - type: idiom
              label: Float Precision
              text: >-
                Use <code>%.Nf</code> to control decimal places in output. This is important for coordinates, currency,
                and scientific values.
        - id: v4
          title: Duration Stringer
          description: >-
            Create a <code>Duration</code> struct with <code>Hours, Minutes, Seconds int</code>. Implement
            <code>String() string</code> to return a format like <code>02:30:05</code>.
          hints:
            - Use <code>fmt.Sprintf("%02d:%02d:%02d", d.Hours, d.Minutes, d.Seconds)</code>
            - <code>%02d</code> zero-pads to 2 digits
          solution: |-
            type Duration struct {
                Hours, Minutes, Seconds int
            }

            func (d Duration) String() string {
                return fmt.Sprintf("%02d:%02d:%02d", d.Hours, d.Minutes, d.Seconds)
            }
          annotations:
            - type: stdlib
              label: time.Duration
              text: >-
                Go's standard library has <code>time.Duration</code> for real use. This exercise teaches the Stringer
                pattern with a familiar concept.
            - type: gotcha
              label: Value vs Pointer Receiver
              text: >-
                Using a value receiver for <code>String()</code> ensures it works on both values and pointers. A pointer
                receiver would not be called on values.
    - id: warmup_2
      concept: Interface Basics
      quickRef: |
        <code>type Reader interface { Read(p []byte) (int, error) }</code><br>
                Implicit satisfaction â€” no <code>implements</code> keyword
      variants:
        - id: v1
          title: Shape Interface
          description: >-
            Define a <code>Shape</code> interface with <code>Area() float64</code>. Implement it for <code>Circle</code>
            and <code>Rectangle</code>. Write <code>func TotalArea(shapes []Shape) float64</code>.
          hints:
            - Circle area = math.Pi * r * r
            - Rectangle area = width * height
            - Loop through shapes and sum their areas
          solution: |-
            type Shape interface {
                Area() float64
            }

            type Circle struct{ Radius float64 }
            func (c Circle) Area() float64 { return math.Pi * c.Radius * c.Radius }

            type Rectangle struct{ Width, Height float64 }
            func (r Rectangle) Area() float64 { return r.Width * r.Height }

            func TotalArea(shapes []Shape) float64 {
                var total float64
                for _, s := range shapes {
                    total += s.Area()
                }
                return total
            }
          annotations:
            - type: idiom
              label: Small Interfaces
              text: >-
                Go favors small interfaces with 1-2 methods. The <code>Shape</code> interface with a single
                <code>Area()</code> method is a good example.
            - type: pattern
              label: Interface Slice
              text: >-
                Using <code>[]Shape</code> lets you store any type that satisfies <code>Shape</code>. This is Go's
                polymorphism: different types, same behavior.
        - id: v2
          title: Measurable Interface
          description: >-
            Define a <code>Measurable</code> interface with <code>Length() int</code>. Implement it for
            <code>Word</code> (a string wrapper) and <code>Sentence</code> (word count). Write <code>func Longest(items
            []Measurable) Measurable</code>.
          hints:
            - Word's Length returns <code>len(string)</code>
            - Sentence's Length returns the number of words
            - Loop through items tracking the one with max Length
          solution: |-
            type Measurable interface {
                Length() int
            }

            type Word string
            func (w Word) Length() int { return len(string(w)) }

            type Sentence struct{ Words []string }
            func (s Sentence) Length() int { return len(s.Words) }

            func Longest(items []Measurable) Measurable {
                var longest Measurable
                maxLen := -1
                for _, item := range items {
                    if item.Length() > maxLen {
                        maxLen = item.Length()
                        longest = item
                    }
                }
                return longest
            }
          annotations:
            - type: idiom
              label: Named Type
              text: >-
                <code>type Word string</code> creates a new named type based on string. It can have its own methods,
                unlike a plain string.
            - type: gotcha
              label: Nil Interface Return
              text: If <code>items</code> is empty, <code>longest</code> will be nil. Callers should check the return value.
        - id: v3
          title: Sortable Interface
          description: >-
            Define a <code>Sortable</code> interface with <code>CompareTo(other Sortable) int</code>. Implement it for
            <code>Age int</code> that returns -1, 0, or 1. Write <code>func Max(items []Sortable) Sortable</code>.
          hints:
            - CompareTo returns -1 if less, 0 if equal, 1 if greater
            - Use a type assertion in CompareTo to get the underlying Age
            - Track the maximum while iterating
          solution: |-
            type Sortable interface {
                CompareTo(other Sortable) int
            }

            type Age int

            func (a Age) CompareTo(other Sortable) int {
                b := other.(Age)
                if a < b {
                    return -1
                } else if a > b {
                    return 1
                }
                return 0
            }

            func Max(items []Sortable) Sortable {
                if len(items) == 0 {
                    return nil
                }
                max := items[0]
                for _, item := range items[1:] {
                    if item.CompareTo(max) > 0 {
                        max = item
                    }
                }
                return max
            }
          annotations:
            - type: gotcha
              label: Type Assertion Panic
              text: >-
                The assertion <code>other.(Age)</code> will panic if other is not an <code>Age</code>. Use the comma-ok
                form <code>b, ok := other.(Age)</code> for safety.
            - type: alternative
              label: sort.Interface
              text: >-
                Go's standard library uses <code>sort.Interface</code> with <code>Len</code>, <code>Less</code>, and
                <code>Swap</code> methods. This approach is more idiomatic than CompareTo.
        - id: v4
          title: Greeter Interface
          description: >-
            Define a <code>Greeter</code> interface with <code>Greet() string</code>. Implement it for
            <code>EnglishGreeter</code>, <code>SpanishGreeter</code>, and <code>FormalGreeter</code> (which wraps a
            name). Write <code>func GreetAll(greeters []Greeter) []string</code>.
          hints:
            - Each greeter returns a different greeting string
            - FormalGreeter uses its Name field in the greeting
            - GreetAll collects all greetings into a slice
          solution: |-
            type Greeter interface {
                Greet() string
            }

            type EnglishGreeter struct{}
            func (e EnglishGreeter) Greet() string { return "Hello!" }

            type SpanishGreeter struct{}
            func (s SpanishGreeter) Greet() string { return "Hola!" }

            type FormalGreeter struct{ Name string }
            func (f FormalGreeter) Greet() string {
                return fmt.Sprintf("Good day, %s.", f.Name)
            }

            func GreetAll(greeters []Greeter) []string {
                var greetings []string
                for _, g := range greeters {
                    greetings = append(greetings, g.Greet())
                }
                return greetings
            }
          annotations:
            - type: idiom
              label: Accept Interfaces
              text: >-
                Go proverb: 'Accept interfaces, return structs.' <code>GreetAll</code> accepts <code>[]Greeter</code>
                (interface), making it work with any Greeter implementation.
            - type: pattern
              label: Stateless vs Stateful
              text: >-
                EnglishGreeter is stateless (empty struct), while FormalGreeter is stateful (carries a Name). Both
                satisfy the same interface.
  challenges:
    - id: challenge_1
      block: 1
      difficulty: 2
      concept: io.Writer
      docLinks:
        - url: https://pkg.go.dev/io#Writer
          title: Package io.Writer
          note: the fundamental writer interface
        - url: https://go.dev/doc/effective_go#interfaces
          title: "Effective Go: Interfaces"
          note: implicit interface satisfaction
      quickRef: |
        <code>type Writer interface { Write(p []byte) (int, error) }</code><br>
                <code>fmt.Fprintf(w, "...")</code> writes to any Writer
      variants:
        - id: v1
          title: UpperWriter
          description: >-
            Create an <code>UpperWriter</code> struct that wraps an <code>io.Writer</code> and converts all bytes to
            uppercase before writing to the inner writer.
          functionSignature: func (u *UpperWriter) Write(p []byte) (int, error)
          testCases:
            - input: var buf bytes.Buffer; uw := &UpperWriter{&buf}; uw.Write([]byte("hello"))
              output: buf.String() == "HELLO"
            - input: var buf bytes.Buffer; uw := &UpperWriter{&buf}; fmt.Fprintln(uw, "go is fun")
              output: buf.String() == "GO IS FUN\n"
          hints:
            - title: ðŸ¤” Think about it
              content: >-
                The <code>io.Writer</code> interface has one method: <code>Write(p []byte) (n int, err error)</code>.
                You need to transform the bytes before passing them along.
            - title: ðŸ’¡ Hint
              content: Use <code>bytes.ToUpper(p)</code> to convert the byte slice, then write the result to the inner writer.
            - title: ðŸ”§ Pattern
              content: |-
                <pre>type UpperWriter struct { w io.Writer }
                func (u *UpperWriter) Write(p []byte) (int, error) {
                    return u.w.Write(bytes.ToUpper(p))
                }</pre>
          solution: |-
            type UpperWriter struct {
                w io.Writer
            }

            func (u *UpperWriter) Write(p []byte) (int, error) {
                return u.w.Write(bytes.ToUpper(p))
            }
          difficulty: 2
          annotations:
            - type: idiom
              label: Writer Wrapper
              text: >-
                Wrapping an <code>io.Writer</code> to transform output is a classic Go pattern. It's used in
                compression, encryption, and logging.
            - type: pattern
              label: Decorator Pattern
              text: >-
                This is the decorator pattern: <code>UpperWriter</code> adds behavior (uppercasing) to any existing
                Writer without modifying it.
        - id: v2
          title: PrefixWriter
          description: >-
            Create a <code>PrefixWriter</code> that prepends a prefix string to every <code>Write</code> call before
            passing data to the inner <code>io.Writer</code>.
          functionSignature: func (pw *PrefixWriter) Write(p []byte) (int, error)
          testCases:
            - input: var buf bytes.Buffer; pw := &PrefixWriter{"[LOG] ", &buf}; pw.Write([]byte("hello"))
              output: buf.String() == "[LOG] hello"
            - input: var buf bytes.Buffer; pw := &PrefixWriter{">> ", &buf}; pw.Write([]byte("test"))
              output: buf.String() == ">> test"
          hints:
            - title: ðŸ¤” Think about it
              content: You need to write the prefix bytes first, then the original data.
            - title: ðŸ’¡ Hint
              content: Concatenate prefix + data into a single byte slice, or write the prefix first then the data.
            - title: ðŸ”§ Pattern
              content: |-
                <pre>type PrefixWriter struct {
                    Prefix string
                    w      io.Writer
                }
                func (pw *PrefixWriter) Write(p []byte) (int, error) {
                    data := append([]byte(pw.Prefix), p...)
                    return pw.w.Write(data)
                }</pre>
          solution: |-
            type PrefixWriter struct {
                Prefix string
                w      io.Writer
            }

            func (pw *PrefixWriter) Write(p []byte) (int, error) {
                data := append([]byte(pw.Prefix), p...)
                return pw.w.Write(data)
            }
          difficulty: 2
          annotations:
            - type: gotcha
              label: Byte Count Mismatch
              text: >-
                The returned byte count includes the prefix bytes, which is more than what the caller wrote. Some
                callers may check this. A production version should handle this carefully.
            - type: idiom
              label: Composable Writers
              text: >-
                Writer wrappers can be stacked: <code>PrefixWriter</code> wrapping an <code>UpperWriter</code> wrapping
                <code>os.Stdout</code>.
        - id: v3
          title: CountWriter
          description: >-
            Create a <code>CountWriter</code> that wraps an <code>io.Writer</code> and tracks the total number of bytes
            written. Add a <code>BytesWritten() int</code> method.
          functionSignature: |-
            func (cw *CountWriter) Write(p []byte) (int, error)
            func (cw *CountWriter) BytesWritten() int
          testCases:
            - input: "var buf bytes.Buffer; cw := &CountWriter{w: &buf}; cw.Write([]byte(\"hello\")); cw.BytesWritten()"
              output: "5"
            - input: cw.Write([]byte(" world")); cw.BytesWritten()
              output: "11"
          hints:
            - title: ðŸ¤” Think about it
              content: You need to track cumulative bytes. Where does the actual byte count come from?
            - title: ðŸ’¡ Hint
              content: The inner writer's Write returns the number of bytes written. Add that to your running total.
            - title: ðŸ”§ Pattern
              content: |-
                <pre>type CountWriter struct {
                    w     io.Writer
                    count int
                }
                func (cw *CountWriter) Write(p []byte) (int, error) {
                    n, err := cw.w.Write(p)
                    cw.count += n
                    return n, err
                }</pre>
          solution: |-
            type CountWriter struct {
                w     io.Writer
                count int
            }

            func (cw *CountWriter) Write(p []byte) (int, error) {
                n, err := cw.w.Write(p)
                cw.count += n
                return n, err
            }

            func (cw *CountWriter) BytesWritten() int {
                return cw.count
            }
          difficulty: 2
          annotations:
            - type: idiom
              label: Passthrough with Side Effect
              text: >-
                CountWriter delegates to the inner writer but adds counting as a side effect. The caller's data flows
                through unchanged.
            - type: complexity
              label: O(1) per Write
              text: Counting adds constant overhead per Write call. No additional memory beyond the counter.
        - id: v4
          title: TeeWriter
          description: >-
            Create a <code>TeeWriter</code> that writes to two <code>io.Writer</code>s simultaneously. If either write
            fails, return the error.
          functionSignature: func (tw *TeeWriter) Write(p []byte) (int, error)
          testCases:
            - input: var b1, b2 bytes.Buffer; tw := &TeeWriter{&b1, &b2}; tw.Write([]byte("hello"))
              output: b1.String() == "hello" && b2.String() == "hello"
            - input: n, err from above
              output: n == 5, err == nil
          hints:
            - title: ðŸ¤” Think about it
              content: You need to write to both writers. What if the first succeeds but the second fails?
            - title: ðŸ’¡ Hint
              content: >-
                Write to the first writer, check for errors. Then write to the second. Return the first error
                encountered.
            - title: ðŸ”§ Pattern
              content: |-
                <pre>type TeeWriter struct { w1, w2 io.Writer }
                func (tw *TeeWriter) Write(p []byte) (int, error) {
                    n, err := tw.w1.Write(p)
                    if err != nil { return n, err }
                    return tw.w2.Write(p)
                }</pre>
          solution: |-
            type TeeWriter struct {
                w1, w2 io.Writer
            }

            func (tw *TeeWriter) Write(p []byte) (int, error) {
                n, err := tw.w1.Write(p)
                if err != nil {
                    return n, err
                }
                return tw.w2.Write(p)
            }
          difficulty: 3
          annotations:
            - type: stdlib
              label: io.MultiWriter
              text: >-
                Go's standard library provides <code>io.MultiWriter(writers ...io.Writer)</code> which does this for any
                number of writers.
            - type: gotcha
              label: Partial Writes
              text: >-
                If w1 succeeds but w2 fails, data is partially written. Production code should consider whether this
                inconsistency is acceptable.
            - type: pattern
              label: Fan-out Pattern
              text: >-
                Writing to multiple destinations is the fan-out pattern. Useful for logging to both file and stdout
                simultaneously.
    - id: challenge_2
      block: 1
      difficulty: 2
      concept: Type Switches
      docLinks:
        - url: https://go.dev/ref/spec#Type_switches
          title: "Go Spec: Type switches"
          note: switching on interface types
        - url: https://go.dev/doc/effective_go#type_switch
          title: "Effective Go: Type switch"
          note: type switch patterns
      quickRef: |
        <code>switch v := i.(type) { case int: ... case string: ... }</code>
      variants:
        - id: v1
          title: Describe Any Value
          description: >-
            Write <code>func describe(i any) string</code> that returns type-specific descriptions for <code>int</code>,
            <code>string</code>, <code>bool</code>, <code>float64</code>, and <code>"unknown"</code> for other types.
          functionSignature: func describe(i any) string
          testCases:
            - input: describe(42)
              output: "\"integer: 42\""
            - input: describe("hello")
              output: "\"text: hello\""
            - input: describe(true)
              output: "\"boolean: true\""
            - input: describe(3.14)
              output: "\"float: 3.14\""
            - input: describe([]int{1})
              output: "\"unknown\""
          hints:
            - title: ðŸ¤” Think about it
              content: Go's type switch lets you branch based on the dynamic type of an interface value.
            - title: ðŸ’¡ Hint
              content: >-
                Use <code>switch v := i.(type)</code>. The variable <code>v</code> has the concrete type in each case
                branch.
            - title: ðŸ”§ Pattern
              content: |-
                <pre>switch v := i.(type) {
                case int:
                    return fmt.Sprintf("integer: %d", v)
                case string:
                    return fmt.Sprintf("text: %s", v)
                // ... more cases
                default:
                    return "unknown"
                }</pre>
          solution: |-
            func describe(i any) string {
                switch v := i.(type) {
                case int:
                    return fmt.Sprintf("integer: %d", v)
                case string:
                    return fmt.Sprintf("text: %s", v)
                case bool:
                    return fmt.Sprintf("boolean: %t", v)
                case float64:
                    return fmt.Sprintf("float: %g", v)
                default:
                    return "unknown"
                }
            }
          difficulty: 1
          annotations:
            - type: idiom
              label: Type Switch
              text: >-
                Type switches are Go's primary mechanism for handling values of unknown type. The <code>v</code>
                variable is automatically narrowed to the matched type.
            - type: gotcha
              label: any vs interface{}
              text: >-
                <code>any</code> is an alias for <code>interface{}</code> introduced in Go 1.18. They are
                interchangeable, but <code>any</code> is preferred in modern Go.
        - id: v2
          title: Stringify Anything
          description: >-
            Write <code>func stringify(i any) string</code> that converts values to strings: numbers to their string
            form, bools to "yes"/"no", strings returned as-is, <code>fmt.Stringer</code> types call
            <code>String()</code>, and anything else returns "?".
          functionSignature: func stringify(i any) string
          testCases:
            - input: stringify(42)
              output: "\"42\""
            - input: stringify(true)
              output: "\"yes\""
            - input: stringify(false)
              output: "\"no\""
            - input: stringify("hi")
              output: "\"hi\""
          hints:
            - title: ðŸ¤” Think about it
              content: Order matters in a type switch. Check concrete types before interfaces.
            - title: ðŸ’¡ Hint
              content: >-
                Check <code>string</code> before <code>fmt.Stringer</code>, since strings also satisfy Stringer. Use
                <code>strconv.Itoa</code> for int-to-string.
            - title: ðŸ”§ Pattern
              content: |-
                <pre>switch v := i.(type) {
                case string:
                    return v
                case int:
                    return strconv.Itoa(v)
                case bool:
                    if v { return "yes" }
                    return "no"
                case fmt.Stringer:
                    return v.String()
                default:
                    return "?"
                }</pre>
          solution: |-
            func stringify(i any) string {
                switch v := i.(type) {
                case string:
                    return v
                case int:
                    return strconv.Itoa(v)
                case bool:
                    if v {
                        return "yes"
                    }
                    return "no"
                case fmt.Stringer:
                    return v.String()
                default:
                    return "?"
                }
            }
          difficulty: 2
          annotations:
            - type: gotcha
              label: Case Order Matters
              text: >-
                In a type switch, the first matching case wins. Put concrete types before interfaces, or a
                <code>fmt.Stringer</code> case could match before <code>string</code>.
            - type: idiom
              label: Interface Case
              text: >-
                Type switches can match interfaces, not just concrete types. <code>case fmt.Stringer</code> matches any
                type with a <code>String()</code> method.
        - id: v3
          title: Sum Mixed Slice
          description: >-
            Write <code>func sumAny(items []any) float64</code> that sums numeric values in the slice, skipping
            non-numeric types. Handle <code>int</code>, <code>float64</code>, and <code>string</code> (parse with
            <code>strconv.ParseFloat</code>, skip on error).
          functionSignature: func sumAny(items []any) float64
          testCases:
            - input: sumAny([]any{1, 2.5, "3.5"})
              output: "7.0"
            - input: sumAny([]any{10, "abc", true})
              output: "10.0"
            - input: sumAny([]any{})
              output: "0.0"
          hints:
            - title: ðŸ¤” Think about it
              content: Loop through items, type-switch each one, and add numeric values to a running sum.
            - title: ðŸ’¡ Hint
              content: >-
                For <code>int</code>, convert to <code>float64</code>. For <code>string</code>, try
                <code>strconv.ParseFloat(v, 64)</code> and skip on error.
            - title: ðŸ”§ Pattern
              content: |-
                <pre>var sum float64
                for _, item := range items {
                    switch v := item.(type) {
                    case int:
                        sum += float64(v)
                    case float64:
                        sum += v
                    case string:
                        if f, err := strconv.ParseFloat(v, 64); err == nil {
                            sum += f
                        }
                    }
                }
                return sum</pre>
          solution: |-
            func sumAny(items []any) float64 {
                var sum float64
                for _, item := range items {
                    switch v := item.(type) {
                    case int:
                        sum += float64(v)
                    case float64:
                        sum += v
                    case string:
                        if f, err := strconv.ParseFloat(v, 64); err == nil {
                            sum += f
                        }
                    }
                }
                return sum
            }
          difficulty: 2
          annotations:
            - type: gotcha
              label: int vs float64
              text: >-
                JSON numbers unmarshaled into <code>any</code> become <code>float64</code>, not <code>int</code>. Always
                handle both numeric types when working with <code>any</code>.
            - type: idiom
              label: Silent Skip
              text: >-
                Not handling a type in a type switch silently skips it (no default needed). This is intentional for
                filtering by type.
        - id: v4
          title: Format for Logging
          description: >-
            Write <code>func formatLog(level string, value any) string</code> that formats log entries differently based
            on the value type: <code>error</code> types include <code>[ERROR]</code> prefix, <code>fmt.Stringer</code>
            types use <code>String()</code>, and others use <code>fmt.Sprintf("%v")</code>.
          functionSignature: func formatLog(level string, value any) string
          testCases:
            - input: formatLog("INFO", "server started")
              output: "\"[INFO] server started\""
            - input: formatLog("WARN", fmt.Errorf("disk full"))
              output: "\"[WARN][ERROR] disk full\""
            - input: formatLog("DEBUG", 42)
              output: "\"[DEBUG] 42\""
          hints:
            - title: ðŸ¤” Think about it
              content: >-
                The <code>error</code> interface has an <code>Error() string</code> method. Check for <code>error</code>
                before <code>fmt.Stringer</code> since errors also satisfy Stringer.
            - title: ðŸ’¡ Hint
              content: >-
                Use <code>case error</code> to match error types. Then <code>case fmt.Stringer</code> for other Stringer
                types. Default uses <code>%v</code>.
            - title: ðŸ”§ Pattern
              content: |-
                <pre>func formatLog(level string, value any) string {
                    prefix := fmt.Sprintf("[%s]", level)
                    switch v := value.(type) {
                    case error:
                        return fmt.Sprintf("%s[ERROR] %s", prefix, v.Error())
                    case fmt.Stringer:
                        return fmt.Sprintf("%s %s", prefix, v.String())
                    default:
                        return fmt.Sprintf("%s %v", prefix, v)
                    }
                }</pre>
          solution: |-
            func formatLog(level string, value any) string {
                prefix := fmt.Sprintf("[%s]", level)
                switch v := value.(type) {
                case error:
                    return fmt.Sprintf("%s[ERROR] %s", prefix, v.Error())
                case fmt.Stringer:
                    return fmt.Sprintf("%s %s", prefix, v.String())
                default:
                    return fmt.Sprintf("%s %v", prefix, v)
                }
            }
          difficulty: 3
          annotations:
            - type: gotcha
              label: error vs Stringer Order
              text: >-
                The <code>error</code> interface defines <code>Error() string</code>, and many errors also implement
                <code>Stringer</code>. Check <code>error</code> first to avoid treating errors as generic Stringers.
            - type: pattern
              label: Structured Logging
              text: >-
                This pattern is foundational for logging libraries. Real loggers like <code>slog</code> use similar
                type-based formatting internally.
            - type: stdlib
              label: log/slog
              text: >-
                Go 1.21 introduced <code>log/slog</code> for structured logging. For production code, prefer
                <code>slog</code> over manual formatting.
