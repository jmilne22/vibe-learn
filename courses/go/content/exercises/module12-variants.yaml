conceptLinks:
  Functional Options: "#lesson-functional-options"
  Factory Pattern: "#lesson-factory-pattern"
  Strategy Pattern: "#lesson-strategy-pattern"
  Builder Pattern: "#lesson-builder-pattern"
sharedContent: {}
variants:
  warmups:
    - id: warmup_1
      concept: Functional Options
      variants:
        - id: v1
          title: HTTP Client with Options
          description: >-
            Create an <code>HTTPClient</code> struct with fields <code>timeout</code> (<code>time.Duration</code>),
            <code>retries</code> (<code>int</code>), and <code>baseURL</code> (<code>string</code>). Implement the
            functional options pattern with <code>WithTimeout</code>, <code>WithRetries</code>, and
            <code>WithBaseURL</code>. Write a constructor <code>NewHTTPClient(opts ...Option) *HTTPClient</code> that
            applies all options with a default timeout of 30 seconds.
          hints:
            - Define <code>type Option func(*HTTPClient)</code> as your option function type.
            - Each <code>With</code> function returns a closure that modifies the client.
          solution: |-
            type HTTPClient struct {
                timeout time.Duration
                retries int
                baseURL string
            }

            type Option func(*HTTPClient)

            func WithTimeout(d time.Duration) Option {
                return func(c *HTTPClient) { c.timeout = d }
            }

            func WithRetries(n int) Option {
                return func(c *HTTPClient) { c.retries = n }
            }

            func WithBaseURL(url string) Option {
                return func(c *HTTPClient) { c.baseURL = url }
            }

            func NewHTTPClient(opts ...Option) *HTTPClient {
                c := &HTTPClient{timeout: 30 * time.Second}
                for _, opt := range opts {
                    opt(c)
                }
                return c
            }
          annotations:
            - type: idiom
              label: Functional Options
              text: >-
                The functional options pattern uses variadic closures to configure structs. This is idiomatic Go and
                avoids large config structs or multiple constructors.
            - type: gotcha
              label: Default Values
              text: >-
                Always set sensible defaults before applying options. A zero-value timeout means no timeout, which can
                cause hanging requests.
        - id: v2
          title: Database Connection with Options
          description: >-
            Create a <code>DBConn</code> struct with fields <code>host</code> (<code>string</code>), <code>port</code>
            (<code>int</code>), and <code>maxConns</code> (<code>int</code>). Implement functional options
            <code>WithHost</code>, <code>WithPort</code>, and <code>WithMaxConns</code>. Write <code>NewDBConn(opts
            ...DBOption) *DBConn</code> with defaults: host <code>"localhost"</code>, port <code>5432</code>, maxConns
            <code>10</code>.
          hints:
            - Define <code>type DBOption func(*DBConn)</code>.
            - Set defaults in the constructor before applying options.
          solution: |-
            type DBConn struct {
                host     string
                port     int
                maxConns int
            }

            type DBOption func(*DBConn)

            func WithHost(h string) DBOption {
                return func(c *DBConn) { c.host = h }
            }

            func WithPort(p int) DBOption {
                return func(c *DBConn) { c.port = p }
            }

            func WithMaxConns(n int) DBOption {
                return func(c *DBConn) { c.maxConns = n }
            }

            func NewDBConn(opts ...DBOption) *DBConn {
                c := &DBConn{host: "localhost", port: 5432, maxConns: 10}
                for _, opt := range opts {
                    opt(c)
                }
                return c
            }
          annotations:
            - type: idiom
              label: Sensible Defaults
              text: >-
                Idiomatic Go constructors provide zero-configuration usability. NewDBConn() with no arguments should
                return a working connection to localhost.
            - type: alternative
              label: Config Struct
              text: >-
                An alternative is passing a Config struct, but functional options scale better when adding new settings
                without breaking existing callers.
        - id: v3
          title: Server with Options
          description: >-
            Create a <code>Server</code> struct with fields <code>addr</code> (<code>string</code>),
            <code>readTimeout</code> (<code>time.Duration</code>), and <code>maxBodySize</code> (<code>int64</code>).
            Implement functional options <code>WithAddr</code>, <code>WithReadTimeout</code>, and
            <code>WithMaxBodySize</code>. Write <code>NewServer(opts ...ServerOption) *Server</code> with defaults: addr
            <code>":8080"</code>, readTimeout <code>5*time.Second</code>, maxBodySize <code>1 &lt;&lt; 20</code> (1MB).
          hints:
            - Define <code>type ServerOption func(*Server)</code>.
            - Use <code>1 &lt;&lt; 20</code> for 1MB in bytes.
          solution: |-
            type Server struct {
                addr        string
                readTimeout time.Duration
                maxBodySize int64
            }

            type ServerOption func(*Server)

            func WithAddr(a string) ServerOption {
                return func(s *Server) { s.addr = a }
            }

            func WithReadTimeout(d time.Duration) ServerOption {
                return func(s *Server) { s.readTimeout = d }
            }

            func WithMaxBodySize(n int64) ServerOption {
                return func(s *Server) { s.maxBodySize = n }
            }

            func NewServer(opts ...ServerOption) *Server {
                s := &Server{addr: ":8080", readTimeout: 5 * time.Second, maxBodySize: 1 << 20}
                for _, opt := range opts {
                    opt(s)
                }
                return s
            }
          annotations:
            - type: idiom
              label: Bit Shifting for Sizes
              text: Using 1 << 20 for 1MB is idiomatic in Go. The standard library itself uses this pattern for byte sizes.
            - type: pattern
              label: Functional Options
              text: >-
                This pattern was popularized by Dave Cheney and Rob Pike. It allows API evolution without breaking
                backward compatibility.
        - id: v4
          title: Cache with Options
          description: >-
            Create a <code>Cache</code> struct with fields <code>maxSize</code> (<code>int</code>), <code>ttl</code>
            (<code>time.Duration</code>), and <code>onEvict</code> (<code>func(string)</code>). Implement functional
            options <code>WithMaxSize</code>, <code>WithTTL</code>, and <code>WithOnEvict</code>. Write
            <code>NewCache(opts ...CacheOption) *Cache</code> with defaults: maxSize <code>100</code>, ttl
            <code>5*time.Minute</code>, nil onEvict.
          hints:
            - Define <code>type CacheOption func(*Cache)</code>.
            - The <code>onEvict</code> callback is a function value; it can be nil by default.
          solution: |-
            type Cache struct {
                maxSize int
                ttl     time.Duration
                onEvict func(string)
            }

            type CacheOption func(*Cache)

            func WithMaxSize(n int) CacheOption {
                return func(c *Cache) { c.maxSize = n }
            }

            func WithTTL(d time.Duration) CacheOption {
                return func(c *Cache) { c.ttl = d }
            }

            func WithOnEvict(fn func(string)) CacheOption {
                return func(c *Cache) { c.onEvict = fn }
            }

            func NewCache(opts ...CacheOption) *Cache {
                c := &Cache{maxSize: 100, ttl: 5 * time.Minute}
                for _, opt := range opts {
                    opt(c)
                }
                return c
            }
          annotations:
            - type: idiom
              label: Callback Options
              text: >-
                Functional options can accept function values as callbacks. This is common in Go libraries for hooks
                like eviction handlers, middleware, and error handlers.
            - type: gotcha
              label: Nil Function Check
              text: >-
                Always check if a callback is non-nil before calling it: <code>if c.onEvict != nil { c.onEvict(key)
                }</code>. Calling a nil function panics.
    - id: warmup_2
      concept: Factory Pattern
      variants:
        - id: v1
          title: Logger Factory
          description: >-
            Create a <code>Logger</code> interface with a <code>Log(msg string)</code> method. Implement
            <code>ConsoleLogger</code> (prints to stdout), <code>FileLogger</code> (has a <code>file</code> field), and
            <code>NullLogger</code> (discards). Write <code>NewLogger(logType string) Logger</code> that returns the
            right implementation for <code>"console"</code>, <code>"file"</code>, or <code>"null"</code>.
          hints:
            - Use a <code>switch</code> statement on the <code>logType</code> string.
            - Each struct must have a <code>Log(msg string)</code> method to satisfy the interface.
          solution: |-
            type Logger interface {
                Log(msg string)
            }

            type ConsoleLogger struct{}
            func (l *ConsoleLogger) Log(msg string) { fmt.Println(msg) }

            type FileLogger struct{ file string }
            func (l *FileLogger) Log(msg string) { /* write to l.file */ }

            type NullLogger struct{}
            func (l *NullLogger) Log(msg string) {}

            func NewLogger(logType string) Logger {
                switch logType {
                case "console":
                    return &ConsoleLogger{}
                case "file":
                    return &FileLogger{file: "app.log"}
                case "null":
                    return &NullLogger{}
                default:
                    return &ConsoleLogger{}
                }
            }
          annotations:
            - type: idiom
              label: Interface Return
              text: >-
                Factory functions in Go return interfaces, not concrete types. This allows callers to depend on
                behavior, not implementation.
            - type: pattern
              label: Factory Method
              text: >-
                The factory pattern centralizes object creation. Callers don't need to know about concrete types like
                ConsoleLogger or FileLogger.
        - id: v2
          title: Storage Factory
          description: >-
            Create a <code>Storage</code> interface with <code>Save(key, value string) error</code> and <code>Load(key
            string) (string, error)</code>. Implement <code>MemoryStorage</code> (uses a map), <code>FileStorage</code>
            (has a <code>dir</code> field), and <code>NullStorage</code> (returns empty). Write
            <code>NewStorage(storageType string) Storage</code>.
          hints:
            - >-
              The <code>MemoryStorage</code> needs a <code>map[string]string</code> field initialized with
              <code>make</code>.
            - Return a sensible default (like <code>MemoryStorage</code>) for unknown types.
          solution: |-
            type Storage interface {
                Save(key, value string) error
                Load(key string) (string, error)
            }

            type MemoryStorage struct {
                data map[string]string
            }

            func (s *MemoryStorage) Save(key, value string) error {
                s.data[key] = value
                return nil
            }

            func (s *MemoryStorage) Load(key string) (string, error) {
                v, ok := s.data[key]
                if !ok {
                    return "", fmt.Errorf("key not found: %s", key)
                }
                return v, nil
            }

            type FileStorage struct{ dir string }
            func (s *FileStorage) Save(key, value string) error { return nil }
            func (s *FileStorage) Load(key string) (string, error) { return "", nil }

            type NullStorage struct{}
            func (s *NullStorage) Save(key, value string) error { return nil }
            func (s *NullStorage) Load(key string) (string, error) { return "", nil }

            func NewStorage(storageType string) Storage {
                switch storageType {
                case "memory":
                    return &MemoryStorage{data: make(map[string]string)}
                case "file":
                    return &FileStorage{dir: "/tmp"}
                case "null":
                    return &NullStorage{}
                default:
                    return &MemoryStorage{data: make(map[string]string)}
                }
            }
          annotations:
            - type: gotcha
              label: Map Initialization
              text: >-
                Always initialize maps with make() before use. A nil map will panic on write. The factory is the right
                place to ensure proper initialization.
            - type: idiom
              label: Error Returns
              text: >-
                Go interfaces that do I/O should return errors. Even in-memory implementations return error to satisfy
                the interface contract.
        - id: v3
          title: Notifier Factory
          description: >-
            Create a <code>Notifier</code> interface with <code>Send(to, message string) error</code>. Implement
            <code>EmailNotifier</code>, <code>SMSNotifier</code>, and <code>SlackNotifier</code>. Write
            <code>NewNotifier(channel string) Notifier</code> that returns the correct implementation for
            <code>"email"</code>, <code>"sms"</code>, or <code>"slack"</code>.
          hints:
            - Each notifier struct can have relevant fields (e.g., <code>apiKey</code> for Slack).
            - Switch on the <code>channel</code> parameter.
          solution: |-
            type Notifier interface {
                Send(to, message string) error
            }

            type EmailNotifier struct{}
            func (n *EmailNotifier) Send(to, message string) error {
                fmt.Printf("Email to %s: %s\n", to, message)
                return nil
            }

            type SMSNotifier struct{}
            func (n *SMSNotifier) Send(to, message string) error {
                fmt.Printf("SMS to %s: %s\n", to, message)
                return nil
            }

            type SlackNotifier struct{ webhook string }
            func (n *SlackNotifier) Send(to, message string) error {
                fmt.Printf("Slack to %s: %s\n", to, message)
                return nil
            }

            func NewNotifier(channel string) Notifier {
                switch channel {
                case "email":
                    return &EmailNotifier{}
                case "sms":
                    return &SMSNotifier{}
                case "slack":
                    return &SlackNotifier{webhook: "https://hooks.slack.com/..."}
                default:
                    return &EmailNotifier{}
                }
            }
          annotations:
            - type: pattern
              label: Factory Method
              text: >-
                Factories decouple creation from usage. The caller only needs to know the interface, making it easy to
                add new notification channels later.
            - type: alternative
              label: Registry Pattern
              text: >-
                For extensibility, consider a map-based registry: <code>var factories = map[string]func()
                Notifier{}</code> with a Register function.
        - id: v4
          title: Parser Factory
          description: >-
            Create a <code>Parser</code> interface with <code>Parse(data []byte) (map[string]any, error)</code>.
            Implement <code>JSONParser</code>, <code>YAMLParser</code>, and <code>TOMLParser</code>. Write
            <code>NewParser(format string) Parser</code> that returns the correct parser for <code>"json"</code>,
            <code>"yaml"</code>, or <code>"toml"</code>.
          hints:
            - >-
              For the <code>JSONParser</code>, use <code>encoding/json</code> to unmarshal into
              <code>map[string]any</code>.
            - Return an error for unknown formats instead of a default.
          solution: |-
            type Parser interface {
                Parse(data []byte) (map[string]any, error)
            }

            type JSONParser struct{}
            func (p *JSONParser) Parse(data []byte) (map[string]any, error) {
                var result map[string]any
                err := json.Unmarshal(data, &result)
                return result, err
            }

            type YAMLParser struct{}
            func (p *YAMLParser) Parse(data []byte) (map[string]any, error) {
                return nil, fmt.Errorf("YAML parsing not implemented")
            }

            type TOMLParser struct{}
            func (p *TOMLParser) Parse(data []byte) (map[string]any, error) {
                return nil, fmt.Errorf("TOML parsing not implemented")
            }

            func NewParser(format string) (Parser, error) {
                switch format {
                case "json":
                    return &JSONParser{}, nil
                case "yaml":
                    return &YAMLParser{}, nil
                case "toml":
                    return &TOMLParser{}, nil
                default:
                    return nil, fmt.Errorf("unsupported format: %s", format)
                }
            }
          annotations:
            - type: idiom
              label: Error on Unknown
              text: >-
                When a factory cannot create a valid object, return an error instead of a default. This follows Go's
                explicit error handling philosophy.
            - type: stdlib
              label: encoding/json
              text: >-
                The standard library's json.Unmarshal can decode into map[string]any for dynamic JSON. This is useful
                when the structure is not known at compile time.
  challenges:
    - id: challenge_1
      block: 1
      difficulty: 2
      concept: Strategy Pattern
      docLinks:
        - url: https://go.dev/doc/effective_go#interfaces
          title: "Effective Go: Interfaces"
          note: interfaces enable strategy swapping
        - url: https://pkg.go.dev/sort#Interface
          title: Package sort.Interface
          note: stdlib strategy pattern example
      variants:
        - id: v1
          title: Sort Strategy
          description: >-
            Define a <code>Sorter</code> interface with <code>Sort([]int) []int</code>. Implement
            <code>BubbleSort</code> and <code>QuickSort</code>. Create a <code>DataProcessor</code> struct that accepts
            any <code>Sorter</code> and has a <code>Process(data []int) []int</code> method that delegates to the
            strategy.
          functionSignature: func NewDataProcessor(s Sorter) *DataProcessor
          testCases:
            - input: NewDataProcessor(&BubbleSort{}), []int{3, 1, 2}
              output: "[]int{1, 2, 3}"
            - input: NewDataProcessor(&QuickSort{}), []int{5, 3, 8, 1}
              output: "[]int{1, 3, 5, 8}"
          hints:
            - title: ðŸ¤” Think about it
              content: How can you allow a struct to use different algorithms without knowing which one at compile time?
            - title: ðŸ’¡ Hint
              content: >-
                Store the Sorter interface as a field on DataProcessor. The Process method just calls the sorter's Sort
                method.
            - title: ðŸ”§ Pattern
              content: |-
                <pre>1. Define Sorter interface with Sort([]int) []int
                2. Implement BubbleSort and QuickSort
                3. DataProcessor holds a Sorter field
                4. Process() delegates to the stored strategy</pre>
          solution: |-
            type Sorter interface {
                Sort([]int) []int
            }

            type BubbleSort struct{}
            func (b *BubbleSort) Sort(data []int) []int {
                n := len(data)
                result := make([]int, n)
                copy(result, data)
                for i := 0; i < n-1; i++ {
                    for j := 0; j < n-i-1; j++ {
                        if result[j] > result[j+1] {
                            result[j], result[j+1] = result[j+1], result[j]
                        }
                    }
                }
                return result
            }

            type QuickSort struct{}
            func (q *QuickSort) Sort(data []int) []int {
                result := make([]int, len(data))
                copy(result, data)
                sort.Ints(result)
                return result
            }

            type DataProcessor struct {
                sorter Sorter
            }

            func NewDataProcessor(s Sorter) *DataProcessor {
                return &DataProcessor{sorter: s}
            }

            func (dp *DataProcessor) Process(data []int) []int {
                return dp.sorter.Sort(data)
            }
          difficulty: 2
          annotations:
            - type: pattern
              label: Strategy Pattern
              text: >-
                The strategy pattern encapsulates algorithms behind an interface, letting you swap them at runtime
                without changing the client code.
            - type: idiom
              label: Accept Interfaces
              text: >-
                Go proverb: 'Accept interfaces, return structs.' DataProcessor accepts a Sorter interface, not a
                concrete type.
            - type: complexity
              label: Varies
              text: >-
                BubbleSort is O(n^2), QuickSort is O(n log n) average. The strategy pattern lets you choose the right
                algorithm for your data.
        - id: v2
          title: Compression Strategy
          description: >-
            Define a <code>Compressor</code> interface with <code>Compress(data []byte) []byte</code>. Implement
            <code>GzipCompressor</code> and <code>NoopCompressor</code>. Create a <code>FileProcessor</code> struct that
            accepts a <code>Compressor</code> and has <code>ProcessFile(data []byte) []byte</code>.
          functionSignature: func NewFileProcessor(c Compressor) *FileProcessor
          testCases:
            - input: NewFileProcessor(&NoopCompressor{}), []byte("hello")
              output: "[]byte(\"hello\")"
            - input: NewFileProcessor(&GzipCompressor{}), []byte("hello")
              output: compressed bytes (shorter or gzip header)
          hints:
            - title: ðŸ¤” Think about it
              content: What if you want to swap compression algorithms without changing the file processing logic?
            - title: ðŸ’¡ Hint
              content: >-
                The FileProcessor stores a Compressor interface. ProcessFile delegates to it. NoopCompressor just
                returns data unchanged.
            - title: ðŸ”§ Pattern
              content: |-
                <pre>1. Define Compressor interface
                2. Implement GzipCompressor using compress/gzip
                3. Implement NoopCompressor returning input unchanged
                4. FileProcessor holds Compressor and delegates</pre>
          solution: |-
            type Compressor interface {
                Compress(data []byte) []byte
            }

            type GzipCompressor struct{}
            func (g *GzipCompressor) Compress(data []byte) []byte {
                var buf bytes.Buffer
                w := gzip.NewWriter(&buf)
                w.Write(data)
                w.Close()
                return buf.Bytes()
            }

            type NoopCompressor struct{}
            func (n *NoopCompressor) Compress(data []byte) []byte {
                return data
            }

            type FileProcessor struct {
                compressor Compressor
            }

            func NewFileProcessor(c Compressor) *FileProcessor {
                return &FileProcessor{compressor: c}
            }

            func (fp *FileProcessor) ProcessFile(data []byte) []byte {
                return fp.compressor.Compress(data)
            }
          difficulty: 2
          annotations:
            - type: pattern
              label: Strategy Pattern
              text: >-
                Swapping GzipCompressor for NoopCompressor changes behavior without touching FileProcessor. This is the
                Open/Closed Principle in action.
            - type: stdlib
              label: compress/gzip
              text: >-
                Go's compress/gzip package provides gzip compression. Always call Close() on the writer to flush and
                finalize the compressed data.
        - id: v3
          title: Pricing Strategy
          description: >-
            Define a <code>PricingStrategy</code> interface with <code>Calculate(basePrice float64) float64</code>.
            Implement <code>RegularPricing</code> (no discount), <code>MemberPricing</code> (10% off), and
            <code>VIPPricing</code> (25% off). Create an <code>Order</code> struct that uses a strategy for
            <code>Total(basePrice float64) float64</code>.
          functionSignature: func NewOrder(strategy PricingStrategy) *Order
          testCases:
            - input: NewOrder(&RegularPricing{}), 100.0
              output: "100.0"
            - input: NewOrder(&MemberPricing{}), 100.0
              output: "90.0"
            - input: NewOrder(&VIPPricing{}), 100.0
              output: "75.0"
          hints:
            - title: ðŸ¤” Think about it
              content: How can the same Order type compute different totals depending on who is buying?
            - title: ðŸ’¡ Hint
              content: Store the PricingStrategy in Order. The Total method calls strategy.Calculate(basePrice).
            - title: ðŸ”§ Pattern
              content: |-
                <pre>1. Define PricingStrategy interface
                2. RegularPricing returns price unchanged
                3. MemberPricing returns price * 0.9
                4. VIPPricing returns price * 0.75
                5. Order delegates to its strategy</pre>
          solution: |-
            type PricingStrategy interface {
                Calculate(basePrice float64) float64
            }

            type RegularPricing struct{}
            func (r *RegularPricing) Calculate(basePrice float64) float64 {
                return basePrice
            }

            type MemberPricing struct{}
            func (m *MemberPricing) Calculate(basePrice float64) float64 {
                return basePrice * 0.9
            }

            type VIPPricing struct{}
            func (v *VIPPricing) Calculate(basePrice float64) float64 {
                return basePrice * 0.75
            }

            type Order struct {
                strategy PricingStrategy
            }

            func NewOrder(strategy PricingStrategy) *Order {
                return &Order{strategy: strategy}
            }

            func (o *Order) Total(basePrice float64) float64 {
                return o.strategy.Calculate(basePrice)
            }
          difficulty: 2
          annotations:
            - type: pattern
              label: Strategy Pattern
              text: >-
                The pricing strategy can be changed at runtime, e.g., when a user upgrades to VIP. No changes to Order
                are needed.
            - type: gotcha
              label: Float Precision
              text: >-
                Floating-point math can produce unexpected results (e.g., 0.1 + 0.2 != 0.3). For real money
                calculations, use integers (cents) or a decimal library.
        - id: v4
          title: Validation Strategy
          description: >-
            Define a <code>Validator</code> interface with <code>Validate(value string) error</code>. Implement
            <code>EmailValidator</code> (checks for @), <code>PhoneValidator</code> (checks all digits, length 10), and
            <code>NotEmptyValidator</code>. Create a <code>FormField</code> struct that accepts a <code>Validator</code>
            and has <code>SetValue(v string) error</code>.
          functionSignature: func NewFormField(name string, v Validator) *FormField
          testCases:
            - input: NewFormField("email", &EmailValidator{}), "user@test.com"
              output: nil (valid)
            - input: NewFormField("email", &EmailValidator{}), "invalid"
              output: "error: invalid email"
            - input: NewFormField("phone", &PhoneValidator{}), "1234567890"
              output: nil (valid)
          hints:
            - title: ðŸ¤” Think about it
              content: How can the same form field type validate differently depending on what data it holds?
            - title: ðŸ’¡ Hint
              content: >-
                FormField stores a Validator. SetValue calls Validate first. If valid, store the value; if not, return
                the error.
            - title: ðŸ”§ Pattern
              content: |-
                <pre>1. Define Validator interface with Validate(string) error
                2. EmailValidator checks strings.Contains(value, "@")
                3. PhoneValidator checks length and all digits
                4. FormField delegates validation before storing</pre>
          solution: |-
            type Validator interface {
                Validate(value string) error
            }

            type EmailValidator struct{}
            func (e *EmailValidator) Validate(value string) error {
                if !strings.Contains(value, "@") {
                    return fmt.Errorf("invalid email: missing @")
                }
                return nil
            }

            type PhoneValidator struct{}
            func (p *PhoneValidator) Validate(value string) error {
                if len(value) != 10 {
                    return fmt.Errorf("phone must be 10 digits")
                }
                for _, c := range value {
                    if c < '0' || c > '9' {
                        return fmt.Errorf("phone must contain only digits")
                    }
                }
                return nil
            }

            type NotEmptyValidator struct{}
            func (n *NotEmptyValidator) Validate(value string) error {
                if strings.TrimSpace(value) == "" {
                    return fmt.Errorf("value cannot be empty")
                }
                return nil
            }

            type FormField struct {
                name      string
                value     string
                validator Validator
            }

            func NewFormField(name string, v Validator) *FormField {
                return &FormField{name: name, validator: v}
            }

            func (f *FormField) SetValue(v string) error {
                if err := f.validator.Validate(v); err != nil {
                    return fmt.Errorf("field %s: %w", f.name, err)
                }
                f.value = v
                return nil
            }
          difficulty: 2
          annotations:
            - type: pattern
              label: Strategy Pattern
              text: >-
                Each form field can have a different validation strategy. You can even compose validators by creating a
                CompositeValidator that runs multiple checks.
            - type: idiom
              label: Error Wrapping
              text: >-
                Using fmt.Errorf with %w wraps the inner error, preserving the error chain. Callers can use errors.Is or
                errors.As to inspect wrapped errors.
    - id: challenge_2
      block: 2
      difficulty: 3
      concept: Builder Pattern
      docLinks:
        - url: https://go.dev/doc/effective_go#methods
          title: "Effective Go: Methods"
          note: method chaining on pointer receivers
        - url: https://pkg.go.dev/strings#Builder
          title: Package strings.Builder
          note: stdlib builder pattern example
      variants:
        - id: v1
          title: SQL Query Builder
          description: >-
            Build a fluent SQL query builder. <code>NewQuery(table)</code> creates a query. Chain
            <code>.Select(cols...)</code>, <code>.Where(cond, args...)</code>, and <code>.Limit(n)</code>. Call
            <code>.String()</code> to get the SQL string. Example: <code>NewQuery("users").Select("name",
            "email").Where("active = %t", true).Limit(10).String()</code> returns <code>"SELECT name, email FROM users
            WHERE active = true LIMIT 10"</code>.
          functionSignature: func NewQuery(table string) *Query
          testCases:
            - input: NewQuery("users").Select("name").Where("active = %t", true).Limit(5).String()
              output: "\"SELECT name FROM users WHERE active = true LIMIT 5\""
            - input: NewQuery("orders").Select("*").String()
              output: "\"SELECT * FROM orders\""
            - input: NewQuery("products").Select("name", "price").Where("price > %d", 100).Limit(20).String()
              output: "\"SELECT name, price FROM products WHERE price > 100 LIMIT 20\""
          hints:
            - title: ðŸ¤” Think about it
              content: How do you make methods chainable? What must each method return?
            - title: ðŸ’¡ Hint
              content: >-
                Each method modifies the Query and returns *Query (pointer to self). This enables method chaining. Store
                columns, where clauses, and limit as fields.
            - title: ðŸ”§ Pattern
              content: |-
                <pre>1. Query struct: table, cols []string, wheres []string, limit int
                2. NewQuery sets table, default cols to ["*"]
                3. Select/Where/Limit modify fields and return q
                4. String() assembles the SQL from fields</pre>
          solution: |-
            type Query struct {
                table  string
                cols   []string
                wheres []string
                limit  int
            }

            func NewQuery(table string) *Query {
                return &Query{table: table, cols: []string{"*"}}
            }

            func (q *Query) Select(cols ...string) *Query {
                q.cols = cols
                return q
            }

            func (q *Query) Where(cond string, args ...any) *Query {
                q.wheres = append(q.wheres, fmt.Sprintf(cond, args...))
                return q
            }

            func (q *Query) Limit(n int) *Query {
                q.limit = n
                return q
            }

            func (q *Query) String() string {
                sql := fmt.Sprintf("SELECT %s FROM %s",
                    strings.Join(q.cols, ", "), q.table)
                if len(q.wheres) > 0 {
                    sql += " WHERE " + strings.Join(q.wheres, " AND ")
                }
                if q.limit > 0 {
                    sql += fmt.Sprintf(" LIMIT %d", q.limit)
                }
                return sql
            }
          difficulty: 3
          annotations:
            - type: pattern
              label: Builder Pattern
              text: >-
                The builder pattern constructs complex objects step by step. Method chaining (returning *Query) creates
                a fluent API that reads like natural language.
            - type: gotcha
              label: SQL Injection
              text: >-
                Using fmt.Sprintf for SQL parameters is unsafe in production. Real query builders use parameterized
                queries ($1, $2) to prevent SQL injection.
            - type: idiom
              label: Pointer Receiver
              text: >-
                Methods return *Query (pointer), enabling chaining. If they returned Query (value), each method would
                operate on a copy.
        - id: v2
          title: HTML Builder
          description: >-
            Build a fluent HTML element builder. <code>NewElement(tag)</code> creates an element. Chain <code>.Attr(key,
            value)</code>, <code>.Class(cls)</code>, <code>.Text(content)</code>, and <code>.Child(elem)</code>. Call
            <code>.Render()</code> to produce HTML. Example:
            <code>NewElement("div").Class("container").Text("Hello").Render()</code> produces <code>&lt;div
            class="container"&gt;Hello&lt;/div&gt;</code>.
          functionSignature: func NewElement(tag string) *Element
          testCases:
            - input: NewElement("p").Text("Hello").Render()
              output: "\"<p>Hello</p>\""
            - input: NewElement("div").Class("box").Attr("id", "main").Text("Content").Render()
              output: "\"<div class=\\\"box\\\" id=\\\"main\\\">Content</div>\""
            - input: NewElement("a").Attr("href", "/home").Text("Home").Render()
              output: "\"<a href=\\\"/home\\\">Home</a>\""
          hints:
            - title: ðŸ¤” Think about it
              content: What data does an HTML element consist of? How do you assemble the opening tag with attributes?
            - title: ðŸ’¡ Hint
              content: >-
                Store tag, attrs (map or slice of pairs), classes ([]string), text, and children. Render assembles them:
                opening tag + attrs + text + children + closing tag.
            - title: ðŸ”§ Pattern
              content: |-
                <pre>1. Element: tag, attrs map, classes []string, text, children
                2. Each method modifies Element and returns *Element
                3. Render() builds: &lt;tag attrs&gt;text + children&lt;/tag&gt;
                4. Class() is syntactic sugar for Attr("class", ...)</pre>
          solution: |-
            type Element struct {
                tag      string
                attrs    [][2]string
                classes  []string
                text     string
                children []*Element
            }

            func NewElement(tag string) *Element {
                return &Element{tag: tag}
            }

            func (e *Element) Attr(key, value string) *Element {
                e.attrs = append(e.attrs, [2]string{key, value})
                return e
            }

            func (e *Element) Class(cls string) *Element {
                e.classes = append(e.classes, cls)
                return e
            }

            func (e *Element) Text(content string) *Element {
                e.text = content
                return e
            }

            func (e *Element) Child(child *Element) *Element {
                e.children = append(e.children, child)
                return e
            }

            func (e *Element) Render() string {
                var b strings.Builder
                b.WriteString("<" + e.tag)
                if len(e.classes) > 0 {
                    b.WriteString(fmt.Sprintf(` class="%s"`, strings.Join(e.classes, " ")))
                }
                for _, attr := range e.attrs {
                    b.WriteString(fmt.Sprintf(` %s="%s"`, attr[0], attr[1]))
                }
                b.WriteString(">")
                b.WriteString(e.text)
                for _, child := range e.children {
                    b.WriteString(child.Render())
                }
                b.WriteString("</" + e.tag + ">")
                return b.String()
            }
          difficulty: 3
          annotations:
            - type: pattern
              label: Builder Pattern
              text: >-
                The builder creates a tree structure. Each method adds data and returns the builder for chaining.
                Render() is the terminal operation.
            - type: stdlib
              label: strings.Builder
              text: >-
                Use strings.Builder for efficient string concatenation. It avoids allocating new strings on every
                append, unlike string += operations.
        - id: v3
          title: Request Builder
          description: >-
            Build a fluent HTTP request builder. <code>NewRequest(method, url)</code> creates a request. Chain
            <code>.Header(key, value)</code>, <code>.QueryParam(key, value)</code>, <code>.Body(data)</code>, and
            <code>.Timeout(d)</code>. Call <code>.Build()</code> to produce a description string showing method, full
            URL with query params, headers, and body.
          functionSignature: func NewRequest(method, url string) *RequestBuilder
          testCases:
            - input: >-
                NewRequest("GET", "https://api.example.com/users").QueryParam("page", "1").Header("Accept",
                "application/json").Build()
              output: "\"GET https://api.example.com/users?page=1\\nAccept: application/json\""
            - input: NewRequest("POST", "https://api.example.com/users").Body(`{"name":"Go"}`).Build()
              output: "\"POST https://api.example.com/users\\n\\n{\\\"name\\\":\\\"Go\\\"}\""
          hints:
            - title: ðŸ¤” Think about it
              content: What parts make up a full HTTP request? How do query parameters attach to a URL?
            - title: ðŸ’¡ Hint
              content: >-
                Store method, base URL, query params as key-value pairs, headers as key-value pairs, body, and timeout.
                Build() assembles the URL with query string and formats the output.
            - title: ðŸ”§ Pattern
              content: |-
                <pre>1. RequestBuilder: method, url, params, headers, body, timeout
                2. QueryParam appends to params slice
                3. Build() joins params with & and appends to URL with ?
                4. Format: METHOD URL\nHeaders\n\nBody</pre>
          solution: |-
            type RequestBuilder struct {
                method  string
                url     string
                params  [][2]string
                headers [][2]string
                body    string
                timeout time.Duration
            }

            func NewRequest(method, url string) *RequestBuilder {
                return &RequestBuilder{method: method, url: url}
            }

            func (r *RequestBuilder) Header(key, value string) *RequestBuilder {
                r.headers = append(r.headers, [2]string{key, value})
                return r
            }

            func (r *RequestBuilder) QueryParam(key, value string) *RequestBuilder {
                r.params = append(r.params, [2]string{key, value})
                return r
            }

            func (r *RequestBuilder) Body(data string) *RequestBuilder {
                r.body = data
                return r
            }

            func (r *RequestBuilder) Timeout(d time.Duration) *RequestBuilder {
                r.timeout = d
                return r
            }

            func (r *RequestBuilder) Build() string {
                fullURL := r.url
                if len(r.params) > 0 {
                    parts := make([]string, len(r.params))
                    for i, p := range r.params {
                        parts[i] = p[0] + "=" + p[1]
                    }
                    fullURL += "?" + strings.Join(parts, "&")
                }
                result := r.method + " " + fullURL
                for _, h := range r.headers {
                    result += "\n" + h[0] + ": " + h[1]
                }
                if r.body != "" {
                    result += "\n\n" + r.body
                }
                return result
            }
          difficulty: 3
          annotations:
            - type: pattern
              label: Builder Pattern
              text: >-
                HTTP request builders are common in Go libraries. They ensure all parts of a request are set before
                sending, avoiding partially-configured requests.
            - type: alternative
              label: net/http
              text: >-
                In production, use net/http.NewRequest and set headers directly. This builder is educational; real code
                uses the standard library.
            - type: gotcha
              label: URL Encoding
              text: >-
                Query parameters should be URL-encoded in production. Use net/url.Values and its Encode() method to
                handle special characters.
        - id: v4
          title: Config Builder
          description: >-
            Build a fluent configuration builder. <code>NewConfig()</code> creates a config. Chain <code>.Set(key, value
            string)</code>, <code>.SetInt(key string, value int)</code>, <code>.SetBool(key string, value bool)</code>,
            and <code>.From(map[string]string)</code>. Call <code>.Build()</code> to return a
            <code>map[string]string</code> of all settings. Call <code>.Get(key)</code> on the result to retrieve
            values.
          functionSignature: func NewConfig() *ConfigBuilder
          testCases:
            - input: NewConfig().Set("host", "localhost").SetInt("port", 8080).Build()
              output: "map[string]string{\"host\": \"localhost\", \"port\": \"8080\"}"
            - input: NewConfig().SetBool("debug", true).Set("env", "dev").Build()
              output: "map[string]string{\"debug\": \"true\", \"env\": \"dev\"}"
            - input: "NewConfig().From(map[string]string{\"a\": \"1\"}).Set(\"b\", \"2\").Build()"
              output: "map[string]string{\"a\": \"1\", \"b\": \"2\"}"
          hints:
            - title: ðŸ¤” Think about it
              content: How do you store values of different types in a uniform way? What is the simplest common representation?
            - title: ðŸ’¡ Hint
              content: >-
                Store everything as map[string]string internally. SetInt uses strconv.Itoa, SetBool uses
                strconv.FormatBool. From merges an existing map.
            - title: ðŸ”§ Pattern
              content: |-
                <pre>1. ConfigBuilder has data map[string]string
                2. Set stores string directly
                3. SetInt converts int to string
                4. SetBool converts bool to string
                5. From copies all entries from input map
                6. Build returns a copy of the map</pre>
          solution: |-
            type ConfigBuilder struct {
                data map[string]string
            }

            func NewConfig() *ConfigBuilder {
                return &ConfigBuilder{data: make(map[string]string)}
            }

            func (c *ConfigBuilder) Set(key, value string) *ConfigBuilder {
                c.data[key] = value
                return c
            }

            func (c *ConfigBuilder) SetInt(key string, value int) *ConfigBuilder {
                c.data[key] = strconv.Itoa(value)
                return c
            }

            func (c *ConfigBuilder) SetBool(key string, value bool) *ConfigBuilder {
                c.data[key] = strconv.FormatBool(value)
                return c
            }

            func (c *ConfigBuilder) From(m map[string]string) *ConfigBuilder {
                for k, v := range m {
                    c.data[k] = v
                }
                return c
            }

            func (c *ConfigBuilder) Build() map[string]string {
                result := make(map[string]string, len(c.data))
                for k, v := range c.data {
                    result[k] = v
                }
                return result
            }
          difficulty: 3
          annotations:
            - type: pattern
              label: Builder Pattern
              text: >-
                The config builder accumulates settings and produces an immutable result. Build() returns a copy, so
                further modifications to the builder do not affect the built config.
            - type: idiom
              label: Defensive Copy
              text: >-
                Build() copies the internal map to prevent callers from mutating the builder's state. This is a common
                Go pattern for returning safe data.
            - type: stdlib
              label: strconv
              text: >-
                The strconv package converts between strings and basic types. Itoa (int to ASCII), FormatBool, and their
                Parse counterparts are essential Go tools.
