{
  "conceptLinks": {
    "Which Clone": "#lesson-exec-lookpath",
    "System Info": "#lesson-os-user",
    "Process List": "#lesson-exec-command",
    "Git Status Parser": "#lesson-command-output"
  },
  "sharedContent": {},
  "variants": {
    "warmups": [
      {
        "id": "warmup_1",
        "concept": "Which Clone",
        "variants": [
          {
            "id": "v1",
            "title": "Which Clone",
            "description": "Write a program that takes a command name as <code>os.Args[1]</code> and prints its full path using <code>exec.LookPath</code>. If not found, print an error to stderr and exit with code 1. If no argument is given, print usage and exit with code 1.",
            "hints": [
              "Use <code>exec.LookPath(os.Args[1])</code> to find the binary.",
              "Check <code>len(os.Args) < 2</code> for missing arguments.",
              "Use <code>fmt.Fprintln(os.Stderr, ...)</code> for error output."
            ],
            "solution": "func main() {\n    if len(os.Args) < 2 {\n        fmt.Fprintln(os.Stderr, \"usage: which command\")\n        os.Exit(1)\n    }\n\n    path, err := exec.LookPath(os.Args[1])\n    if err != nil {\n        fmt.Fprintf(os.Stderr, \"%s: command not found\\n\", os.Args[1])\n        os.Exit(1)\n    }\n    fmt.Println(path)\n}",
            "annotations": [
              { "type": "stdlib", "label": "exec.LookPath", "text": "exec.LookPath searches for an executable in the directories listed in the PATH environment variable. It returns the full path or an error." },
              { "type": "idiom", "label": "Exit Codes", "text": "os.Exit(1) signals failure to the calling shell. Convention: 0 = success, 1 = general error, 2 = misuse. Match the behavior of the tool you are cloning." }
            ]
          },
          {
            "id": "v2",
            "title": "Which All",
            "description": "Write a program that finds ALL matching executables for a command name (not just the first). Split the <code>PATH</code> environment variable, check each directory for the executable, and print all matches.",
            "hints": [
              "Use <code>os.Getenv(\"PATH\")</code> and <code>strings.Split(..., \":\")</code> to get directories.",
              "Use <code>filepath.Join(dir, name)</code> to construct the path.",
              "Check if the file exists and is executable with <code>os.Stat</code>."
            ],
            "solution": "func main() {\n    if len(os.Args) < 2 {\n        fmt.Fprintln(os.Stderr, \"usage: which-all command\")\n        os.Exit(1)\n    }\n\n    name := os.Args[1]\n    pathDirs := strings.Split(os.Getenv(\"PATH\"), \":\")\n    found := false\n\n    for _, dir := range pathDirs {\n        full := filepath.Join(dir, name)\n        info, err := os.Stat(full)\n        if err != nil {\n            continue\n        }\n        if info.Mode()&0111 != 0 {\n            fmt.Println(full)\n            found = true\n        }\n    }\n\n    if !found {\n        os.Exit(1)\n    }\n}",
            "annotations": [
              { "type": "idiom", "label": "File Permissions", "text": "Check executable bits with info.Mode()&0111 != 0. The octal 0111 checks user, group, and other execute bits. This is how the shell determines if a file is runnable." },
              { "type": "stdlib", "label": "filepath.Join", "text": "filepath.Join correctly joins path components using the OS-specific separator. Always prefer it over manual string concatenation for file paths." }
            ]
          },
          {
            "id": "v3",
            "title": "Command Checker",
            "description": "Write <code>func commandExists(name string) bool</code> that returns true if the given command is available on the system. Then write a main function that checks a list of required tools (<code>go</code>, <code>git</code>, <code>docker</code>, <code>kubectl</code>) and prints which are available and which are missing.",
            "hints": [
              "Use <code>exec.LookPath</code> and check the error.",
              "Loop over a slice of tool names and print status for each.",
              "Use a boolean return instead of printing directly for testability."
            ],
            "solution": "func commandExists(name string) bool {\n    _, err := exec.LookPath(name)\n    return err == nil\n}\n\nfunc main() {\n    tools := []string{\"go\", \"git\", \"docker\", \"kubectl\"}\n    for _, tool := range tools {\n        if commandExists(tool) {\n            fmt.Printf(\"[OK]    %s\\n\", tool)\n        } else {\n            fmt.Printf(\"[MISS]  %s\\n\", tool)\n        }\n    }\n}",
            "annotations": [
              { "type": "idiom", "label": "Boolean Wrapper", "text": "Wrapping exec.LookPath in a bool function is a common Go pattern. It simplifies the calling code and makes the intent clear: does this command exist?" },
              { "type": "alternative", "label": "Error Details", "text": "For more detail, return (string, error) instead of bool. The string can be the path, and the error explains why the lookup failed." }
            ]
          },
          {
            "id": "v4",
            "title": "PATH Inspector",
            "description": "Write a program that prints each directory in the <code>PATH</code> environment variable on its own line, along with how many executables it contains. Skip directories that do not exist.",
            "hints": [
              "Use <code>os.ReadDir(dir)</code> to list directory contents.",
              "Count files where <code>info.Type().IsRegular()</code> and executable bits are set.",
              "Use <code>strings.Split(os.Getenv(\"PATH\"), \":\")</code> to get directories."
            ],
            "solution": "func main() {\n    pathDirs := strings.Split(os.Getenv(\"PATH\"), \":\")\n    for _, dir := range pathDirs {\n        entries, err := os.ReadDir(dir)\n        if err != nil {\n            continue\n        }\n        count := 0\n        for _, entry := range entries {\n            if !entry.IsDir() {\n                info, err := entry.Info()\n                if err == nil && info.Mode()&0111 != 0 {\n                    count++\n                }\n            }\n        }\n        fmt.Printf(\"%s (%d executables)\\n\", dir, count)\n    }\n}",
            "annotations": [
              { "type": "stdlib", "label": "os.ReadDir", "text": "os.ReadDir reads a directory and returns sorted DirEntry values. It is more efficient than os.ReadFile for listing directories and was added in Go 1.16." },
              { "type": "gotcha", "label": "Permission Errors", "text": "Some PATH directories may not be readable. Always check errors from os.ReadDir and skip inaccessible directories gracefully." }
            ]
          }
        ]
      },
      {
        "id": "warmup_2",
        "concept": "System Info",
        "variants": [
          {
            "id": "v1",
            "title": "System Info",
            "description": "Write a program that prints: hostname, current user, home directory, shell (from <code>SHELL</code> env var), and whether the current user is root (<code>os.Geteuid() == 0</code>).",
            "hints": [
              "Use <code>os.Hostname()</code> for hostname.",
              "Use <code>user.Current()</code> to get user info.",
              "Use <code>os.Getenv(\"SHELL\")</code> for the shell."
            ],
            "solution": "func main() {\n    hostname, _ := os.Hostname()\n    u, _ := user.Current()\n    shell := os.Getenv(\"SHELL\")\n    isRoot := os.Geteuid() == 0\n\n    fmt.Println(\"Hostname:\", hostname)\n    fmt.Println(\"User:\", u.Username)\n    fmt.Println(\"Home:\", u.HomeDir)\n    fmt.Println(\"Shell:\", shell)\n    fmt.Println(\"Root:\", isRoot)\n}",
            "annotations": [
              { "type": "stdlib", "label": "os/user", "text": "The os/user package provides user.Current() for the current user's info including Username, HomeDir, Uid, and Gid." },
              { "type": "gotcha", "label": "Cross-Platform", "text": "os.Geteuid() is Unix-only. On Windows, use a different approach. The SHELL env var is also Unix-specific; Windows uses COMSPEC." }
            ]
          },
          {
            "id": "v2",
            "title": "Environment Dump",
            "description": "Write a program that prints all environment variables sorted alphabetically. Format each as <code>KEY=VALUE</code>. Also print the total count of environment variables.",
            "hints": [
              "Use <code>os.Environ()</code> to get all env vars as <code>[]string</code>.",
              "Use <code>sort.Strings</code> to sort them.",
              "Each entry is already in <code>KEY=VALUE</code> format."
            ],
            "solution": "func main() {\n    envs := os.Environ()\n    sort.Strings(envs)\n    for _, env := range envs {\n        fmt.Println(env)\n    }\n    fmt.Printf(\"\\nTotal: %d environment variables\\n\", len(envs))\n}",
            "annotations": [
              { "type": "stdlib", "label": "os.Environ", "text": "os.Environ() returns a copy of all environment variables as a []string in KEY=VALUE format. Modifying the returned slice does not affect the environment." },
              { "type": "idiom", "label": "Sort Before Display", "text": "Sorting environment variables makes output reproducible and easier to read. sort.Strings sorts in-place, which is fine since os.Environ returns a copy." }
            ]
          },
          {
            "id": "v3",
            "title": "Runtime Info",
            "description": "Write a program that prints Go runtime information: Go version, OS, architecture, number of CPUs, and number of goroutines currently running.",
            "hints": [
              "Use <code>runtime.Version()</code>, <code>runtime.GOOS</code>, <code>runtime.GOARCH</code>.",
              "Use <code>runtime.NumCPU()</code> for CPU count.",
              "Use <code>runtime.NumGoroutine()</code> for active goroutines."
            ],
            "solution": "func main() {\n    fmt.Println(\"Go Version:\", runtime.Version())\n    fmt.Println(\"OS:\", runtime.GOOS)\n    fmt.Println(\"Arch:\", runtime.GOARCH)\n    fmt.Println(\"CPUs:\", runtime.NumCPU())\n    fmt.Println(\"Goroutines:\", runtime.NumGoroutine())\n}",
            "annotations": [
              { "type": "stdlib", "label": "runtime Package", "text": "The runtime package exposes Go runtime internals. GOOS and GOARCH are compile-time constants reflecting the target platform." },
              { "type": "idiom", "label": "Build Constraints", "text": "runtime.GOOS and runtime.GOARCH are set at compile time based on GOOS/GOARCH environment variables or build tags. They cannot change at runtime." }
            ]
          },
          {
            "id": "v4",
            "title": "Disk Usage",
            "description": "Write a program that prints the current working directory and the total size of all files in it (non-recursive). Use <code>os.Getwd()</code> and <code>os.ReadDir</code>.",
            "hints": [
              "Use <code>os.Getwd()</code> for the current directory.",
              "Use <code>os.ReadDir(\".\")</code> to list files.",
              "Call <code>entry.Info()</code> to get size via <code>info.Size()</code>."
            ],
            "solution": "func main() {\n    cwd, _ := os.Getwd()\n    fmt.Println(\"Directory:\", cwd)\n\n    entries, err := os.ReadDir(\".\")\n    if err != nil {\n        fmt.Fprintln(os.Stderr, err)\n        os.Exit(1)\n    }\n\n    var totalSize int64\n    fileCount := 0\n    for _, entry := range entries {\n        if !entry.IsDir() {\n            info, err := entry.Info()\n            if err == nil {\n                totalSize += info.Size()\n                fileCount++\n            }\n        }\n    }\n    fmt.Printf(\"Files: %d\\n\", fileCount)\n    fmt.Printf(\"Total size: %d bytes\\n\", totalSize)\n}",
            "annotations": [
              { "type": "stdlib", "label": "os.Getwd", "text": "os.Getwd returns the current working directory. It corresponds to the shell's pwd command. The returned path is always absolute." },
              { "type": "alternative", "label": "filepath.WalkDir", "text": "For recursive directory traversal, use filepath.WalkDir instead of os.ReadDir. It handles nested directories and provides the path to each entry." }
            ]
          }
        ]
      }
    ],
    "challenges": [
      {
        "id": "challenge_1",
        "block": 1,
        "difficulty": 3,
        "concept": "Process List",
        "variants": [
          {
            "id": "v1",
            "title": "High CPU Processes",
            "description": "Write a program that runs <code>ps aux</code>, parses the output, and prints the PID and command name for any process using more than 1% CPU. Use <code>strings.Fields</code> to split columns and <code>strconv.ParseFloat</code> for CPU%.",
            "functionSignature": "func main()",
            "testCases": [
              { "input": "ps aux output with chrome at 5.2% CPU", "output": "PID: 1234  CPU: 5.2%  CMD: chrome" },
              { "input": "ps aux output with no high-CPU process", "output": "(no output)" }
            ],
            "hints": [
              { "title": "\ud83e\udd14 Think about it", "content": "What does each column in ps aux output represent? Which column index is CPU%, PID, and command?" },
              { "title": "\ud83d\udca1 Hint", "content": "Fields: [0]=USER, [1]=PID, [2]=%CPU, [3]=%MEM, ... [10]=COMMAND. Skip the header line (first line). Parse field[2] as float64." },
              { "title": "\ud83d\udd27 Pattern", "content": "<pre>1. exec.Command(\"ps\", \"aux\").Output()\n2. Split by newline, skip header\n3. For each line: strings.Fields, parse CPU% at index 2\n4. If > 1.0: print PID and CMD</pre>" }
            ],
            "solution": "func main() {\n    out, err := exec.Command(\"ps\", \"aux\").Output()\n    if err != nil {\n        fmt.Fprintln(os.Stderr, err)\n        os.Exit(1)\n    }\n    lines := strings.Split(string(out), \"\\n\")\n\n    for _, line := range lines[1:] {\n        fields := strings.Fields(line)\n        if len(fields) < 11 {\n            continue\n        }\n        cpu, err := strconv.ParseFloat(fields[2], 64)\n        if err != nil {\n            continue\n        }\n        if cpu > 1.0 {\n            fmt.Printf(\"PID: %s  CPU: %.1f%%  CMD: %s\\n\",\n                fields[1], cpu, fields[10])\n        }\n    }\n}",
            "difficulty": 3,
            "annotations": [
              { "type": "stdlib", "label": "exec.Command", "text": "exec.Command creates a command to run. Output() runs it and returns combined stdout. For stderr too, use CombinedOutput()." },
              { "type": "gotcha", "label": "Field Parsing", "text": "strings.Fields handles multiple spaces between columns, unlike strings.Split(line, \" \") which would create empty entries. Always use Fields for columnar output." }
            ]
          },
          {
            "id": "v2",
            "title": "Memory Hogs",
            "description": "Write a program that runs <code>ps aux</code>, parses output, and prints the top 5 processes by memory usage (%MEM column). Sort them in descending order and display PID, %MEM, and command.",
            "functionSignature": "func main()",
            "testCases": [
              { "input": "ps aux output with various processes", "output": "Top 5 processes by memory, sorted descending" },
              { "input": "Fewer than 5 processes", "output": "All processes sorted by memory" }
            ],
            "hints": [
              { "title": "\ud83e\udd14 Think about it", "content": "How do you sort processes by a parsed numeric field? What data structure can hold the parsed data for sorting?" },
              { "title": "\ud83d\udca1 Hint", "content": "Parse into a struct slice: {pid string, mem float64, cmd string}. Use sort.Slice with a custom less function. Take the first 5 (or fewer)." },
              { "title": "\ud83d\udd27 Pattern", "content": "<pre>1. Parse ps aux into []ProcessInfo structs\n2. sort.Slice by mem descending\n3. Print top min(5, len) entries</pre>" }
            ],
            "solution": "type ProcessInfo struct {\n    pid string\n    mem float64\n    cmd string\n}\n\nfunc main() {\n    out, err := exec.Command(\"ps\", \"aux\").Output()\n    if err != nil {\n        fmt.Fprintln(os.Stderr, err)\n        os.Exit(1)\n    }\n\n    var procs []ProcessInfo\n    lines := strings.Split(string(out), \"\\n\")\n    for _, line := range lines[1:] {\n        fields := strings.Fields(line)\n        if len(fields) < 11 {\n            continue\n        }\n        mem, err := strconv.ParseFloat(fields[3], 64)\n        if err != nil {\n            continue\n        }\n        procs = append(procs, ProcessInfo{\n            pid: fields[1], mem: mem, cmd: fields[10],\n        })\n    }\n\n    sort.Slice(procs, func(i, j int) bool {\n        return procs[i].mem > procs[j].mem\n    })\n\n    limit := 5\n    if len(procs) < limit {\n        limit = len(procs)\n    }\n    for _, p := range procs[:limit] {\n        fmt.Printf(\"PID: %s  MEM: %.1f%%  CMD: %s\\n\", p.pid, p.mem, p.cmd)\n    }\n}",
            "difficulty": 3,
            "annotations": [
              { "type": "stdlib", "label": "sort.Slice", "text": "sort.Slice sorts a slice using a custom less function. It modifies the slice in place. For stable sorting (preserving equal-element order), use sort.SliceStable." },
              { "type": "complexity", "label": "O(n log n)", "text": "Parsing is O(n), sorting is O(n log n). For top-K problems, a heap (container/heap) would be O(n log k) but sort.Slice is simpler for small k." }
            ]
          },
          {
            "id": "v3",
            "title": "Process Tree",
            "description": "Write a program that runs <code>ps -eo pid,ppid,comm</code> and builds a parent-child tree. Print processes in a tree format with indentation showing the hierarchy. Start from PID 1 (init/systemd).",
            "functionSignature": "func main()",
            "testCases": [
              { "input": "ps output with systemd -> sshd -> bash", "output": "1 systemd\\n  123 sshd\\n    456 bash" },
              { "input": "ps output with multiple children", "output": "indented tree showing parent-child relationships" }
            ],
            "hints": [
              { "title": "\ud83e\udd14 Think about it", "content": "What data structure represents a tree? How do you map parent PIDs to their children?" },
              { "title": "\ud83d\udca1 Hint", "content": "Use map[string][]string to map PPID to list of child PIDs. Use another map for PID to command name. Recursively print from PID 1 with increasing indent." },
              { "title": "\ud83d\udd27 Pattern", "content": "<pre>1. Parse ps -eo pid,ppid,comm\n2. Build children map: ppid -> []pid\n3. Build names map: pid -> comm\n4. Recursive print: printTree(pid, indent)\n5. Start from PID \"1\"</pre>" }
            ],
            "solution": "func main() {\n    out, err := exec.Command(\"ps\", \"-eo\", \"pid,ppid,comm\").Output()\n    if err != nil {\n        fmt.Fprintln(os.Stderr, err)\n        os.Exit(1)\n    }\n\n    children := make(map[string][]string)\n    names := make(map[string]string)\n\n    lines := strings.Split(string(out), \"\\n\")\n    for _, line := range lines[1:] {\n        fields := strings.Fields(line)\n        if len(fields) < 3 {\n            continue\n        }\n        pid, ppid, comm := fields[0], fields[1], fields[2]\n        names[pid] = comm\n        children[ppid] = append(children[ppid], pid)\n    }\n\n    var printTree func(pid string, indent int)\n    printTree = func(pid string, indent int) {\n        fmt.Printf(\"%s%s %s\\n\", strings.Repeat(\"  \", indent), pid, names[pid])\n        for _, child := range children[pid] {\n            printTree(child, indent+1)\n        }\n    }\n    printTree(\"1\", 0)\n}",
            "difficulty": 3,
            "annotations": [
              { "type": "pattern", "label": "Tree Building", "text": "Building a tree from flat parent-child data is a common pattern. Use a map from parent to children list, then traverse recursively from the root." },
              { "type": "idiom", "label": "Recursive Closure", "text": "Declaring a function variable before the closure allows recursion: var f func(); f = func() { f() }. This is how Go handles anonymous recursive functions." }
            ]
          },
          {
            "id": "v4",
            "title": "Process Monitor",
            "description": "Write a program that monitors a specific process name. Run <code>ps aux</code> every 2 seconds, find the process, and print its CPU and memory usage. Stop after 5 iterations or if the process disappears.",
            "functionSignature": "func main()",
            "testCases": [
              { "input": "Monitor 'bash' for 5 iterations", "output": "5 lines showing CPU/MEM for bash" },
              { "input": "Monitor 'nonexistent'", "output": "'Process not found' and exit" }
            ],
            "hints": [
              { "title": "\ud83e\udd14 Think about it", "content": "How do you repeatedly check for a process? How do you match the process name in ps output?" },
              { "title": "\ud83d\udca1 Hint", "content": "Use a for loop with time.Sleep(2 * time.Second). In each iteration, run ps aux, scan for the process name in the command column. Print CPU/MEM or break if not found." },
              { "title": "\ud83d\udd27 Pattern", "content": "<pre>1. Get process name from os.Args[1]\n2. Loop 5 times with 2s sleep\n3. Run ps aux, parse lines\n4. Find matching command, print stats\n5. If not found, print message and break</pre>" }
            ],
            "solution": "func main() {\n    if len(os.Args) < 2 {\n        fmt.Fprintln(os.Stderr, \"usage: monitor <process-name>\")\n        os.Exit(1)\n    }\n    target := os.Args[1]\n\n    for i := 0; i < 5; i++ {\n        out, err := exec.Command(\"ps\", \"aux\").Output()\n        if err != nil {\n            fmt.Fprintln(os.Stderr, err)\n            os.Exit(1)\n        }\n\n        found := false\n        lines := strings.Split(string(out), \"\\n\")\n        for _, line := range lines[1:] {\n            fields := strings.Fields(line)\n            if len(fields) < 11 {\n                continue\n            }\n            if strings.Contains(fields[10], target) {\n                cpu, _ := strconv.ParseFloat(fields[2], 64)\n                mem, _ := strconv.ParseFloat(fields[3], 64)\n                fmt.Printf(\"[%d] %s - CPU: %.1f%% MEM: %.1f%%\\n\",\n                    i+1, target, cpu, mem)\n                found = true\n                break\n            }\n        }\n\n        if !found {\n            fmt.Printf(\"Process '%s' not found\\n\", target)\n            break\n        }\n        if i < 4 {\n            time.Sleep(2 * time.Second)\n        }\n    }\n}",
            "difficulty": 3,
            "annotations": [
              { "type": "alternative", "label": "Ticker-Based", "text": "For production monitoring, use time.NewTicker instead of time.Sleep. Tickers account for execution time, keeping intervals more consistent." },
              { "type": "gotcha", "label": "Self-Matching", "text": "Be aware that the ps command itself or the monitor program may appear in ps output. Real tools use PID files or more specific matching to avoid false positives." }
            ]
          }
        ]
      },
      {
        "id": "challenge_2",
        "block": 2,
        "difficulty": 3,
        "concept": "Git Status Parser",
        "variants": [
          {
            "id": "v1",
            "title": "Git Status Counter",
            "description": "Write a program that runs <code>git status --porcelain</code> and prints counts of modified, added, and deleted files. Handle the porcelain format where the first two characters indicate status: <code>M</code>=modified, <code>A</code> or <code>??</code>=added/new, <code>D</code>=deleted.",
            "functionSignature": "func main()",
            "testCases": [
              { "input": "git repo with 2 modified, 1 new, 1 deleted", "output": "Modified: 2, Added: 1, Deleted: 1" },
              { "input": "clean git repo", "output": "Modified: 0, Added: 0, Deleted: 0" },
              { "input": "not a git repo", "output": "Not a git repo" }
            ],
            "hints": [
              { "title": "\ud83e\udd14 Think about it", "content": "What does each two-character status code mean in porcelain format? How do you distinguish staged vs unstaged changes?" },
              { "title": "\ud83d\udca1 Hint", "content": "Porcelain first two chars: 'M ' or ' M' or 'MM' = modified, 'A ' or '??' = added, 'D ' or ' D' = deleted. Check with line[0:2] switch." },
              { "title": "\ud83d\udd27 Pattern", "content": "<pre>1. Run git status --porcelain\n2. Check error (not a git repo)\n3. Split output by newline\n4. For each line: switch on first 2 chars\n5. Increment counters, print results</pre>" }
            ],
            "solution": "func main() {\n    out, err := exec.Command(\"git\", \"status\", \"--porcelain\").Output()\n    if err != nil {\n        fmt.Println(\"Not a git repo\")\n        return\n    }\n\n    var modified, added, deleted int\n    for _, line := range strings.Split(string(out), \"\\n\") {\n        if len(line) < 2 {\n            continue\n        }\n        switch line[0:2] {\n        case \" M\", \"M \", \"MM\":\n            modified++\n        case \"A \", \"??\":\n            added++\n        case \" D\", \"D \":\n            deleted++\n        }\n    }\n    fmt.Printf(\"Modified: %d, Added: %d, Deleted: %d\\n\",\n        modified, added, deleted)\n}",
            "difficulty": 3,
            "annotations": [
              { "type": "stdlib", "label": "exec.Command", "text": "git status --porcelain gives machine-readable output that is stable across Git versions. Always use --porcelain for scripting, never the default human-readable format." },
              { "type": "gotcha", "label": "Two-Character Status", "text": "The porcelain format uses TWO characters: index status and working tree status. 'M ' means staged modification, ' M' means unstaged. Both are valid modifications." }
            ]
          },
          {
            "id": "v2",
            "title": "Git Branch Info",
            "description": "Write a program that parses <code>git status --porcelain -b</code> to extract the current branch name and ahead/behind counts. Also list all changed files grouped by status.",
            "functionSignature": "func main()",
            "testCases": [
              { "input": "On branch main, 2 ahead, 1 modified file", "output": "Branch: main (ahead 2)\\nModified: file.go" },
              { "input": "On branch feature, clean", "output": "Branch: feature\\nNo changes" }
            ],
            "hints": [
              { "title": "\ud83e\udd14 Think about it", "content": "What does the -b flag add to porcelain output? What does the branch line look like?" },
              { "title": "\ud83d\udca1 Hint", "content": "With -b, the first line is: ## branch...origin/branch [ahead N, behind M]. Parse this line separately. Remaining lines are status lines." },
              { "title": "\ud83d\udd27 Pattern", "content": "<pre>1. Run git status --porcelain -b\n2. First line: parse branch and ahead/behind\n3. Remaining lines: parse status codes\n4. Group files by status\n5. Print branch info and file groups</pre>" }
            ],
            "solution": "func main() {\n    out, err := exec.Command(\"git\", \"status\", \"--porcelain\", \"-b\").Output()\n    if err != nil {\n        fmt.Println(\"Not a git repo\")\n        return\n    }\n\n    lines := strings.Split(strings.TrimSpace(string(out)), \"\\n\")\n    if len(lines) == 0 {\n        return\n    }\n\n    // Parse branch line: ## main...origin/main [ahead 2]\n    branchLine := lines[0][3:] // skip \"## \"\n    branch := branchLine\n    if idx := strings.Index(branchLine, \"...\"); idx != -1 {\n        branch = branchLine[:idx]\n    }\n    info := branch\n    if idx := strings.Index(branchLine, \"[\"); idx != -1 {\n        end := strings.Index(branchLine, \"]\")\n        info += \" (\" + branchLine[idx+1:end] + \")\"\n    }\n    fmt.Println(\"Branch:\", info)\n\n    modified := []string{}\n    added := []string{}\n    deleted := []string{}\n    for _, line := range lines[1:] {\n        if len(line) < 3 {\n            continue\n        }\n        file := strings.TrimSpace(line[3:])\n        switch line[0:2] {\n        case \" M\", \"M \", \"MM\":\n            modified = append(modified, file)\n        case \"A \", \"??\":\n            added = append(added, file)\n        case \" D\", \"D \":\n            deleted = append(deleted, file)\n        }\n    }\n\n    if len(modified)+len(added)+len(deleted) == 0 {\n        fmt.Println(\"No changes\")\n        return\n    }\n    for _, f := range modified { fmt.Println(\"Modified:\", f) }\n    for _, f := range added { fmt.Println(\"Added:\", f) }\n    for _, f := range deleted { fmt.Println(\"Deleted:\", f) }\n}",
            "difficulty": 3,
            "annotations": [
              { "type": "gotcha", "label": "Branch Line Format", "text": "The -b branch line format varies: '## main' (no remote), '## main...origin/main' (with remote), '## main...origin/main [ahead 1]' (with tracking info)." },
              { "type": "idiom", "label": "String Slicing", "text": "Go strings can be sliced like line[0:2] or line[3:]. This is efficient as it shares the underlying bytes. Be careful with Unicode; use []rune for multi-byte characters." }
            ]
          },
          {
            "id": "v3",
            "title": "Git Diff Stats",
            "description": "Write a program that runs <code>git diff --stat</code> and parses the output to extract file names and the number of insertions/deletions for each. Print a summary showing total files changed, insertions, and deletions.",
            "functionSignature": "func main()",
            "testCases": [
              { "input": "git diff --stat with 3 files, +20 -5", "output": "3 files changed, 20 insertions, 5 deletions" },
              { "input": "no changes", "output": "No changes" }
            ],
            "hints": [
              { "title": "\ud83e\udd14 Think about it", "content": "What does git diff --stat output look like? Where are the numbers for insertions and deletions?" },
              { "title": "\ud83d\udca1 Hint", "content": "The last line of --stat is a summary like: '3 files changed, 20 insertions(+), 5 deletions(-)'. Parse this line, or parse each file line which shows ' file | N +++---'." },
              { "title": "\ud83d\udd27 Pattern", "content": "<pre>1. Run git diff --stat\n2. Parse the summary line (last non-empty line)\n3. Extract numbers using string parsing or regexp\n4. Print formatted summary</pre>" }
            ],
            "solution": "func main() {\n    out, err := exec.Command(\"git\", \"diff\", \"--stat\").Output()\n    if err != nil {\n        fmt.Fprintln(os.Stderr, err)\n        os.Exit(1)\n    }\n\n    output := strings.TrimSpace(string(out))\n    if output == \"\" {\n        fmt.Println(\"No changes\")\n        return\n    }\n\n    lines := strings.Split(output, \"\\n\")\n    // Parse individual file lines\n    for _, line := range lines[:len(lines)-1] {\n        parts := strings.Split(line, \"|\")\n        if len(parts) == 2 {\n            file := strings.TrimSpace(parts[0])\n            changes := strings.TrimSpace(parts[1])\n            fmt.Printf(\"  %s: %s\\n\", file, changes)\n        }\n    }\n\n    // Print summary line as-is\n    summary := lines[len(lines)-1]\n    fmt.Println(strings.TrimSpace(summary))\n}",
            "difficulty": 3,
            "annotations": [
              { "type": "stdlib", "label": "git diff --stat", "text": "git diff --stat produces a human-readable summary of changes. For machine-readable output, use --numstat which gives tab-separated insertions/deletions/filename." },
              { "type": "alternative", "label": "Use --numstat", "text": "git diff --numstat outputs 'insertions\\tdeletions\\tfile' per line, which is easier to parse programmatically than --stat's visual bars." }
            ]
          },
          {
            "id": "v4",
            "title": "Git Log Parser",
            "description": "Write a program that runs <code>git log --oneline -10</code> and parses each line into a commit hash and message. Group commits by the first word of the message (e.g., \"fix\", \"add\", \"update\") and print the grouped results.",
            "functionSignature": "func main()",
            "testCases": [
              { "input": "git log with 'fix: bug', 'add: feature', 'fix: typo'", "output": "fix (2):\\n  abc1234 fix: bug\\n  def5678 fix: typo\\nadd (1):\\n  ghi9012 add: feature" },
              { "input": "empty repo", "output": "No commits" }
            ],
            "hints": [
              { "title": "\ud83e\udd14 Think about it", "content": "How do you extract the first word from a commit message? What data structure groups items by a key?" },
              { "title": "\ud83d\udca1 Hint", "content": "Each oneline line is: 'hash message'. Split to get hash and message. Use strings.Fields(message)[0] for the first word. Group with map[string][]string." },
              { "title": "\ud83d\udd27 Pattern", "content": "<pre>1. Run git log --oneline -10\n2. For each line: split into hash and message\n3. Extract first word of message (lowercase)\n4. Group in map[string][]string\n5. Print groups with counts</pre>" }
            ],
            "solution": "func main() {\n    out, err := exec.Command(\"git\", \"log\", \"--oneline\", \"-10\").Output()\n    if err != nil {\n        fmt.Println(\"Not a git repo or no commits\")\n        return\n    }\n\n    output := strings.TrimSpace(string(out))\n    if output == \"\" {\n        fmt.Println(\"No commits\")\n        return\n    }\n\n    groups := make(map[string][]string)\n    var order []string\n\n    for _, line := range strings.Split(output, \"\\n\") {\n        parts := strings.SplitN(line, \" \", 2)\n        if len(parts) < 2 {\n            continue\n        }\n        hash := parts[0]\n        message := parts[1]\n        keyword := strings.ToLower(strings.Fields(message)[0])\n        // Remove trailing colon if present\n        keyword = strings.TrimRight(keyword, \":\")\n\n        if _, exists := groups[keyword]; !exists {\n            order = append(order, keyword)\n        }\n        groups[keyword] = append(groups[keyword], hash+\" \"+message)\n    }\n\n    for _, key := range order {\n        commits := groups[key]\n        fmt.Printf(\"%s (%d):\\n\", key, len(commits))\n        for _, c := range commits {\n            fmt.Printf(\"  %s\\n\", c)\n        }\n    }\n}",
            "difficulty": 3,
            "annotations": [
              { "type": "idiom", "label": "Insertion Order Map", "text": "Go maps do not preserve insertion order. To print groups in the order they were first seen, maintain a separate slice of keys." },
              { "type": "stdlib", "label": "strings.SplitN", "text": "strings.SplitN(s, sep, n) splits into at most n parts. SplitN(line, \" \", 2) splits on the first space only, keeping the rest of the message intact." }
            ]
          }
        ]
      }
    ]
  }
}