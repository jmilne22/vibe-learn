conceptLinks:
  Multiple Files: "#lesson-multiple-files"
  Packages: "#lesson-packages"
  Exported/Unexported: "#lesson-exported"
  internal/ Directory: "#lesson-internal"
  Project Layout: "#lesson-layout"
  Circular Imports: "#lesson-circular"
sharedContent: {}
variants:
  warmups:
    - id: warmup_1
      concept: Multiple Files
      variants:
        - id: v1
          title: Split Code Across Files
          description: >-
            You have a program with a <code>Config</code> struct and a <code>Process</code> function. Show how to split
            them into <code>config.go</code> and <code>process.go</code> in the same package. Write the code for both
            files.
          hints:
            - Both files must have <code>package main</code> at the top.
            - No imports are needed between files in the same package.
            - <code>config.go</code> defines the struct, <code>process.go</code> uses it directly.
          solution: |-
            // config.go
            package main

            type Config struct {
                Name string
                Port int
            }

            func LoadConfig() *Config {
                return &Config{Name: "app", Port: 8080}
            }

            // process.go
            package main

            import "fmt"

            func Process(cfg *Config) {
                fmt.Printf("Processing %s on port %d\n", cfg.Name, cfg.Port)
            }
          annotations:
            - type: idiom
              label: Same Package
              text: >-
                Files in the same directory with the same <code>package</code> declaration share everything
                automatically. No imports needed.
            - type: gotcha
              label: go run .
              text: >-
                Use <code>go run .</code> to compile all files in the directory. <code>go run main.go</code> alone won't
                include other files.
        - id: v2
          title: When to Split Files
          description: >-
            You have a <code>main.go</code> file with 400 lines containing a <code>Server</code> struct, an
            <code>App</code> struct, and their methods. Describe how you'd split this and write the package declaration
            for each file.
          hints:
            - "Split by type: <code>server.go</code> for Server, <code>app.go</code> for App."
            - Keep <code>main()</code> in <code>main.go</code> — it's the entry point.
            - All files use <code>package main</code>.
          solution: |-
            // main.go — entry point only
            package main

            func main() {
                app := NewApp()
                srv := NewServer(app)
                srv.Start()
            }

            // app.go — App type and its methods
            package main

            type App struct { /* fields */ }
            func NewApp() *App { return &App{} }

            // server.go — Server type and its methods
            package main

            type Server struct { app *App }
            func NewServer(app *App) *Server { return &Server{app: app} }
            func (s *Server) Start() { /* ... */ }
          annotations:
            - type: idiom
              label: One Type Per File
              text: >-
                A common Go convention: one major type and its methods per file, named after the type
                (<code>server.go</code>, <code>app.go</code>).
            - type: pattern
              label: Thin main()
              text: >-
                Keep <code>main()</code> thin — just create objects and wire them together. Business logic belongs in
                other files.
        - id: v3
          title: Run Multi-File Program
          description: >-
            You have <code>main.go</code>, <code>config.go</code>, and <code>helpers.go</code> in the same directory,
            all with <code>package main</code>. Write the command to compile and run all of them.
          hints:
            - <code>go run .</code> compiles all <code>.go</code> files in the current directory.
            - "Alternatively: <code>go run main.go config.go helpers.go</code>."
            - <code>go build .</code> to compile into a binary.
          solution: |-
            // Run all files in current directory:
            // $ go run .

            // Or explicitly list files:
            // $ go run main.go config.go helpers.go

            // Build a binary:
            // $ go build -o myapp .
            // $ ./myapp
          annotations:
            - type: idiom
              label: go run .
              text: >-
                The dot <code>.</code> tells Go to compile all Go files in the current directory. This is the standard
                way to run multi-file programs.
            - type: gotcha
              label: go run main.go
              text: >-
                Running just <code>go run main.go</code> won't include other files. You'll get "undefined" errors for
                types and functions in other files.
    - id: warmup_2
      concept: Packages
      variants:
        - id: v1
          title: Create a Package
          description: >-
            Create a <code>utils</code> package in a <code>utils/</code> directory with a function <code>Greet(name
            string) string</code>. Import and use it from <code>main.go</code>.
          hints:
            - File <code>utils/utils.go</code> with <code>package utils</code>.
            - "Function must be uppercase to be exported: <code>func Greet</code>."
            - "Import with the module path: <code>import \"myproject/utils\"</code>."
          solution: |-
            // utils/utils.go
            package utils

            import "fmt"

            func Greet(name string) string {
                return fmt.Sprintf("Hello, %s!", name)
            }

            // main.go
            package main

            import (
                "fmt"
                "myproject/utils"
            )

            func main() {
                msg := utils.Greet("Alice")
                fmt.Println(msg)
            }
          annotations:
            - type: idiom
              label: Package = Directory
              text: >-
                In Go, each directory is one package. The package name is declared in the source file, not the directory
                name (though they usually match).
            - type: idiom
              label: Import Path
              text: >-
                The import path is your module name (from <code>go.mod</code>) plus the directory path. Not the file
                path.
        - id: v2
          title: Package with Multiple Functions
          description: >-
            Create a <code>math</code> package with two files: <code>add.go</code> with <code>Add(a, b int) int</code>
            and <code>multiply.go</code> with <code>Multiply(a, b int) int</code>. Show the directory structure.
          hints:
            - Both files use <code>package math</code>.
            - Both functions are uppercase (exported).
            - "From main: <code>math.Add(1, 2)</code> and <code>math.Multiply(3, 4)</code>."
          solution: |-
            // Directory structure:
            // myproject/
            // ├── go.mod
            // ├── main.go
            // └── math/
            //     ├── add.go
            //     └── multiply.go

            // math/add.go
            package math

            func Add(a, b int) int {
                return a + b
            }

            // math/multiply.go
            package math

            func Multiply(a, b int) int {
                return a * b
            }

            // main.go
            package main

            import (
                "fmt"
                "myproject/math"
            )

            func main() {
                fmt.Println(math.Add(1, 2))
                fmt.Println(math.Multiply(3, 4))
            }
          annotations:
            - type: idiom
              label: Multi-File Package
              text: A package can span multiple files. The compiler merges all files in the same directory into one package.
        - id: v3
          title: Nested Packages
          description: >-
            Show the import path for a file at <code>internal/database/postgres.go</code> in a module named
            <code>github.com/you/myapp</code>.
          hints:
            - The import path follows the directory structure from the module root.
            - "Module name + directory: <code>github.com/you/myapp/internal/database</code>."
            - The package declaration in the file would be <code>package database</code>.
          solution: |-
            // internal/database/postgres.go
            package database

            type DB struct { /* ... */ }

            func Connect(dsn string) (*DB, error) {
                // ...
                return &DB{}, nil
            }

            // Import from within the module:
            import "github.com/you/myapp/internal/database"

            db, err := database.Connect("postgres://...")
          annotations:
            - type: idiom
              label: Import = Module + Dir
              text: >-
                Import paths are always the module name from <code>go.mod</code> concatenated with the directory path
                from the module root.
            - type: gotcha
              label: Package vs Directory Name
              text: >-
                The package name and directory name don't have to match, but by convention they should. The package
                declaration in the file is what matters for code references.
    - id: warmup_3
      concept: Exported/Unexported
      variants:
        - id: v1
          title: Identify Exported Names
          description: >-
            Given a package with <code>Config</code>, <code>loadDefaults</code>, <code>Port</code>, and
            <code>httpClient</code>, identify which are exported (visible outside the package) and which are unexported.
          hints:
            - Uppercase first letter = exported.
            - Lowercase first letter = unexported.
            - This applies to types, functions, variables, and constants.
          solution: |-
            package server

            // Exported — visible from other packages
            type Config struct{}     // ✓ Uppercase C
            var Port = 8080          // ✓ Uppercase P

            // Unexported — only visible within this package
            func loadDefaults() {}   // ✗ Lowercase l
            var httpClient = &http.Client{} // ✗ Lowercase h
          annotations:
            - type: idiom
              label: Visibility Rule
              text: >-
                Go's visibility is the simplest of any language: uppercase = public, lowercase = private. No keywords
                needed.
            - type: gotcha
              label: Struct Fields Too
              text: >-
                The uppercase/lowercase rule applies to struct fields as well. Lowercase fields won't be visible in JSON
                encoding or from other packages.
        - id: v2
          title: Exported Struct with Unexported Fields
          description: >-
            Create an exported <code>User</code> struct where <code>Name</code> is exported but <code>password</code> is
            unexported. Write a constructor <code>NewUser</code> that sets both fields.
          hints:
            - "Exported type: <code>type User struct</code> (uppercase U)."
            - "Unexported field: <code>password string</code> (lowercase p)."
            - The constructor can set unexported fields because it's in the same package.
          solution: |-
            package auth

            type User struct {
                Name     string  // Exported — other packages can read this
                password string  // Unexported — only this package can access
            }

            func NewUser(name, password string) *User {
                return &User{
                    Name:     name,
                    password: password,
                }
            }

            func (u *User) CheckPassword(attempt string) bool {
                return u.password == attempt
            }
          annotations:
            - type: pattern
              label: Encapsulation
              text: >-
                Unexported fields + exported methods is Go's encapsulation pattern. External code can't access
                <code>password</code> directly but can use <code>CheckPassword()</code>.
            - type: idiom
              label: Constructor Required
              text: >-
                If a struct has unexported fields, external code can't initialize them. A constructor like
                <code>NewUser()</code> is the only way to create a complete instance.
        - id: v3
          title: Unexported Interface Implementation
          description: >-
            Create an unexported <code>storage</code> interface with a <code>Save(data []byte) error</code> method.
            Create an exported <code>NewFileStorage</code> function that returns the interface.
          hints:
            - "Lowercase interface name: <code>type storage interface</code>."
            - "The implementation struct can also be unexported: <code>type fileStorage struct</code>."
            - The constructor returns the interface type, hiding the implementation.
          solution: |-
            package store

            // Unexported interface — implementation detail
            type storage interface {
                Save(data []byte) error
            }

            // Unexported implementation
            type fileStorage struct {
                path string
            }

            func (f *fileStorage) Save(data []byte) error {
                return os.WriteFile(f.path, data, 0644)
            }

            // Exported constructor — returns the unexported interface
            func NewFileStorage(path string) storage {
                return &fileStorage{path: path}
            }
          annotations:
            - type: pattern
              label: Hidden Implementation
              text: >-
                Returning an unexported interface from an exported constructor hides the implementation completely.
                Callers only see the interface methods.
            - type: gotcha
              label: Unexported Return Type
              text: >-
                Go allows exported functions to return unexported types. The caller can use the value but can't name the
                type in their own code.
    - id: warmup_4
      concept: internal/ Directory
      variants:
        - id: v1
          title: internal/ Access Rules
          description: >-
            Given a module <code>github.com/you/myapp</code> with an <code>internal/auth</code> package, which of these
            can import it: <code>main.go</code> (root), <code>cmd/server/main.go</code>, and an external package that
            depends on your module?
          hints:
            - <code>internal/</code> is accessible to the parent directory tree.
            - Both <code>main.go</code> and <code>cmd/server/main.go</code> are within the module.
            - External packages CANNOT import anything under <code>internal/</code>.
          solution: |-
            // Directory structure:
            // github.com/you/myapp/
            // ├── main.go                  ✓ Can import internal/auth
            // ├── cmd/server/main.go       ✓ Can import internal/auth
            // └── internal/auth/auth.go    Package being imported

            // External module:
            // github.com/other/project/
            // └── main.go                  ✗ CANNOT import internal/auth
            //                              Compiler error: use of internal package not allowed
          annotations:
            - type: idiom
              label: internal/ Convention
              text: >-
                <code>internal/</code> is the only magic directory name in Go. The compiler enforces that only code in
                the parent tree can import from it.
            - type: pattern
              label: API Boundary
              text: >-
                Use <code>internal/</code> for implementation details you want to refactor freely. Your public API stays
                stable while internals can change.
        - id: v2
          title: Move Code to internal/
          description: >-
            You have a <code>database</code> package that external users shouldn't depend on. Show the directory
            structure before and after moving it to <code>internal/</code>, and update the import path.
          hints:
            - "Before: <code>database/db.go</code> → import <code>myapp/database</code>."
            - "After: <code>internal/database/db.go</code> → import <code>myapp/internal/database</code>."
            - The package declaration stays <code>package database</code>.
          solution: |-
            // BEFORE:
            // myapp/
            // ├── database/
            // │   └── db.go          package database
            // └── main.go            import "myapp/database"

            // AFTER:
            // myapp/
            // ├── internal/
            // │   └── database/
            // │       └── db.go      package database (unchanged)
            // └── main.go            import "myapp/internal/database"

            // The only change in code is the import path:
            import "myapp/internal/database"  // was: "myapp/database"
          annotations:
            - type: idiom
              label: Refactoring to internal/
              text: >-
                Moving packages to <code>internal/</code> only changes import paths. The package declaration and code
                remain the same.
        - id: v3
          title: Nested internal/ Directories
          description: >-
            In a module with <code>pkg/server/internal/handler</code>, who can import the <code>handler</code> package?
            Can <code>pkg/server/server.go</code>? Can <code>main.go</code> at the root?
          hints:
            - <code>internal/</code> restricts access to its parent directory tree.
            - The parent of <code>pkg/server/internal/</code> is <code>pkg/server/</code>.
            - Code above <code>pkg/server/</code> cannot access it.
          solution: |-
            // Directory structure:
            // myapp/
            // ├── main.go                          ✗ Cannot import handler
            // ├── pkg/
            // │   ├── client/client.go             ✗ Cannot import handler
            // │   └── server/
            // │       ├── server.go                ✓ CAN import handler
            // │       └── internal/
            // │           └── handler/handler.go   The restricted package

            // pkg/server/server.go:
            import "myapp/pkg/server/internal/handler"  // ✓ Works

            // main.go:
            import "myapp/pkg/server/internal/handler"  // ✗ Compiler error
          annotations:
            - type: idiom
              label: Scoped internal/
              text: >-
                <code>internal/</code> scopes to its parent. You can have multiple <code>internal/</code> directories at
                different levels, each with different access scopes.
  challenges:
    - id: challenge_1
      concept: Project Layout
      docLinks:
        - url: https://go.dev/doc/modules/layout
          title: "Go Docs: Module layout"
          note: organizing Go modules
        - url: https://pkg.go.dev/cmd/go#hdr-Internal_Directories
          title: "Go Command: internal directories"
          note: access control via internal/
      variants:
        - id: v1
          title: Design CLI Tool Layout
          description: >-
            Design the directory structure for a CLI tool called <code>taskctl</code> that has: a main entry point,
            command handlers (list, add, delete), a config loader, and a task storage layer. Show the files and their
            package declarations.
          hints:
            - Use <code>cmd/</code> for command definitions or keep it flat for small CLIs.
            - Put storage in <code>internal/</code> to hide the implementation.
            - Config can be in the main package for simple tools.
          solution: |-
            // taskctl/
            // ├── go.mod              module github.com/you/taskctl
            // ├── main.go             package main — entry point, wires everything
            // ├── commands.go         package main — list, add, delete handlers
            // ├── config.go           package main — config loading
            // └── internal/
            //     └── store/
            //         └── store.go    package store — task persistence

            // main.go
            package main

            func main() {
                cfg := LoadConfig()
                store := store.New(cfg.DBPath)
                runCLI(store)
            }

            // internal/store/store.go
            package store

            type Store struct { path string }
            func New(path string) *Store { return &Store{path: path} }
            func (s *Store) List() ([]Task, error) { /* ... */ }
          annotations:
            - type: pattern
              label: Flat Main Package
              text: >-
                Small CLI tools can keep everything in <code>package main</code> with multiple files. Only extract
                packages when complexity grows.
            - type: idiom
              label: internal/ for Storage
              text: >-
                Storage implementations are internal details. Users of your tool don't need to import your database
                layer.
        - id: v2
          title: Design Library Layout
          description: >-
            Design the directory structure for a reusable Go library called <code>httputil</code> that provides: public
            middleware functions, a public client wrapper, and internal rate limiting logic.
          hints:
            - "The root package is the public API: <code>package httputil</code>."
            - Rate limiting goes in <code>internal/</code>.
            - Middleware and client can be in the root or separate public packages.
          solution: |-
            // httputil/
            // ├── go.mod             module github.com/you/httputil
            // ├── client.go          package httputil — public client wrapper
            // ├── middleware.go       package httputil — public middleware
            // └── internal/
            //     └── ratelimit/
            //         └── limiter.go  package ratelimit — hidden implementation

            // client.go
            package httputil

            import "github.com/you/httputil/internal/ratelimit"

            type Client struct {
                limiter *ratelimit.Limiter
            }

            // middleware.go
            package httputil

            func LoggingMiddleware(next http.Handler) http.Handler { /* ... */ }
            func AuthMiddleware(next http.Handler) http.Handler { /* ... */ }
          annotations:
            - type: pattern
              label: Library Root = API
              text: >-
                For libraries, the root package IS the public API. Users import just <code>httputil</code> and access
                all public functions.
            - type: idiom
              label: Hide Complexity
              text: >-
                Internal packages keep implementation details private. The rate limiter can change freely without
                breaking library users.
        - id: v3
          title: Resolve Circular Import
          description: >-
            Package <code>user</code> imports <code>order</code> to get user's orders, and package <code>order</code>
            imports <code>user</code> to get order's owner. This causes a circular import. Design a solution.
          hints:
            - "Option 1: Extract shared types into a third package (e.g., <code>models</code>)."
            - "Option 2: Use an interface to break the dependency."
            - "Option 3: Merge the packages if they're tightly coupled."
          solution: |-
            // PROBLEM: user ↔ order circular import

            // SOLUTION: Extract shared types into a models package

            // models/models.go
            package models

            type User struct {
                ID   int
                Name string
            }

            type Order struct {
                ID     int
                UserID int
                Amount float64
            }

            // user/user.go
            package user

            import "myapp/models"

            func GetUser(id int) *models.User { /* ... */ }

            // order/order.go
            package order

            import "myapp/models"

            func GetOrders(userID int) []models.Order { /* ... */ }

            // No circular import — both packages import models, not each other
          annotations:
            - type: pattern
              label: Third Package
              text: >-
                The most common fix for circular imports: extract shared types into a neutral <code>models</code> or
                <code>types</code> package that both can import.
            - type: pattern
              label: Interface Solution
              text: >-
                Alternatively, define an interface in one package and have the other implement it. This breaks the
                compile-time dependency.
