conceptLinks:
  os.ReadFile: "#lesson-reading-files"
  os.WriteFile: "#lesson-writing-files"
  YAML Parsing: "#lesson-yaml"
  exec.Command: "#lesson-shell-commands"
  Environment Variables: "#lesson-env-vars"
sharedContent: {}
variants:
  warmups:
    - id: warmup_1
      concept: os.ReadFile
      variants:
        - id: v1
          title: Read and Print File
          description: >-
            Use <code>os.ReadFile</code> to read a file called <code>"message.txt"</code> and print its contents. Handle
            the error by printing it and returning early.
          hints:
            - <code>os.ReadFile</code> returns <code>([]byte, error)</code>.
            - Convert the byte slice to a string with <code>string(data)</code>.
            - Check <code>err != nil</code> before using the data.
          solution: |-
            data, err := os.ReadFile("message.txt")
            if err != nil {
                fmt.Println("Error:", err)
                return
            }
            fmt.Println(string(data))
          annotations:
            - type: idiom
              label: ReadFile
              text: >-
                <code>os.ReadFile</code> reads the entire file into memory. For small config files this is the simplest
                approach.
            - type: gotcha
              label: Byte Slice
              text: >-
                <code>os.ReadFile</code> returns <code>[]byte</code>, not <code>string</code>. You must convert with
                <code>string(data)</code> to print it as text.
        - id: v2
          title: Count Lines in File
          description: >-
            Read a file with <code>os.ReadFile</code> and count the number of lines. Print the count. (Hint: split on
            newline.)
          hints:
            - Use <code>strings.Split(string(data), "\n")</code> to split into lines.
            - The last element may be empty if the file ends with a newline — consider trimming.
            - Use <code>len(lines)</code> to get the count.
          solution: |-
            data, err := os.ReadFile("input.txt")
            if err != nil {
                fmt.Println("Error:", err)
                return
            }
            lines := strings.Split(strings.TrimRight(string(data), "\n"), "\n")
            fmt.Println("Lines:", len(lines))
          annotations:
            - type: idiom
              label: TrimRight
              text: >-
                Files often end with a trailing newline. <code>strings.TrimRight</code> removes it before splitting to
                avoid an extra empty element.
        - id: v3
          title: Check File Exists
          description: >-
            Write a function <code>fileExists(path string) bool</code> that returns true if the file exists, false
            otherwise. Use <code>os.Stat</code>.
          hints:
            - <code>os.Stat</code> returns <code>(os.FileInfo, error)</code>.
            - Use <code>os.IsNotExist(err)</code> to check if the error means the file doesn't exist.
            - If <code>err == nil</code>, the file exists.
          solution: |-
            func fileExists(path string) bool {
                _, err := os.Stat(path)
                return !os.IsNotExist(err)
            }
          annotations:
            - type: idiom
              label: os.Stat
              text: >-
                <code>os.Stat</code> is Go's way to check file existence and metadata. It returns an error if the file
                can't be accessed.
            - type: gotcha
              label: Other Errors
              text: >-
                <code>os.IsNotExist</code> only checks for "file not found" errors. Permission errors will also make
                <code>Stat</code> fail but <code>IsNotExist</code> returns false.
    - id: warmup_2
      concept: os.WriteFile
      variants:
        - id: v1
          title: Write String to File
          description: >-
            Use <code>os.WriteFile</code> to write the string <code>"Hello, Go!"</code> to a file called
            <code>"output.txt"</code> with permission <code>0644</code>.
          hints:
            - <code>os.WriteFile</code> takes <code>(name string, data []byte, perm os.FileMode)</code>.
            - Convert the string with <code>[]byte("Hello, Go!")</code>.
            - <code>0644</code> means owner read/write, others read-only.
          solution: |-
            err := os.WriteFile("output.txt", []byte("Hello, Go!"), 0644)
            if err != nil {
                fmt.Println("Error:", err)
            }
          annotations:
            - type: idiom
              label: File Permissions
              text: >-
                <code>0644</code> is the standard permission for config/data files: owner can read and write, everyone
                else can only read.
        - id: v2
          title: Copy File Contents
          description: >-
            Read the contents of <code>"source.txt"</code> and write them to <code>"dest.txt"</code>. Use
            <code>os.ReadFile</code> and <code>os.WriteFile</code>.
          hints:
            - Read first with <code>os.ReadFile("source.txt")</code>.
            - Pass the same <code>[]byte</code> data directly to <code>os.WriteFile</code>.
            - No need to convert between string and bytes — it's already <code>[]byte</code>.
          solution: |-
            data, err := os.ReadFile("source.txt")
            if err != nil {
                fmt.Println("Error reading:", err)
                return
            }
            err = os.WriteFile("dest.txt", data, 0644)
            if err != nil {
                fmt.Println("Error writing:", err)
            }
          annotations:
            - type: idiom
              label: Simple Copy
              text: >-
                For small files, ReadFile + WriteFile is the simplest copy pattern. For large files, use
                <code>io.Copy</code> with open file handles.
        - id: v3
          title: Write Lines to File
          description: >-
            Write a function <code>writeLines(path string, lines []string) error</code> that joins the lines with
            newlines and writes them to the file.
          hints:
            - Use <code>strings.Join(lines, "\n")</code> to combine the lines.
            - "Add a trailing newline: <code>content + \"\\n\"</code>."
            - Return the error from <code>os.WriteFile</code> directly.
          solution: |-
            func writeLines(path string, lines []string) error {
                content := strings.Join(lines, "\n") + "\n"
                return os.WriteFile(path, []byte(content), 0644)
            }
          annotations:
            - type: idiom
              label: Trailing Newline
              text: Text files should end with a trailing newline. It's a POSIX convention and many tools expect it.
    - id: warmup_3
      concept: YAML Parsing
      variants:
        - id: v1
          title: Parse Simple YAML Config
          description: >-
            Define a <code>Config</code> struct with <code>Name string</code> and <code>Port int</code> fields. Read
            <code>"config.yaml"</code> and unmarshal it into the struct. Print the values.
          hints:
            - "Use YAML struct tags: <code>`yaml:\"name\"`</code>."
            - Call <code>yaml.Unmarshal(data, &config)</code> to parse.
            - Import <code>gopkg.in/yaml.v3</code>.
          solution: |-
            type Config struct {
                Name string `yaml:"name"`
                Port int    `yaml:"port"`
            }

            data, err := os.ReadFile("config.yaml")
            if err != nil {
                panic(err)
            }

            var config Config
            if err := yaml.Unmarshal(data, &config); err != nil {
                panic(err)
            }
            fmt.Printf("Name: %s, Port: %d\n", config.Name, config.Port)
          annotations:
            - type: idiom
              label: Struct Tags
              text: >-
                YAML struct tags map Go field names to YAML keys. By convention, YAML keys are lowercase/snake_case
                while Go fields are uppercase CamelCase.
            - type: gotcha
              label: Exported Fields
              text: >-
                Only exported (uppercase) struct fields are visible to <code>yaml.Unmarshal</code>. Lowercase fields
                will be silently ignored.
        - id: v2
          title: Parse YAML with Nested Map
          description: >-
            Define a <code>Config</code> struct with a <code>Tasks map[string]string</code> field. Parse YAML like
            <code>tasks:\n  build: "go build"\n  test: "go test"</code>. Iterate and print each task.
          hints:
            - Maps in YAML become <code>map[string]string</code> in Go.
            - Use the struct tag <code>`yaml:"tasks"`</code>.
            - Iterate with <code>for name, cmd := range config.Tasks</code>.
          solution: |-
            type Config struct {
                Tasks map[string]string `yaml:"tasks"`
            }

            data, err := os.ReadFile("tasks.yaml")
            if err != nil {
                panic(err)
            }

            var config Config
            if err := yaml.Unmarshal(data, &config); err != nil {
                panic(err)
            }

            for name, cmd := range config.Tasks {
                fmt.Printf("%s: %s\n", name, cmd)
            }
          annotations:
            - type: idiom
              label: Map Fields
              text: >-
                YAML mappings naturally map to Go's <code>map[string]T</code>. Use this when keys are dynamic rather
                than a fixed set of fields.
        - id: v3
          title: Parse YAML with Slice Field
          description: >-
            Define a struct with a <code>Tags []string</code> field. Parse YAML like <code>tags:\n  - go\n  - cli\n  -
            tools</code>. Print each tag.
          hints:
            - YAML lists become Go slices.
            - Use <code>`yaml:"tags"`</code> as the struct tag.
            - Iterate with <code>for _, tag := range config.Tags</code>.
          solution: |-
            type Config struct {
                Tags []string `yaml:"tags"`
            }

            data, _ := os.ReadFile("config.yaml")
            var config Config
            yaml.Unmarshal(data, &config)

            for _, tag := range config.Tags {
                fmt.Println(tag)
            }
          annotations:
            - type: idiom
              label: YAML Lists
              text: >-
                YAML sequences (lines starting with <code>-</code>) deserialize into Go slices. The element type must
                match the YAML values.
    - id: warmup_4
      concept: exec.Command
      variants:
        - id: v1
          title: Run a Command and Capture Output
          description: Use <code>exec.Command</code> to run <code>echo "hello"</code> and print the output. Handle the error.
          hints:
            - Use <code>exec.Command("echo", "hello")</code> — the args are separate strings.
            - Call <code>.Output()</code> to get the stdout as <code>[]byte</code>.
            - "Convert to string and print: <code>string(out)</code>."
          solution: |-
            out, err := exec.Command("echo", "hello").Output()
            if err != nil {
                fmt.Println("Error:", err)
                return
            }
            fmt.Print(string(out))
          annotations:
            - type: idiom
              label: Separate Args
              text: >-
                <code>exec.Command</code> takes the program and arguments as separate strings. Do NOT pass <code>"echo
                hello"</code> as one string.
            - type: gotcha
              label: No Shell
              text: >-
                <code>exec.Command</code> runs the program directly — no shell features like pipes or globbing. Use
                <code>bash -c</code> for shell features.
        - id: v2
          title: Run Shell Command with Pipe
          description: >-
            Run <code>echo hello world | wc -w</code> through a shell using <code>exec.Command("bash", "-c",
            ...)</code>. Print the word count.
          hints:
            - Wrap the full command in <code>exec.Command("bash", "-c", "echo hello world | wc -w")</code>.
            - The pipe <code>|</code> is a shell feature, so you must use <code>bash -c</code>.
            - Trim whitespace from the output with <code>strings.TrimSpace</code>.
          solution: |-
            out, err := exec.Command("bash", "-c", "echo hello world | wc -w").Output()
            if err != nil {
                fmt.Println("Error:", err)
                return
            }
            fmt.Println(strings.TrimSpace(string(out)))
          annotations:
            - type: idiom
              label: bash -c
              text: When you need shell features (pipes, redirects, globs), wrap the command in <code>bash -c "..."</code>.
        - id: v3
          title: Stream Command Output
          description: >-
            Run <code>go version</code> and stream its output directly to stdout. Use <code>cmd.Stdout =
            os.Stdout</code>.
          hints:
            - "Create the command: <code>cmd := exec.Command(\"go\", \"version\")</code>."
            - Set <code>cmd.Stdout = os.Stdout</code> and <code>cmd.Stderr = os.Stderr</code>.
            - Call <code>cmd.Run()</code> instead of <code>.Output()</code>.
          solution: |-
            cmd := exec.Command("go", "version")
            cmd.Stdout = os.Stdout
            cmd.Stderr = os.Stderr
            if err := cmd.Run(); err != nil {
                fmt.Println("Error:", err)
            }
          annotations:
            - type: idiom
              label: Stream Output
              text: >-
                Setting <code>cmd.Stdout = os.Stdout</code> connects the subprocess output directly to the terminal. No
                buffering, no conversion needed.
            - type: pattern
              label: Run vs Output
              text: >-
                <code>cmd.Run()</code> streams to connected writers. <code>cmd.Output()</code> captures stdout into a
                byte slice. Use <code>Run</code> when you want real-time output.
  challenges:
    - id: challenge_1
      concept: YAML Config Runner
      docLinks:
        - url: https://pkg.go.dev/os#ReadFile
          title: Package os.ReadFile
          note: reading file contents
        - url: https://pkg.go.dev/os/exec#Command
          title: Package exec.Command
          note: running external commands
        - url: https://pkg.go.dev/gopkg.in/yaml.v3
          title: Package yaml.v3
          note: YAML parsing into structs
      variants:
        - id: v1
          title: YAML Task Executor
          description: >-
            Read a YAML file with tasks (each has a <code>command</code> string). Execute each task's command using
            <code>exec.Command</code> through <code>bash -c</code>. Print the task name before running it.
          hints:
            - "Define a struct: <code>type Config struct { Tasks map[string]Task }</code> where Task has a Command field."
            - Iterate tasks with <code>for name, task := range config.Tasks</code>.
            - Run each with <code>exec.Command("bash", "-c", task.Command)</code>.
          solution: |-
            type Task struct {
                Command string `yaml:"command"`
            }

            type Config struct {
                Tasks map[string]Task `yaml:"tasks"`
            }

            data, err := os.ReadFile("tasks.yaml")
            if err != nil {
                panic(err)
            }

            var config Config
            if err := yaml.Unmarshal(data, &config); err != nil {
                panic(err)
            }

            for name, task := range config.Tasks {
                fmt.Printf("Running: %s\n", name)
                cmd := exec.Command("bash", "-c", task.Command)
                cmd.Stdout = os.Stdout
                cmd.Stderr = os.Stderr
                if err := cmd.Run(); err != nil {
                    fmt.Printf("  Error: %v\n", err)
                }
            }
          annotations:
            - type: pattern
              label: Config-Driven Execution
              text: >-
                Reading commands from config files and executing them is a common pattern in task runners, CI systems,
                and deployment tools.
            - type: gotcha
              label: Map Iteration Order
              text: Go maps iterate in random order. If task execution order matters, use a slice instead of a map.
        - id: v2
          title: Config File Loader with Defaults
          description: >-
            Write a function <code>loadConfig(path string) (*Config, error)</code> that reads a YAML config file. If the
            file doesn't exist, return a default config with <code>Port: 8080</code> and <code>Name: "app"</code>.
          hints:
            - >-
              Check for file existence: if <code>os.ReadFile</code> returns an error, check with
              <code>os.IsNotExist</code>.
            - Return the default config when the file is missing.
            - Return the actual error for other failures (e.g., permission denied).
          solution: |-
            type Config struct {
                Name string `yaml:"name"`
                Port int    `yaml:"port"`
            }

            func loadConfig(path string) (*Config, error) {
                data, err := os.ReadFile(path)
                if err != nil {
                    if os.IsNotExist(err) {
                        return &Config{Name: "app", Port: 8080}, nil
                    }
                    return nil, err
                }

                var config Config
                if err := yaml.Unmarshal(data, &config); err != nil {
                    return nil, err
                }
                return &config, nil
            }
          annotations:
            - type: pattern
              label: Defaults Pattern
              text: >-
                Loading config with fallback defaults is a common production pattern. Check for "not found" specifically
                and return defaults; propagate all other errors.
        - id: v3
          title: Directory Lister
          description: >-
            Write a function <code>listGoFiles(dir string) ([]string, error)</code> that reads a directory and returns
            only the <code>.go</code> file names (not directories).
          hints:
            - Use <code>os.ReadDir(dir)</code> to list entries.
            - Check <code>!entry.IsDir()</code> and <code>strings.HasSuffix(entry.Name(), ".go")</code>.
            - Collect matching names into a <code>[]string</code> slice.
          solution: |-
            func listGoFiles(dir string) ([]string, error) {
                entries, err := os.ReadDir(dir)
                if err != nil {
                    return nil, err
                }

                var files []string
                for _, entry := range entries {
                    if !entry.IsDir() && strings.HasSuffix(entry.Name(), ".go") {
                        files = append(files, entry.Name())
                    }
                }
                return files, nil
            }
          annotations:
            - type: idiom
              label: ReadDir
              text: >-
                <code>os.ReadDir</code> returns entries sorted by name. Each entry has <code>Name()</code>,
                <code>IsDir()</code>, and <code>Type()</code> methods.
    - id: challenge_2
      concept: Environment Variables
      docLinks:
        - url: https://pkg.go.dev/os#LookupEnv
          title: Package os.LookupEnv
          note: checking if env var exists
        - url: https://pkg.go.dev/os#Setenv
          title: Package os.Setenv
          note: setting environment variables
      variants:
        - id: v1
          title: Required Env Vars
          description: >-
            Write a function <code>requireEnv(key string) (string, error)</code> that returns the value of an
            environment variable, or an error if it's not set.
          hints:
            - Use <code>os.LookupEnv(key)</code> which returns <code>(value, exists)</code>.
            - If <code>!exists</code>, return an error with <code>fmt.Errorf</code>.
            - Return the value and nil on success.
          solution: |-
            func requireEnv(key string) (string, error) {
                val, exists := os.LookupEnv(key)
                if !exists {
                    return "", fmt.Errorf("required env var %s is not set", key)
                }
                return val, nil
            }
          annotations:
            - type: idiom
              label: LookupEnv
              text: >-
                <code>os.LookupEnv</code> distinguishes between "not set" and "set to empty string".
                <code>os.Getenv</code> returns empty string for both.
            - type: pattern
              label: Required Config
              text: Failing fast on missing required configuration prevents confusing runtime errors later.
        - id: v2
          title: Env with Default
          description: >-
            Write a function <code>envOrDefault(key, fallback string) string</code> that returns the environment
            variable value, or the fallback if not set.
          hints:
            - Use <code>os.Getenv(key)</code> — it returns empty string if not set.
            - Check if the result is empty, return fallback if so.
            - Or use <code>os.LookupEnv</code> for a more precise check.
          solution: |-
            func envOrDefault(key, fallback string) string {
                val, exists := os.LookupEnv(key)
                if !exists {
                    return fallback
                }
                return val
            }
          annotations:
            - type: idiom
              label: Default Pattern
              text: >-
                Using <code>LookupEnv</code> + fallback preserves intentionally empty values. With <code>Getenv</code>,
                you can't tell if the var was set to empty or not set at all.
        - id: v3
          title: Run Command with Custom Env
          description: >-
            Write a function that runs a command with an extra environment variable <code>APP_MODE=production</code>
            added to the current environment. Return the command output.
          hints:
            - Use <code>os.Environ()</code> to get the current environment as a <code>[]string</code>.
            - "Append your extra var: <code>append(os.Environ(), \"APP_MODE=production\")</code>."
            - Set <code>cmd.Env</code> before calling <code>cmd.Output()</code>.
          solution: |-
            func runWithEnv(program string, args ...string) (string, error) {
                cmd := exec.Command(program, args...)
                cmd.Env = append(os.Environ(), "APP_MODE=production")
                out, err := cmd.Output()
                if err != nil {
                    return "", err
                }
                return string(out), nil
            }
          annotations:
            - type: idiom
              label: Custom Env
              text: >-
                Setting <code>cmd.Env</code> replaces the entire environment. Always start with
                <code>os.Environ()</code> and append to preserve the existing environment.
            - type: gotcha
              label: Env Replacement
              text: >-
                If you set <code>cmd.Env</code> to just your custom vars without <code>os.Environ()</code>, the
                subprocess won't have PATH, HOME, or any other standard variables.
