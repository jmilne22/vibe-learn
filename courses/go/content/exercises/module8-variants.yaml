conceptLinks:
  Elm Architecture: "#lesson-elm-architecture"
  Model: "#lesson-model"
  Update: "#lesson-update"
  View: "#lesson-view"
  Lipgloss: "#lesson-lipgloss"
  Bubbles: "#lesson-bubbles"
sharedContent: {}
variants:
  warmups:
    - id: warmup_1
      concept: Elm Architecture
      variants:
        - id: v1
          title: Basic Model Struct
          description: >-
            Define a Bubble Tea <code>model</code> struct for a counter app. It should have a <code>count int</code>
            field. Implement <code>Init()</code> to return <code>nil</code> (no initial command).
          hints:
            - "The model is just a struct: <code>type model struct { count int }</code>."
            - <code>Init()</code> returns a <code>tea.Cmd</code> — use <code>nil</code> for no startup command.
            - The signature is <code>func (m model) Init() tea.Cmd</code>.
          solution: |-
            type model struct {
                count int
            }

            func (m model) Init() tea.Cmd {
                return nil
            }
          annotations:
            - type: idiom
              label: Model = State
              text: In Bubble Tea, the model struct holds your entire application state. Keep it simple and focused.
            - type: pattern
              label: Elm Architecture
              text: Bubble Tea follows Model → Update → View. The model is the single source of truth for your app's state.
        - id: v2
          title: Counter with Choices
          description: >-
            Define a model for a list selector with <code>choices []string</code>, <code>cursor int</code>, and
            <code>selected map[int]struct{}</code> fields. Write an <code>initialModel()</code> function that returns a
            model with three choices.
          hints:
            - Initialize the map with <code>make(map[int]struct{})</code>.
            - Set cursor to <code>0</code> (first item selected by default).
            - "The choices can be anything: <code>[]string{\"Option A\", \"Option B\", \"Option C\"}</code>."
          solution: |-
            type model struct {
                choices  []string
                cursor   int
                selected map[int]struct{}
            }

            func initialModel() model {
                return model{
                    choices:  []string{"Build", "Test", "Deploy"},
                    cursor:   0,
                    selected: make(map[int]struct{}),
                }
            }
          annotations:
            - type: idiom
              label: Empty Struct Set
              text: >-
                <code>map[int]struct{}</code> is Go's idiomatic way to implement a set. The empty struct
                <code>struct{}{}</code> uses zero bytes.
            - type: pattern
              label: Initial Model
              text: >-
                A factory function like <code>initialModel()</code> sets up the starting state cleanly and can be called
                from <code>main()</code>.
        - id: v3
          title: Model with Text Input
          description: >-
            Define a model that embeds a <code>textinput.Model</code> from the <code>bubbles</code> library. Write
            <code>initialModel()</code> that creates a text input with placeholder <code>"Type here..."</code> and
            focuses it.
          hints:
            - Import <code>github.com/charmbracelet/bubbles/textinput</code>.
            - >-
              Create with <code>textinput.New()</code>, then set <code>.Placeholder</code> and call
              <code>.Focus()</code>.
            - "Store it in the model struct: <code>type model struct { input textinput.Model }</code>."
          solution: |-
            type model struct {
                input textinput.Model
            }

            func initialModel() model {
                ti := textinput.New()
                ti.Placeholder = "Type here..."
                ti.Focus()
                ti.CharLimit = 100
                return model{input: ti}
            }
          annotations:
            - type: idiom
              label: Bubbles Components
              text: >-
                Bubbles are pre-built Bubble Tea models. Embed them in your model and delegate Update/View calls to
                them.
            - type: gotcha
              label: Focus Required
              text: Text inputs start unfocused. You must call <code>.Focus()</code> for the input to accept keystrokes.
    - id: warmup_2
      concept: Update
      variants:
        - id: v1
          title: Handle Quit Key
          description: >-
            Write an <code>Update</code> method that handles <code>q</code> and <code>ctrl+c</code> to quit the program.
            Return <code>tea.Quit</code> for those keys, otherwise return the model unchanged.
          hints:
            - "Type-switch on <code>msg</code>: <code>switch msg := msg.(type)</code>."
            - Match <code>tea.KeyMsg</code> and check <code>msg.String()</code>.
            - Return <code>m, tea.Quit</code> for quit, or <code>m, nil</code> otherwise.
          solution: |-
            func (m model) Update(msg tea.Msg) (tea.Model, tea.Cmd) {
                switch msg := msg.(type) {
                case tea.KeyMsg:
                    switch msg.String() {
                    case "q", "ctrl+c":
                        return m, tea.Quit
                    }
                }
                return m, nil
            }
          annotations:
            - type: idiom
              label: Type Switch
              text: >-
                Bubble Tea uses Go's type switch to dispatch different message types. <code>tea.KeyMsg</code> is the
                most common.
            - type: idiom
              label: tea.Quit
              text: <code>tea.Quit</code> is a command that tells Bubble Tea to exit the program gracefully.
        - id: v2
          title: Navigate a List
          description: >-
            Write an <code>Update</code> method for a list model with a <code>cursor int</code> and <code>choices
            []string</code>. Handle <code>up</code>/<code>k</code> to move cursor up and
            <code>down</code>/<code>j</code> to move cursor down. Clamp to bounds.
          hints:
            - Check <code>m.cursor > 0</code> before decrementing.
            - Check <code>m.cursor < len(m.choices)-1</code> before incrementing.
            - Handle both vim keys (j/k) and arrow keys (up/down).
          solution: |-
            func (m model) Update(msg tea.Msg) (tea.Model, tea.Cmd) {
                switch msg := msg.(type) {
                case tea.KeyMsg:
                    switch msg.String() {
                    case "q", "ctrl+c":
                        return m, tea.Quit
                    case "up", "k":
                        if m.cursor > 0 {
                            m.cursor--
                        }
                    case "down", "j":
                        if m.cursor < len(m.choices)-1 {
                            m.cursor++
                        }
                    }
                }
                return m, nil
            }
          annotations:
            - type: idiom
              label: Vim + Arrow Keys
              text: Supporting both arrow keys and vim keys (h/j/k/l) is a TUI convention that power users expect.
            - type: pattern
              label: Bounds Clamping
              text: Always check bounds before moving the cursor. Going below 0 or above the list length would be a bug.
        - id: v3
          title: Toggle Selection
          description: >-
            Add <code>enter</code>/<code>space</code> handling to toggle the current item in <code>m.selected</code> (a
            <code>map[int]struct{}</code>). If the item is selected, deselect it; otherwise, select it.
          hints:
            - "Check if selected: <code>_, ok := m.selected[m.cursor]; ok</code>."
            - Remove with <code>delete(m.selected, m.cursor)</code>.
            - Add with <code>m.selected[m.cursor] = struct{}{}</code>.
          solution: |-
            case "enter", " ":
                if _, ok := m.selected[m.cursor]; ok {
                    delete(m.selected, m.cursor)
                } else {
                    m.selected[m.cursor] = struct{}{}
                }
          annotations:
            - type: idiom
              label: Toggle Pattern
              text: Check-then-delete/add is the standard toggle pattern for sets in Go.
            - type: idiom
              label: Space Key
              text: In Bubble Tea, the space key is represented as <code>" "</code> (a string with one space).
    - id: warmup_3
      concept: View
      variants:
        - id: v1
          title: Render a Counter
          description: >-
            Write a <code>View</code> method for a counter model that displays <code>"Count: 5"</code> (using the actual
            count) and a help line <code>"Press q to quit."</code>.
          hints:
            - <code>View()</code> returns a <code>string</code>.
            - Use <code>fmt.Sprintf</code> to build the string.
            - Add <code>"\n"</code> between lines.
          solution: |-
            func (m model) View() string {
                return fmt.Sprintf("Count: %d\n\nPress q to quit.\n", m.count)
            }
          annotations:
            - type: idiom
              label: View Returns String
              text: The View method always returns a string. Bubble Tea renders this string to the terminal on every update.
            - type: pattern
              label: Help Text
              text: Always include a help line showing available keys. Users need to know how to quit.
        - id: v2
          title: Render a List with Cursor
          description: >-
            Write a <code>View</code> method that renders a list of choices with a <code>></code> cursor on the selected
            item. Non-selected items get a space prefix.
          hints:
            - Loop through <code>m.choices</code> with index.
            - If <code>m.cursor == i</code>, prefix with <code>"> "</code>, otherwise <code>"  "</code>.
            - Build the string incrementally with <code>s += ...</code>.
          solution: |-
            func (m model) View() string {
                s := "Select an option:\n\n"
                for i, choice := range m.choices {
                    cursor := "  "
                    if m.cursor == i {
                        cursor = "> "
                    }
                    s += fmt.Sprintf("%s%s\n", cursor, choice)
                }
                s += "\nPress q to quit.\n"
                return s
            }
          annotations:
            - type: idiom
              label: String Building
              text: >-
                For simple TUIs, building strings with <code>+=</code> is fine. For complex layouts, use
                <code>strings.Builder</code> or Lipgloss.
        - id: v3
          title: Render with Checkboxes
          description: >-
            Write a <code>View</code> method that shows items as <code>[x] Item</code> (selected) or <code>[ ]
            Item</code> (not selected), with a cursor indicator <code>></code> on the current item.
          hints:
            - "Cursor: <code>if m.cursor == i</code> then <code>\">\"</code> else <code>\" \"</code>."
            - "Checked: <code>if _, ok := m.selected[i]; ok</code> then <code>\"x\"</code> else <code>\" \"</code>."
            - "Combine: <code>fmt.Sprintf(\"%s [%s] %s\", cursor, checked, choice)</code>."
          solution: |-
            func (m model) View() string {
                s := "What do you want to do?\n\n"
                for i, choice := range m.choices {
                    cursor := " "
                    if m.cursor == i {
                        cursor = ">"
                    }
                    checked := " "
                    if _, ok := m.selected[i]; ok {
                        checked = "x"
                    }
                    s += fmt.Sprintf("%s [%s] %s\n", cursor, checked, choice)
                }
                s += "\nPress q to quit.\n"
                return s
            }
          annotations:
            - type: pattern
              label: Checkbox UI
              text: >-
                The bracket checkbox pattern <code>[x]</code> / <code>[ ]</code> is a universal TUI convention for
                multi-select interfaces.
    - id: warmup_4
      concept: Lipgloss
      variants:
        - id: v1
          title: Define a Bold Green Style
          description: >-
            Create a Lipgloss style that renders text as bold with a green foreground color (<code>#00ff9d</code>). Use
            it to render the string <code>"Success!"</code>.
          hints:
            - Import <code>github.com/charmbracelet/lipgloss</code>.
            - "Chain methods: <code>lipgloss.NewStyle().Bold(true).Foreground(...)</code>."
            - Colors are <code>lipgloss.Color("#00ff9d")</code>.
          solution: |-
            style := lipgloss.NewStyle().
                Bold(true).
                Foreground(lipgloss.Color("#00ff9d"))

            fmt.Println(style.Render("Success!"))
          annotations:
            - type: idiom
              label: Method Chaining
              text: Lipgloss uses builder-pattern method chaining. Each method returns a new Style so you can chain calls.
            - type: idiom
              label: Hex Colors
              text: >-
                Lipgloss accepts hex colors as strings: <code>lipgloss.Color("#00ff9d")</code>. It also supports ANSI
                256 colors.
        - id: v2
          title: Box with Border
          description: >-
            Create a Lipgloss style with a rounded border, border color <code>#00ff9d</code>, and padding of 1 vertical
            and 2 horizontal. Render the text <code>"Hello, TUI!"</code> inside it.
          hints:
            - Use <code>.Border(lipgloss.RoundedBorder())</code>.
            - Set border color with <code>.BorderForeground(lipgloss.Color(...))</code>.
            - Padding is <code>.Padding(1, 2)</code> — vertical then horizontal.
          solution: |-
            boxStyle := lipgloss.NewStyle().
                Border(lipgloss.RoundedBorder()).
                BorderForeground(lipgloss.Color("#00ff9d")).
                Padding(1, 2)

            fmt.Println(boxStyle.Render("Hello, TUI!"))
          annotations:
            - type: idiom
              label: Border Styles
              text: >-
                Lipgloss offers <code>RoundedBorder()</code>, <code>NormalBorder()</code>, <code>DoubleBorder()</code>,
                and <code>ThickBorder()</code>.
        - id: v3
          title: Conditional Styling
          description: >-
            Write a function that renders an item string. If <code>isSelected</code> is true, render it with purple bold
            text. Otherwise, render with dim gray text.
          hints:
            - Define two styles as package-level vars.
            - Use an if/else to pick which style to apply.
            - Call <code>style.Render(text)</code> to apply the style.
          solution: |-
            var (
                selectedStyle = lipgloss.NewStyle().
                    Foreground(lipgloss.Color("#9d00ff")).
                    Bold(true)
                normalStyle = lipgloss.NewStyle().
                    Foreground(lipgloss.Color("#888888"))
            )

            func renderItem(text string, isSelected bool) string {
                if isSelected {
                    return selectedStyle.Render("❯ " + text)
                }
                return normalStyle.Render("  " + text)
            }
          annotations:
            - type: idiom
              label: Package-Level Styles
              text: >-
                Define styles as package-level <code>var</code>s. They're reusable and avoid recreating styles on every
                render.
            - type: pattern
              label: Conditional Rendering
              text: Switching styles based on state (selected, focused, error) is the core pattern for interactive TUIs.
  challenges:
    - id: challenge_1
      concept: Full Bubble Tea App
      docLinks:
        - url: https://pkg.go.dev/github.com/charmbracelet/bubbletea
          title: Package bubbletea
          note: The Elm Architecture for terminals
        - url: https://pkg.go.dev/github.com/charmbracelet/lipgloss
          title: Package lipgloss
          note: terminal styling and layout
      variants:
        - id: v1
          title: Counter App
          description: >-
            Build a complete Bubble Tea counter app. Press <code>up</code>/<code>k</code> to increment,
            <code>down</code>/<code>j</code> to decrement, <code>r</code> to reset to 0, and <code>q</code> to quit.
            Display the count with a help line.
          hints:
            - Model struct needs just <code>count int</code>.
            - "In Update, handle four key cases: up/k, down/j, r, q."
            - In View, show the count and key bindings.
          solution: |-
            type model struct {
                count int
            }

            func (m model) Init() tea.Cmd { return nil }

            func (m model) Update(msg tea.Msg) (tea.Model, tea.Cmd) {
                switch msg := msg.(type) {
                case tea.KeyMsg:
                    switch msg.String() {
                    case "q", "ctrl+c":
                        return m, tea.Quit
                    case "up", "k":
                        m.count++
                    case "down", "j":
                        m.count--
                    case "r":
                        m.count = 0
                    }
                }
                return m, nil
            }

            func (m model) View() string {
                return fmt.Sprintf(
                    "\n  Count: %d\n\n  ↑/k: increment  ↓/j: decrement  r: reset  q: quit\n",
                    m.count,
                )
            }

            func main() {
                p := tea.NewProgram(model{})
                if _, err := p.Run(); err != nil {
                    fmt.Println("Error:", err)
                }
            }
          annotations:
            - type: pattern
              label: Complete TUI App
              text: >-
                Every Bubble Tea app needs: a model struct, Init(), Update(), and View(). Plus
                <code>tea.NewProgram(model).Run()</code> in main.
        - id: v2
          title: Todo List App
          description: >-
            Build a Bubble Tea app with a list of todo items. Support navigation (up/down), toggling items
            (enter/space), adding items (a key opens an input), and quitting (q). Track completed state per item.
          hints:
            - "Model needs: <code>items []string</code>, <code>done map[int]bool</code>, <code>cursor int</code>."
            - Render done items as <code>[x]</code> and pending as <code>[ ]</code>.
            - "Toggle with enter: flip <code>m.done[m.cursor]</code>."
          solution: |-
            type model struct {
                items  []string
                done   map[int]bool
                cursor int
            }

            func initialModel() model {
                return model{
                    items: []string{"Buy groceries", "Write code", "Go for a walk"},
                    done:  make(map[int]bool),
                }
            }

            func (m model) Init() tea.Cmd { return nil }

            func (m model) Update(msg tea.Msg) (tea.Model, tea.Cmd) {
                switch msg := msg.(type) {
                case tea.KeyMsg:
                    switch msg.String() {
                    case "q", "ctrl+c":
                        return m, tea.Quit
                    case "up", "k":
                        if m.cursor > 0 {
                            m.cursor--
                        }
                    case "down", "j":
                        if m.cursor < len(m.items)-1 {
                            m.cursor++
                        }
                    case "enter", " ":
                        m.done[m.cursor] = !m.done[m.cursor]
                    }
                }
                return m, nil
            }

            func (m model) View() string {
                s := "Todo List:\n\n"
                for i, item := range m.items {
                    cursor := "  "
                    if m.cursor == i {
                        cursor = "> "
                    }
                    check := " "
                    if m.done[i] {
                        check = "x"
                    }
                    s += fmt.Sprintf("%s[%s] %s\n", cursor, check, item)
                }
                s += "\n↑/↓: navigate  enter: toggle  q: quit\n"
                return s
            }
          annotations:
            - type: pattern
              label: Interactive List
              text: Navigation + selection is the foundational TUI pattern. Most real TUI apps are variations of this.
            - type: idiom
              label: map[int]bool
              text: >-
                Using <code>map[int]bool</code> is simpler than <code>map[int]struct{}</code> when you need to toggle —
                <code>!m.done[i]</code> works directly.
        - id: v3
          title: Styled Menu
          description: >-
            Build a Bubble Tea menu with Lipgloss styling. The title should be bold green, the selected item should be
            purple with a <code>❯</code> prefix, and unselected items should be dim. Wrap everything in a rounded border
            box.
          hints:
            - Define styles as package-level vars using <code>lipgloss.NewStyle()</code>.
            - In View, apply different styles based on <code>m.cursor == i</code>.
            - Use <code>boxStyle.Render(content)</code> to wrap the final output.
          solution: |-
            var (
                titleStyle = lipgloss.NewStyle().Bold(true).Foreground(lipgloss.Color("#00ff9d"))
                selStyle   = lipgloss.NewStyle().Bold(true).Foreground(lipgloss.Color("#9d00ff"))
                dimStyle   = lipgloss.NewStyle().Foreground(lipgloss.Color("#555555"))
                boxStyle   = lipgloss.NewStyle().Border(lipgloss.RoundedBorder()).
                                BorderForeground(lipgloss.Color("#00ff9d")).Padding(1, 2)
            )

            func (m model) View() string {
                s := titleStyle.Render("Select an Option") + "\n\n"
                for i, choice := range m.choices {
                    if m.cursor == i {
                        s += selStyle.Render("❯ "+choice) + "\n"
                    } else {
                        s += dimStyle.Render("  "+choice) + "\n"
                    }
                }
                s += "\n" + dimStyle.Render("↑/↓: navigate • enter: select • q: quit")
                return boxStyle.Render(s)
            }
          annotations:
            - type: pattern
              label: Styled TUI
              text: >-
                Lipgloss turns plain text TUIs into polished interfaces. Define style constants and apply them in View
                based on state.
