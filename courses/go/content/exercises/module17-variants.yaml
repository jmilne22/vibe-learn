conceptLinks:
  Sets with Maps: "#lesson-sets"
  Set Operations: "#lesson-set-ops"
  Map as Set: "#lesson-maps-as-sets"
  Diffing Collections: "#lesson-diffing"
sharedContent: {}
variants:
  warmups:
    - id: warmup_1
      concept: Sets with Maps
      variants:
        - id: v1
          title: Directory Diff
          description: >-
            Write a program that compares filenames in two string slices representing directories. Print files only in
            A, only in B, and in both.
          hints:
            - Build a <code>map[string]struct{}</code> from each slice, then iterate to find differences.
          solution: |-
            func directoryDiff(a, b []string) (onlyA, onlyB, both []string) {
                setA := make(map[string]struct{})
                for _, f := range a {
                    setA[f] = struct{}{}
                }
                setB := make(map[string]struct{})
                for _, f := range b {
                    setB[f] = struct{}{}
                }
                for f := range setA {
                    if _, ok := setB[f]; ok {
                        both = append(both, f)
                    } else {
                        onlyA = append(onlyA, f)
                    }
                }
                for f := range setB {
                    if _, ok := setA[f]; !ok {
                        onlyB = append(onlyB, f)
                    }
                }
                return
            }
          annotations:
            - type: idiom
              label: Empty Struct Set
              text: Use map[string]struct{}{} as a set. The empty struct uses zero bytes of storage.
            - type: complexity
              label: O(n + m)
              text: Building both sets and diffing them is linear in the total number of elements.
        - id: v2
          title: Package Import Diff
          description: Given two slices of Go import paths, find which imports are unique to each file and which are shared.
          hints:
            - Use <code>map[string]struct{}</code> to build sets from each import list, then compare.
          solution: |-
            func importDiff(fileA, fileB []string) (onlyA, onlyB, shared []string) {
                setA := make(map[string]struct{})
                for _, imp := range fileA {
                    setA[imp] = struct{}{}
                }
                setB := make(map[string]struct{})
                for _, imp := range fileB {
                    setB[imp] = struct{}{}
                }
                for imp := range setA {
                    if _, ok := setB[imp]; ok {
                        shared = append(shared, imp)
                    } else {
                        onlyA = append(onlyA, imp)
                    }
                }
                for imp := range setB {
                    if _, ok := setA[imp]; !ok {
                        onlyB = append(onlyB, imp)
                    }
                }
                return
            }
          annotations:
            - type: idiom
              label: Comma-Ok Pattern
              text: Use _, ok := m[key] to check membership without caring about the value.
            - type: gotcha
              label: Map Iteration Order
              text: Map iteration order is randomized in Go. Sort results if you need deterministic output.
        - id: v3
          title: Config Key Diff
          description: >-
            Given two <code>map[string]string</code> representing config files, find keys that are only in the first,
            only in the second, and in both.
          hints:
            - You already have maps -- just iterate the keys and check for membership in the other map.
          solution: |-
            func configDiff(a, b map[string]string) (onlyA, onlyB, both []string) {
                for k := range a {
                    if _, ok := b[k]; ok {
                        both = append(both, k)
                    } else {
                        onlyA = append(onlyA, k)
                    }
                }
                for k := range b {
                    if _, ok := a[k]; !ok {
                        onlyB = append(onlyB, k)
                    }
                }
                return
            }
          annotations:
            - type: idiom
              label: Range over Map
              text: for k := range m iterates over keys only, ignoring values.
            - type: alternative
              label: Sorted Output
              text: Use sort.Strings() on results if you need deterministic ordering for tests.
        - id: v4
          title: Tag Diff
          description: >-
            Given two slices of tag strings (e.g., blog post tags), return tags that were added, removed, and unchanged
            between the old and new versions.
          hints:
            - Build sets from both slices. Tags in new but not old are added; tags in old but not new are removed.
          solution: |-
            func tagDiff(oldTags, newTags []string) (added, removed, unchanged []string) {
                oldSet := make(map[string]struct{})
                for _, t := range oldTags {
                    oldSet[t] = struct{}{}
                }
                newSet := make(map[string]struct{})
                for _, t := range newTags {
                    newSet[t] = struct{}{}
                }
                for t := range newSet {
                    if _, ok := oldSet[t]; ok {
                        unchanged = append(unchanged, t)
                    } else {
                        added = append(added, t)
                    }
                }
                for t := range oldSet {
                    if _, ok := newSet[t]; !ok {
                        removed = append(removed, t)
                    }
                }
                return
            }
          annotations:
            - type: pattern
              label: Before/After Diff
              text: >-
                The before/after diff pattern is fundamental: build sets, then classify items as added, removed, or
                unchanged.
            - type: gotcha
              label: Duplicate Tags
              text: Using a set automatically deduplicates. If duplicates matter, use a map[string]int count instead.
    - id: warmup_2
      concept: Set Operations
      variants:
        - id: v1
          title: Find Common Words
          description: Given two string slices of words, return a slice of words that appear in both lists.
          hints:
            - Build a set from the first slice, then check each word in the second slice against it.
          solution: |-
            func findCommon(a, b []string) []string {
                set := make(map[string]struct{})
                for _, w := range a {
                    set[w] = struct{}{}
                }
                var common []string
                seen := make(map[string]struct{})
                for _, w := range b {
                    if _, ok := set[w]; ok {
                        if _, dup := seen[w]; !dup {
                            common = append(common, w)
                            seen[w] = struct{}{}
                        }
                    }
                }
                return common
            }
          annotations:
            - type: idiom
              label: Set Intersection
              text: Intersection means items in both sets. Build one set, check the other against it.
            - type: gotcha
              label: Duplicates in Output
              text: Without a 'seen' set, duplicates in the second slice could appear multiple times in the result.
        - id: v2
          title: Common Permissions
          description: >-
            Given two slices of permission strings (e.g., <code>["read", "write", "admin"]</code>), return the
            permissions that both users share.
          hints:
            - >-
              Build a <code>map[string]struct{}</code> from user A's permissions. Check each of user B's permissions
              against it.
          solution: |-
            func commonPermissions(userA, userB []string) []string {
                setA := make(map[string]struct{})
                for _, p := range userA {
                    setA[p] = struct{}{}
                }
                var shared []string
                for _, p := range userB {
                    if _, ok := setA[p]; ok {
                        shared = append(shared, p)
                    }
                }
                return shared
            }
          annotations:
            - type: idiom
              label: Set Membership
              text: Checking if _, ok := set[item]; ok is the standard Go pattern for set membership.
            - type: complexity
              label: O(n + m)
              text: Building the first set is O(n), checking each item of the second is O(m). Total is linear.
        - id: v3
          title: Shared Dependencies
          description: Given two slices representing Go module dependencies, return the modules both projects depend on.
          hints:
            - This is a set intersection. Build a set from one list, check the other.
          solution: |-
            func sharedDeps(projA, projB []string) []string {
                setA := make(map[string]struct{})
                for _, dep := range projA {
                    setA[dep] = struct{}{}
                }
                var shared []string
                for _, dep := range projB {
                    if _, ok := setA[dep]; ok {
                        shared = append(shared, dep)
                    }
                }
                return shared
            }
          annotations:
            - type: stdlib
              label: slices Package
              text: Go 1.21+ has slices.Contains(), but a map set is still faster for repeated lookups.
            - type: complexity
              label: O(n + m)
              text: Map lookup is O(1) amortized, making the total operation linear.
        - id: v4
          title: Common Students
          description: Given two string slices representing class rosters, find students enrolled in both classes.
          hints:
            - Build a set from the first roster. Iterate over the second roster and collect matches.
          solution: |-
            func commonStudents(classA, classB []string) []string {
                enrolled := make(map[string]struct{})
                for _, s := range classA {
                    enrolled[s] = struct{}{}
                }
                var both []string
                for _, s := range classB {
                    if _, ok := enrolled[s]; ok {
                        both = append(both, s)
                    }
                }
                return both
            }
          annotations:
            - type: idiom
              label: Empty Struct Value
              text: struct{}{} is the idiomatic zero-cost value for Go sets since it allocates no memory.
            - type: alternative
              label: map[string]bool
              text: Some Go code uses map[string]bool for readability (if set[key]), but struct{} saves memory.
  challenges:
    - id: challenge_1
      block: 1
      difficulty: 2
      concept: Set Operations
      docLinks:
        - url: https://go.dev/blog/maps
          title: "Go Blog: Go maps in action"
          note: maps as sets (map[T]struct{})
        - url: https://go.dev/ref/spec#Map_types
          title: "Go Spec: Map types"
          note: map type declarations
      variants:
        - id: v1
          title: Set Calculator
          description: >-
            Write a function that performs set operations (union, intersection, difference) on two string slices. The
            operation is specified as a string parameter.
          functionSignature: func setCalc(op string, a, b []string) []string
          testCases:
            - input: "\"union\", []string{\"a\", \"b\", \"c\"}, []string{\"b\", \"c\", \"d\"}"
              output: "[\"a\", \"b\", \"c\", \"d\"]"
            - input: "\"intersect\", []string{\"a\", \"b\", \"c\"}, []string{\"b\", \"c\", \"d\"}"
              output: "[\"b\", \"c\"]"
            - input: "\"diff\", []string{\"a\", \"b\", \"c\"}, []string{\"b\", \"c\", \"d\"}"
              output: "[\"a\"]"
          hints:
            - title: ðŸ¤” Think about it
              content: >-
                What does each set operation mean? Union = everything from both. Intersection = only shared. Difference
                = in A but not B.
            - title: ðŸ’¡ Hint
              content: >-
                Build map sets from both slices. Use a switch statement on the operation string. For union, combine both
                sets. For intersect, find common keys. For diff, find keys only in A.
            - title: ðŸ”§ Pattern
              content: |-
                <pre>1. Build setA and setB from slices
                2. Switch on op:
                   - union: add all from A, then all from B not in A
                   - intersect: items in A that are also in B
                   - diff: items in A that are NOT in B
                3. Return result slice</pre>
          solution: |-
            func setCalc(op string, a, b []string) []string {
                setA := make(map[string]struct{})
                for _, s := range a {
                    setA[s] = struct{}{}
                }
                setB := make(map[string]struct{})
                for _, s := range b {
                    setB[s] = struct{}{}
                }

                var result []string
                switch op {
                case "union":
                    for s := range setA {
                        result = append(result, s)
                    }
                    for s := range setB {
                        if _, ok := setA[s]; !ok {
                            result = append(result, s)
                        }
                    }
                case "intersect":
                    for s := range setA {
                        if _, ok := setB[s]; ok {
                            result = append(result, s)
                        }
                    }
                case "diff":
                    for s := range setA {
                        if _, ok := setB[s]; !ok {
                            result = append(result, s)
                        }
                    }
                }
                sort.Strings(result)
                return result
            }
          difficulty: 2
          annotations:
            - type: idiom
              label: Switch on Strings
              text: Go's switch statement works cleanly on strings without needing break statements.
            - type: complexity
              label: O(n + m)
              text: Each operation iterates through at most both sets, giving linear time complexity.
        - id: v2
          title: Permission Calculator
          description: >-
            Write a function that combines or restricts permission sets. Given an operation (<code>"grant"</code> for
            union, <code>"restrict"</code> for intersection, <code>"revoke"</code> for difference), compute the
            resulting permission set.
          functionSignature: func permCalc(op string, current, modifier []string) []string
          testCases:
            - input: "\"grant\", []string{\"read\", \"write\"}, []string{\"write\", \"admin\"}"
              output: "[\"admin\", \"read\", \"write\"]"
            - input: "\"restrict\", []string{\"read\", \"write\", \"admin\"}, []string{\"read\", \"write\"}"
              output: "[\"read\", \"write\"]"
            - input: "\"revoke\", []string{\"read\", \"write\", \"admin\"}, []string{\"admin\"}"
              output: "[\"read\", \"write\"]"
          hints:
            - title: ðŸ¤” Think about it
              content: >-
                Grant adds new permissions (union). Restrict keeps only allowed permissions (intersection). Revoke
                removes specific permissions (difference).
            - title: ðŸ’¡ Hint
              content: >-
                Map each operation name to its set operation. Build sets from both slices, then apply the appropriate
                logic.
            - title: ðŸ”§ Pattern
              content: |-
                <pre>1. Build sets from current and modifier slices
                2. Switch on op:
                   - "grant": union of current + modifier
                   - "restrict": intersection of current and modifier
                   - "revoke": difference of current minus modifier
                3. Sort and return</pre>
          solution: |-
            func permCalc(op string, current, modifier []string) []string {
                cur := make(map[string]struct{})
                for _, p := range current {
                    cur[p] = struct{}{}
                }
                mod := make(map[string]struct{})
                for _, p := range modifier {
                    mod[p] = struct{}{}
                }

                var result []string
                switch op {
                case "grant":
                    for p := range cur {
                        result = append(result, p)
                    }
                    for p := range mod {
                        if _, ok := cur[p]; !ok {
                            result = append(result, p)
                        }
                    }
                case "restrict":
                    for p := range cur {
                        if _, ok := mod[p]; ok {
                            result = append(result, p)
                        }
                    }
                case "revoke":
                    for p := range cur {
                        if _, ok := mod[p]; !ok {
                            result = append(result, p)
                        }
                    }
                }
                sort.Strings(result)
                return result
            }
          difficulty: 2
          annotations:
            - type: pattern
              label: Domain-Specific Names
              text: Mapping domain concepts (grant/revoke) to set operations makes code more readable in context.
            - type: idiom
              label: Sorted Output
              text: Sorting the result ensures deterministic output, essential for testing.
        - id: v3
          title: Feature Flag Manager
          description: >-
            Write a function that manages feature flags using set operations. Supports <code>"enable"</code> (union),
            <code>"common"</code> (intersection), and <code>"disable"</code> (difference).
          functionSignature: func featureFlags(op string, active, targets []string) []string
          testCases:
            - input: "\"enable\", []string{\"dark-mode\", \"beta-ui\"}, []string{\"beta-ui\", \"new-api\"}"
              output: "[\"beta-ui\", \"dark-mode\", \"new-api\"]"
            - input: "\"common\", []string{\"dark-mode\", \"beta-ui\", \"new-api\"}, []string{\"beta-ui\", \"new-api\"}"
              output: "[\"beta-ui\", \"new-api\"]"
            - input: "\"disable\", []string{\"dark-mode\", \"beta-ui\", \"new-api\"}, []string{\"beta-ui\"}"
              output: "[\"dark-mode\", \"new-api\"]"
          hints:
            - title: ðŸ¤” Think about it
              content: >-
                Enable adds flags (union), common finds shared flags (intersection), disable removes flags (difference).
                Which set operation matches each?
            - title: ðŸ’¡ Hint
              content: Build sets from both slices. Switch on the operation and apply the matching set operation.
            - title: ðŸ”§ Pattern
              content: |-
                <pre>1. Build map sets from active and targets
                2. Switch on op:
                   - enable: union
                   - common: intersection
                   - disable: difference
                3. Collect, sort, return</pre>
          solution: |-
            func featureFlags(op string, active, targets []string) []string {
                actSet := make(map[string]struct{})
                for _, f := range active {
                    actSet[f] = struct{}{}
                }
                tgtSet := make(map[string]struct{})
                for _, f := range targets {
                    tgtSet[f] = struct{}{}
                }

                var result []string
                switch op {
                case "enable":
                    for f := range actSet {
                        result = append(result, f)
                    }
                    for f := range tgtSet {
                        if _, ok := actSet[f]; !ok {
                            result = append(result, f)
                        }
                    }
                case "common":
                    for f := range actSet {
                        if _, ok := tgtSet[f]; ok {
                            result = append(result, f)
                        }
                    }
                case "disable":
                    for f := range actSet {
                        if _, ok := tgtSet[f]; !ok {
                            result = append(result, f)
                        }
                    }
                }
                sort.Strings(result)
                return result
            }
          difficulty: 2
          annotations:
            - type: idiom
              label: Set as Map
              text: Go has no built-in set type. map[T]struct{} is the canonical implementation.
            - type: alternative
              label: Generic Set
              text: With Go generics, you could write a reusable Set[T comparable] type for all three operations.
        - id: v4
          title: Ingredient Calculator
          description: >-
            Write a function for recipe management. Given an operation (<code>"combine"</code> for union,
            <code>"overlap"</code> for intersection, <code>"missing"</code> for difference), calculate the result
            between two ingredient lists.
          functionSignature: func ingredientCalc(op string, recipe, pantry []string) []string
          testCases:
            - input: "\"combine\", []string{\"flour\", \"sugar\"}, []string{\"sugar\", \"butter\"}"
              output: "[\"butter\", \"flour\", \"sugar\"]"
            - input: "\"overlap\", []string{\"flour\", \"sugar\", \"eggs\"}, []string{\"sugar\", \"eggs\", \"milk\"}"
              output: "[\"eggs\", \"sugar\"]"
            - input: "\"missing\", []string{\"flour\", \"sugar\", \"eggs\"}, []string{\"sugar\"}"
              output: "[\"eggs\", \"flour\"]"
          hints:
            - title: ðŸ¤” Think about it
              content: >-
                Combine merges all ingredients (union). Overlap finds what you already have (intersection). Missing
                finds what you need to buy (difference).
            - title: ðŸ’¡ Hint
              content: Build sets from both slices. Apply the matching set operation based on the op string.
            - title: ðŸ”§ Pattern
              content: |-
                <pre>1. Build map sets from recipe and pantry
                2. Switch on op:
                   - combine: all unique items from both
                   - overlap: items in both
                   - missing: items in recipe but not pantry
                3. Sort and return</pre>
          solution: |-
            func ingredientCalc(op string, recipe, pantry []string) []string {
                rSet := make(map[string]struct{})
                for _, i := range recipe {
                    rSet[i] = struct{}{}
                }
                pSet := make(map[string]struct{})
                for _, i := range pantry {
                    pSet[i] = struct{}{}
                }

                var result []string
                switch op {
                case "combine":
                    for i := range rSet {
                        result = append(result, i)
                    }
                    for i := range pSet {
                        if _, ok := rSet[i]; !ok {
                            result = append(result, i)
                        }
                    }
                case "overlap":
                    for i := range rSet {
                        if _, ok := pSet[i]; ok {
                            result = append(result, i)
                        }
                    }
                case "missing":
                    for i := range rSet {
                        if _, ok := pSet[i]; !ok {
                            result = append(result, i)
                        }
                    }
                }
                sort.Strings(result)
                return result
            }
          difficulty: 2
          annotations:
            - type: gotcha
              label: Nil Slice vs Empty
              text: If no items match, result is nil. Use make([]string, 0) if you need a non-nil empty slice for JSON.
            - type: complexity
              label: O((n+m) log(n+m))
              text: Set operations are O(n+m) but the final sort adds O(k log k) where k is the result size.
    - id: challenge_2
      block: 2
      difficulty: 3
      concept: Diffing Collections
      docLinks:
        - url: https://go.dev/blog/maps
          title: "Go Blog: Go maps in action"
          note: membership testing with maps
        - url: https://pkg.go.dev/sort#Strings
          title: Package sort.Strings
          note: sorting result slices
      variants:
        - id: v1
          title: Change Detector
          description: >-
            Write a function that takes two string slices representing before/after snapshots and returns three slices:
            added items, removed items, and unchanged items.
          functionSignature: func detectChanges(before, after []string) (added, removed, unchanged []string)
          testCases:
            - input: "[]string{\"a.txt\", \"b.txt\", \"c.txt\"}, []string{\"b.txt\", \"c.txt\", \"d.txt\"}"
              output: added=["d.txt"], removed=["a.txt"], unchanged=["b.txt", "c.txt"]
            - input: "[]string{\"x\"}, []string{\"x\", \"y\", \"z\"}"
              output: added=["y", "z"], removed=[], unchanged=["x"]
            - input: "[]string{\"a\", \"b\"}, []string{}"
              output: added=[], removed=["a", "b"], unchanged=[]
          hints:
            - title: ðŸ¤” Think about it
              content: >-
                How do you classify each item? It's added if it's in 'after' but not 'before'. Removed if in 'before'
                but not 'after'. Unchanged if in both.
            - title: ðŸ’¡ Hint
              content: Build a set from 'before' and a set from 'after'. Iterate each set checking membership in the other.
            - title: ðŸ”§ Pattern
              content: |-
                <pre>1. Build beforeSet and afterSet
                2. For each item in afterSet:
                   - In beforeSet? -> unchanged
                   - Not in beforeSet? -> added
                3. For each item in beforeSet:
                   - Not in afterSet? -> removed
                4. Sort all three slices</pre>
          solution: |-
            func detectChanges(before, after []string) (added, removed, unchanged []string) {
                beforeSet := make(map[string]struct{})
                for _, s := range before {
                    beforeSet[s] = struct{}{}
                }
                afterSet := make(map[string]struct{})
                for _, s := range after {
                    afterSet[s] = struct{}{}
                }

                for s := range afterSet {
                    if _, ok := beforeSet[s]; ok {
                        unchanged = append(unchanged, s)
                    } else {
                        added = append(added, s)
                    }
                }
                for s := range beforeSet {
                    if _, ok := afterSet[s]; !ok {
                        removed = append(removed, s)
                    }
                }

                sort.Strings(added)
                sort.Strings(removed)
                sort.Strings(unchanged)
                return
            }
          difficulty: 3
          annotations:
            - type: idiom
              label: Named Returns
              text: Named return values (added, removed, unchanged) act as documentation and allow bare returns.
            - type: complexity
              label: O(n log n)
              text: Set operations are O(n), but sorting the output adds O(n log n).
            - type: pattern
              label: Three-Way Diff
              text: The three-way classification (added/removed/unchanged) is the foundation of most diff algorithms.
        - id: v2
          title: Config Change Tracker
          description: >-
            Write a function that compares two <code>map[string]string</code> configs and returns slices of keys that
            were added, removed, or modified (value changed).
          functionSignature: func configChanges(old, new map[string]string) (added, removed, modified []string)
          testCases:
            - input: >-
                map[string]string{"port": "8080", "host": "localhost"}, map[string]string{"port": "9090", "debug":
                "true"}
              output: added=["debug"], removed=["host"], modified=["port"]
            - input: "map[string]string{\"a\": \"1\"}, map[string]string{\"a\": \"1\"}"
              output: added=[], removed=[], modified=[]
          hints:
            - title: ðŸ¤” Think about it
              content: >-
                This is like a diff but with an extra category: modified. A key is modified if it exists in both maps
                but has a different value.
            - title: ðŸ’¡ Hint
              content: >-
                Iterate the old map: if a key is not in new, it was removed. If it is in new but with a different value,
                it was modified. Then iterate new for keys not in old (added).
            - title: ðŸ”§ Pattern
              content: |-
                <pre>1. For each key in old:
                   - Not in new? -> removed
                   - In new with different value? -> modified
                2. For each key in new:
                   - Not in old? -> added
                3. Sort all slices</pre>
          solution: |-
            func configChanges(old, new map[string]string) (added, removed, modified []string) {
                for k, oldVal := range old {
                    newVal, exists := new[k]
                    if !exists {
                        removed = append(removed, k)
                    } else if oldVal != newVal {
                        modified = append(modified, k)
                    }
                }
                for k := range new {
                    if _, exists := old[k]; !exists {
                        added = append(added, k)
                    }
                }
                sort.Strings(added)
                sort.Strings(removed)
                sort.Strings(modified)
                return
            }
          difficulty: 3
          annotations:
            - type: pattern
              label: Value-Aware Diff
              text: Unlike a pure set diff, this pattern also detects modifications by comparing values for shared keys.
            - type: gotcha
              label: Zero Values
              text: >-
                Accessing a missing map key returns the zero value (empty string), so always use the comma-ok idiom to
                distinguish missing from empty.
        - id: v3
          title: Roster Change Report
          description: >-
            Write a function that compares an old and new team roster (slices of name strings) and returns a formatted
            report string listing who joined, who left, and who stayed.
          functionSignature: func rosterReport(old, new []string) string
          testCases:
            - input: "[]string{\"Alice\", \"Bob\", \"Charlie\"}, []string{\"Bob\", \"Charlie\", \"Diana\"}"
              output: "\"Joined: Diana\\nLeft: Alice\\nStayed: Bob, Charlie\""
            - input: "[]string{\"Alice\"}, []string{\"Alice\"}"
              output: "\"Joined: (none)\\nLeft: (none)\\nStayed: Alice\""
          hints:
            - title: ðŸ¤” Think about it
              content: First compute the three categories (joined, left, stayed), then format them into a report string.
            - title: ðŸ’¡ Hint
              content: >-
                Use set operations to find joined (in new, not old), left (in old, not new), stayed (in both). Then use
                strings.Join to format each list.
            - title: ðŸ”§ Pattern
              content: |-
                <pre>1. Build oldSet and newSet
                2. Compute joined, left, stayed slices
                3. Sort each slice
                4. Format with strings.Join
                5. Use "(none)" for empty categories</pre>
          solution: |-
            func rosterReport(old, new []string) string {
                oldSet := make(map[string]struct{})
                for _, n := range old {
                    oldSet[n] = struct{}{}
                }
                newSet := make(map[string]struct{})
                for _, n := range new {
                    newSet[n] = struct{}{}
                }

                var joined, left, stayed []string
                for n := range newSet {
                    if _, ok := oldSet[n]; ok {
                        stayed = append(stayed, n)
                    } else {
                        joined = append(joined, n)
                    }
                }
                for n := range oldSet {
                    if _, ok := newSet[n]; !ok {
                        left = append(left, n)
                    }
                }

                sort.Strings(joined)
                sort.Strings(left)
                sort.Strings(stayed)

                format := func(label string, items []string) string {
                    if len(items) == 0 {
                        return label + ": (none)"
                    }
                    return label + ": " + strings.Join(items, ", ")
                }

                return format("Joined", joined) + "\n" + format("Left", left) + "\n" + format("Stayed", stayed)
            }
          difficulty: 3
          annotations:
            - type: idiom
              label: strings.Join
              text: strings.Join is the idiomatic way to combine string slices with a separator.
            - type: pattern
              label: Closures for Formatting
              text: Using a local closure (format func) avoids code duplication for repetitive formatting logic.
        - id: v4
          title: Inventory Tracker
          description: >-
            Write a function that compares two <code>map[string]int</code> representing inventory counts. Return maps of
            items that are new, removed, increased, and decreased.
          functionSignature: >-
            func inventoryDiff(before, after map[string]int) (new, removed map[string]int, increased, decreased
            map[string][2]int)
          testCases:
            - input: "map[string]int{\"apples\": 5, \"bananas\": 3}, map[string]int{\"apples\": 8, \"cherries\": 2}"
              output: "new={\"cherries\": 2}, removed={\"bananas\": 3}, increased={\"apples\": [5, 8]}, decreased={}"
            - input: "map[string]int{\"a\": 10}, map[string]int{\"a\": 5}"
              output: "new={}, removed={}, increased={}, decreased={\"a\": [10, 5]}"
          hints:
            - title: ðŸ¤” Think about it
              content: >-
                This extends the diff pattern with quantity awareness. Items can be new, removed, or present in both
                with a changed count.
            - title: ðŸ’¡ Hint
              content: >-
                Iterate 'before': if not in 'after', it was removed. If in 'after' with higher count, it increased. If
                lower, decreased. Then check 'after' for new items.
            - title: ðŸ”§ Pattern
              content: |-
                <pre>1. Initialize result maps with make()
                2. For each item in before:
                   - Not in after -> removed
                   - In after, count higher -> increased
                   - In after, count lower -> decreased
                3. For each item in after:
                   - Not in before -> new
                4. Return all four maps</pre>
          solution: >-
            func inventoryDiff(before, after map[string]int) (newItems, removed map[string]int, increased, decreased
            map[string][2]int) {
                newItems = make(map[string]int)
                removed = make(map[string]int)
                increased = make(map[string][2]int)
                decreased = make(map[string][2]int)

                for item, oldCount := range before {
                    newCount, exists := after[item]
                    if !exists {
                        removed[item] = oldCount
                    } else if newCount > oldCount {
                        increased[item] = [2]int{oldCount, newCount}
                    } else if newCount < oldCount {
                        decreased[item] = [2]int{oldCount, newCount}
                    }
                }
                for item, count := range after {
                    if _, exists := before[item]; !exists {
                        newItems[item] = count
                    }
                }
                return
            }
          difficulty: 3
          annotations:
            - type: idiom
              label: Array Value in Map
              text: Using [2]int as a map value stores old/new counts without needing a struct.
            - type: gotcha
              label: Initialize Maps
              text: Always initialize maps with make() before writing to them. Writing to a nil map causes a runtime panic.
            - type: complexity
              label: O(n + m)
              text: Each item is visited once from each map, making the operation linear.
