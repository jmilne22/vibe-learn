conceptLinks:
  Maps: "#lesson-maps"
  Slices: "#lesson-slices"
  Generics: "#lesson-generics"
  Structs & Methods: "#lesson-structs"
  Stacks: "#lesson-stacks"
  Comma-Ok Pattern: "#lesson-comma-ok"
  make() Function: "#lesson-make"
sharedContent: {}
variants:
  warmups:
    - id: warmup_1
      concept: Maps
      quickRef: |
        <code>m := map[string]int{}</code> &nbsp; <code>m[k] = v</code><br>
                <code>v, ok := m[k]</code> &nbsp; <code>delete(m, k)</code>
      variants:
        - id: v1
          title: Remove Duplicate Strings
          description: >-
            Write <code>func unique(items []string) []string</code> that removes duplicates from a string slice,
            preserving the original order.
          hints:
            - Use a <code>map[string]bool</code> to track which items you have already seen.
            - Only <code>append</code> to the result slice when the item is not in the map.
          solution: |-
            func unique(items []string) []string {
                seen := make(map[string]bool)
                result := make([]string, 0)
                for _, item := range items {
                    if !seen[item] {
                        seen[item] = true
                        result = append(result, item)
                    }
                }
                return result
            }
          annotations:
            - type: idiom
              label: Map as Set
              text: >-
                In Go, a <code>map[T]bool</code> is the idiomatic way to implement a set since Go has no built-in set
                type.
            - type: complexity
              label: O(n)
              text: Single pass through the slice with O(1) map lookups gives O(n) total time.
        - id: v2
          title: Remove Duplicate Integers
          description: >-
            Write <code>func uniqueInts(nums []int) []int</code> that removes duplicate integers from a slice,
            preserving the original order.
          hints:
            - Use a <code>map[int]bool</code> to track seen numbers.
            - Iterate with <code>range</code> and only append unseen values.
          solution: |-
            func uniqueInts(nums []int) []int {
                seen := make(map[int]bool)
                result := make([]int, 0)
                for _, n := range nums {
                    if !seen[n] {
                        seen[n] = true
                        result = append(result, n)
                    }
                }
                return result
            }
          annotations:
            - type: idiom
              label: Zero Value Lookup
              text: >-
                Accessing a missing map key returns the zero value (<code>false</code> for bool), so
                <code>!seen[n]</code> works without the comma-ok pattern.
            - type: gotcha
              label: Order Not Guaranteed
              text: >-
                Maps in Go have no guaranteed iteration order. Using a map as a 'seen' set while appending to a slice is
                how you preserve original order.
        - id: v3
          title: Unique Characters
          description: >-
            Write <code>func uniqueChars(s string) string</code> that returns a string with duplicate characters
            removed, preserving the first occurrence order.
          hints:
            - Convert the string to <code>[]rune</code> or iterate with <code>range</code> to handle Unicode.
            - Use a <code>map[rune]bool</code> to track seen characters.
          solution: |-
            func uniqueChars(s string) string {
                seen := make(map[rune]bool)
                result := make([]rune, 0)
                for _, ch := range s {
                    if !seen[ch] {
                        seen[ch] = true
                        result = append(result, ch)
                    }
                }
                return string(result)
            }
          annotations:
            - type: gotcha
              label: Rune vs Byte
              text: >-
                Iterating a string with <code>range</code> yields runes (Unicode code points), not bytes. This correctly
                handles multi-byte characters like emoji.
            - type: idiom
              label: Rune Slice Conversion
              text: >-
                Build a <code>[]rune</code> and convert back with <code>string(result)</code> to produce the final
                string.
        - id: v4
          title: Unique by Last Occurrence
          description: >-
            Write <code>func uniqueLast(items []string) []string</code> that removes duplicates but keeps the
            <strong>last</strong> occurrence of each item instead of the first.
          hints:
            - "One approach: iterate in reverse and use a seen map, then reverse the result."
            - "Another approach: first pass to record last index, second pass to collect."
          solution: |-
            func uniqueLast(items []string) []string {
                lastIdx := make(map[string]int)
                for i, item := range items {
                    lastIdx[item] = i
                }
                result := make([]string, 0)
                for i, item := range items {
                    if lastIdx[item] == i {
                        result = append(result, item)
                    }
                }
                return result
            }
          annotations:
            - type: alternative
              label: Reverse Approach
              text: An alternative is to iterate backward, use a seen map, collect items, then reverse the result slice.
            - type: complexity
              label: O(n)
              text: "Two passes through the slice: one to record last indices, one to collect. Both are O(n)."
    - id: warmup_2
      concept: Generics
      quickRef: |
        <code>func F[T any](s []T) T { }</code><br>
                <code>type Set[T comparable] map[T]struct{}{}</code>
      variants:
        - id: v1
          title: Merge String Maps
          description: >-
            Write <code>func merge[K comparable, V any](a, b map[K]V) map[K]V</code> that merges two maps. Values from
            <code>b</code> override values from <code>a</code> when keys conflict.
          hints:
            - Create a new map with <code>make(map[K]V)</code>.
            - >-
              Copy all entries from <code>a</code> first, then copy all from <code>b</code> to let <code>b</code>
              override.
          solution: |-
            func merge[K comparable, V any](a, b map[K]V) map[K]V {
                result := make(map[K]V)
                for k, v := range a {
                    result[k] = v
                }
                for k, v := range b {
                    result[k] = v
                }
                return result
            }
          annotations:
            - type: idiom
              label: Generic Constraints
              text: >-
                The <code>comparable</code> constraint is required for map keys because Go maps need keys that support
                <code>==</code> and <code>!=</code>.
            - type: gotcha
              label: Nil Map Write
              text: Writing to a nil map panics. Always use <code>make()</code> to initialize a map before writing to it.
        - id: v2
          title: Merge with Priority Flag
          description: >-
            Write <code>func mergeWith[K comparable, V any](a, b map[K]V, preferA bool) map[K]V</code>. If
            <code>preferA</code> is true, values from <code>a</code> take priority on conflicts; otherwise
            <code>b</code> wins.
          hints:
            - Start by copying both maps into the result.
            - Control which map you copy second to determine which one overrides.
          solution: |-
            func mergeWith[K comparable, V any](a, b map[K]V, preferA bool) map[K]V {
                result := make(map[K]V)
                if preferA {
                    for k, v := range b {
                        result[k] = v
                    }
                    for k, v := range a {
                        result[k] = v
                    }
                } else {
                    for k, v := range a {
                        result[k] = v
                    }
                    for k, v := range b {
                        result[k] = v
                    }
                }
                return result
            }
          annotations:
            - type: idiom
              label: Copy Order Matters
              text: >-
                When merging maps, the map copied second wins on conflicts. This is a common Go idiom for setting
                defaults then overriding.
            - type: alternative
              label: Conditional Insert
              text: >-
                Alternatively, copy both maps in any order but check existence with the comma-ok pattern before
                overwriting.
        - id: v3
          title: Merge Integer Maps with Sum
          description: >-
            Write <code>func mergeSum(a, b map[string]int) map[string]int</code> that merges two maps by
            <strong>summing</strong> values for shared keys instead of overriding.
          hints:
            - >-
              Create a result map, copy all from <code>a</code>, then for each entry in <code>b</code> add to the
              existing value.
            - Remember that accessing a missing int map key returns <code>0</code>.
          solution: |-
            func mergeSum(a, b map[string]int) map[string]int {
                result := make(map[string]int)
                for k, v := range a {
                    result[k] += v
                }
                for k, v := range b {
                    result[k] += v
                }
                return result
            }
          annotations:
            - type: idiom
              label: Zero Value Addition
              text: >-
                In Go, <code>result[k] += v</code> works even if <code>k</code> is not yet in the map because the zero
                value for <code>int</code> is <code>0</code>.
            - type: complexity
              label: O(n+m)
              text: Iterates through both maps once, where n and m are the sizes of maps a and b.
        - id: v4
          title: Merge Multiple Maps
          description: >-
            Write <code>func mergeAll[K comparable, V any](maps ...map[K]V) map[K]V</code> that merges any number of
            maps. Later maps override earlier ones on conflicts.
          hints:
            - Use a variadic parameter <code>...map[K]V</code>.
            - Iterate through each map in order, copying entries into a single result map.
          solution: |-
            func mergeAll[K comparable, V any](maps ...map[K]V) map[K]V {
                result := make(map[K]V)
                for _, m := range maps {
                    for k, v := range m {
                        result[k] = v
                    }
                }
                return result
            }
          annotations:
            - type: idiom
              label: Variadic Generics
              text: >-
                Combining generics with variadic parameters (<code>...map[K]V</code>) creates flexible, reusable utility
                functions.
            - type: gotcha
              label: Nil Map in Variadic
              text: Ranging over a nil map is safe in Go (zero iterations), so nil entries in the variadic list won't panic.
  challenges:
    - id: challenge_1
      block: 1
      difficulty: 2
      concept: Structs & Methods
      docLinks:
        - url: https://go.dev/ref/spec#Method_declarations
          title: "Go Spec: Method declarations"
          note: defining methods on types
        - url: https://go.dev/doc/effective_go#methods
          title: "Effective Go: Methods"
          note: method design patterns
      quickRef: |
        <code>func (s *S) Method() { }</code><br>
                Pointer receiver for mutation, value receiver for read-only
      variants:
        - id: v1
          title: Simple String Cache
          description: >-
            Implement a <code>Cache</code> struct with <code>Get(key string) (string, bool)</code> and <code>Set(key,
            value string)</code> methods. <code>Get</code> returns the value and whether the key exists.
          functionSignature: func NewCache() *Cache
          testCases:
            - input: c := NewCache(); c.Set("name", "Go"); c.Get("name")
              output: "\"Go\", true"
            - input: c := NewCache(); c.Get("missing")
              output: "\"\", false"
          hints:
            - title: ðŸ¤” Think about it
              content: What underlying data structure naturally maps keys to values? How do you check if a key exists in Go?
            - title: ðŸ’¡ Hint
              content: >-
                Use a struct wrapping a <code>map[string]string</code>. The comma-ok pattern <code>val, ok :=
                m[key]</code> gives you both the value and existence.
            - title: ðŸ”§ Pattern
              content: |-
                <pre>1. Define Cache struct with a map field
                2. NewCache initializes the map with make()
                3. Get uses comma-ok on the map
                4. Set assigns to the map</pre>
          solution: |-
            type Cache struct {
                data map[string]string
            }

            func NewCache() *Cache {
                return &Cache{data: make(map[string]string)}
            }

            func (c *Cache) Get(key string) (string, bool) {
                val, ok := c.data[key]
                return val, ok
            }

            func (c *Cache) Set(key, value string) {
                c.data[key] = value
            }
          difficulty: 2
          annotations:
            - type: idiom
              label: Constructor Function
              text: >-
                Go uses <code>NewXxx()</code> constructor functions instead of constructors. This ensures the internal
                map is properly initialized.
            - type: gotcha
              label: Uninitialized Map
              text: A struct with a map field has a nil map by default. Writing to it panics. Always provide a constructor.
        - id: v2
          title: Cache with Default Values
          description: >-
            Implement a <code>Cache</code> with <code>GetOrDefault(key, defaultVal string) string</code> and
            <code>Set(key, value string)</code>. If the key does not exist, return the provided default.
          functionSignature: func NewCache() *Cache
          testCases:
            - input: c := NewCache(); c.Set("lang", "Go"); c.GetOrDefault("lang", "Rust")
              output: "\"Go\""
            - input: c := NewCache(); c.GetOrDefault("lang", "Rust")
              output: "\"Rust\""
          hints:
            - title: ðŸ¤” Think about it
              content: >-
                How do you distinguish between a key that exists with an empty value and a key that does not exist at
                all?
            - title: ðŸ’¡ Hint
              content: Use the comma-ok pattern. If <code>ok</code> is false, return the default value instead.
            - title: ðŸ”§ Pattern
              content: |-
                <pre>1. Look up key with comma-ok
                2. If ok is true, return the stored value
                3. If ok is false, return the default value</pre>
          solution: |-
            type Cache struct {
                data map[string]string
            }

            func NewCache() *Cache {
                return &Cache{data: make(map[string]string)}
            }

            func (c *Cache) GetOrDefault(key, defaultVal string) string {
                if val, ok := c.data[key]; ok {
                    return val
                }
                return defaultVal
            }

            func (c *Cache) Set(key, value string) {
                c.data[key] = value
            }
          difficulty: 2
          annotations:
            - type: idiom
              label: Comma-Ok Pattern
              text: >-
                The comma-ok pattern <code>val, ok := m[key]</code> is idiomatic Go for distinguishing missing keys from
                zero values.
            - type: pattern
              label: Default Value Pattern
              text: >-
                Providing a default parameter is a common alternative to returning (value, bool) tuples when you always
                want a usable result.
        - id: v3
          title: Cache with Delete
          description: >-
            Implement a <code>Cache</code> with <code>Get(key string) (string, bool)</code>, <code>Set(key, value
            string)</code>, and <code>Delete(key string) bool</code>. Delete returns true if the key existed.
          functionSignature: func NewCache() *Cache
          testCases:
            - input: c := NewCache(); c.Set("a", "1"); c.Delete("a")
              output: "true"
            - input: c := NewCache(); c.Delete("missing")
              output: "false"
            - input: c := NewCache(); c.Set("a", "1"); c.Delete("a"); c.Get("a")
              output: "\"\", false"
          hints:
            - title: ðŸ¤” Think about it
              content: How do you remove a key from a map in Go? How can you tell if the key was there before you removed it?
            - title: ðŸ’¡ Hint
              content: >-
                Use <code>delete(m, key)</code> to remove a map entry. Check existence with the comma-ok pattern before
                deleting to know the return value.
            - title: ðŸ”§ Pattern
              content: |-
                <pre>1. Delete: check if key exists, delete it, return whether it existed
                2. Get: comma-ok lookup
                3. Set: simple assignment</pre>
          solution: |-
            type Cache struct {
                data map[string]string
            }

            func NewCache() *Cache {
                return &Cache{data: make(map[string]string)}
            }

            func (c *Cache) Get(key string) (string, bool) {
                val, ok := c.data[key]
                return val, ok
            }

            func (c *Cache) Set(key, value string) {
                c.data[key] = value
            }

            func (c *Cache) Delete(key string) bool {
                _, ok := c.data[key]
                if ok {
                    delete(c.data, key)
                }
                return ok
            }
          difficulty: 2
          annotations:
            - type: stdlib
              label: delete() Builtin
              text: >-
                The built-in <code>delete(m, key)</code> removes a key from a map. It is a no-op if the key does not
                exist and does not panic on nil maps.
            - type: gotcha
              label: Delete on Nil Map
              text: >-
                Calling <code>delete()</code> on a nil map does not panic, but reading from a nil map after construction
                could indicate a bug.
        - id: v4
          title: Cache with Size Limit
          description: >-
            Implement a <code>Cache</code> with a maximum capacity. <code>Set</code> should reject new keys (return
            false) when the cache is full. Updating existing keys is always allowed.
          functionSignature: func NewCache(maxSize int) *Cache
          testCases:
            - input: c := NewCache(2); c.Set("a", "1"); c.Set("b", "2"); c.Set("c", "3")
              output: true, true, false
            - input: c := NewCache(1); c.Set("a", "1"); c.Set("a", "2"); c.Get("a")
              output: true, true, ("2", true)
          hints:
            - title: ðŸ¤” Think about it
              content: >-
                How do you track the capacity? When should a Set be rejected vs allowed? What about updating an existing
                key?
            - title: ðŸ’¡ Hint
              content: >-
                Store <code>maxSize</code> in the struct. In Set, check if the key already exists (update is OK) or if
                <code>len(data) < maxSize</code> (room for new key).
            - title: ðŸ”§ Pattern
              content: |-
                <pre>1. Store maxSize in struct alongside the map
                2. Set: if key exists, update and return true
                3. Set: if len(map) >= maxSize, return false
                4. Set: otherwise, add and return true</pre>
          solution: |-
            type Cache struct {
                data    map[string]string
                maxSize int
            }

            func NewCache(maxSize int) *Cache {
                return &Cache{
                    data:    make(map[string]string),
                    maxSize: maxSize,
                }
            }

            func (c *Cache) Get(key string) (string, bool) {
                val, ok := c.data[key]
                return val, ok
            }

            func (c *Cache) Set(key, value string) bool {
                if _, ok := c.data[key]; ok {
                    c.data[key] = value
                    return true
                }
                if len(c.data) >= c.maxSize {
                    return false
                }
                c.data[key] = value
                return true
            }
          difficulty: 3
          annotations:
            - type: idiom
              label: len() on Maps
              text: >-
                The built-in <code>len()</code> returns the number of entries in a map, which is the idiomatic way to
                check map size.
            - type: pattern
              label: Capacity Guard
              text: >-
                Checking capacity before insertion is a common pattern for bounded data structures. In production,
                consider an LRU eviction policy instead of hard rejection.
    - id: challenge_2
      block: 1
      difficulty: 2
      concept: Generics
      docLinks:
        - url: https://go.dev/ref/spec#Type_parameter_declarations
          title: "Go Spec: Type parameters"
          note: generic type syntax
        - url: https://go.dev/blog/intro-generics
          title: "Go Blog: An Introduction To Generics"
          note: generics tutorial
      quickRef: |
        <code>func F[T any](s []T) T { }</code><br>
                <code>type Set[T comparable] map[T]struct{}{}</code>
      variants:
        - id: v1
          title: Generic Filter
          description: >-
            Write <code>func Filter[T any](items []T, pred func(T) bool) []T</code> that returns a new slice containing
            only elements for which the predicate returns true.
          functionSignature: func Filter[T any](items []T, pred func(T) bool) []T
          testCases:
            - input: Filter([]int{1, 2, 3, 4, 5}, func(n int) bool { return n%2 == 0 })
              output: "[]int{2, 4}"
            - input: Filter([]string{"go", "rust", "zig"}, func(s string) bool { return len(s) == 2 })
              output: "[]string{\"go\"}"
          hints:
            - title: ðŸ¤” Think about it
              content: How do you build a new slice from a subset of elements? What determines which elements to keep?
            - title: ðŸ’¡ Hint
              content: >-
                Create an empty result slice. Range over items, call <code>pred(item)</code>, and append if it returns
                true.
            - title: ðŸ”§ Pattern
              content: |-
                <pre>1. Create empty result slice
                2. For each item:
                   - Call pred(item)
                   - If true, append to result
                3. Return result</pre>
          solution: |-
            func Filter[T any](items []T, pred func(T) bool) []T {
                result := make([]T, 0)
                for _, item := range items {
                    if pred(item) {
                        result = append(result, item)
                    }
                }
                return result
            }
          difficulty: 2
          annotations:
            - type: idiom
              label: Generic Functions
              text: >-
                Go 1.18+ supports type parameters. <code>[T any]</code> means T can be any type. The function works with
                int, string, or any other type.
            - type: complexity
              label: O(n)
              text: Single pass through the slice. The predicate is called once per element.
        - id: v2
          title: Generic Map (Transform)
          description: >-
            Write <code>func Map[T any, U any](items []T, fn func(T) U) []U</code> that applies a transformation
            function to each element and returns a new slice.
          functionSignature: func Map[T any, U any](items []T, fn func(T) U) []U
          testCases:
            - input: Map([]int{1, 2, 3}, func(n int) int { return n * 2 })
              output: "[]int{2, 4, 6}"
            - input: Map([]string{"go", "rust"}, func(s string) int { return len(s) })
              output: "[]int{2, 4}"
          hints:
            - title: ðŸ¤” Think about it
              content: You need to transform each element from type T to type U. What does the result slice look like?
            - title: ðŸ’¡ Hint
              content: >-
                Pre-allocate <code>result := make([]U, len(items))</code> since you know the output size. Assign
                <code>result[i] = fn(items[i])</code>.
            - title: ðŸ”§ Pattern
              content: |-
                <pre>1. Allocate result slice of same length
                2. For each index and item:
                   - result[i] = fn(item)
                3. Return result</pre>
          solution: |-
            func Map[T any, U any](items []T, fn func(T) U) []U {
                result := make([]U, len(items))
                for i, item := range items {
                    result[i] = fn(item)
                }
                return result
            }
          difficulty: 2
          annotations:
            - type: idiom
              label: Two Type Parameters
              text: >-
                Generic functions can have multiple type parameters. <code>[T any, U any]</code> allows input and output
                to be different types.
            - type: alternative
              label: Pre-allocate vs Append
              text: >-
                When the output length equals the input length, pre-allocate with <code>make([]U, len(items))</code>
                instead of using append for better performance.
        - id: v3
          title: Generic Reduce
          description: >-
            Write <code>func Reduce[T any, U any](items []T, initial U, fn func(U, T) U) U</code> that reduces a slice
            to a single value by applying a function cumulatively.
          functionSignature: func Reduce[T any, U any](items []T, initial U, fn func(U, T) U) U
          testCases:
            - input: Reduce([]int{1, 2, 3, 4}, 0, func(acc, n int) int { return acc + n })
              output: "10"
            - input: Reduce([]string{"a", "b", "c"}, "", func(acc, s string) string { return acc + s })
              output: "\"abc\""
          hints:
            - title: ðŸ¤” Think about it
              content: >-
                You need to accumulate a result by processing each element. What is the starting value and how does it
                change with each element?
            - title: ðŸ’¡ Hint
              content: >-
                Start with <code>acc := initial</code>. For each item, update <code>acc = fn(acc, item)</code>. Return
                acc at the end.
            - title: ðŸ”§ Pattern
              content: |-
                <pre>1. Set accumulator = initial value
                2. For each item:
                   - accumulator = fn(accumulator, item)
                3. Return accumulator</pre>
          solution: |-
            func Reduce[T any, U any](items []T, initial U, fn func(U, T) U) U {
                acc := initial
                for _, item := range items {
                    acc = fn(acc, item)
                }
                return acc
            }
          difficulty: 3
          annotations:
            - type: pattern
              label: Fold/Reduce
              text: >-
                Reduce (also called fold) is a fundamental functional programming pattern. It can express sum, product,
                concatenation, and many other aggregations.
            - type: complexity
              label: O(n)
              text: Single pass through the slice. Total complexity depends on the provided function.
        - id: v4
          title: Generic Contains
          description: >-
            Write <code>func Contains[T comparable](items []T, target T) bool</code> that returns true if the target
            element is found in the slice.
          functionSignature: func Contains[T comparable](items []T, target T) bool
          testCases:
            - input: Contains([]int{1, 2, 3}, 2)
              output: "true"
            - input: Contains([]string{"go", "rust"}, "python")
              output: "false"
            - input: Contains([]int{}, 1)
              output: "false"
          hints:
            - title: ðŸ¤” Think about it
              content: Why does this function need the <code>comparable</code> constraint instead of <code>any</code>?
            - title: ðŸ’¡ Hint
              content: Loop through items, compare each with <code>==</code>. Return true on first match, false after the loop.
            - title: ðŸ”§ Pattern
              content: |-
                <pre>1. For each item:
                   - If item == target, return true
                2. Return false (not found)</pre>
          solution: |-
            func Contains[T comparable](items []T, target T) bool {
                for _, item := range items {
                    if item == target {
                        return true
                    }
                }
                return false
            }
          difficulty: 2
          annotations:
            - type: idiom
              label: Comparable Constraint
              text: >-
                The <code>comparable</code> constraint is needed because <code>==</code> is not defined for all types
                (e.g., slices, maps, functions cannot be compared).
            - type: stdlib
              label: slices.Contains
              text: >-
                Go 1.21+ provides <code>slices.Contains()</code> in the standard library, but implementing it yourself
                teaches the underlying pattern.
    - id: challenge_3
      block: 2
      difficulty: 3
      concept: Stacks
      docLinks:
        - url: https://go.dev/ref/spec#Slice_types
          title: "Go Spec: Slice types"
          note: slices as dynamic arrays for stacks
        - url: https://go.dev/ref/spec#Appending_and_copying_slices
          title: "Go Spec: Appending and copying slices"
          note: append for push, reslice for pop
      quickRef: |
        <code>stack = append(stack, v)</code> (push)<br>
                <code>v, stack = stack[len(stack)-1], stack[:len(stack)-1]</code> (pop)
      variants:
        - id: v1
          title: Balanced Brackets
          description: >-
            Write <code>func isBalanced(s string) bool</code> that checks if a string of brackets <code>()[]{}</code> is
            properly balanced. Non-bracket characters should be ignored.
          functionSignature: func isBalanced(s string) bool
          testCases:
            - input: "\"({[]})\""
              output: "true"
            - input: "\"([)]\""
              output: "false"
            - input: "\"((())\""
              output: "false"
            - input: "\"\""
              output: "true"
          hints:
            - title: ðŸ¤” Think about it
              content: >-
                When you see a closing bracket, what do you need to check? What data structure helps you remember the
                most recent unmatched opening bracket?
            - title: ðŸ’¡ Hint
              content: >-
                Use a slice as a stack. Push opening brackets, pop on closing brackets and check if they match. The
                stack should be empty at the end.
            - title: ðŸ”§ Pattern
              content: |-
                <pre>1. Create bracket pairs map: closing -> opening
                2. For each character:
                   - Opening bracket? Push to stack
                   - Closing bracket? Pop and verify match
                3. Return: is stack empty?</pre>
          solution: |-
            func isBalanced(s string) bool {
                stack := make([]rune, 0)
                pairs := map[rune]rune{')': '(', ']': '[', '}': '{'}

                for _, ch := range s {
                    switch ch {
                    case '(', '[', '{':
                        stack = append(stack, ch)
                    case ')', ']', '}':
                        if len(stack) == 0 || stack[len(stack)-1] != pairs[ch] {
                            return false
                        }
                        stack = stack[:len(stack)-1]
                    }
                }
                return len(stack) == 0
            }
          difficulty: 3
          annotations:
            - type: idiom
              label: Slice as Stack
              text: >-
                Go has no built-in stack type. Use a slice with <code>append()</code> for push and
                <code>s[:len(s)-1]</code> for pop.
            - type: complexity
              label: O(n)
              text: Single pass through the string. Each character is pushed and popped at most once.
        - id: v2
          title: Valid HTML Tags
          description: >-
            Write <code>func isValidHTML(s string) bool</code> that checks if simple HTML tags are properly nested. Tags
            are like <code>&lt;b&gt;</code> and <code>&lt;/b&gt;</code>. Self-closing tags and attributes are not used.
          functionSignature: func isValidHTML(s string) bool
          testCases:
            - input: "\"<b><i></i></b>\""
              output: "true"
            - input: "\"<b><i></b></i>\""
              output: "false"
            - input: "\"<p></p><div></div>\""
              output: "true"
            - input: "\"<p>\""
              output: "false"
          hints:
            - title: ðŸ¤” Think about it
              content: >-
                This is the bracket matching problem but with named tags. What needs to match when you encounter a
                closing tag?
            - title: ðŸ’¡ Hint
              content: >-
                Extract tag names between < and >. Push opening tags onto a stack. When you see a closing tag (starts
                with /), pop and check if the names match.
            - title: ðŸ”§ Pattern
              content: |-
                <pre>1. Parse tag names from the string
                2. For each tag:
                   - Opening tag? Push name to stack
                   - Closing tag? Pop and verify name matches
                3. Return: is stack empty?</pre>
          solution: |-
            func isValidHTML(s string) bool {
                stack := make([]string, 0)
                i := 0
                for i < len(s) {
                    if s[i] == '<' {
                        j := i + 1
                        for j < len(s) && s[j] != '>' {
                            j++
                        }
                        if j >= len(s) {
                            return false
                        }
                        tag := s[i+1 : j]
                        if len(tag) > 0 && tag[0] == '/' {
                            name := tag[1:]
                            if len(stack) == 0 || stack[len(stack)-1] != name {
                                return false
                            }
                            stack = stack[:len(stack)-1]
                        } else {
                            stack = append(stack, tag)
                        }
                        i = j + 1
                    } else {
                        i++
                    }
                }
                return len(stack) == 0
            }
          difficulty: 3
          annotations:
            - type: pattern
              label: Stack-Based Parsing
              text: >-
                Stacks are fundamental to parsing nested structures. Compilers and interpreters use this same pattern
                for syntax analysis.
            - type: gotcha
              label: String Slicing
              text: >-
                Go string slicing <code>s[i:j]</code> operates on bytes. For ASCII HTML tags this is fine, but be
                careful with Unicode content.
        - id: v3
          title: Reverse Polish Notation
          description: >-
            Write <code>func evalRPN(tokens []string) int</code> that evaluates an expression in Reverse Polish
            Notation. Supports <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code> (integer division).
          functionSignature: func evalRPN(tokens []string) int
          testCases:
            - input: "[]string{\"2\", \"3\", \"+\"}"
              output: "5"
            - input: "[]string{\"4\", \"13\", \"5\", \"/\", \"+\"}"
              output: "6"
            - input: "[]string{\"3\", \"4\", \"*\", \"2\", \"-\"}"
              output: "10"
          hints:
            - title: ðŸ¤” Think about it
              content: >-
                In RPN, operators act on the two most recent numbers. What data structure naturally gives you access to
                the most recent items?
            - title: ðŸ’¡ Hint
              content: >-
                Use a stack. Push numbers. When you see an operator, pop two numbers, apply the operator, push the
                result. The final answer is the last item on the stack.
            - title: ðŸ”§ Pattern
              content: |-
                <pre>1. For each token:
                   - Number? Parse and push to stack
                   - Operator? Pop b, pop a, push a op b
                2. Return top of stack</pre>
          solution: |-
            func evalRPN(tokens []string) int {
                stack := make([]int, 0)
                for _, tok := range tokens {
                    switch tok {
                    case "+", "-", "*", "/":
                        b := stack[len(stack)-1]
                        a := stack[len(stack)-2]
                        stack = stack[:len(stack)-2]
                        switch tok {
                        case "+":
                            stack = append(stack, a+b)
                        case "-":
                            stack = append(stack, a-b)
                        case "*":
                            stack = append(stack, a*b)
                        case "/":
                            stack = append(stack, a/b)
                        }
                    default:
                        n, _ := strconv.Atoi(tok)
                        stack = append(stack, n)
                    }
                }
                return stack[0]
            }
          difficulty: 3
          annotations:
            - type: pattern
              label: Stack-Based Evaluation
              text: >-
                RPN evaluation is a classic stack application. Calculators like the HP-48 use this notation because it
                eliminates the need for parentheses.
            - type: gotcha
              label: Operand Order
              text: >-
                When popping two operands, the first popped is the right operand (b) and the second is the left (a).
                Getting this wrong breaks subtraction and division.
            - type: complexity
              label: O(n)
              text: Each token is processed exactly once. Stack operations are O(1) amortized.
        - id: v4
          title: Min Stack
          description: >-
            Implement a <code>MinStack</code> that supports <code>Push(val int)</code>, <code>Pop() int</code>,
            <code>Top() int</code>, and <code>Min() int</code>. All operations must be O(1).
          functionSignature: func NewMinStack() *MinStack
          testCases:
            - input: s := NewMinStack(); s.Push(3); s.Push(1); s.Push(2); s.Min()
              output: "1"
            - input: s := NewMinStack(); s.Push(3); s.Push(1); s.Pop(); s.Min()
              output: "3"
          hints:
            - title: ðŸ¤” Think about it
              content: >-
                If you only track one minimum value, what happens when you pop that minimum? How can you remember the
                previous minimum?
            - title: ðŸ’¡ Hint
              content: >-
                Use two stacks: one for values and one for minimums. When pushing, also push the current minimum onto
                the min stack. When popping, pop from both.
            - title: ðŸ”§ Pattern
              content: |-
                <pre>1. Maintain two parallel stacks: values and mins
                2. Push: push value; push min(value, current min) to mins
                3. Pop: pop from both stacks
                4. Min: peek at top of mins stack</pre>
          solution: |-
            type MinStack struct {
                values []int
                mins   []int
            }

            func NewMinStack() *MinStack {
                return &MinStack{}
            }

            func (s *MinStack) Push(val int) {
                s.values = append(s.values, val)
                if len(s.mins) == 0 || val <= s.mins[len(s.mins)-1] {
                    s.mins = append(s.mins, val)
                } else {
                    s.mins = append(s.mins, s.mins[len(s.mins)-1])
                }
            }

            func (s *MinStack) Pop() int {
                val := s.values[len(s.values)-1]
                s.values = s.values[:len(s.values)-1]
                s.mins = s.mins[:len(s.mins)-1]
                return val
            }

            func (s *MinStack) Top() int {
                return s.values[len(s.values)-1]
            }

            func (s *MinStack) Min() int {
                return s.mins[len(s.mins)-1]
            }
          difficulty: 3
          annotations:
            - type: pattern
              label: Auxiliary Stack
              text: >-
                Using a parallel stack to track metadata (like minimums) is a classic pattern for achieving O(1)
                operations on additional properties.
            - type: complexity
              label: O(1) all ops
              text: Push, Pop, Top, and Min are all O(1) time. The trade-off is O(n) extra space for the mins stack.
            - type: alternative
              label: Space Optimization
              text: >-
                An optimization: only push to the min stack when the new value is less than or equal to the current min,
                and only pop from it when the popped value equals the current min.
