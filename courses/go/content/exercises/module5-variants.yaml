conceptLinks:
  Maps: "#lesson-maps"
  Structs & Methods: "#lesson-structs"
  Comma-Ok Pattern: "#lesson-comma-ok"
  make() Function: "#lesson-make"
sharedContent: {}
variants:
  warmups:
    - id: warmup_1
      concept: Maps
      variants:
        - id: v1
          title: Remove Duplicate Strings
          description: >-
            Write <code>func unique(items []string) []string</code> that removes duplicates from a string slice,
            preserving the original order.
          hints:
            - Use a <code>map[string]bool</code> to track which items you have already seen.
            - Only <code>append</code> to the result slice when the item is not in the map.
          solution: |-
            func unique(items []string) []string {
                seen := make(map[string]bool)
                result := make([]string, 0)
                for _, item := range items {
                    if !seen[item] {
                        seen[item] = true
                        result = append(result, item)
                    }
                }
                return result
            }
          annotations:
            - type: idiom
              label: Map as Set
              text: >-
                In Go, a <code>map[T]bool</code> is the idiomatic way to implement a set since Go has no built-in set
                type.
            - type: complexity
              label: O(n)
              text: Single pass through the slice with O(1) map lookups gives O(n) total time.
        - id: v2
          title: Remove Duplicate Integers
          description: >-
            Write <code>func uniqueInts(nums []int) []int</code> that removes duplicate integers from a slice,
            preserving the original order.
          hints:
            - Use a <code>map[int]bool</code> to track seen numbers.
            - Iterate with <code>range</code> and only append unseen values.
          solution: |-
            func uniqueInts(nums []int) []int {
                seen := make(map[int]bool)
                result := make([]int, 0)
                for _, n := range nums {
                    if !seen[n] {
                        seen[n] = true
                        result = append(result, n)
                    }
                }
                return result
            }
          annotations:
            - type: idiom
              label: Zero Value Lookup
              text: >-
                Accessing a missing map key returns the zero value (<code>false</code> for bool), so
                <code>!seen[n]</code> works without the comma-ok pattern.
            - type: gotcha
              label: Order Not Guaranteed
              text: >-
                Maps in Go have no guaranteed iteration order. Using a map as a 'seen' set while appending to a slice is
                how you preserve original order.
        - id: v3
          title: Unique Characters
          description: >-
            Write <code>func uniqueChars(s string) string</code> that returns a string with duplicate characters
            removed, preserving the first occurrence order.
          hints:
            - Convert the string to <code>[]rune</code> or iterate with <code>range</code> to handle Unicode.
            - Use a <code>map[rune]bool</code> to track seen characters.
          solution: |-
            func uniqueChars(s string) string {
                seen := make(map[rune]bool)
                result := make([]rune, 0)
                for _, ch := range s {
                    if !seen[ch] {
                        seen[ch] = true
                        result = append(result, ch)
                    }
                }
                return string(result)
            }
          annotations:
            - type: gotcha
              label: Rune vs Byte
              text: >-
                Iterating a string with <code>range</code> yields runes (Unicode code points), not bytes. This correctly
                handles multi-byte characters like emoji.
            - type: idiom
              label: Rune Slice Conversion
              text: >-
                Build a <code>[]rune</code> and convert back with <code>string(result)</code> to produce the final
                string.
        - id: v4
          title: Unique by Last Occurrence
          description: >-
            Write <code>func uniqueLast(items []string) []string</code> that removes duplicates but keeps the
            <strong>last</strong> occurrence of each item instead of the first.
          hints:
            - "One approach: iterate in reverse and use a seen map, then reverse the result."
            - "Another approach: first pass to record last index, second pass to collect."
          solution: |-
            func uniqueLast(items []string) []string {
                lastIdx := make(map[string]int)
                for i, item := range items {
                    lastIdx[item] = i
                }
                result := make([]string, 0)
                for i, item := range items {
                    if lastIdx[item] == i {
                        result = append(result, item)
                    }
                }
                return result
            }
          annotations:
            - type: alternative
              label: Reverse Approach
              text: An alternative is to iterate backward, use a seen map, collect items, then reverse the result slice.
            - type: complexity
              label: O(n)
              text: "Two passes through the slice: one to record last indices, one to collect. Both are O(n)."
  challenges:
    - id: challenge_1
      block: 1
      difficulty: 2
      concept: Structs & Methods
      docLinks:
        - url: https://go.dev/ref/spec#Method_declarations
          title: "Go Spec: Method declarations"
          note: defining methods on types
        - url: https://go.dev/doc/effective_go#methods
          title: "Effective Go: Methods"
          note: method design patterns
      variants:
        - id: v1
          title: Simple String Cache
          description: >-
            Implement a <code>Cache</code> struct with <code>Get(key string) (string, bool)</code> and <code>Set(key,
            value string)</code> methods. <code>Get</code> returns the value and whether the key exists.
          functionSignature: func NewCache() *Cache
          testCases:
            - input: c := NewCache(); c.Set("name", "Go"); c.Get("name")
              output: "\"Go\", true"
            - input: c := NewCache(); c.Get("missing")
              output: "\"\", false"
          hints:
            - title: ðŸ¤” Think about it
              content: What underlying data structure naturally maps keys to values? How do you check if a key exists in Go?
            - title: ðŸ’¡ Hint
              content: >-
                Use a struct wrapping a <code>map[string]string</code>. The comma-ok pattern <code>val, ok :=
                m[key]</code> gives you both the value and existence.
            - title: ðŸ”§ Pattern
              content: |-
                <pre>1. Define Cache struct with a map field
                2. NewCache initializes the map with make()
                3. Get uses comma-ok on the map
                4. Set assigns to the map</pre>
          solution: |-
            type Cache struct {
                data map[string]string
            }

            func NewCache() *Cache {
                return &Cache{data: make(map[string]string)}
            }

            func (c *Cache) Get(key string) (string, bool) {
                val, ok := c.data[key]
                return val, ok
            }

            func (c *Cache) Set(key, value string) {
                c.data[key] = value
            }
          difficulty: 2
          annotations:
            - type: idiom
              label: Constructor Function
              text: >-
                Go uses <code>NewXxx()</code> constructor functions instead of constructors. This ensures the internal
                map is properly initialized.
            - type: gotcha
              label: Uninitialized Map
              text: A struct with a map field has a nil map by default. Writing to it panics. Always provide a constructor.
        - id: v2
          title: Cache with Default Values
          description: >-
            Implement a <code>Cache</code> with <code>GetOrDefault(key, defaultVal string) string</code> and
            <code>Set(key, value string)</code>. If the key does not exist, return the provided default.
          functionSignature: func NewCache() *Cache
          testCases:
            - input: c := NewCache(); c.Set("lang", "Go"); c.GetOrDefault("lang", "Rust")
              output: "\"Go\""
            - input: c := NewCache(); c.GetOrDefault("lang", "Rust")
              output: "\"Rust\""
          hints:
            - title: ðŸ¤” Think about it
              content: >-
                How do you distinguish between a key that exists with an empty value and a key that does not exist at
                all?
            - title: ðŸ’¡ Hint
              content: Use the comma-ok pattern. If <code>ok</code> is false, return the default value instead.
            - title: ðŸ”§ Pattern
              content: |-
                <pre>1. Look up key with comma-ok
                2. If ok is true, return the stored value
                3. If ok is false, return the default value</pre>
          solution: |-
            type Cache struct {
                data map[string]string
            }

            func NewCache() *Cache {
                return &Cache{data: make(map[string]string)}
            }

            func (c *Cache) GetOrDefault(key, defaultVal string) string {
                if val, ok := c.data[key]; ok {
                    return val
                }
                return defaultVal
            }

            func (c *Cache) Set(key, value string) {
                c.data[key] = value
            }
          difficulty: 2
          annotations:
            - type: idiom
              label: Comma-Ok Pattern
              text: >-
                The comma-ok pattern <code>val, ok := m[key]</code> is idiomatic Go for distinguishing missing keys from
                zero values.
            - type: pattern
              label: Default Value Pattern
              text: >-
                Providing a default parameter is a common alternative to returning (value, bool) tuples when you always
                want a usable result.
        - id: v3
          title: Cache with Delete
          description: >-
            Implement a <code>Cache</code> with <code>Get(key string) (string, bool)</code>, <code>Set(key, value
            string)</code>, and <code>Delete(key string) bool</code>. Delete returns true if the key existed.
          functionSignature: func NewCache() *Cache
          testCases:
            - input: c := NewCache(); c.Set("a", "1"); c.Delete("a")
              output: "true"
            - input: c := NewCache(); c.Delete("missing")
              output: "false"
            - input: c := NewCache(); c.Set("a", "1"); c.Delete("a"); c.Get("a")
              output: "\"\", false"
          hints:
            - title: ðŸ¤” Think about it
              content: How do you remove a key from a map in Go? How can you tell if the key was there before you removed it?
            - title: ðŸ’¡ Hint
              content: >-
                Use <code>delete(m, key)</code> to remove a map entry. Check existence with the comma-ok pattern before
                deleting to know the return value.
            - title: ðŸ”§ Pattern
              content: |-
                <pre>1. Delete: check if key exists, delete it, return whether it existed
                2. Get: comma-ok lookup
                3. Set: simple assignment</pre>
          solution: |-
            type Cache struct {
                data map[string]string
            }

            func NewCache() *Cache {
                return &Cache{data: make(map[string]string)}
            }

            func (c *Cache) Get(key string) (string, bool) {
                val, ok := c.data[key]
                return val, ok
            }

            func (c *Cache) Set(key, value string) {
                c.data[key] = value
            }

            func (c *Cache) Delete(key string) bool {
                _, ok := c.data[key]
                if ok {
                    delete(c.data, key)
                }
                return ok
            }
          difficulty: 2
          annotations:
            - type: stdlib
              label: delete() Builtin
              text: >-
                The built-in <code>delete(m, key)</code> removes a key from a map. It is a no-op if the key does not
                exist and does not panic on nil maps.
            - type: gotcha
              label: Delete on Nil Map
              text: >-
                Calling <code>delete()</code> on a nil map does not panic, but reading from a nil map after construction
                could indicate a bug.
        - id: v4
          title: Cache with Size Limit
          description: >-
            Implement a <code>Cache</code> with a maximum capacity. <code>Set</code> should reject new keys (return
            false) when the cache is full. Updating existing keys is always allowed.
          functionSignature: func NewCache(maxSize int) *Cache
          testCases:
            - input: c := NewCache(2); c.Set("a", "1"); c.Set("b", "2"); c.Set("c", "3")
              output: true, true, false
            - input: c := NewCache(1); c.Set("a", "1"); c.Set("a", "2"); c.Get("a")
              output: true, true, ("2", true)
          hints:
            - title: ðŸ¤” Think about it
              content: >-
                How do you track the capacity? When should a Set be rejected vs allowed? What about updating an existing
                key?
            - title: ðŸ’¡ Hint
              content: >-
                Store <code>maxSize</code> in the struct. In Set, check if the key already exists (update is OK) or if
                <code>len(data) < maxSize</code> (room for new key).
            - title: ðŸ”§ Pattern
              content: |-
                <pre>1. Store maxSize in struct alongside the map
                2. Set: if key exists, update and return true
                3. Set: if len(map) >= maxSize, return false
                4. Set: otherwise, add and return true</pre>
          solution: |-
            type Cache struct {
                data    map[string]string
                maxSize int
            }

            func NewCache(maxSize int) *Cache {
                return &Cache{
                    data:    make(map[string]string),
                    maxSize: maxSize,
                }
            }

            func (c *Cache) Get(key string) (string, bool) {
                val, ok := c.data[key]
                return val, ok
            }

            func (c *Cache) Set(key, value string) bool {
                if _, ok := c.data[key]; ok {
                    c.data[key] = value
                    return true
                }
                if len(c.data) >= c.maxSize {
                    return false
                }
                c.data[key] = value
                return true
            }
          difficulty: 3
          annotations:
            - type: idiom
              label: len() on Maps
              text: >-
                The built-in <code>len()</code> returns the number of entries in a map, which is the idiomatic way to
                check map size.
            - type: pattern
              label: Capacity Guard
              text: >-
                Checking capacity before insertion is a common pattern for bounded data structures. In production,
                consider an LRU eviction policy instead of hard rejection.
