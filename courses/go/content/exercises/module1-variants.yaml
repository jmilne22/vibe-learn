conceptLinks:
  Variable Declaration: "#lesson-variables"
  Type Conversion: "#lesson-variables"
  Function Basics: "#lesson-functions"
  Multiple Returns: "#lesson-functions"
  For Loops: "#lesson-loops"
  If/Else: "#lesson-if"

sharedContent: {}

variants:
  warmups:
    # ── warmup_1: For Loops ──────────────────────────────────────────────
    - id: warmup_1
      concept: For Loops
      variants:
        - id: v1
          title: Print 1 to 10
          description: >-
            Write a program that prints the numbers 1 through 10, one per line, using a classic
            <code>for</code> loop with an index variable.
          hints:
            - "Use <code>for i := 1; i &lt;= 10; i++</code>"
            - "Print each number with <code>fmt.Println(i)</code>"
          solution: |-
            for i := 1; i <= 10; i++ {
                fmt.Println(i)
            }

        - id: v2
          title: Print Server Names
          description: >-
            Given the slice <code>servers := []string{"web-01", "web-02", "db-01", "cache-01"}</code>,
            use a <code>range</code> loop to print each server with its index, like
            <code>0: web-01</code>.
          hints:
            - "Use <code>for i, name := range servers</code>"
            - "Print with <code>fmt.Printf(\"%d: %s\\n\", i, name)</code>"
          solution: |-
            servers := []string{"web-01", "web-02", "db-01", "cache-01"}
            for i, name := range servers {
                fmt.Printf("%d: %s\n", i, name)
            }

        - id: v3
          title: Alert Countdown
          description: >-
            Write a program that counts down from 10 to 1. On multiples of 3, print
            <code>ALERT!</code> instead of the number.
          hints:
            - "Use <code>for i := 10; i >= 1; i--</code>"
            - "Check multiples with <code>if i % 3 == 0</code>"
          solution: |-
            for i := 10; i >= 1; i-- {
                if i%3 == 0 {
                    fmt.Println("ALERT!")
                } else {
                    fmt.Println(i)
                }
            }

        - id: v4
          title: Multiplication Table
          description: >-
            Write a program that prints a 3x3 multiplication table. For rows 1-3 and columns 1-3,
            print each product separated by a tab, with a newline after each row.
            Output should look like:<br><code>1  2  3</code><br><code>2  4  6</code><br><code>3  6  9</code>
          hints:
            - "Use a nested loop: outer for rows, inner for columns"
            - "Use <code>fmt.Printf(\"%d\\t\", i*j)</code> for each cell and <code>fmt.Println()</code> after each row"
          solution: |-
            for i := 1; i <= 3; i++ {
                for j := 1; j <= 3; j++ {
                    fmt.Printf("%d\t", i*j)
                }
                fmt.Println()
            }

    # ── warmup_2: If/Else ────────────────────────────────────────────────
    - id: warmup_2
      concept: If/Else
      variants:
        - id: v1
          title: Privileged Port Check
          description: >-
            Write <code>func isPrivileged(port int) string</code> that returns
            <code>"privileged"</code> if the port is less than 1024, or
            <code>"unprivileged"</code> otherwise.
          hints:
            - "Ports below 1024 are privileged: <code>if port &lt; 1024</code>"
          solution: |-
            func isPrivileged(port int) string {
                if port < 1024 {
                    return "privileged"
                }
                return "unprivileged"
            }

        - id: v2
          title: HTTP Status Classifier
          description: >-
            Write <code>func classifyStatus(code int) string</code> that returns
            <code>"success"</code> for 200-299, <code>"redirect"</code> for 300-399,
            <code>"client error"</code> for 400-499, <code>"server error"</code> for 500-599,
            or <code>"unknown"</code> for anything else.
          hints:
            - "Use <code>if/else if</code> chains to check ranges"
            - "Check <code>code >= 200 && code &lt;= 299</code> for success, etc."
          solution: |-
            func classifyStatus(code int) string {
                if code >= 200 && code <= 299 {
                    return "success"
                } else if code >= 300 && code <= 399 {
                    return "redirect"
                } else if code >= 400 && code <= 499 {
                    return "client error"
                } else if code >= 500 && code <= 599 {
                    return "server error"
                }
                return "unknown"
            }

        - id: v3
          title: Valid Log Level
          description: >-
            Write <code>func isValidLevel(level string) bool</code> that returns
            <code>true</code> if level is one of <code>"INFO"</code>, <code>"WARN"</code>,
            <code>"ERROR"</code>, or <code>"DEBUG"</code>. Use compound conditions with
            <code>||</code>.
          hints:
            - "Use <code>if level == \"INFO\" || level == \"WARN\" || ...</code>"
            - "Return <code>true</code> inside the if, <code>false</code> at the end"
          solution: |-
            func isValidLevel(level string) bool {
                if level == "INFO" || level == "WARN" || level == "ERROR" || level == "DEBUG" {
                    return true
                }
                return false
            }

        - id: v4
          title: Validate Config Value
          description: >-
            Write <code>func validateConfig(value string) string</code> that checks a config value
            and returns an error message or <code>"ok"</code>. Return <code>"empty"</code> if the
            string is empty, <code>"too long"</code> if longer than 64 characters,
            <code>"has spaces"</code> if it contains a space (use <code>strings.Contains</code>),
            or <code>"ok"</code> if it passes all checks.
          hints:
            - "Use early returns — check the simplest conditions first"
            - "Use <code>strings.Contains(value, \" \")</code> to check for spaces"
            - "Use <code>len(value)</code> to check length"
          solution: |-
            func validateConfig(value string) string {
                if value == "" {
                    return "empty"
                }
                if len(value) > 64 {
                    return "too long"
                }
                if strings.Contains(value, " ") {
                    return "has spaces"
                }
                return "ok"
            }

  challenges:
    # ── challenge_1: Variable Declaration ────────────────────────────────
    - id: challenge_1
      block: 1
      difficulty: 1
      concept: Variable Declaration
      docLinks:
        - url: https://go.dev/tour/basics/9
          title: "Go Tour: Short variable declarations"
          note: := syntax
        - url: https://go.dev/ref/spec#Short_variable_declarations
          title: "Go Spec: Short variable declarations"
          note: specification details
      variants:
        - id: v1
          title: Declare and Return Integer
          description: Write <code>func declareInt() int</code> that uses <code>:=</code> to declare <code>x</code> as 42 and return it.
          functionSignature: func declareInt() int
          difficulty: 1
          testCases:
            - input: "declareInt()"
              output: "42"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                The := operator declares a new variable and infers its type from the value on the right side. What value do you need to assign?
            - title: "\U0001F4A1 Hint"
              content: >-
                Use <code>x := 42</code> to declare and initialize x, then return it.
          solution: |-
            func declareInt() int {
                x := 42
                return x
            }
          annotations:
            - type: idiom
              label: Short Declaration
              text: >-
                The <code>:=</code> operator is Go's most common way to declare variables inside functions.
                The compiler infers the type from the value on the right.

        - id: v2
          title: Declare and Concatenate
          description: >-
            Write <code>func fullGreeting() string</code> that declares <code>greeting := "Hello"</code> and
            <code>target := "Gopher"</code> on separate lines, then returns them joined with a space.
          functionSignature: func fullGreeting() string
          difficulty: 1
          testCases:
            - input: "fullGreeting()"
              output: "\"Hello Gopher\""
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                You can use := multiple times in the same function. How do you join two strings with a space between them?
            - title: "\U0001F4A1 Hint"
              content: >-
                Declare both variables, then <code>return greeting + " " + target</code>.
          solution: |-
            func fullGreeting() string {
                greeting := "Hello"
                target := "Gopher"
                return greeting + " " + target
            }

        - id: v3
          title: Zero Values
          description: >-
            Write <code>func zeroValues() (int, string, bool)</code> that uses <code>var</code> to
            declare an int, string, and bool <em>without</em> assigning values, then returns all three.
            This demonstrates Go's zero-value guarantee.
          functionSignature: func zeroValues() (int, string, bool)
          difficulty: 2
          testCases:
            - input: "zeroValues()"
              output: "0, \"\", false"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                When you use <code>var x int</code> without assigning a value, Go initializes it to the zero value for that type. What are the zero values for int, string, and bool?
            - title: "\U0001F4A1 Hint"
              content: >-
                Use <code>var n int</code>, <code>var s string</code>, <code>var b bool</code>, then return all three.
          solution: |-
            func zeroValues() (int, string, bool) {
                var n int
                var s string
                var b bool
                return n, s, b
            }
          annotations:
            - type: idiom
              label: Zero Values
              text: >-
                Go guarantees every variable has a well-defined initial value. For numeric types it's 0,
                for strings it's <code>""</code>, and for bools it's <code>false</code>. This eliminates
                an entire class of "uninitialized variable" bugs.

        - id: v4
          title: Multi-Assignment Swap
          description: >-
            Write <code>func swap(a, b int) (int, int)</code> that uses multi-assignment
            (<code>a, b = b, a</code>) to swap the values and return them.
          functionSignature: func swap(a, b int) (int, int)
          difficulty: 2
          testCases:
            - input: "swap(10, 20)"
              output: "20, 10"
            - input: "swap(-1, 1)"
              output: "1, -1"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                Go evaluates the right side of an assignment fully before writing to the left side. This means you can swap without a temp variable.
            - title: "\U0001F4A1 Hint"
              content: >-
                Use <code>a, b = b, a</code> — Go's parallel assignment handles the swap.
          solution: |-
            func swap(a, b int) (int, int) {
                a, b = b, a
                return a, b
            }
          annotations:
            - type: idiom
              label: Parallel Assignment
              text: >-
                Go evaluates all right-hand values before assigning, so <code>a, b = b, a</code> swaps
                without needing a temporary variable.

    # ── challenge_2: Type Conversion ─────────────────────────────────────
    - id: challenge_2
      block: 1
      difficulty: 1
      concept: Type Conversion
      docLinks:
        - url: https://go.dev/tour/basics/13
          title: "Go Tour: Type conversions"
          note: basic conversion syntax
        - url: https://pkg.go.dev/strconv
          title: "Package strconv"
          note: string/number conversions
      variants:
        - id: v1
          title: Int to String
          description: >-
            Write <code>func intToString(n int) string</code> that converts an integer to its string
            representation using <code>strconv.Itoa</code>.
          functionSignature: func intToString(n int) string
          difficulty: 1
          testCases:
            - input: "intToString(42)"
              output: "\"42\""
            - input: "intToString(-7)"
              output: "\"-7\""
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                <code>strconv.Itoa</code> converts an int to its ASCII string representation. Don't confuse it with <code>string(n)</code>, which treats n as a Unicode code point.
            - title: "\U0001F4A1 Hint"
              content: >-
                <code>return strconv.Itoa(n)</code>
          solution: |-
            func intToString(n int) string {
                return strconv.Itoa(n)
            }
          annotations:
            - type: gotcha
              label: string(int) Trap
              text: >-
                <code>string(65)</code> gives <code>"A"</code> (the Unicode character), not <code>"65"</code>.
                Always use <code>strconv.Itoa</code> to convert numbers to their string representation.

        - id: v2
          title: String to Int
          description: >-
            Write <code>func stringToInt(s string) (int, error)</code> that converts a string to an
            integer using <code>strconv.Atoi</code>. Return both the value and the error.
          functionSignature: func stringToInt(s string) (int, error)
          difficulty: 1
          testCases:
            - input: "stringToInt(\"123\")"
              output: "123, nil"
            - input: "stringToInt(\"abc\")"
              output: "0, error"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                <code>strconv.Atoi</code> returns two values: the parsed integer and an error. What happens when the input isn't a valid number?
            - title: "\U0001F4A1 Hint"
              content: >-
                <code>return strconv.Atoi(s)</code> — it already returns (int, error).
          solution: |-
            func stringToInt(s string) (int, error) {
                return strconv.Atoi(s)
            }
          annotations:
            - type: idiom
              label: Error Returns
              text: >-
                Go's convention is to return errors as the last value. <code>strconv.Atoi</code> returns
                <code>(int, error)</code> — callers must check the error before using the value.

        - id: v3
          title: Float Truncation vs Round
          description: >-
            Write <code>func truncateAndRound(f float64) (int, int)</code> that returns two values:
            the result of <code>int(f)</code> (truncation) and <code>int(math.Round(f))</code> (rounding).
          functionSignature: func truncateAndRound(f float64) (int, int)
          difficulty: 2
          testCases:
            - input: "truncateAndRound(3.7)"
              output: "3, 4"
            - input: "truncateAndRound(-2.3)"
              output: "-2, -2"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                <code>int(f)</code> truncates toward zero — it just drops the decimal. <code>math.Round(f)</code> rounds to the nearest integer. They give different results for most inputs.
            - title: "\U0001F4A1 Hint"
              content: >-
                Return <code>int(f), int(math.Round(f))</code>.
          solution: |-
            func truncateAndRound(f float64) (int, int) {
                return int(f), int(math.Round(f))
            }
          annotations:
            - type: gotcha
              label: Truncation Surprise
              text: >-
                <code>int(3.9)</code> is <code>3</code>, not <code>4</code>. Go truncates toward zero,
                which catches many newcomers. Use <code>math.Round</code> when you want rounding.

        - id: v4
          title: Chain Conversions
          description: >-
            Write <code>func doubleString(s string) (string, error)</code> that parses a numeric string,
            doubles it, and returns the result as a string. Return an error if the input isn't a valid integer.
          functionSignature: func doubleString(s string) (string, error)
          difficulty: 2
          testCases:
            - input: "doubleString(\"21\")"
              output: "\"42\", nil"
            - input: "doubleString(\"abc\")"
              output: "\"\", error"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                You need three steps: parse string → do math → format back to string. Handle the error from parsing.
            - title: "\U0001F4A1 Hint"
              content: >-
                Use <code>strconv.Atoi</code> to parse, multiply by 2, then <code>strconv.Itoa</code> to convert back.
          solution: |-
            func doubleString(s string) (string, error) {
                n, err := strconv.Atoi(s)
                if err != nil {
                    return "", err
                }
                return strconv.Itoa(n * 2), nil
            }
          annotations:
            - type: pattern
              label: Parse-Process-Format
              text: >-
                A common pattern: parse input → process → format output. Always handle the parse error
                before proceeding to the processing step.

    # ── challenge_3: Function Basics (Log Parser Begins) ────────────────
    - id: challenge_3
      block: 1
      difficulty: 1
      concept: Function Basics
      docLinks:
        - url: https://go.dev/tour/moretypes/2
          title: "Go Tour: Functions"
          note: function syntax
        - url: https://pkg.go.dev/strings
          title: "Package strings"
          note: string manipulation functions
      variants:
        - id: v1
          title: Format Log Entry
          description: >-
            Write <code>func formatLogEntry(level, message string) string</code> that returns a
            formatted log string like <code>"[ERROR] connection timeout"</code>. Wrap the level
            in square brackets, followed by a space and the message.
          functionSignature: func formatLogEntry(level, message string) string
          difficulty: 1
          testCases:
            - input: "formatLogEntry(\"ERROR\", \"connection timeout\")"
              output: "\"[ERROR] connection timeout\""
            - input: "formatLogEntry(\"INFO\", \"server started\")"
              output: "\"[INFO] server started\""
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                You need to build a string with brackets around the level. How do you concatenate strings in Go?
            - title: "\U0001F4A1 Hint"
              content: >-
                Use <code>fmt.Sprintf("[%s] %s", level, message)</code> or string concatenation.
          solution: |-
            func formatLogEntry(level, message string) string {
                return fmt.Sprintf("[%s] %s", level, message)
            }
          annotations:
            - type: idiom
              label: fmt.Sprintf
              text: >-
                <code>fmt.Sprintf</code> is Go's string formatting function — like <code>Printf</code>
                but returns a string instead of printing. It's the idiomatic way to build formatted strings.

        - id: v2
          title: Is Error Level
          description: >-
            Write <code>func isError(level string) bool</code> that returns <code>true</code>
            if the level is <code>"ERROR"</code> or <code>"FATAL"</code>, and <code>false</code> otherwise.
          functionSignature: func isError(level string) bool
          difficulty: 1
          testCases:
            - input: "isError(\"ERROR\")"
              output: "true"
            - input: "isError(\"FATAL\")"
              output: "true"
            - input: "isError(\"INFO\")"
              output: "false"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                You need to check if the level matches either of two values. Use <code>||</code> to combine conditions.
            - title: "\U0001F4A1 Hint"
              content: >-
                <code>return level == "ERROR" || level == "FATAL"</code>
          solution: |-
            func isError(level string) bool {
                return level == "ERROR" || level == "FATAL"
            }

        - id: v3
          title: Truncate Message
          description: >-
            Write <code>func truncateMessage(msg string, maxLen int) string</code>. If the message
            is longer than <code>maxLen</code>, return the first <code>maxLen</code> characters followed
            by <code>"..."</code>. Otherwise return the message unchanged.
          functionSignature: func truncateMessage(msg string, maxLen int) string
          difficulty: 2
          testCases:
            - input: "truncateMessage(\"connection timeout after 30s\", 10)"
              output: "\"connection...\""
            - input: "truncateMessage(\"ok\", 10)"
              output: "\"ok\""
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                Use <code>len(msg)</code> to check the length. Slice the string with <code>msg[:maxLen]</code> to get the first N characters.
            - title: "\U0001F4A1 Hint"
              content: >-
                <code>if len(msg) > maxLen { return msg[:maxLen] + "..." }</code>
          solution: |-
            func truncateMessage(msg string, maxLen int) string {
                if len(msg) > maxLen {
                    return msg[:maxLen] + "..."
                }
                return msg
            }

        - id: v4
          title: Extract Timestamp
          description: >-
            Write <code>func extractTimestamp(line string) string</code>. Log lines start with a
            timestamp in the format <code>"2024-01-15 10:30:45"</code> (19 characters). Return the
            first 19 characters of the line. If the line is shorter than 19 characters, return the
            entire line.
          functionSignature: func extractTimestamp(line string) string
          difficulty: 2
          testCases:
            - input: "extractTimestamp(\"2024-01-15 10:30:45 ERROR connection timeout\")"
              output: "\"2024-01-15 10:30:45\""
            - input: "extractTimestamp(\"short\")"
              output: "\"short\""
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                You need to safely slice the string. What happens if you try <code>line[:19]</code> on a string shorter than 19 characters?
            - title: "\U0001F4A1 Hint"
              content: >-
                Check <code>len(line) &lt; 19</code> first to avoid a slice bounds panic.
          solution: |-
            func extractTimestamp(line string) string {
                if len(line) < 19 {
                    return line
                }
                return line[:19]
            }
          annotations:
            - type: gotcha
              label: Slice Bounds
              text: >-
                Slicing beyond a string's length causes a runtime panic. Always check
                <code>len(s)</code> before slicing with a fixed index.

    # ── challenge_4: Multiple Returns & Error Handling (Log Parser) ─────
    - id: challenge_4
      block: 2
      difficulty: 2
      concept: Multiple Returns
      docLinks:
        - url: https://go.dev/tour/moretypes/6
          title: "Go Tour: Multiple results"
          note: returning multiple values
        - url: https://go.dev/blog/error-handling-and-go
          title: "Error handling and Go"
          note: idiomatic error handling
      variants:
        - id: v1
          title: Parse Log Level
          description: >-
            Write <code>func parseLogLevel(line string) (string, error)</code>. A log line has the
            format <code>"2024-01-15 10:30:45 ERROR connection timeout"</code>. Extract the log level
            (the word after the timestamp, at index 20). Return an error if the line has fewer than
            21 characters. Use <code>strings.Fields</code> to split or slice at known positions.
          functionSignature: func parseLogLevel(line string) (string, error)
          difficulty: 1
          testCases:
            - input: "parseLogLevel(\"2024-01-15 10:30:45 ERROR connection timeout\")"
              output: "\"ERROR\", nil"
            - input: "parseLogLevel(\"short\")"
              output: "\"\", error"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                The timestamp is 19 characters, then a space, then the level. Use <code>strings.Fields</code> to split or
                index from position 20.
            - title: "\U0001F4A1 Hint"
              content: >-
                Split with <code>fields := strings.Fields(line)</code> and check <code>len(fields) >= 3</code>.
                The level is <code>fields[2]</code> (index 0 = date, 1 = time, 2 = level).
          solution: |-
            func parseLogLevel(line string) (string, error) {
                fields := strings.Fields(line)
                if len(fields) < 3 {
                    return "", fmt.Errorf("malformed log line: too short")
                }
                return fields[2], nil
            }
          annotations:
            - type: idiom
              label: Error Returns
              text: >-
                Go functions signal failure by returning an <code>error</code> as the last value.
                Callers check <code>if err != nil</code> before using the result.

        - id: v2
          title: Split Log Line
          description: >-
            Write <code>func splitLogLine(line string) (string, string, string, error)</code>.
            Split a log line into its three parts: timestamp (first two fields joined with a space),
            level (third field), and message (everything else). Return an error if the line has
            fewer than 4 fields.
          functionSignature: func splitLogLine(line string) (string, string, string, error)
          difficulty: 2
          testCases:
            - input: "splitLogLine(\"2024-01-15 10:30:45 ERROR connection timeout\")"
              output: "\"2024-01-15 10:30:45\", \"ERROR\", \"connection timeout\", nil"
            - input: "splitLogLine(\"bad line\")"
              output: "\"\", \"\", \"\", error"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                Use <code>strings.Fields</code> to split the line, then reassemble the parts.
                The timestamp is fields[0] + " " + fields[1], level is fields[2], message is the rest joined.
            - title: "\U0001F4A1 Hint"
              content: >-
                Use <code>strings.Join(fields[3:], " ")</code> to reconstruct the message from the remaining fields.
          solution: |-
            func splitLogLine(line string) (string, string, string, error) {
                fields := strings.Fields(line)
                if len(fields) < 4 {
                    return "", "", "", fmt.Errorf("malformed log line: need at least 4 fields, got %d", len(fields))
                }
                timestamp := fields[0] + " " + fields[1]
                level := fields[2]
                message := strings.Join(fields[3:], " ")
                return timestamp, level, message, nil
            }
          annotations:
            - type: pattern
              label: Destructure & Validate
              text: >-
                Split input into parts, validate you have enough parts, then work with them.
                This pattern prevents index-out-of-bounds panics.

        - id: v3
          title: Parse Port Number
          description: >-
            Write <code>func parsePort(s string) (int, error)</code>. Parse a string to an integer.
            Return an error if it's not a valid integer or if the port is outside the range 1–65535.
          functionSignature: func parsePort(s string) (int, error)
          difficulty: 2
          testCases:
            - input: "parsePort(\"8080\")"
              output: "8080, nil"
            - input: "parsePort(\"0\")"
              output: "0, error"
            - input: "parsePort(\"99999\")"
              output: "0, error"
            - input: "parsePort(\"abc\")"
              output: "0, error"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                Use <code>strconv.Atoi</code> first, then validate the range. Return different errors for each failure case.
            - title: "\U0001F4A1 Hint"
              content: >-
                Parse with <code>strconv.Atoi</code>, check <code>err != nil</code>, then check <code>port &lt; 1 || port > 65535</code>.
          solution: |-
            func parsePort(s string) (int, error) {
                port, err := strconv.Atoi(s)
                if err != nil {
                    return 0, fmt.Errorf("invalid port %q: %w", s, err)
                }
                if port < 1 || port > 65535 {
                    return 0, fmt.Errorf("port %d out of range 1-65535", port)
                }
                return port, nil
            }
          annotations:
            - type: idiom
              label: Error Wrapping
              text: >-
                Use <code>%w</code> in <code>fmt.Errorf</code> to wrap errors. This preserves the original
                error while adding context, enabling callers to use <code>errors.Is</code> and <code>errors.As</code>.

        - id: v4
          title: Safe Map Lookup
          description: >-
            Write <code>func safeLookup(m map[string]string, key string) (string, bool)</code>.
            Look up the key in the map using the comma-ok pattern and return both values.
          functionSignature: func safeLookup(m map[string]string, key string) (string, bool)
          difficulty: 1
          testCases:
            - input: "safeLookup(map[string]string{\"host\": \"localhost\"}, \"host\")"
              output: "\"localhost\", true"
            - input: "safeLookup(map[string]string{\"host\": \"localhost\"}, \"port\")"
              output: "\"\", false"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                Go maps return two values when accessed with <code>val, ok := m[key]</code>. The second value indicates whether the key was found.
            - title: "\U0001F4A1 Hint"
              content: >-
                <code>val, ok := m[key]; return val, ok</code>
          solution: |-
            func safeLookup(m map[string]string, key string) (string, bool) {
                val, ok := m[key]
                return val, ok
            }
          annotations:
            - type: idiom
              label: Comma-Ok Pattern
              text: >-
                The comma-ok pattern — <code>val, ok := m[key]</code> — is how Go distinguishes between
                "key not found" and "key exists with zero value". You'll see this pattern with maps,
                type assertions, and channel receives.
