conceptLinks:
  Variable Declaration: "#lesson-variables"
  Type Conversion: "#lesson-variables"
  Function Basics: "#lesson-functions"
  Multiple Returns: "#lesson-functions"
  For Loops: "#lesson-loops"
  If/Else: "#lesson-if"

sharedContent: {}

variants:
  warmups:
    # ── warmup_1: For Loops ──────────────────────────────────────────────
    - id: warmup_1
      concept: For Loops
      variants:
        - id: v1
          title: Print 1 to 10
          description: >-
            Write a program that prints the numbers 1 through 10, one per line, using a classic
            <code>for</code> loop with an index variable.
          hints:
            - "Use <code>for i := 1; i &lt;= 10; i++</code>"
            - "Print each number with <code>fmt.Println(i)</code>"
          solution: |-
            for i := 1; i <= 10; i++ {
                fmt.Println(i)
            }

        - id: v2
          title: Print Server Names
          description: >-
            Given the slice <code>servers := []string{"web-01", "web-02", "db-01", "cache-01"}</code>,
            use a <code>range</code> loop to print each server with its index, like
            <code>0: web-01</code>.
          hints:
            - "Use <code>for i, name := range servers</code>"
            - "Print with <code>fmt.Printf(\"%d: %s\\n\", i, name)</code>"
          solution: |-
            servers := []string{"web-01", "web-02", "db-01", "cache-01"}
            for i, name := range servers {
                fmt.Printf("%d: %s\n", i, name)
            }

        - id: v3
          title: Alert Countdown
          description: >-
            Write a program that counts down from 10 to 1. On multiples of 3, print
            <code>ALERT!</code> instead of the number.
          hints:
            - "Use <code>for i := 10; i >= 1; i--</code>"
            - "Check multiples with <code>if i % 3 == 0</code>"
          solution: |-
            for i := 10; i >= 1; i-- {
                if i%3 == 0 {
                    fmt.Println("ALERT!")
                } else {
                    fmt.Println(i)
                }
            }

        - id: v4
          title: Multiplication Table
          description: >-
            Write a program that prints a 3x3 multiplication table. For rows 1-3 and columns 1-3,
            print each product separated by a tab, with a newline after each row.
            Output should look like:<br><code>1  2  3</code><br><code>2  4  6</code><br><code>3  6  9</code>
          hints:
            - "Use a nested loop: outer for rows, inner for columns"
            - "Use <code>fmt.Printf(\"%d\\t\", i*j)</code> for each cell and <code>fmt.Println()</code> after each row"
          solution: |-
            for i := 1; i <= 3; i++ {
                for j := 1; j <= 3; j++ {
                    fmt.Printf("%d\t", i*j)
                }
                fmt.Println()
            }

    # ── warmup_2: If/Else ────────────────────────────────────────────────
    - id: warmup_2
      concept: If/Else
      variants:
        - id: v1
          title: Privileged Port Check
          description: >-
            Write <code>func isPrivileged(port int) string</code> that returns
            <code>"privileged"</code> if the port is less than 1024, or
            <code>"unprivileged"</code> otherwise.
          hints:
            - "Ports below 1024 are privileged: <code>if port &lt; 1024</code>"
          solution: |-
            func isPrivileged(port int) string {
                if port < 1024 {
                    return "privileged"
                }
                return "unprivileged"
            }

        - id: v2
          title: HTTP Status Classifier
          description: >-
            Write <code>func classifyStatus(code int) string</code> that returns
            <code>"success"</code> for 200-299, <code>"redirect"</code> for 300-399,
            <code>"client error"</code> for 400-499, <code>"server error"</code> for 500-599,
            or <code>"unknown"</code> for anything else.
          hints:
            - "Use <code>if/else if</code> chains to check ranges"
            - "Check <code>code >= 200 && code &lt;= 299</code> for success, etc."
          solution: |-
            func classifyStatus(code int) string {
                if code >= 200 && code <= 299 {
                    return "success"
                } else if code >= 300 && code <= 399 {
                    return "redirect"
                } else if code >= 400 && code <= 499 {
                    return "client error"
                } else if code >= 500 && code <= 599 {
                    return "server error"
                }
                return "unknown"
            }

        - id: v3
          title: Valid Card Suit
          description: >-
            Write <code>func isValidSuit(suit string) bool</code> that returns
            <code>true</code> if suit is one of <code>"hearts"</code>, <code>"diamonds"</code>,
            <code>"clubs"</code>, or <code>"spades"</code>. Use compound conditions with
            <code>||</code>.
          hints:
            - "Use <code>if suit == \"hearts\" || suit == \"diamonds\" || ...</code>"
            - "Return <code>true</code> inside the if, <code>false</code> at the end"
          solution: |-
            func isValidSuit(suit string) bool {
                if suit == "hearts" || suit == "diamonds" || suit == "clubs" || suit == "spades" {
                    return true
                }
                return false
            }

        - id: v4
          title: Validate Config Value
          description: >-
            Write <code>func validateConfig(value string) string</code> that checks a config value
            and returns an error message or <code>"ok"</code>. Return <code>"empty"</code> if the
            string is empty, <code>"too long"</code> if longer than 64 characters,
            <code>"has spaces"</code> if it contains a space (use <code>strings.Contains</code>),
            or <code>"ok"</code> if it passes all checks.
          hints:
            - "Use early returns — check the simplest conditions first"
            - "Use <code>strings.Contains(value, \" \")</code> to check for spaces"
            - "Use <code>len(value)</code> to check length"
          solution: |-
            func validateConfig(value string) string {
                if value == "" {
                    return "empty"
                }
                if len(value) > 64 {
                    return "too long"
                }
                if strings.Contains(value, " ") {
                    return "has spaces"
                }
                return "ok"
            }

  challenges:
    # ── challenge_1: Variable Declaration ────────────────────────────────
    - id: challenge_1
      block: 1
      difficulty: 1
      concept: Variable Declaration
      docLinks:
        - url: https://go.dev/tour/basics/9
          title: "Go Tour: Short variable declarations"
          note: := syntax
        - url: https://go.dev/ref/spec#Short_variable_declarations
          title: "Go Spec: Short variable declarations"
          note: specification details
      variants:
        - id: v1
          title: Constant Enum with iota
          description: >-
            Define a <code>Day</code> type (based on <code>int</code>) and constants for each day of the week
            using <code>iota</code>, starting with <code>Monday = 1</code> (use <code>iota + 1</code>)
            through <code>Sunday = 7</code>. Then write <code>func isWorkday(d Day) bool</code> that returns
            <code>true</code> for Monday through Friday and <code>false</code> for Saturday and Sunday.
          functionSignature: func isWorkday(d Day) bool
          difficulty: 2
          testCases:
            - input: "isWorkday(Monday)"
              output: "true"
            - input: "isWorkday(Wednesday)"
              output: "true"
            - input: "isWorkday(Saturday)"
              output: "false"
            - input: "isWorkday(Sunday)"
              output: "false"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                Use <code>type Day int</code> to define a new type. In a <code>const</code> block,
                <code>iota</code> starts at 0 and increments by 1 for each constant. How do you
                make it start at 1?
            - title: "\U0001F4A1 Hint"
              content: >-
                Define <code>Monday Day = iota + 1</code> as the first constant.
                The remaining days auto-increment. Saturday is 6, Sunday is 7.
          solution: |-
            type Day int

            const (
                Monday Day = iota + 1
                Tuesday
                Wednesday
                Thursday
                Friday
                Saturday
                Sunday
            )

            func isWorkday(d Day) bool {
                return d >= Monday && d <= Friday
            }
          annotations:
            - type: idiom
              label: iota Enums
              text: >-
                Go uses <code>iota</code> in <code>const</code> blocks to create enumerated constants.
                Each constant in the block gets the next value. Use <code>iota + 1</code> to start
                from 1 instead of 0.

        - id: v2
          title: Shadowing Trap
          description: >-
            Read the code below carefully. What does <code>func shadowTrap() int</code> return?
            Implement it exactly as shown and return the final value of <code>x</code>.<br><br>
            <code>x := 10</code><br>
            <code>if true {</code><br>
            <code>&nbsp;&nbsp;&nbsp;&nbsp;x := x + 5  // note: := not =</code><br>
            <code>&nbsp;&nbsp;&nbsp;&nbsp;x = x + 3</code><br>
            <code>}</code><br>
            <code>return x</code>
          functionSignature: func shadowTrap() int
          difficulty: 2
          testCases:
            - input: "shadowTrap()"
              output: "10"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                Pay close attention to <code>:=</code> vs <code>=</code>. What does <code>:=</code>
                do when used inside a nested block? Does it modify the existing variable or do
                something else?
            - title: "\U0001F4A1 Hint"
              content: >-
                The inner <code>x</code> becomes 18 (10+5+3), but it goes out of scope when the
                if block ends. The outer <code>x</code> is still 10.
          solution: |-
            func shadowTrap() int {
                x := 10
                if true {
                    x := x + 5
                    x = x + 3
                    _ = x // 18, but scoped to this block
                }
                return x // 10 — outer x was never modified
            }
          annotations:
            - type: gotcha
              label: Variable Shadowing
              text: >-
                Using <code>:=</code> inside a nested scope creates a new variable that shadows the
                outer one. This is a common source of bugs in Go — the outer variable is never modified.
                Use <code>=</code> (not <code>:=</code>) when you intend to reassign an existing variable.

        - id: v3
          title: Zero Values
          description: >-
            Write <code>func zeroValues() (int, string, bool)</code> that uses <code>var</code> to
            declare an int, string, and bool <em>without</em> assigning values, then returns all three.
            This demonstrates Go's zero-value guarantee.
          functionSignature: func zeroValues() (int, string, bool)
          difficulty: 2
          testCases:
            - input: "zeroValues()"
              output: "0, \"\", false"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                When you use <code>var x int</code> without assigning a value, Go initializes it to the zero value for that type. What are the zero values for int, string, and bool?
            - title: "\U0001F4A1 Hint"
              content: >-
                Use <code>var n int</code>, <code>var s string</code>, <code>var b bool</code>, then return all three.
          solution: |-
            func zeroValues() (int, string, bool) {
                var n int
                var s string
                var b bool
                return n, s, b
            }
          annotations:
            - type: idiom
              label: Zero Values
              text: >-
                Go guarantees every variable has a well-defined initial value. For numeric types it's 0,
                for strings it's <code>""</code>, and for bools it's <code>false</code>. This eliminates
                an entire class of "uninitialized variable" bugs.

        - id: v4
          title: Multi-Assignment Swap
          description: >-
            Write <code>func swap(a, b int) (int, int)</code> that uses multi-assignment
            (<code>a, b = b, a</code>) to swap the values and return them.
          functionSignature: func swap(a, b int) (int, int)
          difficulty: 2
          testCases:
            - input: "swap(10, 20)"
              output: "20, 10"
            - input: "swap(-1, 1)"
              output: "1, -1"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                Go evaluates the right side of an assignment fully before writing to the left side. This means you can swap without a temp variable.
            - title: "\U0001F4A1 Hint"
              content: >-
                Use <code>a, b = b, a</code> — Go's parallel assignment handles the swap.
          solution: |-
            func swap(a, b int) (int, int) {
                a, b = b, a
                return a, b
            }
          annotations:
            - type: idiom
              label: Parallel Assignment
              text: >-
                Go evaluates all right-hand values before assigning, so <code>a, b = b, a</code> swaps
                without needing a temporary variable.

    # ── challenge_2: Type Conversion ─────────────────────────────────────
    - id: challenge_2
      block: 1
      difficulty: 1
      concept: Type Conversion
      docLinks:
        - url: https://go.dev/tour/basics/13
          title: "Go Tour: Type conversions"
          note: basic conversion syntax
        - url: https://pkg.go.dev/strconv
          title: "Package strconv"
          note: string/number conversions
      variants:
        - id: v1
          title: Int to String
          description: >-
            Write <code>func intToString(n int) string</code> that converts an integer to its string
            representation using <code>strconv.Itoa</code>.
          functionSignature: func intToString(n int) string
          difficulty: 1
          testCases:
            - input: "intToString(42)"
              output: "\"42\""
            - input: "intToString(-7)"
              output: "\"-7\""
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                <code>strconv.Itoa</code> converts an int to its ASCII string representation. Don't confuse it with <code>string(n)</code>, which treats n as a Unicode code point.
            - title: "\U0001F4A1 Hint"
              content: >-
                <code>return strconv.Itoa(n)</code>
          solution: |-
            func intToString(n int) string {
                return strconv.Itoa(n)
            }
          annotations:
            - type: gotcha
              label: string(int) Trap
              text: >-
                <code>string(65)</code> gives <code>"A"</code> (the Unicode character), not <code>"65"</code>.
                Always use <code>strconv.Itoa</code> to convert numbers to their string representation.

        - id: v2
          title: String to Int
          description: >-
            Write <code>func stringToInt(s string) (int, error)</code> that converts a string to an
            integer using <code>strconv.Atoi</code>. Return both the value and the error.
          functionSignature: func stringToInt(s string) (int, error)
          difficulty: 1
          testCases:
            - input: "stringToInt(\"123\")"
              output: "123, nil"
            - input: "stringToInt(\"abc\")"
              output: "0, error"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                <code>strconv.Atoi</code> returns two values: the parsed integer and an error. What happens when the input isn't a valid number?
            - title: "\U0001F4A1 Hint"
              content: >-
                <code>return strconv.Atoi(s)</code> — it already returns (int, error).
          solution: |-
            func stringToInt(s string) (int, error) {
                return strconv.Atoi(s)
            }
          annotations:
            - type: idiom
              label: Error Returns
              text: >-
                Go's convention is to return errors as the last value. <code>strconv.Atoi</code> returns
                <code>(int, error)</code> — callers must check the error before using the value.

        - id: v3
          title: Float Truncation vs Round
          description: >-
            Write <code>func truncateAndRound(f float64) (int, int)</code> that returns two values:
            the result of <code>int(f)</code> (truncation) and <code>int(math.Round(f))</code> (rounding).
          functionSignature: func truncateAndRound(f float64) (int, int)
          difficulty: 2
          testCases:
            - input: "truncateAndRound(3.7)"
              output: "3, 4"
            - input: "truncateAndRound(-2.3)"
              output: "-2, -2"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                <code>int(f)</code> truncates toward zero — it just drops the decimal. <code>math.Round(f)</code> rounds to the nearest integer. They give different results for most inputs.
            - title: "\U0001F4A1 Hint"
              content: >-
                Return <code>int(f), int(math.Round(f))</code>.
          solution: |-
            func truncateAndRound(f float64) (int, int) {
                return int(f), int(math.Round(f))
            }
          annotations:
            - type: gotcha
              label: Truncation Surprise
              text: >-
                <code>int(3.9)</code> is <code>3</code>, not <code>4</code>. Go truncates toward zero,
                which catches many newcomers. Use <code>math.Round</code> when you want rounding.

        - id: v4
          title: Chain Conversions
          description: >-
            Write <code>func doubleString(s string) (string, error)</code> that parses a numeric string,
            doubles it, and returns the result as a string. Return an error if the input isn't a valid integer.
          functionSignature: func doubleString(s string) (string, error)
          difficulty: 2
          testCases:
            - input: "doubleString(\"21\")"
              output: "\"42\", nil"
            - input: "doubleString(\"abc\")"
              output: "\"\", error"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                You need three steps: parse string → do math → format back to string. Handle the error from parsing.
            - title: "\U0001F4A1 Hint"
              content: >-
                Use <code>strconv.Atoi</code> to parse, multiply by 2, then <code>strconv.Itoa</code> to convert back.
          solution: |-
            func doubleString(s string) (string, error) {
                n, err := strconv.Atoi(s)
                if err != nil {
                    return "", err
                }
                return strconv.Itoa(n * 2), nil
            }
          annotations:
            - type: pattern
              label: Parse-Process-Format
              text: >-
                A common pattern: parse input → process → format output. Always handle the parse error
                before proceeding to the processing step.

    # ── challenge_3: Function Basics ──────────────────────────────────────
    - id: challenge_3
      block: 1
      difficulty: 1
      concept: Function Basics
      docLinks:
        - url: https://go.dev/tour/moretypes/2
          title: "Go Tour: Functions"
          note: function syntax
        - url: https://pkg.go.dev/strings
          title: "Package strings"
          note: string manipulation functions
      variants:
        - id: v1
          title: Format Price Tag
          description: >-
            Write <code>func formatPrice(item string, cents int) string</code> that returns a
            formatted price tag like <code>"Coffee Beans - $12.99"</code>. Convert cents to
            dollars and cents using integer division and modulo.
          functionSignature: func formatPrice(item string, cents int) string
          difficulty: 1
          testCases:
            - input: "formatPrice(\"Coffee Beans\", 1299)"
              output: "\"Coffee Beans - $12.99\""
            - input: "formatPrice(\"Sticker\", 50)"
              output: "\"Sticker - $0.50\""
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                Dollars is <code>cents / 100</code>, remaining cents is <code>cents % 100</code>. How do you format with zero-padding for the cents?
            - title: "\U0001F4A1 Hint"
              content: >-
                Use <code>fmt.Sprintf("%s - $%d.%02d", item, cents/100, cents%100)</code>. The <code>%02d</code> pads with a leading zero.
          solution: |-
            func formatPrice(item string, cents int) string {
                return fmt.Sprintf("%s - $%d.%02d", item, cents/100, cents%100)
            }
          annotations:
            - type: idiom
              label: fmt.Sprintf
              text: >-
                <code>fmt.Sprintf</code> is Go's string formatting function — like <code>Printf</code>
                but returns a string instead of printing. It's the idiomatic way to build formatted strings.

        - id: v2
          title: Day Type (Switch)
          description: >-
            Write <code>func dayType(day string) string</code> using a <code>switch</code> statement.
            Return <code>"weekend"</code> for <code>"Saturday"</code> or <code>"Sunday"</code>,
            <code>"weekday"</code> for <code>"Monday"</code> through <code>"Friday"</code>,
            or <code>"unknown"</code> for any other input.
          functionSignature: func dayType(day string) string
          difficulty: 1
          testCases:
            - input: "dayType(\"Monday\")"
              output: "\"weekday\""
            - input: "dayType(\"Saturday\")"
              output: "\"weekend\""
            - input: "dayType(\"Sunday\")"
              output: "\"weekend\""
            - input: "dayType(\"Funday\")"
              output: "\"unknown\""
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                A <code>switch</code> on a string value can match multiple values per case
                using commas: <code>case "a", "b":</code>.
            - title: "\U0001F4A1 Hint"
              content: >-
                Use <code>case "Saturday", "Sunday":</code> for the weekend case and list all five
                weekdays in the weekday case. Use <code>default:</code> for unknown.
          solution: |-
            func dayType(day string) string {
                switch day {
                case "Monday", "Tuesday", "Wednesday", "Thursday", "Friday":
                    return "weekday"
                case "Saturday", "Sunday":
                    return "weekend"
                default:
                    return "unknown"
                }
            }
          annotations:
            - type: idiom
              label: Switch with Multi-Value Cases
              text: >-
                Go's <code>switch</code> cases can match multiple values: <code>case "a", "b":</code>.
                Unlike C/Java, Go cases don't fall through by default — no <code>break</code> needed.

        - id: v3
          title: Truncate Bio
          description: >-
            Write <code>func truncateBio(bio string, maxLen int) string</code>. If the bio
            is longer than <code>maxLen</code>, return the first <code>maxLen</code> characters followed
            by <code>"..."</code>. Otherwise return the bio unchanged. Think social media profile limits.
          functionSignature: func truncateBio(bio string, maxLen int) string
          difficulty: 2
          testCases:
            - input: "truncateBio(\"Software engineer who loves Go and coffee\", 15)"
              output: "\"Software engine...\""
            - input: "truncateBio(\"Hi!\", 15)"
              output: "\"Hi!\""
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                You need to check whether the string is too long, and if so, cut it short. How do
                you grab just the beginning of a string in Go?
            - title: "\U0001F4A1 Hint"
              content: >-
                <code>if len(bio) > maxLen { return bio[:maxLen] + "..." }</code>
          solution: |-
            func truncateBio(bio string, maxLen int) string {
                if len(bio) > maxLen {
                    return bio[:maxLen] + "..."
                }
                return bio
            }

        - id: v4
          title: Extract Area Code
          description: >-
            Write <code>func extractAreaCode(phone string) string</code>. Phone numbers are
            formatted as <code>"(555) 123-4567"</code>. Extract and return the 3-digit area code
            between the parentheses (characters 1-3). If the string is shorter than 4 characters,
            return the entire string.
          functionSignature: func extractAreaCode(phone string) string
          difficulty: 2
          testCases:
            - input: "extractAreaCode(\"(415) 555-0123\")"
              output: "\"415\""
            - input: "extractAreaCode(\"(212) 867-5309\")"
              output: "\"212\""
            - input: "extractAreaCode(\"hi\")"
              output: "\"hi\""
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                The area code starts at index 1 and is 3 characters long. What happens if you try <code>phone[1:4]</code> on a short string?
            - title: "\U0001F4A1 Hint"
              content: >-
                Check <code>len(phone) &lt; 4</code> first, then return <code>phone[1:4]</code>.
          solution: |-
            func extractAreaCode(phone string) string {
                if len(phone) < 4 {
                    return phone
                }
                return phone[1:4]
            }
          annotations:
            - type: gotcha
              label: Slice Bounds
              text: >-
                Slicing beyond a string's length causes a runtime panic. Always check
                <code>len(s)</code> before slicing with a fixed index.

    # ── challenge_4: Multiple Returns & Error Handling ───────────────────
    - id: challenge_4
      block: 2
      difficulty: 2
      concept: Multiple Returns
      docLinks:
        - url: https://go.dev/tour/moretypes/6
          title: "Go Tour: Multiple results"
          note: returning multiple values
        - url: https://go.dev/blog/error-handling-and-go
          title: "Error handling and Go"
          note: idiomatic error handling
      variants:
        - id: v1
          title: Parse Score Line
          description: >-
            Write <code>func parseScore(line string) (string, int, error)</code>. A score line has the
            format <code>"Alice:95"</code>. Split on <code>":"</code>, return the name and score as an int.
            Return an error if the format is wrong (no colon) or the score isn't a valid integer.
          functionSignature: func parseScore(line string) (string, int, error)
          difficulty: 1
          testCases:
            - input: "parseScore(\"Alice:95\")"
              output: "\"Alice\", 95, nil"
            - input: "parseScore(\"Bob:abc\")"
              output: "\"\", 0, error"
            - input: "parseScore(\"nocolon\")"
              output: "\"\", 0, error"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                Break the problem into two steps: first separate the name from the score text,
                then turn the score text into a number. Each step can fail — how do you handle that?
            - title: "\U0001F4A1 Hint"
              content: >-
                <code>name, scoreStr, ok := strings.Cut(line, ":")</code> — check <code>ok</code>, then parse <code>scoreStr</code>.
          solution: |-
            func parseScore(line string) (string, int, error) {
                name, scoreStr, ok := strings.Cut(line, ":")
                if !ok {
                    return "", 0, fmt.Errorf("missing colon in %q", line)
                }
                score, err := strconv.Atoi(scoreStr)
                if err != nil {
                    return "", 0, fmt.Errorf("invalid score %q: %w", scoreStr, err)
                }
                return name, score, nil
            }
          annotations:
            - type: idiom
              label: strings.Cut
              text: >-
                <code>strings.Cut(s, sep)</code> (added in Go 1.18) splits a string around the first
                occurrence of a separator. It's cleaner than <code>strings.SplitN</code> for two-part splits.

        - id: v2
          title: Split Full Name
          description: >-
            Write <code>func splitName(full string) (string, string, string, error)</code>.
            Split a full name like <code>"John Michael Smith"</code> into first, middle, and last names.
            Return an error if the name has fewer than 3 parts. Use <code>strings.Fields</code> to split.
          functionSignature: func splitName(full string) (string, string, string, error)
          difficulty: 2
          testCases:
            - input: "splitName(\"John Michael Smith\")"
              output: "\"John\", \"Michael\", \"Smith\", nil"
            - input: "splitName(\"Alice\")"
              output: "\"\", \"\", \"\", error"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                Use <code>strings.Fields</code> to split on whitespace. Check you have at least 3 parts
                before accessing indices.
            - title: "\U0001F4A1 Hint"
              content: >-
                <code>parts := strings.Fields(full)</code>, check <code>len(parts) &lt; 3</code>, then return
                <code>parts[0], parts[1], parts[2]</code>.
          solution: |-
            func splitName(full string) (string, string, string, error) {
                parts := strings.Fields(full)
                if len(parts) < 3 {
                    return "", "", "", fmt.Errorf("need first, middle, and last name, got %d parts", len(parts))
                }
                return parts[0], parts[1], parts[2], nil
            }
          annotations:
            - type: pattern
              label: Destructure & Validate
              text: >-
                Split input into parts, validate you have enough parts, then work with them.
                This pattern prevents index-out-of-bounds panics.

        - id: v3
          title: Parse Port Number
          description: >-
            Write <code>func parsePort(s string) (int, error)</code>. Parse a string to an integer.
            Return an error if it's not a valid integer or if the port is outside the range 1–65535.
          functionSignature: func parsePort(s string) (int, error)
          difficulty: 2
          testCases:
            - input: "parsePort(\"8080\")"
              output: "8080, nil"
            - input: "parsePort(\"0\")"
              output: "0, error"
            - input: "parsePort(\"99999\")"
              output: "0, error"
            - input: "parsePort(\"abc\")"
              output: "0, error"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                Use <code>strconv.Atoi</code> first, then validate the range. Return different errors for each failure case.
            - title: "\U0001F4A1 Hint"
              content: >-
                Parse with <code>strconv.Atoi</code>, check <code>err != nil</code>, then check <code>port &lt; 1 || port > 65535</code>.
          solution: |-
            func parsePort(s string) (int, error) {
                port, err := strconv.Atoi(s)
                if err != nil {
                    return 0, fmt.Errorf("invalid port %q: %w", s, err)
                }
                if port < 1 || port > 65535 {
                    return 0, fmt.Errorf("port %d out of range 1-65535", port)
                }
                return port, nil
            }
          annotations:
            - type: idiom
              label: Error Wrapping
              text: >-
                Use <code>%w</code> in <code>fmt.Errorf</code> to wrap errors. This preserves the original
                error while adding context, enabling callers to use <code>errors.Is</code> and <code>errors.As</code>.

        - id: v4
          title: Safe Map Lookup
          description: >-
            Write <code>func safeLookup(m map[string]string, key string) (string, bool)</code>.
            Look up the key in the map using the comma-ok pattern and return both values.
          functionSignature: func safeLookup(m map[string]string, key string) (string, bool)
          difficulty: 1
          testCases:
            - input: "safeLookup(map[string]string{\"host\": \"localhost\"}, \"host\")"
              output: "\"localhost\", true"
            - input: "safeLookup(map[string]string{\"host\": \"localhost\"}, \"port\")"
              output: "\"\", false"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                Go maps return two values when accessed with <code>val, ok := m[key]</code>. The second value indicates whether the key was found.
            - title: "\U0001F4A1 Hint"
              content: >-
                <code>val, ok := m[key]; return val, ok</code>
          solution: |-
            func safeLookup(m map[string]string, key string) (string, bool) {
                val, ok := m[key]
                return val, ok
            }
          annotations:
            - type: idiom
              label: Comma-Ok Pattern
              text: >-
                The comma-ok pattern — <code>val, ok := m[key]</code> — is how Go distinguishes between
                "key not found" and "key exists with zero value". You'll see this pattern with maps,
                type assertions, and channel receives.
