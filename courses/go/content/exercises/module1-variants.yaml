conceptLinks:
  For Loops: "#lesson-loops"
  If/Else: "#lesson-if"
  Slices & Range: "#lesson-slices"
  Maps: "#lesson-maps"
  make() Function: "#lesson-slices"
  Comma-Ok Pattern: "#lesson-comma-ok"
  Range with Index: "#lesson-loops"
  Building Slices: "#lesson-slices"
variants:
  warmups:
    - id: warmup_1
      concept: For Loops
      variants:
        - id: v1
          title: Print 1 to 10
          description: Write a program that prints the numbers 1 to 10, one per line.
          hints:
            - Use <code>for i := 1; i <= 10; i++</code>
          solution: |-
            for i := 1; i <= 10; i++ {
                fmt.Println(i)
            }
        - id: v2
          title: Countdown from 5
          description: Write a program that counts down from 5 to 1, then prints "Go!"
          hints:
            - Use <code>for i := 5; i >= 1; i--</code>
            - Print "Go!" after the loop
          solution: |-
            for i := 5; i >= 1; i-- {
                fmt.Println(i)
            }
            fmt.Println("Go!")
        - id: v3
          title: Print Even Numbers
          description: Write a program that prints even numbers from 2 to 10.
          hints:
            - Use <code>for i := 2; i <= 10; i += 2</code>
          solution: |-
            for i := 2; i <= 10; i += 2 {
                fmt.Println(i)
            }
        - id: v4
          title: Count by Twos
          description: Write a program that prints odd numbers from 1 to 9.
          hints:
            - Use <code>for i := 1; i <= 9; i += 2</code>
          solution: |-
            for i := 1; i <= 9; i += 2 {
                fmt.Println(i)
            }
        - id: v5
          title: Sum First N Numbers
          description: Write a program that calculates and prints the sum of numbers from 1 to 5.
          hints:
            - Create a <code>sum</code> variable
            - "Add each number: <code>sum += i</code>"
          solution: |-
            sum := 0
            for i := 1; i <= 5; i++ {
                sum += i
            }
            fmt.Println(sum)  // 15
        - id: v6
          title: Multiplication Table Row
          description: Write a program that prints the 3 times table from 3x1 to 3x5.
          hints:
            - Loop from 1 to 5
            - Print <code>3 * i</code> each time
          solution: |-
            for i := 1; i <= 5; i++ {
                fmt.Printf("3 x %d = %d\n", i, 3*i)
            }
        - id: v7
          title: Print Squares
          description: Write a program that prints the square of numbers from 1 to 4.
          hints:
            - Square is <code>i * i</code>
          solution: |-
            for i := 1; i <= 4; i++ {
                fmt.Println(i * i)
            }
        - id: v8
          title: Count Down by Threes
          description: Write a program that counts down from 15 to 0 by threes (15, 12, 9, 6, 3, 0).
          hints:
            - Start at 15, use <code>i -= 3</code>
          solution: |-
            for i := 15; i >= 0; i -= 3 {
                fmt.Println(i)
            }
        - id: v9
          title: Fibonacci First N
          description: Write a program that prints the first 7 Fibonacci numbers (1, 1, 2, 3, 5, 8, 13).
          hints:
            - Start with <code>a, b := 1, 1</code>
            - Each new number is the sum of the previous two
          solution: |-
            a, b := 1, 1
            for i := 0; i < 7; i++ {
                fmt.Println(a)
                a, b = b, a+b
            }
        - id: v10
          title: Factorial
          description: Write a program that calculates and prints 5! (5 factorial = 5 Ã— 4 Ã— 3 Ã— 2 Ã— 1 = 120).
          hints:
            - Start with <code>result := 1</code>
            - "Multiply by each number: <code>result *= i</code>"
          solution: |-
            result := 1
            for i := 1; i <= 5; i++ {
                result *= i
            }
            fmt.Println(result)  // 120
        - id: v11
          title: Skip Count by Fives
          description: Write a program that counts from 0 to 25 by fives (0, 5, 10, 15, 20, 25).
          hints:
            - Use <code>for i := 0; i <= 25; i += 5</code>
          solution: |-
            for i := 0; i <= 25; i += 5 {
                fmt.Println(i)
            }
        - id: v12
          title: Print Star Pattern
          description: Write a program that prints a triangle pattern of stars (1 star, then 2 stars, then 3 stars).
          hints:
            - Outer loop controls rows
            - "Inner loop prints stars: <code>for j := 0; j < i; j++</code>"
          solution: |-
            for i := 1; i <= 3; i++ {
                for j := 0; j < i; j++ {
                    fmt.Print("*")
                }
                fmt.Println()
            }
        - id: v13
          title: Power of Two
          description: Write a program that prints powers of 2 from 2^0 to 2^5 (1, 2, 4, 8, 16, 32).
          hints:
            - Start with <code>power := 1</code>
            - "Double each time: <code>power *= 2</code>"
          solution: |-
            power := 1
            for i := 0; i <= 5; i++ {
                fmt.Println(power)
                power *= 2
            }
    - id: warmup_2
      concept: If/Else
      variants:
        - id: v1
          title: Odd or Even
          description: Write <code>func oddOrEven(n int) string</code> that returns "even" if n is divisible by 2, else "odd".
          hints:
            - "Use modulo: <code>if n % 2 == 0</code> means even"
          solution: |-
            func oddOrEven(n int) string {
                if n % 2 == 0 {
                    return "even"
                }
                return "odd"
            }
        - id: v2
          title: Pass or Fail
          description: Write <code>func passOrFail(score int) string</code> that returns "pass" if score >= 60, else "fail".
          hints:
            - "Simple if/else: <code>if score >= 60 { return \"pass\" }</code>"
          solution: |-
            func passOrFail(score int) string {
                if score >= 60 {
                    return "pass"
                }
                return "fail"
            }
        - id: v3
          title: Temperature Feel
          description: >-
            Write <code>func tempFeel(celsius int) string</code> that returns "freezing" (< 0), "cold" (0-15), "warm"
            (16-25), or "hot" (> 25).
          hints:
            - Chain if/else if based on temperature thresholds
          solution: |-
            func tempFeel(celsius int) string {
                if celsius < 0 {
                    return "freezing"
                } else if celsius <= 15 {
                    return "cold"
                } else if celsius <= 25 {
                    return "warm"
                }
                return "hot"
            }
        - id: v4
          title: Grade Letter
          description: >-
            Write <code>func gradeLetter(score int) string</code> that returns "A" (>=90), "B" (>=80), "C" (>=70), "D"
            (>=60), or "F" (<60).
          hints:
            - Use chained if/else if statements
            - Check highest grade first
          solution: |-
            func gradeLetter(score int) string {
                if score >= 90 {
                    return "A"
                } else if score >= 80 {
                    return "B"
                } else if score >= 70 {
                    return "C"
                } else if score >= 60 {
                    return "D"
                }
                return "F"
            }
        - id: v5
          title: Voting Eligibility
          description: Write <code>func canVote(age int) string</code> that returns "can vote" if age >= 18, else "too young".
          hints:
            - Simple comparison with 18
          solution: |-
            func canVote(age int) string {
                if age >= 18 {
                    return "can vote"
                }
                return "too young"
            }
        - id: v6
          title: Discount Eligibility
          description: >-
            Write <code>func getDiscount(age int) string</code> that returns "senior discount" (>=65), "student
            discount" (<=25), or "no discount".
          hints:
            - Check senior first, then student, then default
          solution: |-
            func getDiscount(age int) string {
                if age >= 65 {
                    return "senior discount"
                } else if age <= 25 {
                    return "student discount"
                }
                return "no discount"
            }
        - id: v7
          title: Positive or Negative
          description: Write <code>func posNegZero(n int) string</code> that returns "positive", "negative", or "zero".
          hints:
            - Check if n > 0, n < 0, or else it's zero
          solution: |-
            func posNegZero(n int) string {
                if n > 0 {
                    return "positive"
                } else if n < 0 {
                    return "negative"
                }
                return "zero"
            }
        - id: v8
          title: Speed Limit
          description: >-
            Write <code>func speedCheck(speed int) string</code> that returns "safe" (<=60), "warning" (61-80), or
            "ticket" (>80).
          hints:
            - Use ranges for different categories
          solution: |-
            func speedCheck(speed int) string {
                if speed <= 60 {
                    return "safe"
                } else if speed <= 80 {
                    return "warning"
                }
                return "ticket"
            }
        - id: v9
          title: Age Category
          description: >-
            Write <code>func ageCategory(age int) string</code> that returns "child" if age < 13, "teen" if age < 20,
            else "adult".
          hints:
            - Use multiple if/else if statements
            - Check conditions from smallest to largest
          solution: |-
            func ageCategory(age int) string {
                if age < 13 {
                    return "child"
                } else if age < 20 {
                    return "teen"
                }
                return "adult"
            }
        - id: v10
          title: BMI Category
          description: >-
            Write <code>func bmiCategory(bmi float64) string</code> that returns "underweight" if bmi < 18.5, "normal"
            if bmi < 25, else "overweight".
          hints:
            - Use <code>else if</code> for the middle condition
          solution: |-
            func bmiCategory(bmi float64) string {
                if bmi < 18.5 {
                    return "underweight"
                } else if bmi < 25 {
                    return "normal"
                }
                return "overweight"
            }
        - id: v11
          title: Season from Month
          description: >-
            Write <code>func season(month int) string</code> that returns "winter" for 12-2, "spring" for 3-5, "summer"
            for 6-8, "fall" for 9-11.
          hints:
            - Use multiple if/else if conditions
            - Check ranges like <code>month >= 3 && month <= 5</code>
          solution: |-
            func season(month int) string {
                if month == 12 || month <= 2 {
                    return "winter"
                } else if month <= 5 {
                    return "spring"
                } else if month <= 8 {
                    return "summer"
                }
                return "fall"
            }
        - id: v12
          title: Weekend or Weekday
          description: >-
            Write <code>func dayType(day string) string</code> that returns "weekend" if day is "Saturday" or "Sunday",
            else "weekday".
          hints:
            - Use <code>||</code> (OR) operator
            - "Check: <code>if day == \"Saturday\" || day == \"Sunday\"</code>"
          solution: |-
            func dayType(day string) string {
                if day == "Saturday" || day == "Sunday" {
                    return "weekend"
                }
                return "weekday"
            }
        - id: v13
          title: Password Strength
          description: >-
            Write <code>func passwordStrength(length int) string</code> that returns "weak" if length < 8, "medium" if
            length < 12, else "strong".
          hints:
            - Simple if/else if chain based on length thresholds
          solution: |-
            func passwordStrength(length int) string {
                if length < 8 {
                    return "weak"
                } else if length < 12 {
                    return "medium"
                }
                return "strong"
            }
    - id: warmup_3
      concept: Slices & Range
      variants:
        - id: v1
          title: Iterate Numbers
          description: Create a slice with three numbers, then print each using <code>for range</code>.
          hints:
            - "Create: <code>nums := []int{7, 42, 99}</code>"
            - "Loop: <code>for _, num := range nums</code>"
          solution: |-
            nums := []int{7, 42, 99}
            for _, num := range nums {
                fmt.Println(num)
            }
        - id: v2
          title: Iterate with Index
          description: "Create a slice of colors, then print each with its index: \"0: red\", \"1: blue\", etc."
          hints:
            - "Loop with index: <code>for i, color := range colors</code>"
            - "Use <code>fmt.Printf(\"%d: %s\\n\", i, color)</code>"
          solution: |-
            colors := []string{"red", "blue", "green"}
            for i, color := range colors {
                fmt.Printf("%d: %s\n", i, color)
            }
        - id: v3
          title: Iterate Strings
          description: Create a slice of your favorite foods, print each on its own line.
          hints:
            - "Create: <code>foods := []string{\"pizza\", \"sushi\", \"tacos\"}</code>"
          solution: |-
            foods := []string{"pizza", "sushi", "tacos"}
            for _, food := range foods {
                fmt.Println(food)
            }
        - id: v4
          title: Sum Slice
          description: Create a slice of numbers, then calculate and print their sum.
          hints:
            - Create a sum variable before the loop
            - "Add each number: <code>sum += num</code>"
          solution: |-
            nums := []int{10, 20, 30}
            sum := 0
            for _, num := range nums {
                sum += num
            }
            fmt.Println(sum)  // 60
        - id: v5
          title: Count Items
          description: Create a slice of fruits and print how many items are in it.
          hints:
            - Use <code>len(fruits)</code> to get the count
          solution: |-
            fruits := []string{"apple", "banana", "orange", "grape"}
            fmt.Println(len(fruits))  // 4
        - id: v6
          title: Names List
          description: "Create a slice of names and print each with a greeting: \"Hello, Alice!\""
          hints:
            - Use <code>fmt.Printf("Hello, %s!\n", name)</code>
          solution: |-
            names := []string{"Alice", "Bob", "Charlie"}
            for _, name := range names {
                fmt.Printf("Hello, %s!\n", name)
            }
        - id: v7
          title: Test Scores
          description: "Create a slice of test scores and print each one with its position: \"Test 1: 85\""
          hints:
            - Use the index in the range loop
            - Add 1 to the index for human-readable numbering
          solution: |-
            scores := []int{85, 92, 78, 95}
            for i, score := range scores {
                fmt.Printf("Test %d: %d\n", i+1, score)
            }
        - id: v8
          title: Reverse Print
          description: Create a slice of 3 animals and print them in reverse order using a regular for loop.
          hints:
            - Start from <code>len(animals)-1</code>
            - "Count down: <code>i--</code>"
          solution: |-
            animals := []string{"cat", "dog", "bird"}
            for i := len(animals) - 1; i >= 0; i-- {
                fmt.Println(animals[i])
            }
        - id: v9
          title: Find Maximum
          description: Write <code>func findMax(nums []int) int</code> that returns the largest number in the slice.
          hints:
            - Start with <code>max := nums[0]</code>
            - Use range to compare each number
          solution: |-
            func findMax(nums []int) int {
                max := nums[0]
                for _, n := range nums {
                    if n > max {
                        max = n
                    }
                }
                return max
            }
        - id: v10
          title: Find Minimum
          description: Write <code>func findMin(nums []int) int</code> that returns the smallest number in the slice.
          hints:
            - Start with <code>min := nums[0]</code>
            - "Compare each number: <code>if n < min</code>"
          solution: |-
            func findMin(nums []int) int {
                min := nums[0]
                for _, n := range nums {
                    if n < min {
                        min = n
                    }
                }
                return min
            }
        - id: v11
          title: Calculate Average
          description: Write <code>func average(nums []float64) float64</code> that returns the average of all numbers.
          hints:
            - Sum all numbers first
            - "Divide by length: <code>sum / float64(len(nums))</code>"
          solution: |-
            func average(nums []float64) float64 {
                sum := 0.0
                for _, n := range nums {
                    sum += n
                }
                return sum / float64(len(nums))
            }
        - id: v12
          title: Contains Check
          description: >-
            Write <code>func contains(items []string, target string) bool</code> that returns true if target is in
            items.
          hints:
            - Use range to check each item
            - Return true immediately when found
          solution: |-
            func contains(items []string, target string) bool {
                for _, item := range items {
                    if item == target {
                        return true
                    }
                }
                return false
            }
        - id: v13
          title: First N Elements
          description: >-
            Write <code>func firstN(items []string, n int) []string</code> that returns the first n elements of the
            slice.
          hints:
            - "Use slice syntax: <code>items[:n]</code>"
          solution: |-
            func firstN(items []string, n int) []string {
                return items[:n]
            }
    - id: warmup_4
      concept: Maps
      variants:
        - id: v1
          title: Ages Map
          description: Create a map of names to ages, then print each person's name and age.
          hints:
            - "Map syntax: <code>map[string]int{\"alice\": 30}</code>"
            - "Loop: <code>for name, age := range ages</code>"
          solution: |-
            ages := map[string]int{
                "alice": 30,
                "bob":   25,
            }
            for name, age := range ages {
                fmt.Printf("%s is %d\n", name, age)
            }
        - id: v2
          title: Prices Map
          description: Create a map of items to prices (float64), then print each item and price.
          hints:
            - "Map syntax: <code>map[string]float64{\"apple\": 1.50}</code>"
          solution: |-
            prices := map[string]float64{
                "apple":  1.50,
                "banana": 0.75,
            }
            for item, price := range prices {
                fmt.Printf("%s: $%.2f\n", item, price)
            }
        - id: v3
          title: Capitals Map
          description: Create a map of countries to their capitals, then print each pair.
          hints:
            - "Map syntax: <code>map[string]string{\"France\": \"Paris\"}</code>"
          solution: |-
            capitals := map[string]string{
                "France": "Paris",
                "Japan":  "Tokyo",
            }
            for country, capital := range capitals {
                fmt.Printf("%s: %s\n", country, capital)
            }
        - id: v4
          title: Inventory Count
          description: Create a map of product names to quantities in stock, then print each item and count.
          hints:
            - "Map syntax: <code>map[string]int{\"shirt\": 15}</code>"
          solution: |-
            inventory := map[string]int{
                "shirt": 15,
                "pants": 8,
                "hat":   20,
            }
            for item, count := range inventory {
                fmt.Printf("%s: %d in stock\n", item, count)
            }
        - id: v5
          title: Student Grades
          description: Create a map of student names to their letter grades, then print each student and grade.
          hints:
            - "Map syntax: <code>map[string]string{\"Alice\": \"A\"}</code>"
          solution: |-
            grades := map[string]string{
                "Alice": "A",
                "Bob":   "B",
                "Carol": "A",
            }
            for student, grade := range grades {
                fmt.Printf("%s: %s\n", student, grade)
            }
        - id: v6
          title: Phone Book
          description: Create a map of names to phone numbers, then print each entry.
          hints:
            - "Phone numbers can be strings: <code>\"555-1234\"</code>"
          solution: |-
            phonebook := map[string]string{
                "Alice": "555-1234",
                "Bob":   "555-5678",
            }
            for name, phone := range phonebook {
                fmt.Printf("%s: %s\n", name, phone)
            }
        - id: v7
          title: Menu Prices
          description: Create a map of menu items to their prices (use integers for cents), then print the menu.
          hints:
            - "Store cents as int: 250 for $2.50"
            - Divide by 100.0 when printing
          solution: |-
            menu := map[string]int{
                "burger": 850,
                "fries":  350,
                "soda":   200,
            }
            for item, cents := range menu {
                fmt.Printf("%s: $%.2f\n", item, float64(cents)/100.0)
            }
        - id: v8
          title: Room Numbers
          description: Create a map of employee names to their office room numbers, then print the directory.
          hints:
            - "Map syntax: <code>map[string]int{\"Alice\": 101}</code>"
          solution: |-
            offices := map[string]int{
                "Alice": 101,
                "Bob":   102,
                "Carol": 105,
            }
            for name, room := range offices {
                fmt.Printf("%s - Room %d\n", name, room)
            }
        - id: v9
          title: Most Common Value
          description: >-
            Write <code>func mostCommon(counts map[string]int) string</code> that returns the key with the highest
            value.
          hints:
            - Track max value and corresponding key
            - Loop through map with range
          solution: |-
            func mostCommon(counts map[string]int) string {
                maxKey := ""
                maxVal := 0
                for k, v := range counts {
                    if v > maxVal {
                        maxVal = v
                        maxKey = k
                    }
                }
                return maxKey
            }
        - id: v10
          title: Merge Maps
          description: >-
            Write <code>func mergeMaps(m1, m2 map[string]int) map[string]int</code> that combines both maps (m2
            overwrites m1 on conflicts).
          hints:
            - Create new result map
            - Copy all from m1, then all from m2
          solution: |-
            func mergeMaps(m1, m2 map[string]int) map[string]int {
                result := make(map[string]int)
                for k, v := range m1 {
                    result[k] = v
                }
                for k, v := range m2 {
                    result[k] = v
                }
                return result
            }
        - id: v11
          title: Filter by Value
          description: >-
            Write <code>func filterByValue(m map[string]int, threshold int) map[string]int</code> that returns only
            entries where value >= threshold.
          hints:
            - Create new map for results
            - Only add entries that meet the condition
          solution: |-
            func filterByValue(m map[string]int, threshold int) map[string]int {
                result := make(map[string]int)
                for k, v := range m {
                    if v >= threshold {
                        result[k] = v
                    }
                }
                return result
            }
        - id: v12
          title: Key Exists Multiple
          description: >-
            Write <code>func hasAllKeys(m map[string]int, keys []string) bool</code> that returns true if all keys exist
            in the map.
          hints:
            - Loop through keys slice
            - "Use comma-ok idiom: <code>_, ok := m[key]</code>"
          solution: |-
            func hasAllKeys(m map[string]int, keys []string) bool {
                for _, key := range keys {
                    if _, ok := m[key]; !ok {
                        return false
                    }
                }
                return true
            }
        - id: v13
          title: Invert Map
          description: Write <code>func invertMap(m map[string]string) map[string]string</code> that swaps keys and values.
          hints:
            - Create new map where values become keys
            - "Loop: <code>result[v] = k</code>"
          solution: |-
            func invertMap(m map[string]string) map[string]string {
                result := make(map[string]string)
                for k, v := range m {
                    result[v] = k
                }
                return result
            }
    - id: warmup_5
      concept: Variables & Assignment
      variants:
        - id: v1
          title: Declare and Print
          description: >-
            Declare a variable <code>name</code> with value "Go", and an integer <code>year</code> with value 2009.
            Print both.
          hints:
            - "Use short declaration: <code>name := \"Go\"</code>"
            - Use <code>fmt.Println(name, year)</code>
          solution: |-
            name := "Go"
            year := 2009
            fmt.Println(name, year)
        - id: v2
          title: Swap Two Variables
          description: Create two variables <code>a := 10</code> and <code>b := 20</code>. Swap their values, then print them.
          hints:
            - "Go allows simultaneous assignment: <code>a, b = b, a</code>"
          solution: |-
            a := 10
            b := 20
            a, b = b, a
            fmt.Println(a, b)  // 20 10
        - id: v3
          title: Type Inference
          description: >-
            Create variables for your age (int), height (float64), and name (string) using short declaration. Print
            their values and types.
          hints:
            - "Go infers types: <code>age := 25</code> is int"
            - Use <code>fmt.Printf("%T", age)</code> to print type
          solution: |-
            age := 25
            height := 5.9
            name := "Alice"
            fmt.Printf("age: %d (%T)\n", age, age)
            fmt.Printf("height: %.1f (%T)\n", height, height)
            fmt.Printf("name: %s (%T)\n", name, name)
        - id: v4
          title: Calculate Area
          description: Create variables for width (5.0) and height (3.0), calculate the area, and print it.
          hints:
            - Area is width * height
            - Use <code>:=</code> for short declaration
          solution: |-
            width := 5.0
            height := 3.0
            area := width * height
            fmt.Println(area)  // 15
        - id: v5
          title: String Concatenation
          description: Create variables for first name and last name, then create and print a full name.
          hints:
            - Concatenate with <code>+</code>
            - Don't forget the space between names
          solution: |-
            firstName := "John"
            lastName := "Doe"
            fullName := firstName + " " + lastName
            fmt.Println(fullName)  // John Doe
        - id: v6
          title: Boolean Logic
          description: Create two boolean variables, then print their AND and OR results.
          hints:
            - "AND: <code>a && b</code>"
            - "OR: <code>a || b</code>"
          solution: |-
            a := true
            b := false
            fmt.Println(a && b)  // false
            fmt.Println(a || b)  // true
        - id: v7
          title: Temperature Conversion
          description: Create a celsius variable (25), convert it to Fahrenheit (F = C * 9/5 + 32), and print both.
          hints:
            - "Formula: <code>fahrenheit := celsius * 9 / 5 + 32</code>"
            - Use float64 for decimal precision
          solution: |-
            celsius := 25.0
            fahrenheit := celsius * 9 / 5 + 32
            fmt.Printf("%.1fC = %.1fF\n", celsius, fahrenheit)  // 25.0C = 77.0F
        - id: v8
          title: Shopping Total
          description: >-
            Create variables for three item prices, calculate the total, then apply a 10% discount and print the final
            price.
          hints:
            - "Total: <code>price1 + price2 + price3</code>"
            - "Discount: <code>total * 0.9</code>"
          solution: |-
            item1 := 10.0
            item2 := 25.5
            item3 := 8.75
            total := item1 + item2 + item3
            final := total * 0.9
            fmt.Printf("Total: $%.2f, After discount: $%.2f\n", total, final)
        - id: v9
          title: Pythagorean Theorem
          description: >-
            Write a program that calculates the hypotenuse c given sides a=3 and b=4 using c = sqrt(aÂ² + bÂ²). Print the
            result.
          hints:
            - Use <code>math.Sqrt()</code> function
            - "Formula: <code>c := math.Sqrt(a*a + b*b)</code>"
          solution: |-
            import "math"

            a := 3.0
            b := 4.0
            c := math.Sqrt(a*a + b*b)
            fmt.Println(c)  // 5
        - id: v10
          title: Compound Interest
          description: >-
            Write a program that calculates compound interest. Given principal=1000, rate=0.05, time=2, calculate amount
            = principal * (1 + rate)^time. Print result.
          hints:
            - Use <code>math.Pow()</code> for exponentiation
            - "Formula: <code>amount := principal * math.Pow(1+rate, time)</code>"
          solution: |-
            import "math"

            principal := 1000.0
            rate := 0.05
            time := 2.0
            amount := principal * math.Pow(1+rate, time)
            fmt.Println(amount)  // 1102.5
        - id: v11
          title: Temperature Conversion
          description: Write a program that converts 100Â°F to Celsius using the formula C = (F - 32) * 5/9. Print the result.
          hints:
            - Use parentheses for correct order of operations
            - "Formula: <code>celsius := (fahrenheit - 32) * 5 / 9</code>"
          solution: |-
            fahrenheit := 100.0
            celsius := (fahrenheit - 32) * 5 / 9
            fmt.Println(celsius)  // 37.777...
        - id: v12
          title: Circle Circumference
          description: Write a program that calculates the circumference of a circle with radius 7 using C = 2Ï€r. Print the result.
          hints:
            - Use <code>math.Pi</code> constant
            - "Formula: <code>circumference := 2 * math.Pi * radius</code>"
          solution: |-
            import "math"

            radius := 7.0
            circumference := 2 * math.Pi * radius
            fmt.Println(circumference)  // 43.98...
        - id: v13
          title: Distance Formula
          description: >-
            Write a program that calculates distance between points (1,2) and (4,6) using d = sqrt((x2-x1)Â² + (y2-y1)Â²).
            Print result.
          hints:
            - "Calculate differences first: <code>dx := x2 - x1</code>"
            - Use <code>math.Sqrt(dx*dx + dy*dy)</code>
          solution: |-
            import "math"

            x1, y1 := 1.0, 2.0
            x2, y2 := 4.0, 6.0
            dx := x2 - x1
            dy := y2 - y1
            dist := math.Sqrt(dx*dx + dy*dy)
            fmt.Println(dist)  // 5
    - id: warmup_6
      concept: Multiple Returns
      variants:
        - id: v1
          title: Divide with Remainder
          description: Write <code>func divMod(a, b int) (int, int)</code> that returns both quotient and remainder.
          hints:
            - "Return two values: <code>return a / b, a % b</code>"
            - "Call with: <code>q, r := divMod(10, 3)</code>"
          solution: |-
            func divMod(a, b int) (int, int) {
                return a / b, a % b
            }

            // Usage:
            q, r := divMod(10, 3)
            fmt.Println(q, r)  // 3 1
        - id: v2
          title: Min and Max
          description: Write <code>func minMax(a, b int) (int, int)</code> that returns the smaller value first, then the larger.
          hints:
            - Use if to compare, then return in order
          solution: |-
            func minMax(a, b int) (int, int) {
                if a < b {
                    return a, b
                }
                return b, a
            }

            // Usage:
            small, big := minMax(5, 3)
            fmt.Println(small, big)  // 3 5
        - id: v3
          title: First and Last
          description: >-
            Write <code>func firstLast(s string) (string, string)</code> that returns the first and last character of a
            string.
          hints:
            - "First char: <code>string(s[0])</code>"
            - "Last char: <code>string(s[len(s)-1])</code>"
          solution: |-
            func firstLast(s string) (string, string) {
                return string(s[0]), string(s[len(s)-1])
            }

            // Usage:
            f, l := firstLast("hello")
            fmt.Println(f, l)  // h o
        - id: v4
          title: Split Name
          description: >-
            Write <code>func splitName(fullName string) (string, string)</code> that splits "John Doe" into first and
            last name (assume one space).
          hints:
            - Find the space with a simple loop or assume fixed position
            - For warmup, you can hardcode the split at index 4 for "John Doe"
          solution: |-
            func splitName(fullName string) (string, string) {
                // Simple version: find space
                for i, ch := range fullName {
                    if ch == ' ' {
                        return fullName[:i], fullName[i+1:]
                    }
                }
                return fullName, ""
            }

            // Usage:
            first, last := splitName("John Doe")
            fmt.Println(first, last)  // John Doe
        - id: v5
          title: Circle Properties
          description: >-
            Write <code>func circleProps(radius float64) (float64, float64)</code> that returns circumference and area
            (use 3.14 for pi).
          hints:
            - "Circumference: <code>2 * pi * radius</code>"
            - "Area: <code>pi * radius * radius</code>"
          solution: |-
            func circleProps(radius float64) (float64, float64) {
                pi := 3.14
                circumference := 2 * pi * radius
                area := pi * radius * radius
                return circumference, area
            }

            // Usage:
            c, a := circleProps(5.0)
            fmt.Printf("Circumference: %.2f, Area: %.2f\n", c, a)
        - id: v6
          title: Bounds Check
          description: >-
            Write <code>func inRange(n, min, max int) (bool, string)</code> that returns true/"in range" if n is between
            min and max, else false/"out of range".
          hints:
            - Check if <code>n >= min && n <= max</code>
            - Return both the boolean and a message
          solution: |-
            func inRange(n, min, max int) (bool, string) {
                if n >= min && n <= max {
                    return true, "in range"
                }
                return false, "out of range"
            }

            // Usage:
            ok, msg := inRange(15, 10, 20)
            fmt.Println(ok, msg)  // true in range
        - id: v7
          title: Quotient and Remainder
          description: Write <code>func divide(dividend, divisor int) (int, int)</code> that returns quotient and remainder.
          hints:
            - "Quotient: <code>dividend / divisor</code>"
            - "Remainder: <code>dividend % divisor</code>"
          solution: |-
            func divide(dividend, divisor int) (int, int) {
                quotient := dividend / divisor
                remainder := dividend % divisor
                return quotient, remainder
            }

            // Usage:
            q, r := divide(17, 5)
            fmt.Println(q, r)  // 3 2
        - id: v8
          title: String Info
          description: >-
            Write <code>func stringInfo(s string) (int, string)</code> that returns the length and the first character
            as a string.
          hints:
            - "Length: <code>len(s)</code>"
            - "First char: <code>string(s[0])</code>"
          solution: |-
            func stringInfo(s string) (int, string) {
                length := len(s)
                firstChar := string(s[0])
                return length, firstChar
            }

            // Usage:
            len, first := stringInfo("hello")
            fmt.Println(len, first)  // 5 h
        - id: v9
          title: Parse Int with Error
          description: >-
            Write <code>func parsePositive(s string) (int, error)</code> that converts string to int. Return error if
            conversion fails or number is negative.
          hints:
            - Use <code>strconv.Atoi(s)</code> to convert
            - Check if result < 0 and return custom error
          solution: |-
            import (
                "errors"
                "strconv"
            )

            func parsePositive(s string) (int, error) {
                n, err := strconv.Atoi(s)
                if err != nil {
                    return 0, err
                }
                if n < 0 {
                    return 0, errors.New("negative number")
                }
                return n, nil
            }
        - id: v10
          title: Validate Range
          description: >-
            Write <code>func validateRange(n, min, max int) (int, bool)</code> that returns (n, true) if n is in
            [min,max], else (0, false).
          hints:
            - "Check condition: <code>n >= min && n <= max</code>"
            - Return the value with a boolean flag
          solution: |-
            func validateRange(n, min, max int) (int, bool) {
                if n >= min && n <= max {
                    return n, true
                }
                return 0, false
            }
        - id: v11
          title: String Split at Position
          description: >-
            Write <code>func splitAt(s string, pos int) (string, string, bool)</code> that splits string at position.
            Return false if pos is out of bounds.
          hints:
            - Check if <code>pos >= 0 && pos <= len(s)</code>
            - "Use slice notation: <code>s[:pos]</code> and <code>s[pos:]</code>"
          solution: |-
            func splitAt(s string, pos int) (string, string, bool) {
                if pos < 0 || pos > len(s) {
                    return "", "", false
                }
                return s[:pos], s[pos:], true
            }
        - id: v12
          title: Find First Occurrence
          description: >-
            Write <code>func findFirst(items []string, target string) (int, bool)</code> that returns (index, true) if
            found, else (-1, false).
          hints:
            - Use range to get both index and value
            - Return immediately when target is found
          solution: |-
            func findFirst(items []string, target string) (int, bool) {
                for i, item := range items {
                    if item == target {
                        return i, true
                    }
                }
                return -1, false
            }
        - id: v13
          title: Min and Max
          description: >-
            Write <code>func minMax(nums []int) (int, int)</code> that returns both the minimum and maximum values in
            one call.
          hints:
            - Initialize both to first element
            - Update both in one loop using range
          solution: |-
            func minMax(nums []int) (int, int) {
                min, max := nums[0], nums[0]
                for _, n := range nums {
                    if n < min {
                        min = n
                    }
                    if n > max {
                        max = n
                    }
                }
                return min, max
            }
  challenges:
    - id: challenge_1
      block: 1
      difficulty: 1
      concept: Accumulator Pattern
      docLinks:
        - url: https://go.dev/ref/spec#For_statements
          title: "Go Spec: For statements"
          note: range loops
        - url: https://go.dev/ref/spec#Arithmetic_operators
          title: "Go Spec: Arithmetic operators"
          note: += syntax
      patternPrimer:
        bruteForce: Loop and update a running result (sum/product/string).
        bestApproach: Initialize the identity value once, then update per element; sometimes early-return is possible.
        typical: Typically O(n) time, O(1) extra space
      variants:
        - id: v1
          title: Sum of Slice
          description: Write <code>func sum(numbers []int) int</code> that returns the sum of all numbers.
          functionSignature: func sum(numbers []int) int
          testCases:
            - input: "[]int{1, 2, 3, 4, 5}"
              output: "15"
          hints:
            - title: ðŸ¤” Think about it
              content: >-
                As you process each element, you need to build up a result. What variable do you need to track this
                running total?
            - title: ðŸ’¡ Hint
              content: >-
                Create an accumulator variable (number for sums, string for joining). Loop through and combine each
                element with your accumulator.
            - title: ðŸ”§ Pattern
              content: |-
                <pre>1. Start with initial value (0 for sums, "" for strings)
                2. For each element:
                   - Combine element with accumulator
                3. Return accumulator</pre>
          solution: |-
            func sum(numbers []int) int {
                total := 0
                for _, num := range numbers {
                    total += num
                }
                return total
            }
          difficulty: 1
        - id: v2
          title: Join Words
          description: Write <code>func joinWords(words []string) string</code> that joins all words with spaces.
          functionSignature: func joinWords(words []string) string
          testCases:
            - input: "[]string{\"go\", \"is\", \"fun\"}"
              output: "\"go is fun\""
          hints:
            - title: ðŸ¤” Think about it
              content: >-
                As you process each element, you need to build up a result. What variable do you need to track this
                running total?
            - title: ðŸ’¡ Hint
              content: >-
                Create an accumulator variable (number for sums, string for joining). Loop through and combine each
                element with your accumulator.
            - title: ðŸ”§ Pattern
              content: |-
                <pre>1. Start with initial value (0 for sums, "" for strings)
                2. For each element:
                   - Combine element with accumulator
                3. Return accumulator</pre>
          solution: |-
            func joinWords(words []string) string {
                result := ""
                for i, word := range words {
                    if i > 0 {
                        result += " "
                    }
                    result += word
                }
                return result
            }
          difficulty: 2
        - id: v3
          title: Total String Length
          description: Write <code>func totalLength(words []string) int</code> that returns total length of all strings.
          functionSignature: func totalLength(words []string) int
          testCases:
            - input: "[]string{\"go\", \"is\", \"fun\"}"
              output: "7"
          hints:
            - title: ðŸ¤” Think about it
              content: >-
                As you process each element, you need to build up a result. What variable do you need to track this
                running total?
            - title: ðŸ’¡ Hint
              content: >-
                Create an accumulator variable (number for sums, string for joining). Loop through and combine each
                element with your accumulator.
            - title: ðŸ”§ Pattern
              content: |-
                <pre>1. Start with initial value (0 for sums, "" for strings)
                2. For each element:
                   - Combine element with accumulator
                3. Return accumulator</pre>
          solution: |-
            func totalLength(words []string) int {
                total := 0
                for _, word := range words {
                    total += len(word)
                }
                return total
            }
          difficulty: 1
        - id: v4
          title: Product of Slice
          description: >-
            Write <code>func product(nums []int) int</code> that returns the product of all numbers (multiply them
            together).
          functionSignature: func product(nums []int) int
          testCases:
            - input: "[]int{2, 3, 4}"
              output: "24"
            - input: "[]int{5, 2, 1}"
              output: "10"
          hints:
            - title: ðŸ¤” Think about it
              content: "Like sum, but multiply. What should your starting value be? (Hint: not 0!)"
            - title: ðŸ’¡ Hint
              content: Start with result := 1 (identity for multiplication). Multiply each element into the accumulator.
            - title: ðŸ”§ Pattern
              content: |-
                <pre>1. Start with result := 1
                2. For each element:
                   - result *= element
                3. Return result</pre>
          solution: |-
            func product(nums []int) int {
                result := 1
                for _, n := range nums {
                    result *= n
                }
                return result
            }
          difficulty: 2
        - id: v5
          title: Running Balance
          description: >-
            Write <code>func balance(transactions []int) int</code> where positive numbers are deposits, negative are
            withdrawals. Return final balance.
          functionSignature: func balance(transactions []int) int
          testCases:
            - input: "[]int{100, -30, 50, -20}"
              output: "100"
              note: 100 - 30 + 50 - 20 = 100
            - input: "[]int{-10, 20, -5}"
              output: "5"
          hints:
            - title: ðŸ¤” Think about it
              content: This is just a sum! Positive and negative numbers handle themselves.
            - title: ðŸ’¡ Hint
              content: Start with balance := 0. Add each transaction (negatives will subtract automatically).
            - title: ðŸ”§ Pattern
              content: |-
                <pre>1. Start with balance := 0
                2. For each transaction:
                   - balance += transaction
                3. Return balance</pre>
          solution: |-
            func balance(transactions []int) int {
                bal := 0
                for _, t := range transactions {
                    bal += t
                }
                return bal
            }
          difficulty: 1
        - id: v6
          title: Concat All
          description: Write <code>func concatAll(words []string) string</code> that concatenates all strings with no separator.
          functionSignature: func concatAll(words []string) string
          testCases:
            - input: "[]string{\"a\", \"b\", \"c\"}"
              output: "\"abc\""
            - input: "[]string{\"Go\", \"Lang\"}"
              output: "\"GoLang\""
          hints:
            - title: ðŸ¤” Think about it
              content: Build up a string by adding each word to the end.
            - title: ðŸ’¡ Hint
              content: Start with result := "". For each word, result += word.
            - title: ðŸ”§ Pattern
              content: |-
                <pre>1. Start with result := ""
                2. For each word:
                   - result += word
                3. Return result</pre>
          solution: |-
            func concatAll(words []string) string {
                result := ""
                for _, w := range words {
                    result += w
                }
                return result
            }
          difficulty: 1
        - id: v7
          title: Sum of Squares
          difficulty: 2
          description: >-
            Write <code>func sumOfSquares(nums []int) int</code> that returns the sum of the squares of all numbers. For
            example, [1, 2, 3] â†’ 1Â² + 2Â² + 3Â² = 14.
          functionSignature: func sumOfSquares(nums []int) int
          testCases:
            - input: "[]int{1, 2, 3}"
              output: "14"
              note: 1Â² + 2Â² + 3Â² = 1 + 4 + 9 = 14
            - input: "[]int{2, 4}"
              output: "20"
              note: 2Â² + 4Â² = 4 + 16 = 20
          hints:
            - title: ðŸ¤” Think about it
              content: >-
                This is accumulator pattern, but you need to transform each element before adding it. How do you square
                a number in Go?
            - title: ðŸ’¡ Hint
              content: Start with sum := 0. For each number, calculate its square (n * n) and add that to the sum.
            - title: ðŸ”§ Pattern
              content: |-
                <pre>1. sum := 0
                2. For each num:
                   - square := num * num
                   - sum += square
                3. Return sum</pre>
          solution: |-
            func sumOfSquares(nums []int) int {
                sum := 0
                for _, n := range nums {
                    sum += n * n
                }
                return sum
            }
        - id: v8
          title: Weighted Sum
          difficulty: 3
          description: >-
            Write <code>func weightedSum(values []int, weights []int) int</code> that returns the sum of values[i] Ã—
            weights[i]. Assume both slices have the same length.
          functionSignature: func weightedSum(values []int, weights []int) int
          testCases:
            - input: "[]int{10, 20, 30}, []int{1, 2, 3}"
              output: "140"
              note: 10Ã—1 + 20Ã—2 + 30Ã—3 = 10 + 40 + 90 = 140
            - input: "[]int{5, 5, 5}, []int{1, 2, 3}"
              output: "30"
              note: 5Ã—1 + 5Ã—2 + 5Ã—3 = 5 + 10 + 15 = 30
          hints:
            - title: ðŸ¤” Think about it
              content: >-
                You're working with TWO slices, but they have the same length. How do you access corresponding elements
                from both?
            - title: ðŸ’¡ Hint
              content: >-
                You can use range with index: for i := range values. Then access values[i] and weights[i] to multiply
                them together.
            - title: ðŸ”§ Pattern
              content: |-
                <pre>1. sum := 0
                2. For i from 0 to len(values):
                   - sum += values[i] * weights[i]
                3. Return sum</pre>
          solution: |-
            func weightedSum(values []int, weights []int) int {
                sum := 0
                for i := range values {
                    sum += values[i] * weights[i]
                }
                return sum
            }
        - id: v9
          title: Alternating Sum
          difficulty: 2
          description: >-
            Write <code>func alternatingSum(nums []int) int</code> that returns nums[0] - nums[1] + nums[2] - nums[3] +
            ... (alternate adding and subtracting).
          functionSignature: func alternatingSum(nums []int) int
          testCases:
            - input: "[]int{10, 5, 3, 2}"
              output: "6"
              note: 10 - 5 + 3 - 2 = 6
            - input: "[]int{1, 2, 3}"
              output: "2"
              note: 1 - 2 + 3 = 2
          hints:
            - title: ðŸ¤” Think about it
              content: The operation alternates based on position. How can you tell if an index is even or odd?
            - title: ðŸ’¡ Hint
              content: >-
                Use the index! Even indices (0, 2, 4...) are added, odd indices (1, 3, 5...) are subtracted. Check i % 2
                == 0.
            - title: ðŸ”§ Pattern
              content: |-
                <pre>1. sum := 0
                2. For i, num in enumerate:
                   - If i is even: sum += num
                   - If i is odd: sum -= num
                3. Return sum</pre>
          solution: |-
            func alternatingSum(nums []int) int {
                sum := 0
                for i, n := range nums {
                    if i%2 == 0 {
                        sum += n
                    } else {
                        sum -= n
                    }
                }
                return sum
            }
        - id: v10
          title: Total Revenue
          description: >-
            Write <code>func totalRevenue(sales []float64, taxRate float64) float64</code> that sums all sales including
            tax.
          functionSignature: func totalRevenue(sales []float64, taxRate float64) float64
          testCases:
            - input: "[]float64{100.0, 200.0, 50.0}, 0.08"
              output: "378.0"
              note: 350 * 1.08
            - input: "[]float64{25.0, 75.0}, 0.10"
              output: "110.0"
          hints:
            - title: ðŸ¤” Think about it
              content: "First sum all sales, then add tax to the total: total * (1 + taxRate)."
            - title: ðŸ’¡ Hint
              content: Accumulate sum, then multiply by (1 + taxRate) at the end.
            - title: ðŸ”§ Pattern
              content: |-
                <pre>1. sum := 0.0
                2. For each sale:
                   - sum += sale
                3. Return sum * (1 + taxRate)</pre>
          solution: |-
            func totalRevenue(sales []float64, taxRate float64) float64 {
                sum := 0.0
                for _, sale := range sales {
                    sum += sale
                }
                return sum * (1 + taxRate)
            }
          difficulty: 2
        - id: v11
          title: Dice Total
          description: >-
            Write <code>func diceTotal(rolls []int) int</code> that sums dice rolls and returns -1 if any roll is
            invalid (not 1-6).
          functionSignature: func diceTotal(rolls []int) int
          testCases:
            - input: "[]int{6, 3, 4, 2}"
              output: "15"
            - input: "[]int{6, 7, 4}"
              output: "-1"
              note: 7 is invalid
          hints:
            - title: ðŸ¤” Think about it
              content: Check validity while accumulating. If any roll is outside 1-6, return -1 immediately.
            - title: ðŸ’¡ Hint
              content: As you sum, check each roll. Use early return for invalid rolls.
            - title: ðŸ”§ Pattern
              content: |-
                <pre>1. sum := 0
                2. For each roll:
                   - roll < 1 OR roll > 6? â†’ return -1
                   - sum += roll
                3. Return sum</pre>
          solution: |-
            func diceTotal(rolls []int) int {
                sum := 0
                for _, roll := range rolls {
                    if roll < 1 || roll > 6 { return -1 }
                    sum += roll
                }
                return sum
            }
          difficulty: 2
        - id: v12
          title: Compound Interest
          description: >-
            Write <code>func compoundInterest(deposits []float64, rate float64) float64</code> that calculates compound
            interest where each deposit earns interest at rate (as decimal) per period. Process deposits in order,
            adding interest to running balance before adding next deposit.
          functionSignature: func compoundInterest(deposits []float64, rate float64) float64
          testCases:
            - input: "[]float64{100.0, 100.0}, 0.10"
              output: "221.0"
              note: "Period 1: 100. Period 2: 100*1.1 + 100 = 210. Final: 210*1.1 = 231 (approx)"
            - input: "[]float64{1000.0}, 0.05"
              output: "1050.0"
          hints:
            - title: ðŸ¤” Think about it
              content: Each period, you apply interest to the current balance, then add the new deposit.
            - title: ðŸ’¡ Hint
              content: "Keep a running balance. For each deposit: balance = balance * (1 + rate), then balance += deposit."
            - title: ðŸ”§ Pattern
              content: |-
                <pre>1. balance := 0.0
                2. For each deposit:
                   - balance *= (1 + rate)
                   - balance += deposit
                3. Return balance</pre>
          solution: |-
            func compoundInterest(deposits []float64, rate float64) float64 {
                balance := 0.0
                for _, deposit := range deposits {
                    balance = balance * (1 + rate)
                    balance += deposit
                }
                return balance
            }
          difficulty: 3
        - id: v13
          title: Running Max Product
          description: >-
            Write <code>func runningMaxProduct(nums []int) []int</code> that returns a slice where each element is the
            maximum product of any two consecutive elements seen so far (including current position).
          functionSignature: func runningMaxProduct(nums []int) []int
          testCases:
            - input: "[]int{1, 2, 3, 4}"
              output: "[]int{0, 2, 6, 12}"
              note: "Position 0: no pair (0), Pos 1: max(1*2)=2, Pos 2: max(1*2, 2*3)=6, Pos 3: max(1*2, 2*3, 3*4)=12"
            - input: "[]int{5, 1, 3, 2}"
              output: "[]int{0, 5, 5, 6}"
          hints:
            - title: ðŸ¤” Think about it
              content: At each position, you need to track the maximum product of consecutive pairs seen up to that point.
            - title: ðŸ’¡ Hint
              content: >-
                Keep track of maxProduct as you go. At position i, calculate nums[i-1]*nums[i] and update maxProduct if
                it's larger.
            - title: ðŸ”§ Pattern
              content: |-
                <pre>1. result := []int{0}, maxProduct := 0
                2. For i from 1 to len:
                   - product := nums[i-1] * nums[i]
                   - if product > maxProduct: maxProduct = product
                   - append maxProduct to result
                3. Return result</pre>
          solution: |-
            func runningMaxProduct(nums []int) []int {
                result := []int{0}
                maxProduct := 0
                for i := 1; i < len(nums); i++ {
                    product := nums[i-1] * nums[i]
                    if product > maxProduct {
                        maxProduct = product
                    }
                    result = append(result, maxProduct)
                }
                return result
            }
          difficulty: 3
    - id: challenge_2
      block: 1
      difficulty: 1
      concept: Conditional Counter
      docLinks:
        - url: https://go.dev/ref/spec#If_statements
          title: "Go Spec: If statements"
          note: conditionals
        - url: https://go.dev/ref/spec#Arithmetic_operators
          title: "Go Spec: Arithmetic operators"
          note: "% modulo operator"
      patternPrimer:
        bruteForce: Loop through, check condition for each element, increment counter.
        bestApproach: Same approach - this is already optimal! Just loop once and count matches.
        typical: Typically O(n) time, O(1) extra space
      variants:
        - id: v1
          title: Count Evens
          description: Write <code>func countEvens(nums []int) int</code> that counts even numbers.
          functionSignature: func countEvens(nums []int) int
          testCases:
            - input: "[]int{1, 2, 3, 4, 5, 6}"
              output: "3"
          hints:
            - title: ðŸ¤” Think about it
              content: >-
                You need to count things that meet a condition. What two pieces do you need: one to track the count, and
                one to check each element?
            - title: ðŸ’¡ Hint
              content: Start a counter at 0. For each element, check your condition - if true, increment the counter.
            - title: ðŸ”§ Pattern
              content: |-
                <pre>1. Start counter at 0
                2. For each element:
                   - Meets condition? â†’ increment counter
                3. Return counter</pre>
          solution: |-
            func countEvens(nums []int) int {
                count := 0
                for _, num := range nums {
                    if num%2 == 0 {
                        count++
                    }
                }
                return count
            }
          difficulty: 1
        - id: v2
          title: Count Negatives
          description: Write <code>func countNegatives(nums []int) int</code> that counts negative numbers.
          functionSignature: func countNegatives(nums []int) int
          testCases:
            - input: "[]int{-1, 2, -3, 4}"
              output: "2"
          hints:
            - title: ðŸ¤” Think about it
              content: >-
                You need to count things that meet a condition. What two pieces do you need: one to track the count, and
                one to check each element?
            - title: ðŸ’¡ Hint
              content: Start a counter at 0. For each element, check your condition - if true, increment the counter.
            - title: ðŸ”§ Pattern
              content: |-
                <pre>1. Start counter at 0
                2. For each element:
                   - Meets condition? â†’ increment counter
                3. Return counter</pre>
          solution: |-
            func countNegatives(nums []int) int {
                count := 0
                for _, num := range nums {
                    if num < 0 {
                        count++
                    }
                }
                return count
            }
          difficulty: 1
        - id: v3
          title: Count Passing Scores
          description: Write <code>func countPassing(scores []int, threshold int) int</code> that counts scores >= threshold.
          functionSignature: func countPassing(scores []int, threshold int) int
          testCases:
            - input: "[]int{55, 72, 68, 90, 45}, 60"
              output: "3"
          hints:
            - title: ðŸ¤” Think about it
              content: >-
                You need to count things that meet a condition. What two pieces do you need: one to track the count, and
                one to check each element?
            - title: ðŸ’¡ Hint
              content: Start a counter at 0. For each element, check your condition - if true, increment the counter.
            - title: ðŸ”§ Pattern
              content: |-
                <pre>1. Start counter at 0
                2. For each element:
                   - Meets condition? â†’ increment counter
                3. Return counter</pre>
          solution: |-
            func countPassing(scores []int, threshold int) int {
                count := 0
                for _, score := range scores {
                    if score >= threshold {
                        count++
                    }
                }
                return count
            }
          difficulty: 1
        - id: v4
          title: Count Divisible By
          description: Write <code>func countDivisible(nums []int, d int) int</code> that counts numbers divisible by d.
          functionSignature: func countDivisible(nums []int, d int) int
          testCases:
            - input: "[]int{3, 6, 7, 9, 12}, 3"
              output: "4"
              note: 3, 6, 9, 12 are divisible by 3
            - input: "[]int{1, 2, 3, 4, 5}, 2"
              output: "2"
          hints:
            - title: ðŸ¤” Think about it
              content: How do you check if a number is divisible by another? What operation gives you the remainder?
            - title: ðŸ’¡ Hint
              content: "Use the modulo operator: num % d == 0 means num is divisible by d."
            - title: ðŸ”§ Pattern
              content: |-
                <pre>1. count := 0
                2. For each num:
                   - num % d == 0? â†’ count++
                3. Return count</pre>
          solution: |-
            func countDivisible(nums []int, d int) int {
                count := 0
                for _, n := range nums {
                    if n % d == 0 { count++ }
                }
                return count
            }
          difficulty: 1
        - id: v5
          title: Count Long Words
          description: >-
            Write <code>func countLongWords(words []string, minLen int) int</code> that counts words with length >=
            minLen.
          functionSignature: func countLongWords(words []string, minLen int) int
          testCases:
            - input: "[]string{\"go\", \"python\", \"rust\", \"c\"}, 4"
              output: "2"
              note: python and rust have len >= 4
            - input: "[]string{\"a\", \"ab\", \"abc\"}, 2"
              output: "2"
          hints:
            - title: ðŸ¤” Think about it
              content: Same counting pattern, just checking string length instead of numeric value.
            - title: ðŸ’¡ Hint
              content: Use len(word) >= minLen as your condition.
            - title: ðŸ”§ Pattern
              content: |-
                <pre>1. count := 0
                2. For each word:
                   - len(word) >= minLen? â†’ count++
                3. Return count</pre>
          solution: |-
            func countLongWords(words []string, minLen int) int {
                count := 0
                for _, w := range words {
                    if len(w) >= minLen { count++ }
                }
                return count
            }
          difficulty: 1
        - id: v6
          title: Count In Range
          description: >-
            Write <code>func countInRange(nums []int, min, max int) int</code> that counts numbers where min <= num <=
            max.
          functionSignature: func countInRange(nums []int, min, max int) int
          testCases:
            - input: "[]int{1, 5, 10, 15, 20}, 5, 15"
              output: "3"
              note: 5, 10, 15 are in range
            - input: "[]int{1, 2, 3, 4, 5}, 2, 4"
              output: "3"
          hints:
            - title: ðŸ¤” Think about it
              content: "You need to check TWO conditions: num >= min AND num <= max."
            - title: ðŸ’¡ Hint
              content: "Combine conditions with &&: if num >= min && num <= max."
            - title: ðŸ”§ Pattern
              content: |-
                <pre>1. count := 0
                2. For each num:
                   - num >= min && num <= max? â†’ count++
                3. Return count</pre>
          solution: |-
            func countInRange(nums []int, min, max int) int {
                count := 0
                for _, n := range nums {
                    if n >= min && n <= max { count++ }
                }
                return count
            }
          difficulty: 2
        - id: v7
          title: Count Prime Numbers
          difficulty: 3
          description: >-
            Write <code>func countPrimes(nums []int) int</code> that counts how many prime numbers are in the slice. A
            prime number is greater than 1 and only divisible by 1 and itself.
          functionSignature: func countPrimes(nums []int) int
          testCases:
            - input: "[]int{2, 3, 4, 5, 6, 7}"
              output: "4"
              note: 2, 3, 5, 7 are prime
            - input: "[]int{1, 4, 6, 8, 9}"
              output: "0"
              note: No primes
          hints:
            - title: ðŸ¤” Think about it
              content: >-
                Checking if a number is prime requires nested logic. For each number, you need to check if any number
                from 2 to n-1 divides it evenly.
            - title: ðŸ’¡ Hint
              content: >-
                Create a helper function isPrime(n int) bool. A number is prime if it's > 1 and no number from 2 to
                sqrt(n) divides it evenly. Then count how many numbers pass the isPrime test.
            - title: ðŸ”§ Pattern
              content: |-
                <pre>1. count := 0
                2. For each num:
                   - If isPrime(num): count++
                3. Return count

                isPrime(n):
                  - If n <= 1: return false
                  - For i from 2 to sqrt(n):
                    - If n % i == 0: return false
                  - return true</pre>
          solution: |-
            func countPrimes(nums []int) int {
                count := 0
                for _, n := range nums {
                    if isPrime(n) {
                        count++
                    }
                }
                return count
            }

            func isPrime(n int) bool {
                if n <= 1 {
                    return false
                }
                for i := 2; i*i <= n; i++ {
                    if n%i == 0 {
                        return false
                    }
                }
                return true
            }
        - id: v8
          title: Count Words Starting With Vowel
          difficulty: 2
          description: >-
            Write <code>func countVowelStart(words []string) int</code> that counts how many words start with a vowel
            (a, e, i, o, u). Use lowercase comparison.
          functionSignature: func countVowelStart(words []string) int
          testCases:
            - input: "[]string{\"apple\", \"banana\", \"orange\", \"grape\"}"
              output: "2"
              note: apple and orange start with vowels
            - input: "[]string{\"Go\", \"is\", \"awesome\"}"
              output: "2"
              note: is and awesome start with vowels
          hints:
            - title: ðŸ¤” Think about it
              content: >-
                You need to check the first character of each word. How do you get the first character, and how do you
                check if it's in the set {a, e, i, o, u}?
            - title: ðŸ’¡ Hint
              content: >-
                Use strings.ToLower() to convert to lowercase, then check if word[0] is one of the vowel bytes. You can
                use multiple OR conditions, or create a helper function.
            - title: ðŸ”§ Pattern
              content: |-
                <pre>1. count := 0
                2. For each word:
                   - Get first character (lowercase)
                   - If it's a, e, i, o, or u: count++
                3. Return count</pre>
          solution: |-
            func countVowelStart(words []string) int {
                count := 0
                for _, word := range words {
                    if len(word) > 0 {
                        first := strings.ToLower(string(word[0]))
                        if first == "a" || first == "e" || first == "i" || first == "o" || first == "u" {
                            count++
                        }
                    }
                }
                return count
            }
        - id: v9
          title: Three Letter Words
          description: Write <code>func threeLetterWords(words []string) int</code> that counts words with exactly 3 letters.
          functionSignature: func threeLetterWords(words []string) int
          testCases:
            - input: "[]string{\"cat\", \"dog\", \"elephant\", \"bat\"}"
              output: "3"
            - input: "[]string{\"hello\", \"world\"}"
              output: "0"
          hints:
            - title: ðŸ¤” Think about it
              content: Count words where len(word) == 3.
            - title: ðŸ’¡ Hint
              content: "Simple counter with condition: if len(word) == 3, count++"
            - title: ðŸ”§ Pattern
              content: |-
                <pre>1. count := 0
                2. For each word:
                   - len(word) == 3? â†’ count++
                3. Return count</pre>
          solution: |-
            func threeLetterWords(words []string) int {
                count := 0
                for _, word := range words {
                    if len(word) == 3 { count++ }
                }
                return count
            }
          difficulty: 1
        - id: v10
          title: Temperature Extremes
          description: Write <code>func tempExtremes(temps []int) int</code> that counts how many temps are below 0 or above 100.
          functionSignature: func tempExtremes(temps []int) int
          testCases:
            - input: "[]int{-5, 50, 105, 25, -10}"
              output: "3"
            - input: "[]int{20, 30, 40}"
              output: "0"
          hints:
            - title: ðŸ¤” Think about it
              content: Count temperatures that are < 0 OR > 100.
            - title: ðŸ’¡ Hint
              content: if temp < 0 || temp > 100, increment count.
            - title: ðŸ”§ Pattern
              content: |-
                <pre>1. count := 0
                2. For each temp:
                   - temp < 0 OR temp > 100? â†’ count++
                3. Return count</pre>
          solution: |-
            func tempExtremes(temps []int) int {
                count := 0
                for _, temp := range temps {
                    if temp < 0 || temp > 100 { count++ }
                }
                return count
            }
          difficulty: 1
        - id: v11
          title: Count By Multiple Criteria
          description: >-
            Write <code>func countByCriteria(words []string, minLen, maxLen int, mustContain string) int</code> that
            counts words where length is between minLen and maxLen (inclusive) AND the word contains the substring
            mustContain.
          functionSignature: func countByCriteria(words []string, minLen, maxLen int, mustContain string) int
          testCases:
            - input: "[\"hello\", \"world\", \"hi\", \"help\"], 4, 6, \"el\""
              output: "2"
              note: hello and help both have length 4-5 and contain 'el'
            - input: "[\"go\", \"gopher\", \"golang\", \"rust\"], 2, 6, \"go\""
              output: "3"
              note: go, gopher, golang all contain 'go' and fit length constraint
          hints:
            - title: ðŸ¤” Think about it
              content: >-
                You need to check THREE conditions for each word: minimum length, maximum length, and contains
                substring. Use strings.Contains() to check for substring.
            - title: ðŸ’¡ Hint
              content: >-
                Import strings package. For each word, check: len(word) >= minLen AND len(word) <= maxLen AND
                strings.Contains(word, mustContain). Only count if all three are true.
            - title: ðŸ”§ Pattern
              content: |-
                <pre>1. count := 0
                2. For each word:
                   - length in range? AND
                   - contains substring?
                   - Both true? â†’ count++
                3. Return count</pre>
          solution: |-
            import "strings"

            func countByCriteria(words []string, minLen, maxLen int, mustContain string) int {
                count := 0
                for _, word := range words {
                    if len(word) >= minLen && len(word) <= maxLen && strings.Contains(word, mustContain) {
                        count++
                    }
                }
                return count
            }
          difficulty: 3
        - id: v12
          title: Count Valid Pairs
          description: >-
            Write <code>func countValidPairs(nums []int, targetSum int) int</code> that counts how many pairs of
            adjacent elements sum to targetSum.
          functionSignature: func countValidPairs(nums []int, targetSum int) int
          testCases:
            - input: "[]int{1, 4, 3, 2, 5}, 5"
              output: "2"
              note: pairs (1,4) and (3,2) both sum to 5
            - input: "[]int{2, 3, 2, 3}, 5"
              output: "3"
              note: all three adjacent pairs (2,3), (3,2), (2,3) sum to 5
          hints:
            - title: ðŸ¤” Think about it
              content: >-
                You need to look at each pair of consecutive elements. For position i, check if nums[i] + nums[i+1]
                equals targetSum.
            - title: ðŸ’¡ Hint
              content: Loop from i=0 to len(nums)-2 (so i+1 is valid). For each i, check if nums[i] + nums[i+1] == targetSum.
            - title: ðŸ”§ Pattern
              content: |-
                <pre>1. count := 0
                2. For i from 0 to len-2:
                   - nums[i] + nums[i+1] == target?
                   - Yes â†’ count++
                3. Return count</pre>
          solution: |-
            func countValidPairs(nums []int, targetSum int) int {
                count := 0
                for i := 0; i < len(nums)-1; i++ {
                    if nums[i] + nums[i+1] == targetSum {
                        count++
                    }
                }
                return count
            }
          difficulty: 3
        - id: v13
          title: Count Pattern Match
          description: >-
            Write <code>func countPatternMatch(words []string, prefix, suffix string) int</code> that counts words that
            start with prefix AND end with suffix.
          functionSignature: func countPatternMatch(words []string, prefix, suffix string) int
          testCases:
            - input: "[\"hello\", \"hero\", \"hermit\", \"world\"], \"he\", \"o\""
              output: "2"
              note: hello and hero both start with 'he' and end with 'o'
            - input: "[\"testing\", \"resting\", \"test\", \"ing\"], \"test\", \"ing\""
              output: "1"
              note: only 'testing' starts with 'test' and ends with 'ing'
          hints:
            - title: ðŸ¤” Think about it
              content: >-
                Use strings.HasPrefix() and strings.HasSuffix() to check both ends of each word. Count only if both
                conditions are true.
            - title: ðŸ’¡ Hint
              content: >-
                Import strings package. For each word: if strings.HasPrefix(word, prefix) && strings.HasSuffix(word,
                suffix), increment count.
            - title: ðŸ”§ Pattern
              content: |-
                <pre>1. count := 0
                2. For each word:
                   - starts with prefix? AND
                   - ends with suffix?
                   - Both true? â†’ count++
                3. Return count</pre>
          solution: |-
            import "strings"

            func countPatternMatch(words []string, prefix, suffix string) int {
                count := 0
                for _, word := range words {
                    if strings.HasPrefix(word, prefix) && strings.HasSuffix(word, suffix) {
                        count++
                    }
                }
                return count
            }
          difficulty: 3
        - id: v14
          title: Count Words Starting With Letter
          description: >-
            Write <code>func countStartsWith(words []string, letter rune) int</code> that counts words starting with the
            given letter (case-insensitive).
          functionSignature: func countStartsWith(words []string, letter rune) int
          testCases:
            - input: "[\"Hello\", \"world\", \"Hi\"], 'h'"
              output: "2"
              note: Hello and Hi start with h (case-insensitive)
            - input: "[\"Go\", \"Python\", \"Rust\", \"Go\"], 'g'"
              output: "2"
          hints:
            - title: ðŸ¤” Think about it
              content: Check the first character of each word. Convert both to lowercase for case-insensitive comparison.
            - title: ðŸ’¡ Hint
              content: Use strings.ToLower() on the first character. Get first rune with rune(word[0]) if word is non-empty.
            - title: ðŸ”§ Pattern
              content: |-
                <pre>1. count := 0
                2. For each word:
                   - Get first letter (lowercase)
                   - Matches target letter? â†’ count++
                3. Return count</pre>
          solution: |-
            import "strings"

            func countStartsWith(words []string, letter rune) int {
                count := 0
                targetLower := strings.ToLower(string(letter))
                
                for _, word := range words {
                    if len(word) > 0 {
                        firstLetter := strings.ToLower(string(word[0]))
                        if firstLetter == targetLower {
                            count++
                        }
                    }
                }
                
                return count
            }
          difficulty: 2
        - id: v15
          title: Count Between (Exclusive)
          description: >-
            Write <code>func countBetween(nums []int, low, high int) int</code> that counts numbers strictly between low
            and high (exclusive on both ends: low < num < high).
          functionSignature: func countBetween(nums []int, low, high int) int
          testCases:
            - input: "[]int{1, 5, 10, 15, 20}, 5, 15"
              output: "1"
              note: only 10 is strictly between 5 and 15
            - input: "[]int{1, 2, 3, 4, 5}, 1, 5"
              output: "3"
              note: 2, 3, 4 are between 1 and 5 (exclusive)
          hints:
            - title: ðŸ¤” Think about it
              content: Exclusive means not including the boundaries. Check num > low AND num < high (not >= or <=).
            - title: ðŸ’¡ Hint
              content: "Use strict inequality: if num > low && num < high, count it."
            - title: ðŸ”§ Pattern
              content: |-
                <pre>1. count := 0
                2. For each num:
                   - num > low AND num < high? â†’ count++
                3. Return count</pre>
          solution: |-
            func countBetween(nums []int, low, high int) int {
                count := 0
                for _, num := range nums {
                    if num > low && num < high {
                        count++
                    }
                }
                return count
            }
          difficulty: 2
    - id: challenge_3
      block: 1
      difficulty: 1
      concept: Branching Logic
      docLinks:
        - url: https://go.dev/ref/spec#If_statements
          title: "Go Spec: If statements"
          note: else-if chains
        - url: https://go.dev/ref/spec#Comparison_operators
          title: "Go Spec: Comparison operators"
          note: ">=, <, == etc."
      variants:
        - id: v1
          title: FizzBuzz
          description: "Print 1-20. Multiples of 3: \"Fizz\", 5: \"Buzz\", both: \"FizzBuzz\"."
          functionSignature: // loop
          testCases:
            - input: "15"
              output: FizzBuzz
          hints:
            - title: ðŸ¤” Think about it
              content: >-
                When you have overlapping conditions (like a number divisible by both 3 AND 5), which case should you
                check first?
            - title: ðŸ’¡ Hint
              content: >-
                Check the most specific condition first! For FizzBuzz, 15 is divisible by both 3 and 5, so check for 15
                before checking 3 or 5 individually.
            - title: ðŸ”§ Pattern
              content: |-
                <pre>1. Check most specific condition first
                2. Then check less specific conditions
                3. Default case last
                (Order matters: check "both 3 AND 5" before "just 3" or "just 5")</pre>
          solution: |-
            for i := 1; i <= 20; i++ {
                if i%15 == 0 {
                    fmt.Println("FizzBuzz")
                } else if i%3 == 0 {
                    fmt.Println("Fizz")
                } else if i%5 == 0 {
                    fmt.Println("Buzz")
                } else {
                    fmt.Println(i)
                }
            }
          difficulty: 2
        - id: v2
          title: Grade Classifier
          description: Write <code>func grade(score int) string</code> returning A/B/C/D/F.
          functionSignature: func grade(score int) string
          testCases:
            - input: "85"
              output: "\"B\""
          hints:
            - title: ðŸ¤” Think about it
              content: >-
                When you have overlapping conditions (like a number divisible by both 3 AND 5), which case should you
                check first?
            - title: ðŸ’¡ Hint
              content: >-
                Check the most specific condition first! For FizzBuzz, 15 is divisible by both 3 and 5, so check for 15
                before checking 3 or 5 individually.
            - title: ðŸ”§ Pattern
              content: |-
                <pre>1. Check most specific condition first
                2. Then check less specific conditions
                3. Default case last
                (Order matters: check "both 3 AND 5" before "just 3" or "just 5")</pre>
          solution: |-
            func grade(score int) string {
                if score >= 90 { return "A" }
                if score >= 80 { return "B" }
                if score >= 70 { return "C" }
                if score >= 60 { return "D" }
                return "F"
            }
          difficulty: 1
        - id: v3
          title: Age Category
          description: >-
            Write <code>func ageCategory(age int) string</code> returning "infant" (0-1), "toddler" (2-3), "child"
            (4-12), "teen" (13-19), or "adult" (20+).
          functionSignature: func ageCategory(age int) string
          testCases:
            - input: "15"
              output: "\"teen\""
            - input: "2"
              output: "\"toddler\""
          hints:
            - title: ðŸ¤” Think about it
              content: >-
                When you have multiple age ranges to check, what order should you check them in to avoid incorrect
                matches?
            - title: ðŸ’¡ Hint
              content: >-
                Check ranges in ascending order using upper bounds. If age <= 1, it's infant. If age <= 3, it's toddler.
                And so on.
            - title: ðŸ”§ Pattern
              content: |-
                <pre>1. Check ranges in order from youngest to oldest
                2. Use upper bounds (<=) for each category
                3. Default to "adult" for 20+</pre>
          solution: |-
            func ageCategory(age int) string {
                if age <= 1 { return "infant" }
                if age <= 3 { return "toddler" }
                if age <= 12 { return "child" }
                if age <= 19 { return "teen" }
                return "adult"
            }
          difficulty: 2
        - id: v4
          title: Number Sign
          description: Write <code>func sign(n int) string</code> returning "positive", "negative", or "zero".
          functionSignature: func sign(n int) string
          testCases:
            - input: "5"
              output: "\"positive\""
            - input: "-3"
              output: "\"negative\""
            - input: "0"
              output: "\"zero\""
          hints:
            - title: ðŸ¤” Think about it
              content: "Three cases: greater than 0, less than 0, or equal to 0."
            - title: ðŸ’¡ Hint
              content: Check n > 0, then n < 0, else it's zero.
            - title: ðŸ”§ Pattern
              content: |-
                <pre>if n > 0 { return "positive" }
                if n < 0 { return "negative" }
                return "zero"</pre>
          solution: |-
            func sign(n int) string {
                if n > 0 { return "positive" }
                if n < 0 { return "negative" }
                return "zero"
            }
          difficulty: 1
        - id: v5
          title: Ticket Price
          description: >-
            Write <code>func ticketPrice(age int) int</code>: children (0-12) pay 5, teens (13-17) pay 8, adults (18-64)
            pay 12, seniors (65+) pay 7.
          functionSignature: func ticketPrice(age int) int
          testCases:
            - input: "10"
              output: "5"
            - input: "15"
              output: "8"
            - input: "30"
              output: "12"
            - input: "70"
              output: "7"
          hints:
            - title: ðŸ¤” Think about it
              content: Multiple age ranges with different prices. Check from youngest to oldest.
            - title: ðŸ’¡ Hint
              content: "Use if-else chain checking upper bounds: <= 12, <= 17, <= 64, else senior."
            - title: ðŸ”§ Pattern
              content: |-
                <pre>if age <= 12 { return 5 }
                if age <= 17 { return 8 }
                if age <= 64 { return 12 }
                return 7</pre>
          solution: |-
            func ticketPrice(age int) int {
                if age <= 12 { return 5 }
                if age <= 17 { return 8 }
                if age <= 64 { return 12 }
                return 7
            }
          difficulty: 2
        - id: v6
          title: Shipping Cost
          description: >-
            Write <code>func shippingCost(weight int) int</code>: 0-1kg costs 5, 2-5kg costs 10, 6-10kg costs 20, over
            10kg costs 50.
          functionSignature: func shippingCost(weight int) int
          testCases:
            - input: "1"
              output: "5"
            - input: "3"
              output: "10"
            - input: "8"
              output: "20"
            - input: "15"
              output: "50"
          hints:
            - title: ðŸ¤” Think about it
              content: Multiple weight brackets. Check from lightest to heaviest.
            - title: ðŸ’¡ Hint
              content: "Check upper bounds: <= 1, <= 5, <= 10, else heavy."
            - title: ðŸ”§ Pattern
              content: |-
                <pre>if weight <= 1 { return 5 }
                if weight <= 5 { return 10 }
                if weight <= 10 { return 20 }
                return 50</pre>
          solution: |-
            func shippingCost(weight int) int {
                if weight <= 1 { return 5 }
                if weight <= 5 { return 10 }
                if weight <= 10 { return 20 }
                return 50
            }
          difficulty: 2
        - id: v7
          title: Tax Bracket Calculator
          difficulty: 3
          description: >-
            Write <code>func calculateTax(income int) int</code>. Tax brackets: 0-10k: 0%, 10k-50k: 10%, 50k-100k: 20%,
            100k+: 30%. Calculate progressive tax (each bracket taxed at its rate).
          functionSignature: func calculateTax(income int) int
          testCases:
            - input: "15000"
              output: "500"
              note: "First 10k: 0, next 5k at 10% = 500"
            - input: "60000"
              output: "6000"
              note: 10k@0% + 40k@10% + 10k@20% = 0 + 4000 + 2000 = 6000
            - input: "5000"
              output: "0"
              note: All in 0% bracket
          hints:
            - title: ðŸ¤” Think about it
              content: >-
                This is NOT a simple if-else! Each bracket taxes only the portion of income in that range. Someone
                earning 60k pays 10% on the middle 40k, not on all 60k.
            - title: ðŸ’¡ Hint
              content: >-
                Calculate tax bracket by bracket. For each bracket, determine how much income falls in it (min of
                remaining income and bracket size), multiply by rate, add to total tax.
            - title: ðŸ”§ Pattern
              content: |-
                <pre>1. tax := 0, remaining := income
                2. First bracket (0-10k at 0%):
                   - amount = min(remaining, 10000)
                   - tax += amount * 0.0
                   - remaining -= amount
                3. Repeat for each bracket
                4. Return tax</pre>
          solution: |-
            func calculateTax(income int) int {
                if income <= 10000 {
                    return 0
                }
                tax := 0
                if income > 10000 {
                    taxable := income - 10000
                    if taxable > 40000 {
                        taxable = 40000
                    }
                    tax += taxable * 10 / 100
                }
                if income > 50000 {
                    taxable := income - 50000
                    if taxable > 50000 {
                        taxable = 50000
                    }
                    tax += taxable * 20 / 100
                }
                if income > 100000 {
                    tax += (income - 100000) * 30 / 100
                }
                return tax
            }
        - id: v8
          title: Rock Paper Scissors
          difficulty: 2
          description: >-
            Write <code>func rps(p1, p2 string) string</code> that takes "rock", "paper", or "scissors" and returns
            "p1", "p2", or "tie".
          functionSignature: func rps(p1, p2 string) string
          testCases:
            - input: "\"rock\", \"scissors\""
              output: "\"p1\""
              note: Rock beats scissors
            - input: "\"paper\", \"rock\""
              output: "\"p1\""
              note: Paper beats rock
            - input: "\"rock\", \"rock\""
              output: "\"tie\""
            - input: "\"scissors\", \"paper\""
              output: "\"p1\""
          hints:
            - title: ðŸ¤” Think about it
              content: >-
                There are 9 possible combinations (3Ã—3), but some simplify. Check for tie first, then you have 6 win
                cases to check.
            - title: ðŸ’¡ Hint
              content: >-
                First check if p1 == p2 (tie). Then check the three cases where p1 wins: (rock, scissors), (paper,
                rock), (scissors, paper). Otherwise p2 wins.
            - title: ðŸ”§ Pattern
              content: |-
                <pre>1. If p1 == p2: return "tie"
                2. If (p1==rock && p2==scissors) OR
                      (p1==paper && p2==rock) OR
                      (p1==scissors && p2==paper):
                      return "p1"
                3. Else: return "p2"</pre>
          solution: |-
            func rps(p1, p2 string) string {
                if p1 == p2 {
                    return "tie"
                }
                if (p1 == "rock" && p2 == "scissors") ||
                   (p1 == "paper" && p2 == "rock") ||
                   (p1 == "scissors" && p2 == "paper") {
                    return "p1"
                }
                return "p2"
            }
        - id: v9
          title: Rating Categories
          description: >-
            Write <code>func ratingCategory(rating int) string</code>: "Poor" (0-2), "Fair" (3-5), "Good" (6-8),
            "Excellent" (9-10).
          functionSignature: func ratingCategory(rating int) string
          testCases:
            - input: "8"
              output: "\"Good\""
            - input: "10"
              output: "\"Excellent\""
            - input: "1"
              output: "\"Poor\""
          hints:
            - title: ðŸ¤” Think about it
              content: Use if-else chain to check ranges. Order matters - check highest first or use <= appropriately.
            - title: ðŸ’¡ Hint
              content: if rating <= 2 return "Poor", else if rating <= 5 return "Fair", etc.
            - title: ðŸ”§ Pattern
              content: |-
                <pre>if rating <= 2: Poor
                else if rating <= 5: Fair
                else if rating <= 8: Good
                else: Excellent</pre>
          solution: |-
            func ratingCategory(rating int) string {
                if rating <= 2 { return "Poor" }
                if rating <= 5 { return "Fair" }
                if rating <= 8 { return "Good" }
                return "Excellent"
            }
          difficulty: 2
        - id: v10
          title: Message Priority
          description: >-
            Write <code>func messagePriority(msg string) string</code>: "URGENT" if contains "ASAP", "High" if starts
            with "Important", else "Normal".
          functionSignature: func messagePriority(msg string) string
          testCases:
            - input: "\"Please reply ASAP\""
              output: "\"URGENT\""
            - input: "\"Important meeting tomorrow\""
              output: "\"High\""
            - input: "\"Hello there\""
              output: "\"Normal\""
          hints:
            - title: ðŸ¤” Think about it
              content: Check for "ASAP" first (most urgent), then check prefix, otherwise default to Normal.
            - title: ðŸ’¡ Hint
              content: Use strings.Contains() for ASAP, strings.HasPrefix() for Important.
            - title: ðŸ”§ Pattern
              content: |-
                <pre>if contains "ASAP": URGENT
                else if starts with "Important": High
                else: Normal</pre>
          solution: |-
            func messagePriority(msg string) string {
                if strings.Contains(msg, "ASAP") { return "URGENT" }
                if strings.HasPrefix(msg, "Important") { return "High" }
                return "Normal"
            }
          difficulty: 2
        - id: v11
          title: BMI Category
          description: >-
            Write <code>func bmiCategory(bmi float64) string</code> returning "Underweight" (bmi < 18.5), "Normal"
            (18.5-24.9), "Overweight" (25-29.9), or "Obese" (30+).
          functionSignature: func bmiCategory(bmi float64) string
          testCases:
            - input: "22.5"
              output: "\"Normal\""
            - input: "17.0"
              output: "\"Underweight\""
            - input: "31.5"
              output: "\"Obese\""
          hints:
            - title: ðŸ¤” Think about it
              content: Multiple ranges to check. What order should you check them to avoid incorrect matches?
            - title: ðŸ’¡ Hint
              content: "Check from lowest to highest using upper bounds: if bmi < 18.5, if bmi < 25, if bmi < 30, else."
            - title: ðŸ”§ Pattern
              content: |-
                <pre>if bmi < 18.5 { return "Underweight" }
                if bmi < 25 { return "Normal" }
                if bmi < 30 { return "Overweight" }
                return "Obese"</pre>
          solution: |-
            func bmiCategory(bmi float64) string {
                if bmi < 18.5 { return "Underweight" }
                if bmi < 25 { return "Normal" }
                if bmi < 30 { return "Overweight" }
                return "Obese"
            }
          difficulty: 1
        - id: v12
          title: Water State
          description: >-
            Write <code>func waterState(temp int) string</code> returning "ice" (temp <= 0), "water" (1-99), or "steam"
            (temp >= 100). Temperatures in Celsius.
          functionSignature: func waterState(temp int) string
          testCases:
            - input: "25"
              output: "\"water\""
            - input: "-5"
              output: "\"ice\""
            - input: "100"
              output: "\"steam\""
          hints:
            - title: ðŸ¤” Think about it
              content: Three states with specific temperature boundaries. What's the cleanest order to check them?
            - title: ðŸ’¡ Hint
              content: "Check boundaries in order: if temp <= 0 (ice), else if temp >= 100 (steam), else (water)."
            - title: ðŸ”§ Pattern
              content: |-
                <pre>if temp <= 0 { return "ice" }
                if temp >= 100 { return "steam" }
                return "water"</pre>
          solution: |-
            func waterState(temp int) string {
                if temp <= 0 { return "ice" }
                if temp >= 100 { return "steam" }
                return "water"
            }
          difficulty: 1
        - id: v13
          title: Discount Calculator
          description: >-
            Write <code>func discount(price int, isPremium bool, quantity int) int</code>. Premium members get 20% off.
            Non-premium get 10% off if quantity >= 5, else no discount. Return final price.
          functionSignature: func discount(price int, isPremium bool, quantity int) int
          testCases:
            - input: 100, true, 1
              output: "80"
              note: "Premium: 20% off"
            - input: 100, false, 6
              output: "90"
              note: "Non-premium bulk: 10% off"
            - input: 100, false, 3
              output: "100"
              note: "Non-premium small: no discount"
          hints:
            - title: ðŸ¤” Think about it
              content: >-
                Multiple conditions that interact: membership status AND quantity. Check premium first since it's
                simpler.
            - title: ðŸ’¡ Hint
              content: if isPremium â†’ 20% off. else if quantity >= 5 â†’ 10% off. else â†’ no discount.
            - title: ðŸ”§ Pattern
              content: |-
                <pre>if isPremium { return price * 80 / 100 }
                if quantity >= 5 { return price * 90 / 100 }
                return price</pre>
          solution: |-
            func discount(price int, isPremium bool, quantity int) int {
                if isPremium { return price * 80 / 100 }
                if quantity >= 5 { return price * 90 / 100 }
                return price
            }
          difficulty: 1
        - id: v14
          title: Categorize Numbers
          description: >-
            Write <code>func categorizeNumbers(nums []int) map[string][]int</code> that categorizes numbers into "small"
            (<10), "medium" (10-99), or "large" (>=100). Returns a map where keys are categories and values are slices
            of numbers in that category.
          functionSignature: func categorizeNumbers(nums []int) map[string][]int
          testCases:
            - input: "[]int{5, 15, 150, 8, 25, 200}"
              output: map["small":[5, 8] "medium":[15, 25] "large":[150, 200]]
            - input: "[]int{1, 10, 100}"
              output: map["small":[1] "medium":[10] "large":[100]]
          hints:
            - title: ðŸ¤” Think about it
              content: >-
                Create a map where each category name maps to a slice of integers. For each number, determine which
                category it belongs to and append it to that category's slice.
            - title: ðŸ’¡ Hint
              content: >-
                Initialize map with three empty slices. Use if-else to check: num < 10, num < 100, else. Append to the
                appropriate slice.
            - title: ðŸ”§ Pattern
              content: |-
                <pre>1. Create map[string][]int
                2. For each num:
                   - num < 10? â†’ append to "small"
                   - num < 100? â†’ append to "medium"
                   - else â†’ append to "large"
                3. Return map</pre>
          solution: |-
            func categorizeNumbers(nums []int) map[string][]int {
                categories := map[string][]int{
                    "small": {},
                    "medium": {},
                    "large": {},
                }
                
                for _, num := range nums {
                    if num < 10 {
                        categories["small"] = append(categories["small"], num)
                    } else if num < 100 {
                        categories["medium"] = append(categories["medium"], num)
                    } else {
                        categories["large"] = append(categories["large"], num)
                    }
                }
                
                return categories
            }
          difficulty: 3
        - id: v15
          title: Score to Grade with Plus/Minus
          description: >-
            Write <code>func scoreToGradePlus(score int) string</code> that converts a score to a letter grade with +/-
            modifiers. A+ (97-100), A (93-96), A- (90-92), B+ (87-89), B (83-86), B- (80-82), etc. Below 60 is F.
          functionSignature: func scoreToGradePlus(score int) string
          testCases:
            - input: "98"
              output: "\"A+\""
            - input: "85"
              output: "\"B\""
            - input: "72"
              output: "\"C-\""
          hints:
            - title: ðŸ¤” Think about it
              content: >-
                You need precise range checking for 12 different grade levels. Start from the top (100) and work down
                with else-if chains.
            - title: ðŸ’¡ Hint
              content: >-
                Check score >= 97 for A+, >= 93 for A, >= 90 for A-, >= 87 for B+, and so on. Each check needs exact
                boundaries.
            - title: ðŸ”§ Pattern
              content: |-
                <pre>if score >= 97 { return "A+" }
                if score >= 93 { return "A" }
                if score >= 90 { return "A-" }
                ... continue pattern ...
                return "F"</pre>
          solution: |-
            func scoreToGradePlus(score int) string {
                if score >= 97 { return "A+" }
                if score >= 93 { return "A" }
                if score >= 90 { return "A-" }
                if score >= 87 { return "B+" }
                if score >= 83 { return "B" }
                if score >= 80 { return "B-" }
                if score >= 77 { return "C+" }
                if score >= 73 { return "C" }
                if score >= 70 { return "C-" }
                if score >= 67 { return "D+" }
                if score >= 63 { return "D" }
                if score >= 60 { return "D-" }
                return "F"
            }
          difficulty: 3
        - id: v16
          title: Calculate Shipping Cost
          description: >-
            Write <code>func calculateShipping(weight float64, distance int, isPriority bool) float64</code> that
            calculates shipping cost. Base cost = weight * 0.5 + distance * 0.1. If isPriority, multiply total by 1.5.
            If weight > 50, add $10. If distance > 1000, add $20.
          functionSignature: func calculateShipping(weight float64, distance int, isPriority bool) float64
          testCases:
            - input: 30.0, 500, false
              output: "65.0"
              note: 30*0.5 + 500*0.1 = 15 + 50 = 65
            - input: 60.0, 1200, true
              output: "247.5"
              note: (60*0.5 + 1200*0.1 + 10 + 20) * 1.5 = 165 * 1.5 = 247.5
          hints:
            - title: ðŸ¤” Think about it
              content: >-
                Calculate base cost first. Then add conditional fees. Finally, apply priority multiplier if needed.
                Order matters!
            - title: ðŸ’¡ Hint
              content: >-
                Start: cost = weight * 0.5 + distance * 0.1. Then: if weight > 50, cost += 10. if distance > 1000, cost
                += 20. Finally: if isPriority, cost *= 1.5.
            - title: ðŸ”§ Pattern
              content: |-
                <pre>1. Calculate base: weight*0.5 + distance*0.1
                2. Add weight surcharge if needed
                3. Add distance surcharge if needed
                4. Apply priority multiplier if needed
                5. Return total</pre>
          solution: |-
            func calculateShipping(weight float64, distance int, isPriority bool) float64 {
                cost := weight * 0.5 + float64(distance) * 0.1
                
                if weight > 50 {
                    cost += 10
                }
                
                if distance > 1000 {
                    cost += 20
                }
                
                if isPriority {
                    cost *= 1.5
                }
                
                return cost
            }
          difficulty: 3
    - id: challenge_4
      block: 1
      difficulty: 1
      concept: Finding Extrema
      docLinks:
        - url: https://go.dev/ref/spec#Index_expressions
          title: "Go Spec: Index expressions"
          note: accessing slice elements
        - url: https://pkg.go.dev/builtin#len
          title: Builtin len()
          note: string and slice length
      patternPrimer:
        bruteForce: Track the current best value; update whenever you find a better one.
        bestApproach: Same approach - initialize to first element, then compare each subsequent element.
        typical: Typically O(n) time, O(1) extra space
      variants:
        - id: v1
          title: Find Maximum
          description: Write <code>func max(nums []int) int</code> that returns the largest number.
          functionSignature: func max(nums []int) int
          testCases:
            - input: "[]int{3, 7, 2, 9}"
              output: "9"
          hints:
            - title: ðŸ¤” Think about it
              content: >-
                If you want to track the 'best so far', what's a reasonable starting value? Hint: what if the first
                element is the answer?
            - title: ðŸ’¡ Hint
              content: >-
                Initialize with the first element (not 0 or some arbitrary value). Compare each subsequent element - if
                it's better, update your best.
            - title: ðŸ”§ Pattern
              content: |-
                <pre>1. Start with first element as "best so far"
                2. For each remaining element:
                   - Better than current best? â†’ update best
                3. Return best</pre>
          solution: |-
            func max(nums []int) int {
                m := nums[0]
                for _, n := range nums {
                    if n > m { m = n }
                }
                return m
            }
          difficulty: 1
        - id: v2
          title: Find Minimum
          description: Write <code>func min(nums []int) int</code> that returns the smallest number.
          functionSignature: func min(nums []int) int
          testCases:
            - input: "[]int{3, 7, 2, 9}"
              output: "2"
          hints:
            - title: ðŸ¤” Think about it
              content: >-
                If you want to track the 'best so far', what's a reasonable starting value? Hint: what if the first
                element is the answer?
            - title: ðŸ’¡ Hint
              content: >-
                Initialize with the first element (not 0 or some arbitrary value). Compare each subsequent element - if
                it's better, update your best.
            - title: ðŸ”§ Pattern
              content: |-
                <pre>1. Start with first element as "best so far"
                2. For each remaining element:
                   - Better than current best? â†’ update best
                3. Return best</pre>
          solution: |-
            func min(nums []int) int {
                m := nums[0]
                for _, n := range nums {
                    if n < m { m = n }
                }
                return m
            }
          difficulty: 1
        - id: v3
          title: Longest String
          description: Write <code>func longest(words []string) string</code> that returns the longest word.
          functionSignature: func longest(words []string) string
          testCases:
            - input: "[]string{\"go\", \"python\"}"
              output: "\"python\""
          hints:
            - title: ðŸ¤” Think about it
              content: >-
                If you want to track the 'best so far', what's a reasonable starting value? Hint: what if the first
                element is the answer?
            - title: ðŸ’¡ Hint
              content: >-
                Initialize with the first element (not 0 or some arbitrary value). Compare each subsequent element - if
                it's better, update your best.
            - title: ðŸ”§ Pattern
              content: |-
                <pre>1. Start with first element as "best so far"
                2. For each remaining element:
                   - Better than current best? â†’ update best
                3. Return best</pre>
          solution: |-
            func longest(words []string) string {
                r := words[0]
                for _, w := range words {
                    if len(w) > len(r) { r = w }
                }
                return r
            }
          difficulty: 1
        - id: v4
          title: Shortest String
          description: Write <code>func shortest(words []string) string</code> that returns the shortest word.
          functionSignature: func shortest(words []string) string
          testCases:
            - input: "[]string{\"go\", \"python\", \"java\"}"
              output: "\"go\""
          hints:
            - title: ðŸ¤” Think about it
              content: >-
                If you want to track the 'best so far', what's a reasonable starting value? Hint: what if the first
                element is the answer?
            - title: ðŸ’¡ Hint
              content: Initialize with the first element. Compare each subsequent element - if it's shorter, update your best.
            - title: ðŸ”§ Pattern
              content: |-
                <pre>1. Start with first element as "best so far"
                2. For each remaining element:
                   - Shorter than current best? â†’ update best
                3. Return best</pre>
          solution: |-
            func shortest(words []string) string {
                r := words[0]
                for _, w := range words {
                    if len(w) < len(r) { r = w }
                }
                return r
            }
          difficulty: 1
        - id: v5
          title: Second Largest
          description: >-
            Write <code>func secondLargest(nums []int) int</code> that returns the second largest number. Assume at
            least 2 distinct numbers.
          functionSignature: func secondLargest(nums []int) int
          testCases:
            - input: "[]int{5, 1, 9, 3}"
              output: "5"
            - input: "[]int{10, 10, 8, 5}"
              output: "8"
          hints:
            - title: ðŸ¤” Think about it
              content: "You need to track TWO values: the best so far AND the second best. When should each one update?"
            - title: ðŸ’¡ Hint
              content: >-
                Track first and second. When you find a new max, the old max becomes second. When you find something
                bigger than second but smaller than first, that becomes the new second.
            - title: ðŸ”§ Pattern
              content: |-
                <pre>1. Initialize first and second with smallest possible values
                2. For each element:
                   - Bigger than first? â†’ second = first, first = element
                   - Bigger than second (and != first)? â†’ second = element
                3. Return second</pre>
          solution: |-
            func secondLargest(nums []int) int {
                first, second := nums[0], nums[1]
                if second > first { first, second = second, first }
                for _, n := range nums[2:] {
                    if n > first { second, first = first, n
                    } else if n > second && n != first { second = n }
                }
                return second
            }
          difficulty: 3
        - id: v6
          title: Smallest Positive
          description: >-
            Write <code>func smallestPositive(nums []int) int</code> that returns the smallest positive number, or -1 if
            none exist.
          functionSignature: func smallestPositive(nums []int) int
          testCases:
            - input: "[]int{-5, 3, -1, 7, 2}"
              output: "2"
            - input: "[]int{-3, -1, 0}"
              output: "-1"
          hints:
            - title: ðŸ¤” Think about it
              content: >-
                You need to find an extrema (minimum) but with a condition (must be positive). What's tricky about
                initializing the 'best so far'?
            - title: ðŸ’¡ Hint
              content: >-
                You can't initialize with nums[0] if it might not be positive. Either find the first positive to
                initialize, or use a flag to track if you've found any positive.
            - title: ðŸ”§ Pattern
              content: |-
                <pre>1. Initialize result to -1 (not found)
                2. For each element:
                   - Is positive AND (first positive OR smaller than result)?
                   â†’ update result
                3. Return result</pre>
          solution: |-
            func smallestPositive(nums []int) int {
                result := -1
                for _, n := range nums {
                    if n > 0 && (result == -1 || n < result) {
                        result = n
                    }
                }
                return result
            }
          difficulty: 2
        - id: v7
          title: Highest Temperature
          description: Write <code>func highestTemp(temps []float64) float64</code> that returns the highest temperature reading.
          functionSignature: func highestTemp(temps []float64) float64
          testCases:
            - input: "[]float64{23.5, 28.7, 22.1, 30.2}"
              output: "30.2"
            - input: "[]float64{-5.5, -2.0, -10.0}"
              output: "-2.0"
          hints:
            - title: ðŸ¤” Think about it
              content: Track the highest temperature seen so far. Initialize with the first reading.
            - title: ðŸ’¡ Hint
              content: Same pattern as finding max - start with first element, update when you find a higher value.
            - title: ðŸ”§ Pattern
              content: |-
                <pre>1. highest := temps[0]
                2. For each temp:
                   - temp > highest? â†’ highest = temp
                3. Return highest</pre>
          solution: |-
            func highestTemp(temps []float64) float64 {
                highest := temps[0]
                for _, t := range temps {
                    if t > highest { highest = t }
                }
                return highest
            }
          difficulty: 1
        - id: v8
          title: Best Game Score
          description: >-
            Write <code>func bestScore(scores []int) int</code> that finds the highest score. Return -1 if no valid
            scores (all negative).
          functionSignature: func bestScore(scores []int) int
          testCases:
            - input: "[]int{450, 320, 580, 410}"
              output: "580"
            - input: "[]int{-1, -5, -3}"
              output: "-1"
          hints:
            - title: ðŸ¤” Think about it
              content: Find the maximum, but only count non-negative scores as valid. What if all scores are negative?
            - title: ðŸ’¡ Hint
              content: >-
                Track the max, but initialize to -1. Only update if you find a score >= 0 that's also greater than
                current max.
            - title: ðŸ”§ Pattern
              content: |-
                <pre>1. bestScore := -1
                2. For each score:
                   - score >= 0 AND score > bestScore?
                     â†’ bestScore = score
                3. Return bestScore</pre>
          solution: |-
            func bestScore(scores []int) int {
                bestScore := -1
                for _, s := range scores {
                    if s >= 0 && s > bestScore {
                        bestScore = s
                    }
                }
                return bestScore
            }
          difficulty: 2
        - id: v9
          title: Most Expensive Item
          description: >-
            Write <code>func mostExpensive(prices []float64) int</code> that returns the INDEX of the most expensive
            item.
          functionSignature: func mostExpensive(prices []float64) int
          testCases:
            - input: "[]float64{12.99, 45.50, 23.75, 50.00}"
              output: "3"
            - input: "[]float64{100.0, 200.0, 150.0}"
              output: "1"
          hints:
            - title: ðŸ¤” Think about it
              content: Instead of tracking the maximum VALUE, track the INDEX where the maximum occurs.
            - title: ðŸ’¡ Hint
              content: "Keep two variables: maxPrice and maxIndex. When you find a higher price, update both."
            - title: ðŸ”§ Pattern
              content: |-
                <pre>1. maxPrice, maxIndex := prices[0], 0
                2. For i, price:
                   - price > maxPrice?
                     â†’ maxPrice = price, maxIndex = i
                3. Return maxIndex</pre>
          solution: |-
            func mostExpensive(prices []float64) int {
                maxPrice, maxIndex := prices[0], 0
                for i, price := range prices {
                    if price > maxPrice {
                        maxPrice = price
                        maxIndex = i
                    }
                }
                return maxIndex
            }
          difficulty: 2
        - id: v10
          title: Find Two Largest
          description: >-
            Write <code>func findTwoLargest(nums []int) (int, int)</code> that returns the two largest distinct values.
            First return value is the largest, second is second-largest.
          functionSignature: func findTwoLargest(nums []int) (int, int)
          testCases:
            - input: "[]int{3, 7, 2, 9, 5}"
              output: 9, 7
            - input: "[]int{1, 2, 3, 4, 5}"
              output: 5, 4
          hints:
            - title: ðŸ¤” Think about it
              content: >-
                You need to track TWO values as you iterate: the largest and second-largest. When you find a new max,
                the old max becomes second-max.
            - title: ðŸ’¡ Hint
              content: >-
                Initialize first and second to very small values. For each number: if it's bigger than first, shift
                first to second, then update first. Else if it's bigger than second, update second.
            - title: ðŸ”§ Pattern
              content: |-
                <pre>1. first, second := nums[0], nums[1]
                   (handle if first < second)
                2. For each remaining num:
                   - num > first? â†’ second = first, first = num
                   - num > second? â†’ second = num
                3. Return first, second</pre>
          solution: |-
            func findTwoLargest(nums []int) (int, int) {
                first, second := nums[0], nums[1]
                if first < second {
                    first, second = second, first
                }
                
                for i := 2; i < len(nums); i++ {
                    if nums[i] > first {
                        second = first
                        first = nums[i]
                    } else if nums[i] > second {
                        second = nums[i]
                    }
                }
                
                return first, second
            }
          difficulty: 3
        - id: v11
          title: Longest String and Length
          description: >-
            Write <code>func longestStringAndLen(words []string) (string, int)</code> that returns the longest string
            and its length. If multiple strings tie for longest, return the first one.
          functionSignature: func longestStringAndLen(words []string) (string, int)
          testCases:
            - input: "[\"go\", \"rust\", \"python\"]"
              output: "\"python\", 6"
            - input: "[\"hello\", \"world\"]"
              output: "\"hello\", 5"
              note: both length 5, return first
          hints:
            - title: ðŸ¤” Think about it
              content: >-
                Track both the longest word AND its length. For each word, compute len(word) and compare to current max
                length.
            - title: ðŸ’¡ Hint
              content: Keep longest string and maxLen. For each word, if len(word) > maxLen, update both longest and maxLen.
            - title: ðŸ”§ Pattern
              content: |-
                <pre>1. longest := words[0], maxLen := len(words[0])
                2. For each word:
                   - len(word) > maxLen?
                     â†’ longest = word, maxLen = len(word)
                3. Return longest, maxLen</pre>
          solution: |-
            func longestStringAndLen(words []string) (string, int) {
                longest := words[0]
                maxLen := len(words[0])
                
                for _, word := range words {
                    if len(word) > maxLen {
                        longest = word
                        maxLen = len(word)
                    }
                }
                
                return longest, maxLen
            }
          difficulty: 3
        - id: v12
          title: Find Range (Max - Min)
          description: >-
            Write <code>func findRange(nums []int) int</code> that returns the difference between the maximum and
            minimum values in the slice (range = max - min).
          functionSignature: func findRange(nums []int) int
          testCases:
            - input: "[]int{3, 7, 2, 9, 5}"
              output: "7"
              note: 9 - 2 = 7
            - input: "[]int{1, 1, 1}"
              output: "0"
          hints:
            - title: ðŸ¤” Think about it
              content: You need to find both the maximum and minimum values, then calculate their difference.
            - title: ðŸ’¡ Hint
              content: >-
                Track both max and min as you iterate. Initialize both to nums[0]. For each number, update max if
                larger, update min if smaller. Return max - min.
            - title: ðŸ”§ Pattern
              content: |-
                <pre>1. max, min := nums[0], nums[0]
                2. For each num:
                   - num > max? â†’ max = num
                   - num < min? â†’ min = num
                3. Return max - min</pre>
          solution: |-
            func findRange(nums []int) int {
                max, min := nums[0], nums[0]
                
                for _, num := range nums {
                    if num > max {
                        max = num
                    }
                    if num < min {
                        min = num
                    }
                }
                
                return max - min
            }
          difficulty: 3
        - id: v1
          title: Best Time to Buy and Sell Stock
          description: >-
            Given an array of stock prices where prices[i] is the price on day i, find the maximum profit from one buy
            and one sell. You must buy before you sell. <code>func maxProfit(prices []int) int</code>
          functionSignature: func maxProfit(prices []int) int
          testCases:
            - input: "[]int{7, 1, 5, 3, 6, 4}"
              output: "5"
              note: buy at 1, sell at 6
            - input: "[]int{7, 6, 4, 3, 1}"
              output: "0"
              note: prices only go down, no profit possible
            - input: "[]int{2, 4, 1}"
              output: "2"
              note: buy at 2, sell at 4
          solution: |-
            func maxProfit(prices []int) int {
                if len(prices) == 0 {
                    return 0
                }
                
                minPrice := prices[0]
                maxProfit := 0
                
                for _, price := range prices {
                    if price < minPrice {
                        minPrice = price
                    } else if price - minPrice > maxProfit {
                        maxProfit = price - minPrice
                    }
                }
                return maxProfit
            }
          difficulty: 4
        - id: v2
          title: Maximum Difference
          description: >-
            Find the maximum difference between any two elements where the larger element comes after the smaller one.
            Return 0 if no such pair exists. <code>func maxDiff(nums []int) int</code>
          functionSignature: func maxDiff(nums []int) int
          testCases:
            - input: "[]int{2, 3, 10, 6, 4, 8, 1}"
              output: "8"
              note: 10 - 2 = 8
            - input: "[]int{7, 9, 5, 6, 3, 2}"
              output: "2"
              note: 9 - 7 = 2
            - input: "[]int{5, 4, 3, 2, 1}"
              output: "0"
              note: decreasing, no valid pair
          solution: |-
            func maxDiff(nums []int) int {
                if len(nums) < 2 {
                    return 0
                }
                
                minSoFar := nums[0]
                maxDiff := 0
                
                for i := 1; i < len(nums); i++ {
                    diff := nums[i] - minSoFar
                    if diff > maxDiff {
                        maxDiff = diff
                    }
                    if nums[i] < minSoFar {
                        minSoFar = nums[i]
                    }
                }
                return maxDiff
            }
          solutionNotes: >-
            This is the same problem as Best Time to Buy/Sell Stock! Track the minimum seen so far, and at each position
            calculate the potential profit/difference.
          difficulty: 4
        - id: v3
          title: Best Sightseeing Pair
          description: >-
            Given an array of values, find max score of values[i] + values[j] + i - j where i < j. <code>func
            maxScoreSightseeingPair(values []int) int</code>
          functionSignature: func maxScoreSightseeingPair(values []int) int
          testCases:
            - input: "[]int{8, 1, 5, 2, 6}"
              output: "11"
              note: "i=0, j=2: 8+5+0-2=11"
            - input: "[]int{1, 2}"
              output: "2"
              note: 1+2+0-1=2
            - input: "[]int{1, 3, 5}"
              output: "7"
              note: "i=1, j=2: 3+5+1-2=7"
          solution: |-
            func maxScoreSightseeingPair(values []int) int {
                maxScore := 0
                bestI := values[0] + 0  // values[i] + i
                
                for j := 1; j < len(values); j++ {
                    score := bestI + values[j] - j
                    if score > maxScore {
                        maxScore = score
                    }
                    if values[j] + j > bestI {
                        bestI = values[j] + j
                    }
                }
                return maxScore
            }
          solutionNotes: >-
            Rewrite the formula: (values[i] + i) + (values[j] - j). Track the best (values[i] + i) seen so far, then for
            each j compute the score. Same pattern as stock problem!
          difficulty: 4
        - id: v4
          title: Maximum Subarray (Kadane's)
          description: Find the contiguous subarray with the largest sum. <code>func maxSubArray(nums []int) int</code>
          functionSignature: func maxSubArray(nums []int) int
          testCases:
            - input: "[]int{-2, 1, -3, 4, -1, 2, 1, -5, 4}"
              output: "6"
              note: "[4,-1,2,1] = 6"
            - input: "[]int{1}"
              output: "1"
            - input: "[]int{-1, -2, -3}"
              output: "-1"
              note: least negative
          solution: |-
            func maxSubArray(nums []int) int {
                maxSum := nums[0]
                currentSum := nums[0]
                
                for i := 1; i < len(nums); i++ {
                    if currentSum < 0 {
                        currentSum = nums[i]
                    } else {
                        currentSum += nums[i]
                    }
                    if currentSum > maxSum {
                        maxSum = currentSum
                    }
                }
                return maxSum
            }
          solutionNotes: >-
            Kadane's algorithm: at each position, decide whether to extend the current subarray or start fresh. Track
            the best sum seen so far. Same 'best so far' pattern!
          difficulty: 4
        - id: v5
          title: Best Time to Buy and Sell Stock II
          description: >-
            You can buy and sell multiple times (but must sell before buying again). Find the maximum total profit.
            <code>func maxProfitII(prices []int) int</code>
          functionSignature: func maxProfitII(prices []int) int
          testCases:
            - input: "[]int{7, 1, 5, 3, 6, 4}"
              output: "7"
              note: buy@1 sell@5 (+4), buy@3 sell@6 (+3)
            - input: "[]int{1, 2, 3, 4, 5}"
              output: "4"
              note: buy@1 sell@5, or buy/sell each day
            - input: "[]int{7, 6, 4, 3, 1}"
              output: "0"
              note: no profit possible
          solution: |-
            func maxProfitII(prices []int) int {
                profit := 0
                
                for i := 1; i < len(prices); i++ {
                    if prices[i] > prices[i-1] {
                        profit += prices[i] - prices[i-1]
                    }
                }
                return profit
            }
          solutionNotes: >-
            Greedy insight: capture every upward movement! If tomorrow's price is higher, that's profit. Sum all
            positive differences. Much simpler than it seems!
          difficulty: 4
        - id: v6
          title: Trapping Rain Water
          description: >-
            Given an elevation map where width of each bar is 1, compute how much water can be trapped after raining.
            <code>func trap(height []int) int</code>
          functionSignature: func trap(height []int) int
          testCases:
            - input: "[]int{0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1}"
              output: "6"
            - input: "[]int{4, 2, 0, 3, 2, 5}"
              output: "9"
            - input: "[]int{1, 2, 3}"
              output: "0"
              note: strictly increasing, no trapping
          solution: |-
            func trap(height []int) int {
                if len(height) == 0 {
                    return 0
                }
                
                n := len(height)
                maxLeft := make([]int, n)
                maxRight := make([]int, n)
                
                maxLeft[0] = height[0]
                for i := 1; i < n; i++ {
                    if height[i] > maxLeft[i-1] {
                        maxLeft[i] = height[i]
                    } else {
                        maxLeft[i] = maxLeft[i-1]
                    }
                }
                
                maxRight[n-1] = height[n-1]
                for i := n - 2; i >= 0; i-- {
                    if height[i] > maxRight[i+1] {
                        maxRight[i] = height[i]
                    } else {
                        maxRight[i] = maxRight[i+1]
                    }
                }
                
                water := 0
                for i := 0; i < n; i++ {
                    level := maxLeft[i]
                    if maxRight[i] < level {
                        level = maxRight[i]
                    }
                    water += level - height[i]
                }
                return water
            }
          solutionNotes: >-
            At each position, water level = min(maxLeft, maxRight). Pre-compute maxLeft[i] and maxRight[i] arrays using
            the 'best so far' pattern in both directions!
          difficulty: 4
    - id: challenge_5
      block: 2
      difficulty: 2
      concept: Filter with Append
      docLinks:
        - url: https://pkg.go.dev/builtin#append
          title: Builtin append()
          note: growing slices dynamically
        - url: https://go.dev/blog/slices-intro
          title: "Go Blog: Slices introduction"
          note: slice internals
      patternPrimer:
        bruteForce: Create a new slice and append elements that pass the condition.
        bestApproach: Same approach - loop once, append conditionally. Can't do better than O(n).
        typical: Typically O(n) time, O(k) extra space where k = filtered elements
      variants:
        - id: v1
          title: Filter Positives
          description: Write <code>func filterPositives(nums []int) []int</code> returning only positive numbers.
          functionSignature: func filterPositives(nums []int) []int
          testCases:
            - input: "[]int{-2, 3, -1, 5}"
              output: "[3, 5]"
          hints:
            - title: ðŸ¤” Think about it
              content: >-
                You want to build a new collection containing only some elements. What do you start with, and how do you
                add elements that pass your test?
            - title: ðŸ’¡ Hint
              content: Start with an empty slice. Loop through, check your condition, and append elements that pass.
            - title: ðŸ”§ Pattern
              content: |-
                <pre>1. Start with empty result collection
                2. For each element:
                   - Passes test? â†’ add to result
                3. Return result</pre>
          solution: |-
            func filterPositives(nums []int) []int {
                r := []int{}
                for _, n := range nums {
                    if n > 0 { r = append(r, n) }
                }
                return r
            }
          difficulty: 1
        - id: v2
          title: Filter Evens
          description: Write <code>func filterEvens(nums []int) []int</code> returning only even numbers.
          functionSignature: func filterEvens(nums []int) []int
          testCases:
            - input: "[]int{1, 2, 3, 4}"
              output: "[2, 4]"
          hints:
            - title: ðŸ¤” Think about it
              content: >-
                You want to build a new collection containing only some elements. What do you start with, and how do you
                add elements that pass your test?
            - title: ðŸ’¡ Hint
              content: Start with an empty slice. Loop through, check your condition, and append elements that pass.
            - title: ðŸ”§ Pattern
              content: |-
                <pre>1. Start with empty result collection
                2. For each element:
                   - Passes test? â†’ add to result
                3. Return result</pre>
          solution: |-
            func filterEvens(nums []int) []int {
                r := []int{}
                for _, n := range nums {
                    if n%2 == 0 { r = append(r, n) }
                }
                return r
            }
          difficulty: 1
        - id: v3
          title: Filter Short Words
          description: Write <code>func filterShort(words []string, max int) []string</code> returning words with len <= max.
          functionSignature: func filterShort(words []string, max int) []string
          testCases:
            - input: "[]string{\"go\", \"python\"}, 3"
              output: "[\"go\"]"
          hints:
            - title: ðŸ¤” Think about it
              content: >-
                You want to build a new collection containing only some elements. What do you start with, and how do you
                add elements that pass your test?
            - title: ðŸ’¡ Hint
              content: Start with an empty slice. Loop through, check your condition, and append elements that pass.
            - title: ðŸ”§ Pattern
              content: |-
                <pre>1. Start with empty result collection
                2. For each element:
                   - Passes test? â†’ add to result
                3. Return result</pre>
          solution: |-
            func filterShort(words []string, max int) []string {
                r := []string{}
                for _, w := range words {
                    if len(w) <= max { r = append(r, w) }
                }
                return r
            }
          difficulty: 2
        - id: v4
          title: Filter Greater Than
          description: >-
            Write <code>func filterGreater(nums []int, threshold int) []int</code> returning only numbers greater than
            threshold.
          functionSignature: func filterGreater(nums []int, threshold int) []int
          testCases:
            - input: "[]int{1, 5, 3, 8, 2}, 3"
              output: "[5, 8]"
          hints:
            - title: ðŸ¤” Think about it
              content: >-
                You want to build a new collection containing only some elements. What do you start with, and how do you
                add elements that pass your test?
            - title: ðŸ’¡ Hint
              content: Start with an empty slice. Loop through, check if n > threshold, and append elements that pass.
            - title: ðŸ”§ Pattern
              content: |-
                <pre>1. Start with empty result slice
                2. For each element:
                   - Passes test? â†’ append to result
                3. Return result</pre>
          solution: |-
            func filterGreater(nums []int, threshold int) []int {
                r := []int{}
                for _, n := range nums {
                    if n > threshold { r = append(r, n) }
                }
                return r
            }
          difficulty: 1
        - id: v5
          title: Filter Non-Empty
          description: Write <code>func filterNonEmpty(words []string) []string</code> returning only non-empty strings.
          functionSignature: func filterNonEmpty(words []string) []string
          testCases:
            - input: "[]string{\"go\", \"\", \"python\", \"\"}"
              output: "[\"go\", \"python\"]"
          hints:
            - title: ðŸ¤” Think about it
              content: You want to filter out empty strings. How do you check if a string is empty?
            - title: ðŸ’¡ Hint
              content: Check if len(w) > 0 or equivalently w != "". Append only strings that pass this test.
            - title: ðŸ”§ Pattern
              content: |-
                <pre>1. Start with empty result slice
                2. For each element:
                   - Not empty? â†’ append to result
                3. Return result</pre>
          solution: |-
            func filterNonEmpty(words []string) []string {
                r := []string{}
                for _, w := range words {
                    if w != "" { r = append(r, w) }
                }
                return r
            }
          difficulty: 1
        - id: v6
          title: Filter In Range
          description: >-
            Write <code>func filterInRange(nums []int, min, max int) []int</code> returning numbers where min <= n <=
            max.
          functionSignature: func filterInRange(nums []int, min, max int) []int
          testCases:
            - input: "[]int{1, 5, 3, 8, 2}, 2, 5"
              output: "[5, 3, 2]"
          hints:
            - title: ðŸ¤” Think about it
              content: "You need to check TWO conditions: the number must be >= min AND <= max."
            - title: ðŸ’¡ Hint
              content: Use n >= min && n <= max as your filter condition. Only append elements that satisfy both conditions.
            - title: ðŸ”§ Pattern
              content: |-
                <pre>1. Start with empty result slice
                2. For each element:
                   - In range [min, max]? â†’ append to result
                3. Return result</pre>
          solution: |-
            func filterInRange(nums []int, min, max int) []int {
                r := []int{}
                for _, n := range nums {
                    if n >= min && n <= max { r = append(r, n) }
                }
                return r
            }
          difficulty: 2
        - id: v7
          title: Filter Palindromes
          difficulty: 3
          description: >-
            Write <code>func filterPalindromes(words []string) []string</code> that returns only palindromes (words that
            read the same forwards and backwards). Ignore case.
          functionSignature: func filterPalindromes(words []string) []string
          testCases:
            - input: "[]string{\"racecar\", \"hello\", \"level\", \"world\", \"noon\"}"
              output: "[\"racecar\", \"level\", \"noon\"]"
            - input: "[]string{\"Go\", \"was\", \"it\", \"a\", \"cat\", \"I\", \"saw\"}"
              output: "[\"a\", \"I\"]"
              note: Single chars are palindromes
          hints:
            - title: ðŸ¤” Think about it
              content: >-
                You need to filter, but the condition itself is complex (checking if a word is a palindrome). You'll
                need a helper function.
            - title: ðŸ’¡ Hint
              content: >-
                Create isPalindrome(s string) bool that uses two pointers from opposite ends. Then filter: for each
                word, if isPalindrome(word), append it.
            - title: ðŸ”§ Pattern
              content: |-
                <pre>1. result := []string{}
                2. For each word:
                   - If isPalindrome(word): append to result
                3. Return result

                isPalindrome(s):
                  - left, right pointers from ends
                  - Compare chars moving inward</pre>
          solution: |-
            func filterPalindromes(words []string) []string {
                result := []string{}
                for _, w := range words {
                    if isPalindrome(w) {
                        result = append(result, w)
                    }
                }
                return result
            }

            func isPalindrome(s string) bool {
                s = strings.ToLower(s)
                left, right := 0, len(s)-1
                for left < right {
                    if s[left] != s[right] {
                        return false
                    }
                    left++
                    right--
                }
                return true
            }
        - id: v8
          title: Filter Prime Numbers
          difficulty: 3
          description: >-
            Write <code>func filterPrimes(nums []int) []int</code> that returns only prime numbers. A prime is > 1 and
            divisible only by 1 and itself.
          functionSignature: func filterPrimes(nums []int) []int
          testCases:
            - input: "[]int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}"
              output: "[2, 3, 5, 7]"
            - input: "[]int{11, 12, 13, 14, 15}"
              output: "[11, 13]"
          hints:
            - title: ðŸ¤” Think about it
              content: Filtering + prime checking. You'll need an isPrime helper function that checks divisibility.
            - title: ðŸ’¡ Hint
              content: >-
                Create isPrime(n int) bool. A number is prime if n > 1 and no number from 2 to sqrt(n) divides it
                evenly. Then filter using this function.
            - title: ðŸ”§ Pattern
              content: |-
                <pre>1. result := []int{}
                2. For each num:
                   - If isPrime(num): append to result
                3. Return result</pre>
          solution: |-
            func filterPrimes(nums []int) []int {
                result := []int{}
                for _, n := range nums {
                    if isPrime(n) {
                        result = append(result, n)
                    }
                }
                return result
            }

            func isPrime(n int) bool {
                if n <= 1 {
                    return false
                }
                for i := 2; i*i <= n; i++ {
                    if n%i == 0 {
                        return false
                    }
                }
                return true
            }
        - id: v9
          title: Affordable Items
          description: >-
            Write <code>func affordableItems(prices []float64, budget float64) []float64</code> that returns prices
            within budget.
          functionSignature: func affordableItems(prices []float64, budget float64) []float64
          testCases:
            - input: "[]float64{29.99, 45.00, 15.50, 60.00}, 40.0"
              output: "[]float64{29.99, 15.50}"
            - input: "[]float64{100.0, 200.0}, 50.0"
              output: "[]float64{}"
          hints:
            - title: ðŸ¤” Think about it
              content: Filter prices that are <= budget. Append matching prices to result slice.
            - title: ðŸ’¡ Hint
              content: "Standard filter pattern: if price <= budget, append it."
            - title: ðŸ”§ Pattern
              content: |-
                <pre>1. result := []float64{}
                2. For each price:
                   - price <= budget? â†’ append to result
                3. Return result</pre>
          solution: |-
            func affordableItems(prices []float64, budget float64) []float64 {
                result := []float64{}
                for _, price := range prices {
                    if price <= budget {
                        result = append(result, price)
                    }
                }
                return result
            }
          difficulty: 1
        - id: v10
          title: Valid Emails
          description: Write <code>func validEmails(emails []string) []string</code> that returns emails containing '@' symbol.
          functionSignature: func validEmails(emails []string) []string
          testCases:
            - input: "[]string{\"user@example.com\", \"invalid\", \"admin@site.org\"}"
              output: "[]string{\"user@example.com\", \"admin@site.org\"}"
            - input: "[]string{\"nope\", \"nada\"}"
              output: "[]string{}"
          hints:
            - title: ðŸ¤” Think about it
              content: "Simple validation: check if email contains '@'. Use strings.Contains()."
            - title: ðŸ’¡ Hint
              content: Filter emails where strings.Contains(email, "@") is true.
            - title: ðŸ”§ Pattern
              content: |-
                <pre>1. result := []string{}
                2. For each email:
                   - contains '@'? â†’ append to result
                3. Return result</pre>
          solution: |-
            func validEmails(emails []string) []string {
                result := []string{}
                for _, email := range emails {
                    if strings.Contains(email, "@") {
                        result = append(result, email)
                    }
                }
                return result
            }
          difficulty: 1
        - id: v11
          title: Filter By Length Range
          description: >-
            Write <code>func filterByLengthRange(words []string, minLen, maxLen int) []string</code> that returns words
            where minLen <= len(word) <= maxLen.
          functionSignature: func filterByLengthRange(words []string, minLen, maxLen int) []string
          testCases:
            - input: "[]string{\"go\", \"rust\", \"python\", \"c\"}, 2, 4"
              output: "[]string{\"go\", \"rust\"}"
            - input: "[]string{\"a\", \"ab\", \"abc\", \"abcd\"}, 2, 3"
              output: "[]string{\"ab\", \"abc\"}"
          hints:
            - title: ðŸ¤” Think about it
              content: "Check two conditions: length must be >= minLen AND <= maxLen."
            - title: ðŸ’¡ Hint
              content: Filter words where len(word) >= minLen && len(word) <= maxLen.
            - title: ðŸ”§ Pattern
              content: |-
                <pre>1. result := []string{}
                2. For each word:
                   - len(word) in range? â†’ append
                3. Return result</pre>
          solution: |-
            func filterByLengthRange(words []string, minLen, maxLen int) []string {
                result := []string{}
                for _, word := range words {
                    if len(word) >= minLen && len(word) <= maxLen {
                        result = append(result, word)
                    }
                }
                return result
            }
          difficulty: 2
        - id: v12
          title: Filter Multiples
          description: >-
            Write <code>func filterMultiples(nums []int, divisor int) []int</code> that returns only numbers divisible
            by divisor (multiples of divisor).
          functionSignature: func filterMultiples(nums []int, divisor int) []int
          testCases:
            - input: "[]int{3, 6, 7, 9, 12, 15}, 3"
              output: "[]int{3, 6, 9, 12, 15}"
            - input: "[]int{1, 2, 3, 4, 5, 6}, 2"
              output: "[]int{2, 4, 6}"
          hints:
            - title: ðŸ¤” Think about it
              content: A number is divisible by divisor if num % divisor == 0. Filter based on this condition.
            - title: ðŸ’¡ Hint
              content: For each number, check if num % divisor == 0, then append to result.
            - title: ðŸ”§ Pattern
              content: |-
                <pre>1. result := []int{}
                2. For each num:
                   - num % divisor == 0? â†’ append
                3. Return result</pre>
          solution: |-
            func filterMultiples(nums []int, divisor int) []int {
                result := []int{}
                for _, num := range nums {
                    if num % divisor == 0 {
                        result = append(result, num)
                    }
                }
                return result
            }
          difficulty: 2
        - id: v13
          title: Filter Contains Substring
          description: >-
            Write <code>func filterContains(words []string, substr string) []string</code> that returns words containing
            the substring.
          functionSignature: func filterContains(words []string, substr string) []string
          testCases:
            - input: "[]string{\"hello\", \"world\", \"help\", \"loop\"}, \"lo\""
              output: "[]string{\"hello\", \"loop\"}"
            - input: "[]string{\"go\", \"gopher\", \"python\"}, \"go\""
              output: "[]string{\"go\", \"gopher\"}"
          hints:
            - title: ðŸ¤” Think about it
              content: Use strings.Contains() to check if a word contains the substring.
            - title: ðŸ’¡ Hint
              content: Import strings. Filter words where strings.Contains(word, substr) is true.
            - title: ðŸ”§ Pattern
              content: |-
                <pre>1. result := []string{}
                2. For each word:
                   - contains substr? â†’ append
                3. Return result</pre>
          solution: |-
            import "strings"

            func filterContains(words []string, substr string) []string {
                result := []string{}
                for _, word := range words {
                    if strings.Contains(word, substr) {
                        result = append(result, word)
                    }
                }
                return result
            }
          difficulty: 2
    - id: challenge_6
      block: 2
      difficulty: 2
      concept: Find Index
      docLinks:
        - url: https://go.dev/ref/spec#For_statements
          title: "Go Spec: For statements"
          note: range with index
        - url: https://go.dev/ref/spec#Return_statements
          title: "Go Spec: Return statements"
          note: early returns
      patternPrimer:
        bruteForce: Loop through, return index immediately when found; return -1 if not found.
        bestApproach: Same approach - early return is already optimal! No need to continue after finding match.
        typical: Typically O(n) time worst case, O(1) if found early, O(1) extra space
      variants:
        - id: v1
          title: Find Index
          description: Write <code>func findIndex(nums []int, target int) int</code> returning index or -1.
          functionSignature: func findIndex(nums []int, target int) int
          testCases:
            - input: "[]int{10, 20, 30}, 20"
              output: "1"
          hints:
            - title: ðŸ¤” Think about it
              content: >-
                If you're looking for something specific, when should you stop looking? What should you return if you
                never find it?
            - title: ðŸ’¡ Hint
              content: >-
                Loop with the index variable. When you find a match, return that index immediately (early return). If
                the loop completes without finding anything, return -1.
            - title: ðŸ”§ Pattern
              content: |-
                <pre>1. For each element with its index:
                   - Matches target? â†’ return index immediately
                2. Loop finished? â†’ return -1 (not found)</pre>
          solution: |-
            func findIndex(nums []int, target int) int {
                for i, n := range nums {
                    if n == target { return i }
                }
                return -1
            }
          difficulty: 1
        - id: v2
          title: Find Word
          description: Write <code>func findWord(words []string, target string) int</code> returning index or -1.
          functionSignature: func findWord(words []string, target string) int
          testCases:
            - input: "[]string{\"go\", \"py\"}, \"py\""
              output: "1"
          hints:
            - title: ðŸ¤” Think about it
              content: >-
                If you're looking for something specific, when should you stop looking? What should you return if you
                never find it?
            - title: ðŸ’¡ Hint
              content: >-
                Loop with the index variable. When you find a match, return that index immediately (early return). If
                the loop completes without finding anything, return -1.
            - title: ðŸ”§ Pattern
              content: |-
                <pre>1. For each element with its index:
                   - Matches target? â†’ return index immediately
                2. Loop finished? â†’ return -1 (not found)</pre>
          solution: |-
            func findWord(words []string, target string) int {
                for i, w := range words {
                    if w == target { return i }
                }
                return -1
            }
          difficulty: 1
        - id: v3
          title: First Negative Index
          description: Write <code>func firstNegIdx(nums []int) int</code> returning index of first negative or -1.
          functionSignature: func firstNegIdx(nums []int) int
          testCases:
            - input: "[]int{5, -2, 3}"
              output: "1"
          hints:
            - title: ðŸ¤” Think about it
              content: >-
                If you're looking for something specific, when should you stop looking? What should you return if you
                never find it?
            - title: ðŸ’¡ Hint
              content: >-
                Loop with the index variable. When you find a match, return that index immediately (early return). If
                the loop completes without finding anything, return -1.
            - title: ðŸ”§ Pattern
              content: |-
                <pre>1. For each element with its index:
                   - Matches target? â†’ return index immediately
                2. Loop finished? â†’ return -1 (not found)</pre>
          solution: |-
            func firstNegIdx(nums []int) int {
                for i, n := range nums {
                    if n < 0 { return i }
                }
                return -1
            }
          difficulty: 1
        - id: v4
          title: Find First Even
          description: >-
            Write <code>func firstEvenIdx(nums []int) int</code> returning the index of the first even number, or -1 if
            none.
          functionSignature: func firstEvenIdx(nums []int) int
          testCases:
            - input: "[]int{1, 3, 4, 5}"
              output: "2"
            - input: "[]int{1, 3, 5}"
              output: "-1"
          hints:
            - title: ðŸ¤” Think about it
              content: How do you check if a number is even? Use the modulo operator.
            - title: ðŸ’¡ Hint
              content: Check if n % 2 == 0. If so, return that index immediately. Otherwise keep looking.
            - title: ðŸ”§ Pattern
              content: |-
                <pre>1. For each element with its index:
                   - Is even (n % 2 == 0)? â†’ return index
                2. Loop finished? â†’ return -1 (not found)</pre>
          solution: |-
            func firstEvenIdx(nums []int) int {
                for i, n := range nums {
                    if n % 2 == 0 { return i }
                }
                return -1
            }
          difficulty: 1
        - id: v5
          title: Last Index Of
          description: >-
            Write <code>func lastIndex(nums []int, target int) int</code> returning the LAST index where target appears,
            or -1.
          functionSignature: func lastIndex(nums []int, target int) int
          testCases:
            - input: "[]int{1, 2, 3, 2, 1}, 2"
              output: "3"
            - input: "[]int{1, 2, 3}, 5"
              output: "-1"
          hints:
            - title: ðŸ¤” Think about it
              content: >-
                Unlike finding the FIRST match (where you return immediately), for the LAST match you need to keep track
                of matches as you go.
            - title: ðŸ’¡ Hint
              content: >-
                Initialize result to -1. Each time you find a match, update result to that index. After the loop, return
                result.
            - title: ðŸ”§ Pattern
              content: |-
                <pre>1. Initialize result := -1
                2. For each element with its index:
                   - Matches target? â†’ result = index
                3. Return result (last match, or -1)</pre>
          solution: |-
            func lastIndex(nums []int, target int) int {
                result := -1
                for i, n := range nums {
                    if n == target { result = i }
                }
                return result
            }
          difficulty: 2
        - id: v6
          title: Find Long Word Index
          description: >-
            Write <code>func findLongWordIdx(words []string, minLen int) int</code> returning the index of first word
            with length >= minLen, or -1.
          functionSignature: func findLongWordIdx(words []string, minLen int) int
          testCases:
            - input: "[]string{\"go\", \"hi\", \"python\"}, 4"
              output: "2"
            - input: "[]string{\"a\", \"bb\"}, 5"
              output: "-1"
          hints:
            - title: ðŸ¤” Think about it
              content: Instead of matching an exact value, you're matching a condition (length >= minLen).
            - title: ðŸ’¡ Hint
              content: Check if len(w) >= minLen. If so, return that index immediately. Otherwise keep looking.
            - title: ðŸ”§ Pattern
              content: |-
                <pre>1. For each word with its index:
                   - Long enough? â†’ return index
                2. Loop finished? â†’ return -1 (not found)</pre>
          solution: |-
            func findLongWordIdx(words []string, minLen int) int {
                for i, w := range words {
                    if len(w) >= minLen { return i }
                }
                return -1
            }
          difficulty: 1
        - id: v7
          title: Find All Indices
          difficulty: 3
          description: >-
            Write <code>func findAllIndices(nums []int, target int) []int</code> that returns a slice of ALL positions
            where target appears. Return empty slice if not found.
          functionSignature: func findAllIndices(nums []int, target int) []int
          testCases:
            - input: "[]int{1, 3, 5, 3, 7, 3}, 3"
              output: "[1, 3, 5]"
              note: 3 appears at indices 1, 3, and 5
            - input: "[]int{1, 2, 3}, 5"
              output: "[]"
              note: Not found, return empty slice
          hints:
            - title: ðŸ¤” Think about it
              content: Instead of returning on first match, you need to collect ALL matching indices and keep searching.
            - title: ðŸ’¡ Hint
              content: >-
                Create an empty result slice. Loop through all elements - whenever you find a match, append the index to
                result. Don't return early, keep searching.
            - title: ðŸ”§ Pattern
              content: |-
                <pre>1. indices := []int{}
                2. For i, num in enumerate:
                   - If num == target: append i to indices
                3. Return indices (might be empty)</pre>
          solution: |-
            func findAllIndices(nums []int, target int) []int {
                indices := []int{}
                for i, n := range nums {
                    if n == target {
                        indices = append(indices, i)
                    }
                }
                return indices
            }
        - id: v8
          title: Binary Search Index
          difficulty: 3
          description: >-
            Write <code>func binarySearch(nums []int, target int) int</code> that finds target in a SORTED slice using
            binary search. Return index or -1. Must use divide-and-conquer, not linear search.
          functionSignature: func binarySearch(nums []int, target int) int
          testCases:
            - input: "[]int{1, 3, 5, 7, 9, 11}, 7"
              output: "3"
            - input: "[]int{1, 3, 5, 7, 9, 11}, 4"
              output: "-1"
            - input: "[]int{2, 4, 6, 8, 10}, 2"
              output: "0"
          hints:
            - title: ðŸ¤” Think about it
              content: >-
                Since the slice is sorted, you don't need to check every element. Compare target to the middle element -
                this tells you which half to search next.
            - title: ðŸ’¡ Hint
              content: >-
                Use two pointers: left = 0, right = len-1. While left <= right: calculate mid = (left+right)/2. If
                nums[mid] == target, found it! If target < nums[mid], search left half (right = mid-1). Otherwise search
                right half (left = mid+1).
            - title: ðŸ”§ Pattern
              content: |-
                <pre>1. left := 0, right := len(nums)-1
                2. While left <= right:
                   - mid := (left + right) / 2
                   - If nums[mid] == target: return mid
                   - If target < nums[mid]: right = mid - 1
                   - Else: left = mid + 1
                3. Return -1 (not found)</pre>
          solution: |-
            func binarySearch(nums []int, target int) int {
                left, right := 0, len(nums)-1
                for left <= right {
                    mid := (left + right) / 2
                    if nums[mid] == target {
                        return mid
                    } else if target < nums[mid] {
                        right = mid - 1
                    } else {
                        left = mid + 1
                    }
                }
                return -1
            }
        - id: v9
          title: First Negative Index
          description: Write <code>func firstNegativeIdx(nums []int) int</code> that returns index of first negative number, or -1.
          functionSignature: func firstNegativeIdx(nums []int) int
          testCases:
            - input: "[]int{5, 3, -2, 8}"
              output: "2"
            - input: "[]int{1, 2, 3}"
              output: "-1"
          hints:
            - title: ðŸ¤” Think about it
              content: Return index as soon as you find num < 0.
            - title: ðŸ’¡ Hint
              content: "Early return pattern: for i, num := range nums { if num < 0 { return i } }"
            - title: ðŸ”§ Pattern
              content: |-
                <pre>1. For i, num:
                   - num < 0? â†’ return i
                2. Return -1</pre>
          solution: |-
            func firstNegativeIdx(nums []int) int {
                for i, num := range nums {
                    if num < 0 { return i }
                }
                return -1
            }
          difficulty: 1
        - id: v10
          title: Find Keyword Position
          description: >-
            Write <code>func findKeyword(words []string, keyword string) int</code> that returns index of keyword
            (case-insensitive).
          functionSignature: func findKeyword(words []string, keyword string) int
          testCases:
            - input: "[]string{\"hello\", \"WORLD\", \"Go\"}, \"world\""
              output: "1"
            - input: "[]string{\"apple\", \"banana\"}, \"orange\""
              output: "-1"
          hints:
            - title: ðŸ¤” Think about it
              content: Compare lowercase versions of both word and keyword.
            - title: ðŸ’¡ Hint
              content: Use strings.ToLower() to normalize before comparing.
            - title: ðŸ”§ Pattern
              content: |-
                <pre>1. For i, word:
                   - ToLower(word) == ToLower(keyword)?
                     â†’ return i
                2. Return -1</pre>
          solution: |-
            func findKeyword(words []string, keyword string) int {
                keyword = strings.ToLower(keyword)
                for i, word := range words {
                    if strings.ToLower(word) == keyword {
                        return i
                    }
                }
                return -1
            }
          difficulty: 2
        - id: v11
          title: Find First Negative
          description: >-
            Write <code>func findFirstNegative(nums []int) int</code> that returns the index of the first negative
            number, or -1 if none found.
          functionSignature: func findFirstNegative(nums []int) int
          testCases:
            - input: "[]int{5, 3, -2, 8, -1}"
              output: "2"
            - input: "[]int{1, 2, 3}"
              output: "-1"
          hints:
            - title: ðŸ¤” Think about it
              content: Loop through and check each number. Return the index as soon as you find a negative.
            - title: ðŸ’¡ Hint
              content: "Use early return: if num < 0, return i immediately."
            - title: ðŸ”§ Pattern
              content: |-
                <pre>1. For i, num:
                   - num < 0? â†’ return i
                2. Return -1 (not found)</pre>
          solution: |-
            func findFirstNegative(nums []int) int {
                for i, num := range nums {
                    if num < 0 {
                        return i
                    }
                }
                return -1
            }
          difficulty: 2
        - id: v12
          title: Find Last Index Of
          description: >-
            Write <code>func findLastIndexOf(nums []int, target int) int</code> that returns the index of the LAST
            occurrence of target, or -1 if not found.
          functionSignature: func findLastIndexOf(nums []int, target int) int
          testCases:
            - input: "[]int{1, 2, 3, 2, 5}, 2"
              output: "3"
              note: last occurrence of 2 is at index 3
            - input: "[]int{5, 5, 5}, 5"
              output: "2"
          hints:
            - title: ðŸ¤” Think about it
              content: Loop through all elements and track the most recent index where you found the target.
            - title: ðŸ’¡ Hint
              content: Keep updating lastIndex whenever you find target. Initialize to -1.
            - title: ðŸ”§ Pattern
              content: |-
                <pre>1. lastIndex := -1
                2. For i, num:
                   - num == target? â†’ lastIndex = i
                3. Return lastIndex</pre>
          solution: |-
            func findLastIndexOf(nums []int, target int) int {
                lastIndex := -1
                for i, num := range nums {
                    if num == target {
                        lastIndex = i
                    }
                }
                return lastIndex
            }
          difficulty: 2
        - id: v13
          title: Find Index of Longest Word
          description: >-
            Write <code>func findLongestWordIndex(words []string) int</code> that returns the index of the longest word.
            If multiple words tie, return the first occurrence.
          functionSignature: func findLongestWordIndex(words []string) int
          testCases:
            - input: "[]string{\"go\", \"rust\", \"python\", \"c\"}"
              output: "2"
              note: python is longest at index 2
            - input: "[]string{\"hello\", \"world\"}"
              output: "0"
              note: both length 5, return first
          hints:
            - title: ðŸ¤” Think about it
              content: Track both the maximum length seen and the index where it occurred.
            - title: ðŸ’¡ Hint
              content: Keep maxLen and maxIndex. For each word, if len(word) > maxLen, update both.
            - title: ðŸ”§ Pattern
              content: |-
                <pre>1. maxLen := 0, maxIndex := 0
                2. For i, word:
                   - len(word) > maxLen?
                     â†’ maxLen = len(word), maxIndex = i
                3. Return maxIndex</pre>
          solution: |-
            func findLongestWordIndex(words []string) int {
                maxLen := 0
                maxIndex := 0
                
                for i, word := range words {
                    if len(word) > maxLen {
                        maxLen = len(word)
                        maxIndex = i
                    }
                }
                
                return maxIndex
            }
          difficulty: 2
    - id: challenge_7
      block: 2
      difficulty: 2
      concept: Frequency Map
      docLinks:
        - url: https://go.dev/blog/maps
          title: "Go Blog: Go maps in action"
          note: map operations
        - url: https://go.dev/ref/spec#Making_slices_maps_and_channels
          title: "Go Spec: make()"
          note: creating maps
      patternPrimer:
        bruteForce: "Nested loops: for each unique element, scan the entire array again to count occurrences."
        bestApproach: Single pass with a map, incrementing counts[element]++ as we go. Map automatically tracks unique keys.
        typical: Typically O(n) time, O(n) extra space
      variants:
        - id: v1
          title: Count Occurrences
          description: Write <code>func countOccurrences(nums []int) map[int]int</code>.
          functionSignature: func countOccurrences(nums []int) map[int]int
          testCases:
            - input: "[]int{1, 2, 2, 3, 3, 3}"
              output: map[1:1 2:2 3:3]
          hints:
            - title: ðŸ¤” Think about it
              content: >-
                You want to count how many times each element appears. What data structure maps 'thing' to 'count of
                that thing'?
            - title: ðŸ’¡ Hint
              content: >-
                Use a map where keys are the elements and values are counts. The magic: accessing a non-existent key
                returns 0, so you can just do counts[item]++ even for the first occurrence.
            - title: ðŸ”§ Pattern
              content: |-
                <pre>1. Create empty count map
                2. For each element:
                   - Increment count for that element
                3. Return map</pre>
          solution: |-
            func countOccurrences(nums []int) map[int]int {
                c := make(map[int]int)
                for _, n := range nums { c[n]++ }
                return c
            }
          difficulty: 1
        - id: v2
          title: Count Characters
          description: Write <code>func countChars(s string) map[rune]int</code>.
          functionSignature: func countChars(s string) map[rune]int
          testCases:
            - input: "\"hello\""
              output: map[e:1 h:1 l:2 o:1]
          hints:
            - title: ðŸ¤” Think about it
              content: >-
                You want to count how many times each element appears. What data structure maps 'thing' to 'count of
                that thing'?
            - title: ðŸ’¡ Hint
              content: >-
                Use a map where keys are the elements and values are counts. The magic: accessing a non-existent key
                returns 0, so you can just do counts[item]++ even for the first occurrence.
            - title: ðŸ”§ Pattern
              content: |-
                <pre>1. Create empty count map
                2. For each element:
                   - Increment count for that element
                3. Return map</pre>
          solution: |-
            func countChars(s string) map[rune]int {
                c := make(map[rune]int)
                for _, r := range s { c[r]++ }
                return c
            }
          difficulty: 1
        - id: v3
          title: Word Frequency
          description: Write <code>func wordFreq(words []string) map[string]int</code>.
          functionSignature: func wordFreq(words []string) map[string]int
          testCases:
            - input: "[]string{\"go\", \"go\", \"py\"}"
              output: map[go:2 py:1]
          hints:
            - title: ðŸ¤” Think about it
              content: >-
                You want to count how many times each element appears. What data structure maps 'thing' to 'count of
                that thing'?
            - title: ðŸ’¡ Hint
              content: >-
                Use a map where keys are the elements and values are counts. The magic: accessing a non-existent key
                returns 0, so you can just do counts[item]++ even for the first occurrence.
            - title: ðŸ”§ Pattern
              content: |-
                <pre>1. Create empty count map
                2. For each element:
                   - Increment count for that element
                3. Return map</pre>
          solution: |-
            func wordFreq(words []string) map[string]int {
                c := make(map[string]int)
                for _, w := range words { c[w]++ }
                return c
            }
          difficulty: 1
        - id: v4
          title: Count Even and Odd
          description: >-
            Write <code>func countEvenOdd(nums []int) map[string]int</code> returning a map with keys "even" and "odd"
            showing how many of each.
          functionSignature: func countEvenOdd(nums []int) map[string]int
          testCases:
            - input: "[]int{1, 2, 3, 4, 5}"
              output: map[even:2 odd:3]
          hints:
            - title: ðŸ¤” Think about it
              content: >-
                Similar to counting positives/negatives, but now store the counts in a map instead of separate
                variables.
            - title: ðŸ’¡ Hint
              content: "Use num % 2 to check: if it equals 0, the number is even. Increment the appropriate key in your map."
            - title: ðŸ”§ Pattern
              content: |-
                <pre>1. Create empty count map
                2. For each element:
                   - Is it even (num % 2 == 0)? â†’ increment "even"
                   - Otherwise â†’ increment "odd"
                3. Return map</pre>
          solution: |-
            func countEvenOdd(nums []int) map[string]int {
                c := make(map[string]int)
                for _, n := range nums {
                    if n % 2 == 0 { c["even"]++ } else { c["odd"]++ }
                }
                return c
            }
          difficulty: 2
        - id: v5
          title: Invert Count Map
          description: >-
            Write <code>func invertCounts(counts map[string]int) map[int][]string</code> that inverts a frequency map.
            Keys become values grouped by their original values.
          functionSignature: func invertCounts(counts map[string]int) map[int][]string
          testCases:
            - input: "map[string]int{\"a\": 2, \"b\": 1, \"c\": 2}"
              output: map[1:[b] 2:[a c]]
              note: "words with count 1: [b], words with count 2: [a, c]"
          hints:
            - title: ðŸ¤” Think about it
              content: "You're flipping the relationship: instead of wordâ†’count, you want countâ†’[words with that count]."
            - title: ðŸ’¡ Hint
              content: >-
                Loop through the original map. For each key-value pair, append the key to the slice stored at the value
                in your new map.
            - title: ðŸ”§ Pattern
              content: |-
                <pre>1. Create result map[int][]string
                2. For each word, count in original:
                   - Append word to result[count]
                3. Return result</pre>
          solution: |-
            func invertCounts(counts map[string]int) map[int][]string {
                result := make(map[int][]string)
                for word, count := range counts {
                    result[count] = append(result[count], word)
                }
                return result
            }
          difficulty: 3
        - id: v6
          title: Count by Length
          description: >-
            Write <code>func countByLength(words []string) map[int]int</code> that groups words by their length and
            counts how many words are in each group. Keys are lengths, values are counts.
          functionSignature: func countByLength(words []string) map[int]int
          testCases:
            - input: "[]string{\"go\", \"rust\", \"c\", \"js\"}"
              output: map[1:1 2:2 4:1]
              note: 1 word of length 1 (c), 2 words of length 2 (go, js), 1 word of length 4 (rust)
          hints:
            - title: ðŸ¤” Think about it
              content: >-
                Instead of counting the words themselves, you're counting a property of each word. What property? Its
                length.
            - title: ðŸ’¡ Hint
              content: Use len(word) as the key. Same counting pattern, just using the length instead of the word itself.
            - title: ðŸ”§ Pattern
              content: |-
                <pre>1. Create empty count map
                2. For each word:
                   - Get its length with len(word)
                   - Increment count for that length
                3. Return map</pre>
          solution: |-
            func countByLength(words []string) map[int]int {
                c := make(map[int]int)
                for _, w := range words { c[len(w)]++ }
                return c
            }
          difficulty: 2
        - id: v7
          title: Count by Remainder
          description: >-
            Write <code>func countByRemainder(nums []int, divisor int) map[int]int</code> that groups numbers by their
            remainder when divided by divisor.
          functionSignature: func countByRemainder(nums []int, divisor int) map[int]int
          testCases:
            - input: "[]int{1, 2, 3, 4, 5, 6}, 3"
              output: map[0:2 1:2 2:2]
              note: 3,6 have remainder 0; 1,4 have remainder 1; 2,5 have remainder 2
            - input: "[]int{10, 20, 30}, 10"
              output: map[0:3]
          hints:
            - title: ðŸ¤” Think about it
              content: The key is num % divisor (the remainder). Count how many numbers give each remainder.
            - title: ðŸ’¡ Hint
              content: Same counting pattern as before, but use num % divisor as the key.
            - title: ðŸ”§ Pattern
              content: |-
                <pre>1. Create empty count map
                2. For each num:
                   - remainder := num % divisor
                   - counts[remainder]++
                3. Return counts</pre>
          solution: |-
            func countByRemainder(nums []int, divisor int) map[int]int {
                c := make(map[int]int)
                for _, n := range nums { c[n % divisor]++ }
                return c
            }
          difficulty: 2
        - id: v8
          title: Group by First Letter
          description: >-
            Write <code>func countByFirstLetter(words []string) map[string]int</code> that counts how many words start
            with each letter. Use lowercase keys.
          functionSignature: func countByFirstLetter(words []string) map[string]int
          testCases:
            - input: "[]string{\"apple\", \"ant\", \"bear\", \"ace\"}"
              output: map[a:3 b:1]
            - input: "[]string{\"Go\", \"great\", \"Python\"}"
              output: map[g:2 p:1]
              note: lowercase keys
          hints:
            - title: ðŸ¤” Think about it
              content: >-
                Extract the first character of each word and use it as the key. How do you get the first character of a
                string?
            - title: ðŸ’¡ Hint
              content: >-
                Use strings.ToLower(string(word[0])) to get the lowercase first letter as a string. Then count like
                before.
            - title: ðŸ”§ Pattern
              content: |-
                <pre>1. Create empty count map
                2. For each word:
                   - Get first letter (lowercase)
                   - Increment count for that letter
                3. Return map</pre>
          solution: |-
            func countByFirstLetter(words []string) map[string]int {
                c := make(map[string]int)
                for _, w := range words {
                    if len(w) > 0 {
                        first := strings.ToLower(string(w[0]))
                        c[first]++
                    }
                }
                return c
            }
          difficulty: 2
        - id: v9
          title: Vote Tally
          description: Write <code>func voteTally(votes []string) map[string]int</code> that counts votes for each candidate.
          functionSignature: func voteTally(votes []string) map[string]int
          testCases:
            - input: "[]string{\"Alice\", \"Bob\", \"Alice\", \"Charlie\", \"Alice\"}"
              output: "map[string]int{\"Alice\": 3, \"Bob\": 1, \"Charlie\": 1}"
            - input: "[]string{\"Yes\", \"No\", \"Yes\"}"
              output: "map[string]int{\"Yes\": 2, \"No\": 1}"
          hints:
            - title: ðŸ¤” Think about it
              content: "Standard frequency map: increment count for each vote."
            - title: ðŸ’¡ Hint
              content: counts[vote]++ for each vote.
            - title: ðŸ”§ Pattern
              content: |-
                <pre>1. counts := make(map[string]int)
                2. For each vote:
                   - counts[vote]++
                3. Return counts</pre>
          solution: |-
            func voteTally(votes []string) map[string]int {
                counts := make(map[string]int)
                for _, vote := range votes {
                    counts[vote]++
                }
                return counts
            }
          difficulty: 1
        - id: v10
          title: Grade Distribution
          description: >-
            Write <code>func gradeDistribution(grades []string) map[string]int</code> that counts how many of each
            letter grade.
          functionSignature: func gradeDistribution(grades []string) map[string]int
          testCases:
            - input: "[]string{\"A\", \"B\", \"A\", \"C\", \"A\", \"B\"}"
              output: "map[string]int{\"A\": 3, \"B\": 2, \"C\": 1}"
            - input: "[]string{\"F\", \"F\", \"D\"}"
              output: "map[string]int{\"F\": 2, \"D\": 1}"
          hints:
            - title: ðŸ¤” Think about it
              content: Another frequency map - count occurrences of each grade.
            - title: ðŸ’¡ Hint
              content: "Same pattern: dist[grade]++ for each grade."
            - title: ðŸ”§ Pattern
              content: |-
                <pre>1. dist := make(map[string]int)
                2. For each grade:
                   - dist[grade]++
                3. Return dist</pre>
          solution: |-
            func gradeDistribution(grades []string) map[string]int {
                dist := make(map[string]int)
                for _, grade := range grades {
                    dist[grade]++
                }
                return dist
            }
          difficulty: 1
        - id: v11
          title: Most Common Element
          description: >-
            Write <code>func mostCommonElement(items []string) string</code> that returns the element appearing most
            frequently. If multiple items tie for most common, return the one that appeared first.
          functionSignature: func mostCommonElement(items []string) string
          testCases:
            - input: "[\"cat\", \"dog\", \"cat\", \"bird\", \"dog\", \"dog\"]"
              output: "\"dog\""
              note: dog appears 3 times
            - input: "[\"a\", \"b\", \"a\"]"
              output: "\"a\""
          hints:
            - title: ðŸ¤” Think about it
              content: >-
                First build a frequency map to count all items. Then find the key with the highest value. Track both the
                item and its frequency as you search.
            - title: ðŸ’¡ Hint
              content: >-
                Build frequency map with freq[item]++. Then loop through the map to find the key with maximum value.
                Keep track of maxCount and mostCommon item.
            - title: ðŸ”§ Pattern
              content: |-
                <pre>1. Build frequency map
                2. maxCount := 0, mostCommon := ""
                3. For each item, count in map:
                   - count > maxCount?
                     â†’ maxCount = count, mostCommon = item
                4. Return mostCommon</pre>
          solution: |-
            func mostCommonElement(items []string) string {
                freq := make(map[string]int)
                for _, item := range items {
                    freq[item]++
                }
                
                maxCount := 0
                mostCommon := ""
                
                for item, count := range freq {
                    if count > maxCount {
                        maxCount = count
                        mostCommon = item
                    }
                }
                
                return mostCommon
            }
          difficulty: 3
        - id: v12
          title: Frequency Histogram
          description: >-
            Write <code>func frequencyHistogram(nums []int) map[int]int</code> that returns a "meta-map" showing how
            many elements appear each number of times. For example, if 2 elements appear once and 1 element appears
            twice, return map[1:2, 2:1].
          functionSignature: func frequencyHistogram(nums []int) map[int]int
          testCases:
            - input: "[]int{1, 1, 2, 3, 3, 3}"
              output: map[1:1 2:2 3:1]
              note: one element appears 1x (2), two elements appear 2x (1), one element appears 3x (3)
            - input: "[]int{5, 5, 5, 5}"
              output: map[4:1]
              note: one element appears 4 times
          hints:
            - title: ðŸ¤” Think about it
              content: >-
                Build a frequency map first to count how often each number appears. Then build a second map that counts
                how many numbers have each frequency.
            - title: ðŸ’¡ Hint
              content: >-
                Step 1: Build freq map with freq[num]++. Step 2: Build histogram with histogram[count]++ for each count
                in freq. This creates a frequency-of-frequencies map.
            - title: ðŸ”§ Pattern
              content: |-
                <pre>1. Build freq map (num â†’ count)
                2. Create histogram map[int]int
                3. For each count in freq.values:
                   - histogram[count]++
                4. Return histogram</pre>
          solution: |-
            func frequencyHistogram(nums []int) map[int]int {
                freq := make(map[int]int)
                for _, num := range nums {
                    freq[num]++
                }
                
                histogram := make(map[int]int)
                for _, count := range freq {
                    histogram[count]++
                }
                
                return histogram
            }
          difficulty: 3
        - id: v13
          title: Merge Frequency Maps
          description: >-
            Write <code>func mergeFrequencyMaps(map1, map2 map[string]int) map[string]int</code> that merges two
            frequency maps by adding their counts. If a key exists in both maps, add the counts together.
          functionSignature: func mergeFrequencyMaps(map1, map2 map[string]int) map[string]int
          testCases:
            - input: map["a":2, "b":1], map["a":1, "c":3]
              output: map["a":3 "b":1 "c":3]
            - input: map["x":5], map["x":3]
              output: map["x":8]
          hints:
            - title: ðŸ¤” Think about it
              content: >-
                Copy all entries from map1 to result. Then iterate through map2, adding each count to result (which may
                already have that key).
            - title: ðŸ’¡ Hint
              content: >-
                Create result map. Copy map1: result[k] = v. Then for each k, v in map2: result[k] += v. This adds to
                existing or creates new entry.
            - title: ðŸ”§ Pattern
              content: |-
                <pre>1. Create result map
                2. Copy all from map1 to result
                3. For each key, value in map2:
                   - result[key] += value
                4. Return result</pre>
          solution: |-
            func mergeFrequencyMaps(map1, map2 map[string]int) map[string]int {
                result := make(map[string]int)
                
                for k, v := range map1 {
                    result[k] = v
                }
                
                for k, v := range map2 {
                    result[k] += v
                }
                
                return result
            }
          difficulty: 3
        - id: v1
          title: Contains Duplicate
          description: >-
            Write a function <code>func containsDuplicate(nums []int) bool</code> that returns <code>true</code> if any
            number appears more than once in the slice, <code>false</code> if all numbers are unique.
          functionSignature: func containsDuplicate(nums []int) bool
          testCases:
            - input: "[]int{1, 2, 3, 1}"
              output: "true"
            - input: "[]int{1, 2, 3, 4}"
              output: "false"
            - input: "[]int{1, 1, 1, 1}"
              output: "true"
          solution: |-
            func containsDuplicate(nums []int) bool {
                seen := make(map[int]bool)
                for _, num := range nums {
                    if seen[num] {
                        return true
                    }
                    seen[num] = true
                }
                return false
            }
          difficulty: 4
        - id: v2
          title: First Duplicate Value
          description: >-
            Write a function <code>func firstDuplicate(nums []int) int</code> that returns the first number that appears
            twice (the second occurrence). Return <code>-1</code> if no duplicates exist.
          functionSignature: func firstDuplicate(nums []int) int
          testCases:
            - input: "[]int{2, 1, 3, 5, 3, 2}"
              output: "3"
              note: 3 is seen again before 2 is
            - input: "[]int{1, 2, 3, 4}"
              output: "-1"
            - input: "[]int{1, 1, 2, 2}"
              output: "1"
          solution: |-
            func firstDuplicate(nums []int) int {
                seen := make(map[int]bool)
                for _, num := range nums {
                    if seen[num] {
                        return num
                    }
                    seen[num] = true
                }
                return -1
            }
          solutionNotes: >-
            Unlike Contains Duplicate which returns a bool, this returns the actual duplicate value. Same pattern,
            different return type!
          difficulty: 4
        - id: v3
          title: Count Unique Elements
          description: >-
            Write a function <code>func countUnique(nums []int) int</code> that returns how many distinct values are in
            the slice.
          functionSignature: func countUnique(nums []int) int
          testCases:
            - input: "[]int{1, 2, 2, 3, 3, 3}"
              output: "3"
              note: "unique values: 1, 2, 3"
            - input: "[]int{5, 5, 5, 5}"
              output: "1"
            - input: "[]int{1, 2, 3, 4, 5}"
              output: "5"
          solution: |-
            func countUnique(nums []int) int {
                seen := make(map[int]bool)
                for _, num := range nums {
                    seen[num] = true
                }
                return len(seen)
            }
          solutionNotes: >-
            Here we don't check if seen - we just add everything. The map handles duplicates automatically, and
            <code>len(seen)</code> gives us the count of unique keys!
          difficulty: 4
        - id: v4
          title: Find All Duplicates
          description: >-
            Write a function <code>func findDuplicates(nums []int) []int</code> that returns a slice containing each
            number that appears more than once. Each duplicate should only appear once in the result.
          functionSignature: func findDuplicates(nums []int) []int
          testCases:
            - input: "[]int{4, 3, 2, 7, 8, 2, 3, 1}"
              output: "[2, 3]"
            - input: "[]int{1, 1, 2, 2, 3, 3}"
              output: "[1, 2, 3]"
            - input: "[]int{1, 2, 3}"
              output: "[]"
          solution: |-
            func findDuplicates(nums []int) []int {
                seen := make(map[int]bool)
                added := make(map[int]bool)
                result := []int{}
                
                for _, num := range nums {
                    if seen[num] && !added[num] {
                        result = append(result, num)
                        added[num] = true
                    }
                    seen[num] = true
                }
                return result
            }
          solutionNotes: >-
            We need TWO maps here: one to track what we've seen, and one to avoid adding the same duplicate twice to the
            result.
          difficulty: 4
        - id: v5
          title: Common Elements
          description: >-
            Write a function <code>func hasCommon(a, b []int) bool</code> that returns <code>true</code> if the two
            slices share at least one common element.
          functionSignature: func hasCommon(a, b []int) bool
          testCases:
            - input: "[]int{1, 2, 3}, []int{3, 4, 5}"
              output: "true"
              note: 3 is common
            - input: "[]int{1, 2}, []int{3, 4}"
              output: "false"
            - input: "[]int{1}, []int{1}"
              output: "true"
          solution: |-
            func hasCommon(a, b []int) bool {
                setA := make(map[int]bool)
                for _, num := range a {
                    setA[num] = true
                }
                
                for _, num := range b {
                    if setA[num] {
                        return true
                    }
                }
                return false
            }
          solutionNotes: >-
            Build a set from the first slice, then check if any element from the second slice exists in it. This is
            O(n+m) instead of O(n*m)!
          difficulty: 4
        - id: v6
          title: Find Intersection
          description: >-
            Write a function <code>func intersection(a, b []int) []int</code> that returns a slice of elements that
            appear in both input slices. Each element should appear only once in the result.
          functionSignature: func intersection(a, b []int) []int
          testCases:
            - input: "[]int{1, 2, 2, 1}, []int{2, 2}"
              output: "[2]"
            - input: "[]int{4, 9, 5}, []int{9, 4, 9, 8, 4}"
              output: "[9, 4]"
              note: or [4, 9] - order doesn't matter
            - input: "[]int{1, 2}, []int{3, 4}"
              output: "[]"
          solution: |-
            func intersection(a, b []int) []int {
                setA := make(map[int]bool)
                for _, num := range a {
                    setA[num] = true
                }
                
                result := []int{}
                seen := make(map[int]bool)
                for _, num := range b {
                    if setA[num] && !seen[num] {
                        result = append(result, num)
                        seen[num] = true
                    }
                }
                return result
            }
          solutionNotes: >-
            Similar to hasCommon, but we collect the common elements instead of just returning true. We use a second map
            to avoid adding duplicates to the result.
          difficulty: 4
        - id: v1
          title: Word Counter
          description: >-
            Write <code>func wordCount(s string) map[string]int</code> that counts how many times each word appears in a
            string.
          functionSignature: func wordCount(s string) map[string]int
          testCases:
            - input: "\"the quick brown fox jumps over the lazy dog\""
              output: map[brown:1 dog:1 fox:1 jumps:1 lazy:1 over:1 quick:1 the:2]
          solution: |-
            import "strings"

            func wordCount(s string) map[string]int {
                counts := make(map[string]int)
                for _, word := range strings.Fields(s) {
                    counts[word]++
                }
                return counts
            }
          difficulty: 4
        - id: v2
          title: Most Frequent Element
          description: >-
            Write <code>func mostFrequent(nums []int) int</code> that returns the element that appears most frequently.
            If there's a tie, return any of them.
          functionSignature: func mostFrequent(nums []int) int
          testCases:
            - input: "[]int{1, 3, 2, 1, 4, 1}"
              output: "1"
              note: 1 appears 3 times
            - input: "[]int{5, 5, 4, 4, 4}"
              output: "4"
            - input: "[]int{7}"
              output: "7"
          solution: |-
            func mostFrequent(nums []int) int {
                counts := make(map[int]int)
                for _, num := range nums {
                    counts[num]++
                }
                
                maxCount := 0
                result := nums[0]
                for num, count := range counts {
                    if count > maxCount {
                        maxCount = count
                        result = num
                    }
                }
                return result
            }
          solutionNotes: >-
            First count everything, then iterate the map to find the max. This is a two-pass approach over different
            data structures.
          difficulty: 4
        - id: v3
          title: First Unique Character
          description: >-
            Write <code>func firstUniqChar(s string) int</code> that returns the index of the first non-repeating
            character. Return -1 if none exists.
          functionSignature: func firstUniqChar(s string) int
          testCases:
            - input: "\"leetcode\""
              output: "0"
              note: "'l' is first unique"
            - input: "\"loveleetcode\""
              output: "2"
              note: "'v' is first unique"
            - input: "\"aabb\""
              output: "-1"
          solution: |-
            func firstUniqChar(s string) int {
                counts := make(map[rune]int)
                runes := []rune(s)
                
                for _, r := range runes {
                    counts[r]++
                }
                
                for i, r := range runes {
                    if counts[r] == 1 {
                        return i
                    }
                }
                return -1
            }
          solutionNotes: >-
            Two passes needed: first to count, second to find the first character with count == 1. We iterate the
            original string (not the map) to preserve order.
          difficulty: 4
        - id: v4
          title: Is Anagram
          description: >-
            Write <code>func isAnagram(s, t string) bool</code> that returns true if t is an anagram of s (same letters,
            different order).
          functionSignature: func isAnagram(s, t string) bool
          testCases:
            - input: "\"anagram\", \"nagaram\""
              output: "true"
            - input: "\"rat\", \"car\""
              output: "false"
            - input: "\"listen\", \"silent\""
              output: "true"
          solution: |-
            func isAnagram(s, t string) bool {
                if len(s) != len(t) {
                    return false
                }
                
                counts := make(map[rune]int)
                for _, r := range s {
                    counts[r]++
                }
                for _, r := range t {
                    counts[r]--
                    if counts[r] < 0 {
                        return false
                    }
                }
                return true
            }
          solutionNotes: >-
            Count characters in s (increment), then 'uncount' characters in t (decrement). If we ever go negative, t has
            a character s doesn't have.
          difficulty: 4
        - id: v5
          title: Can Construct
          description: >-
            Write <code>func canConstruct(ransomNote, magazine string) bool</code> that returns true if ransomNote can
            be constructed from magazine letters (each letter used once).
          functionSignature: func canConstruct(ransomNote, magazine string) bool
          testCases:
            - input: "\"a\", \"b\""
              output: "false"
            - input: "\"aa\", \"aab\""
              output: "true"
            - input: "\"aa\", \"ab\""
              output: "false"
              note: need 2 a's but only 1
          solution: |-
            func canConstruct(ransomNote, magazine string) bool {
                available := make(map[rune]int)
                
                for _, r := range magazine {
                    available[r]++
                }
                
                for _, r := range ransomNote {
                    available[r]--
                    if available[r] < 0 {
                        return false
                    }
                }
                return true
            }
          solutionNotes: >-
            Similar to anagram check, but one-directional: we only need to verify ransomNote letters exist in magazine,
            not vice versa.
          difficulty: 4
        - id: v6
          title: Majority Element
          description: >-
            Write <code>func majorityElement(nums []int) int</code> that finds the element appearing more than n/2
            times. Assume such element always exists.
          functionSignature: func majorityElement(nums []int) int
          testCases:
            - input: "[]int{3, 2, 3}"
              output: "3"
            - input: "[]int{2, 2, 1, 1, 1, 2, 2}"
              output: "2"
            - input: "[]int{1, 1, 1, 1}"
              output: "1"
          solution: |-
            func majorityElement(nums []int) int {
                counts := make(map[int]int)
                threshold := len(nums) / 2
                
                for _, num := range nums {
                    counts[num]++
                    if counts[num] > threshold {
                        return num
                    }
                }
                return -1
            }
          solutionNotes: We can return early as soon as any element exceeds n/2 count. No need to finish counting everything!
          difficulty: 4
    - id: challenge_8
      block: 3
      difficulty: 3
      concept: Swap Pattern
      docLinks:
        - url: https://go.dev/ref/spec#Assignments
          title: "Go Spec: Assignments"
          note: tuple assignment (a, b = b, a)
        - url: https://go.dev/ref/spec#Index_expressions
          title: "Go Spec: Index expressions"
          note: slice indexing
      patternPrimer:
        bruteForce: "Use a temp variable: temp = a, a = b, b = temp (three operations)."
        bestApproach: "Go's simultaneous assignment: a, b = b, a (evaluates right side first, then assigns)."
        typical: Typically O(1) time, O(1) extra space
      variants:
        - id: v1
          title: Swap Elements
          description: Write <code>func swap(nums []int, i, j int)</code> that swaps elements at i and j.
          functionSignature: func swap(nums []int, i, j int)
          testCases:
            - input: "[]int{1,2,3}, 0, 2"
              output: "[3,2,1]"
          hints:
            - title: ðŸ¤” Think about it
              content: How do you swap two values without losing one of them? Think about what happens if you just write a = b.
            - title: ðŸ’¡ Hint
              content: >-
                Go has a special syntax for simultaneous assignment: a, b = b, a. This evaluates the right side first,
                then assigns, so nothing is lost.
            - title: ðŸ”§ Pattern
              content: |-
                <pre>1. Simultaneous assignment: left, right = right, left
                (Both sides evaluated before assignment - nothing lost!)</pre>
          solution: |-
            func swap(nums []int, i, j int) {
                nums[i], nums[j] = nums[j], nums[i]
            }
          difficulty: 1
        - id: v2
          title: Swap Using Temp
          description: >-
            Write <code>func swapWithTemp(nums []int, i, j int)</code> that swaps elements using a temporary variable
            (not Go's simultaneous assignment).
          functionSignature: func swapWithTemp(nums []int, i, j int)
          testCases:
            - input: "[]int{1,2,3,4}, 0, 3"
              output: "[4,2,3,1]"
          hints:
            - title: ðŸ¤” Think about it
              content: "The classic 3-step swap: save one value, overwrite it, then use the saved value."
            - title: ðŸ’¡ Hint
              content: temp := nums[i], then nums[i] = nums[j], then nums[j] = temp.
            - title: ðŸ”§ Pattern
              content: |-
                <pre>1. temp := nums[i]  // save first value
                2. nums[i] = nums[j]  // overwrite with second
                3. nums[j] = temp  // put saved value in second spot</pre>
          solution: |-
            func swapWithTemp(nums []int, i, j int) {
                temp := nums[i]
                nums[i] = nums[j]
                nums[j] = temp
            }
          difficulty: 1
        - id: v3
          title: Swap Adjacent Pairs
          description: >-
            Write <code>func swapPairs(nums []int)</code> that swaps elements at indices 0&1, 2&3, 4&5, etc. If odd
            length, last element stays.
          functionSignature: func swapPairs(nums []int)
          testCases:
            - input: "[]int{1,2,3,4,5}"
              output: "[2,1,4,3,5]"
            - input: "[]int{1,2,3,4}"
              output: "[2,1,4,3]"
          hints:
            - title: ðŸ¤” Think about it
              content: How do you swap two values without losing one of them? Think about what happens if you just write a = b.
            - title: ðŸ’¡ Hint
              content: >-
                Loop through the slice incrementing by 2 each time. Use Go's simultaneous assignment to swap pairs:
                nums[i], nums[i+1] = nums[i+1], nums[i].
            - title: ðŸ”§ Pattern
              content: |-
                <pre>1. Loop with i += 2
                2. Check i+1 < len to avoid out of bounds
                3. Swap: nums[i], nums[i+1] = nums[i+1], nums[i]</pre>
          solution: |-
            func swapPairs(nums []int) {
                for i := 0; i+1 < len(nums); i += 2 {
                    nums[i], nums[i+1] = nums[i+1], nums[i]
                }
            }
          difficulty: 2
        - id: v4
          title: Swap First Two
          description: >-
            Write <code>func swapFirstTwo(nums []int)</code> that swaps the elements at index 0 and index 1. Assume
            slice has at least 2 elements.
          functionSignature: func swapFirstTwo(nums []int)
          testCases:
            - input: "[]int{1,2,3,4}"
              output: "[2,1,3,4]"
            - input: "[]int{5,10}"
              output: "[10,5]"
          hints:
            - title: ðŸ¤” Think about it
              content: This is just one swap - no loop needed. What indices do you need?
            - title: ðŸ’¡ Hint
              content: Swap nums[0] and nums[1] using simultaneous assignment.
            - title: ðŸ”§ Pattern
              content: <pre>nums[0], nums[1] = nums[1], nums[0]</pre>
          solution: |-
            func swapFirstTwo(nums []int) {
                nums[0], nums[1] = nums[1], nums[0]
            }
          difficulty: 1
        - id: v5
          title: Swap Middle Two
          description: Write <code>func swapMiddle(nums []int)</code> that swaps the two middle elements. Assume even length.
          functionSignature: func swapMiddle(nums []int)
          testCases:
            - input: "[]int{1,2,3,4}"
              output: "[1,3,2,4]"
            - input: "[]int{10,20,30,40,50,60}"
              output: "[10,20,40,30,50,60]"
          hints:
            - title: ðŸ¤” Think about it
              content: For a slice of length n, the two middle elements are at indices n/2-1 and n/2.
            - title: ðŸ’¡ Hint
              content: Calculate mid := len(nums)/2. Then swap nums[mid-1] and nums[mid].
            - title: ðŸ”§ Pattern
              content: |-
                <pre>mid := len(nums) / 2
                nums[mid-1], nums[mid] = nums[mid], nums[mid-1]</pre>
          solution: |-
            func swapMiddle(nums []int) {
                mid := len(nums) / 2
                nums[mid-1], nums[mid] = nums[mid], nums[mid-1]
            }
          difficulty: 2
        - id: v6
          title: Swap at Offset
          description: >-
            Write <code>func swapAtOffset(nums []int, k int)</code> that swaps element at index k with element at index
            len-1-k (mirror positions from each end).
          functionSignature: func swapAtOffset(nums []int, k int)
          testCases:
            - input: "[]int{1,2,3,4,5}, 1"
              output: "[1,4,3,2,5]"
              note: swaps index 1 with index 3
            - input: "[]int{1,2,3,4,5}, 0"
              output: "[5,2,3,4,1]"
              note: swaps index 0 with index 4 (same as swapEnds)
          hints:
            - title: ðŸ¤” Think about it
              content: The mirror position of index k from the start is len-1-k from the end.
            - title: ðŸ’¡ Hint
              content: Swap nums[k] with nums[len(nums)-1-k].
            - title: ðŸ”§ Pattern
              content: <pre>nums[k], nums[len(nums)-1-k] = nums[len(nums)-1-k], nums[k]</pre>
          solution: |-
            func swapAtOffset(nums []int, k int) {
                nums[k], nums[len(nums)-1-k] = nums[len(nums)-1-k], nums[k]
            }
          difficulty: 2
        - id: v7
          title: Swap Min and Max
          description: >-
            Write <code>func swapMinMax(nums []int)</code> that finds the minimum and maximum elements and swaps their
            positions.
          functionSignature: func swapMinMax(nums []int)
          testCases:
            - input: "[]int{3,1,4,1,5}"
              output: "[3,5,4,1,1]"
            - input: "[]int{5,2,8,1}"
              output: "[5,2,1,8]"
          hints:
            - title: ðŸ¤” Think about it
              content: >-
                First you need to find WHERE the min and max are (their indices), then swap the elements at those
                positions.
            - title: ðŸ’¡ Hint
              content: >-
                Track minIdx and maxIdx as you loop. Start with both at 0. Update minIdx when you find a smaller value,
                maxIdx when you find a larger value. Then swap at the end.
            - title: ðŸ”§ Pattern
              content: |-
                <pre>1. Initialize minIdx = 0, maxIdx = 0
                2. Loop through slice:
                   - nums[i] < nums[minIdx]? â†’ minIdx = i
                   - nums[i] > nums[maxIdx]? â†’ maxIdx = i
                3. Swap: nums[minIdx], nums[maxIdx] = nums[maxIdx], nums[minIdx]</pre>
          solution: |-
            func swapMinMax(nums []int) {
                minIdx, maxIdx := 0, 0
                for i := range nums {
                    if nums[i] < nums[minIdx] { minIdx = i }
                    if nums[i] > nums[maxIdx] { maxIdx = i }
                }
                nums[minIdx], nums[maxIdx] = nums[maxIdx], nums[minIdx]
            }
          difficulty: 3
        - id: v8
          title: Rotate Left by One
          description: >-
            Write <code>func rotateLeft(nums []int)</code> that shifts all elements one position left, wrapping the
            first element to the end. E.g., [1,2,3,4] â†’ [2,3,4,1].
          functionSignature: func rotateLeft(nums []int)
          testCases:
            - input: "[]int{1,2,3,4}"
              output: "[2,3,4,1]"
            - input: "[]int{5,10,15}"
              output: "[10,15,5]"
          hints:
            - title: ðŸ¤” Think about it
              content: You need to save the first element, shift everything left, then put the saved element at the end.
            - title: ðŸ’¡ Hint
              content: >-
                Save first := nums[0]. Loop from i=0 to len-2, copying nums[i+1] to nums[i]. Finally set nums[len-1] =
                first.
            - title: ðŸ”§ Pattern
              content: |-
                <pre>1. Save first element: first := nums[0]
                2. Shift elements left: for i := 0; i < len-1; i++ â†’ nums[i] = nums[i+1]
                3. Place first at end: nums[len-1] = first</pre>
          solution: |-
            func rotateLeft(nums []int) {
                if len(nums) == 0 { return }
                first := nums[0]
                for i := 0; i < len(nums)-1; i++ {
                    nums[i] = nums[i+1]
                }
                nums[len(nums)-1] = first
            }
          difficulty: 2
        - id: v9
          title: Swap Halves
          description: >-
            Write <code>func swapHalves(nums []int)</code> that swaps the first half with the second half. For [1,2,3,4]
            â†’ [3,4,1,2]. Assume even length.
          functionSignature: func swapHalves(nums []int)
          testCases:
            - input: "[]int{1,2,3,4}"
              output: "[3,4,1,2]"
            - input: "[]int{10,20,30,40,50,60}"
              output: "[40,50,60,10,20,30]"
          hints:
            - title: ðŸ¤” Think about it
              content: You need to swap element 0 with element n/2, element 1 with element n/2+1, etc. How many swaps is that?
            - title: ðŸ’¡ Hint
              content: Loop from i=0 to len/2. Each iteration swaps nums[i] with nums[i + len/2].
            - title: ðŸ”§ Pattern
              content: |-
                <pre>1. Calculate mid := len(nums) / 2
                2. Loop i from 0 to mid:
                   - Swap nums[i] with nums[i + mid]
                </pre>
          solution: |-
            func swapHalves(nums []int) {
                mid := len(nums) / 2
                for i := 0; i < mid; i++ {
                    nums[i], nums[i+mid] = nums[i+mid], nums[i]
                }
            }
          difficulty: 2
        - id: v10
          title: Bubble Up
          description: >-
            Write <code>func bubbleUp(nums []int, idx int)</code> that 'bubbles' the element at idx towards the front by
            swapping with its left neighbor until it reaches index 0.
          functionSignature: func bubbleUp(nums []int, idx int)
          testCases:
            - input: "[]int{1,2,3,4}, 3"
              output: "[4,1,2,3]"
              note: 4 bubbles from idx 3 to idx 0
            - input: "[]int{5,10,15}, 1"
              output: "[10,5,15]"
              note: 10 bubbles from idx 1 to idx 0
          hints:
            - title: ðŸ¤” Think about it
              content: Start at idx and work backwards to 0, swapping adjacent elements each step.
            - title: ðŸ’¡ Hint
              content: "Loop from idx down to 1: for i := idx; i > 0; i--. Each iteration swap nums[i] with nums[i-1]."
            - title: ðŸ”§ Pattern
              content: |-
                <pre>1. for i := idx; i > 0; i--
                2.   swap nums[i] and nums[i-1]
                (Element 'bubbles' left one position each iteration)</pre>
          solution: |-
            func bubbleUp(nums []int, idx int) {
                for i := idx; i > 0; i-- {
                    nums[i], nums[i-1] = nums[i-1], nums[i]
                }
            }
          difficulty: 3
        - id: v11
          title: Swap If Out of Order
          description: >-
            Write <code>func swapIfGreater(nums []int, i, j int)</code> that swaps elements at i and j only if nums[i] >
            nums[j]. This is a building block for sorting!
          functionSignature: func swapIfGreater(nums []int, i, j int)
          testCases:
            - input: "[]int{5,2,8,1}, 0, 1"
              output: "[2,5,8,1]"
              note: 5 > 2, so swap
            - input: "[]int{1,5,3,4}, 0, 1"
              output: "[1,5,3,4]"
              note: 1 < 5, no swap
          hints:
            - title: ðŸ¤” Think about it
              content: Check if the first element is greater. If yes, swap. If no, do nothing.
            - title: ðŸ’¡ Hint
              content: "Use an if statement: if nums[i] > nums[j], then do the swap."
            - title: ðŸ”§ Pattern
              content: |-
                <pre>if nums[i] > nums[j] {
                    nums[i], nums[j] = nums[j], nums[i]
                }</pre>
          solution: |-
            func swapIfGreater(nums []int, i, j int) {
                if nums[i] > nums[j] {
                    nums[i], nums[j] = nums[j], nums[i]
                }
            }
          difficulty: 2
        - id: v12
          title: Move to Front
          description: >-
            Write <code>func moveToFront(nums []int, idx int)</code> that moves the element at idx to the front,
            shifting other elements right. E.g., [1,2,3,4] with idx=2 â†’ [3,1,2,4].
          functionSignature: func moveToFront(nums []int, idx int)
          testCases:
            - input: "[]int{1,2,3,4}, 2"
              output: "[3,1,2,4]"
            - input: "[]int{10,20,30,40}, 3"
              output: "[40,10,20,30]"
          hints:
            - title: ðŸ¤” Think about it
              content: Save the element at idx. Shift elements from 0 to idx-1 one position right. Put saved element at front.
            - title: ðŸ’¡ Hint
              content: >-
                Save val := nums[idx]. Loop backwards from idx down to 1, copying nums[i-1] to nums[i]. Set nums[0] =
                val.
            - title: ðŸ”§ Pattern
              content: |-
                <pre>1. Save element: val := nums[idx]
                2. Shift right: for i := idx; i > 0; i-- â†’ nums[i] = nums[i-1]
                3. Place at front: nums[0] = val</pre>
          solution: |-
            func moveToFront(nums []int, idx int) {
                val := nums[idx]
                for i := idx; i > 0; i-- {
                    nums[i] = nums[i-1]
                }
                nums[0] = val
            }
          difficulty: 2
        - id: v1
          title: Reverse a String
          description: >-
            Write <code>func reverse(s string) string</code> that reverses any string, including Unicode characters like
            emojis.
          functionSignature: func reverse(s string) string
          testCases:
            - input: "\"hello\""
              output: "\"olleh\""
            - input: "\"ä¸–ç•Œ\""
              output: "\"ç•Œä¸–\""
            - input: "\"GoðŸš€\""
              output: "\"ðŸš€oG\""
          solution: |-
            func reverse(s string) string {
                runes := []rune(s)
                for i, j := 0, len(runes)-1; i < j; i, j = i+1, j-1 {
                    runes[i], runes[j] = runes[j], runes[i]
                }
                return string(runes)
            }
          difficulty: 4
        - id: v2
          title: Is Palindrome
          description: >-
            Write <code>func isPalindrome(s string) bool</code> that checks if a string reads the same forwards and
            backwards. Consider only alphanumeric characters and ignore case.
          functionSignature: func isPalindrome(s string) bool
          testCases:
            - input: "\"A man, a plan, a canal: Panama\""
              output: "true"
            - input: "\"race a car\""
              output: "false"
            - input: "\"Was it a car or a cat I saw?\""
              output: "true"
          solution: |-
            import "unicode"

            func isPalindrome(s string) bool {
                runes := []rune{}
                for _, r := range s {
                    if unicode.IsLetter(r) || unicode.IsDigit(r) {
                        runes = append(runes, unicode.ToLower(r))
                    }
                }
                
                for i, j := 0, len(runes)-1; i < j; i, j = i+1, j-1 {
                    if runes[i] != runes[j] {
                        return false
                    }
                }
                return true
            }
          solutionNotes: >-
            First filter to only alphanumeric and lowercase, then use two-pointer comparison. The <code>unicode</code>
            package helps with character classification.
          difficulty: 4
        - id: v3
          title: Reverse Words in String
          description: >-
            Write <code>func reverseWords(s string) string</code> that reverses the order of words (not characters).
            Words are separated by spaces.
          functionSignature: func reverseWords(s string) string
          testCases:
            - input: "\"hello world\""
              output: "\"world hello\""
            - input: "\"the sky is blue\""
              output: "\"blue is sky the\""
            - input: "\"Go\""
              output: "\"Go\""
          solution: |-
            import "strings"

            func reverseWords(s string) string {
                words := strings.Fields(s)
                
                for i, j := 0, len(words)-1; i < j; i, j = i+1, j-1 {
                    words[i], words[j] = words[j], words[i]
                }
                
                return strings.Join(words, " ")
            }
          solutionNotes: >-
            Use <code>strings.Fields</code> to split by whitespace, reverse the slice of words, then
            <code>strings.Join</code> back together.
          difficulty: 4
        - id: v4
          title: Reverse Only Letters
          description: >-
            Write <code>func reverseOnlyLetters(s string) string</code> that reverses only the letters in a string. All
            other characters stay in their original positions.
          functionSignature: func reverseOnlyLetters(s string) string
          testCases:
            - input: "\"a-bC-dEf-ghIj\""
              output: "\"j-Ih-gfE-dCba\""
            - input: "\"ab-cd\""
              output: "\"dc-ba\""
            - input: "\"Test1ng-Leet=code-Q!\""
              output: "\"Qedo1teleC-test=gnin-T!\""
              note: wait that's wrong
          solution: |-
            import "unicode"

            func reverseOnlyLetters(s string) string {
                runes := []rune(s)
                i, j := 0, len(runes)-1
                
                for i < j {
                    for i < j && !unicode.IsLetter(runes[i]) {
                        i++
                    }
                    for i < j && !unicode.IsLetter(runes[j]) {
                        j--
                    }
                    if i < j {
                        runes[i], runes[j] = runes[j], runes[i]
                        i++
                        j--
                    }
                }
                return string(runes)
            }
          solutionNotes: >-
            Two pointers that skip non-letters. Only swap when both pointers are on letters. This is a variation of the
            standard reverse with added skip logic.
          difficulty: 4
        - id: v5
          title: Valid Palindrome II
          description: >-
            Write <code>func validPalindromeII(s string) bool</code> that returns true if the string can become a
            palindrome by removing <strong>at most one</strong> character.
          functionSignature: func validPalindromeII(s string) bool
          testCases:
            - input: "\"aba\""
              output: "true"
              note: already palindrome
            - input: "\"abca\""
              output: "true"
              note: remove 'c' or 'b'
            - input: "\"abc\""
              output: "false"
          solution: |-
            func validPalindromeII(s string) bool {
                runes := []rune(s)
                
                isPalin := func(i, j int) bool {
                    for i < j {
                        if runes[i] != runes[j] {
                            return false
                        }
                        i++
                        j--
                    }
                    return true
                }
                
                i, j := 0, len(runes)-1
                for i < j {
                    if runes[i] != runes[j] {
                        return isPalin(i+1, j) || isPalin(i, j-1)
                    }
                    i++
                    j--
                }
                return true
            }
          solutionNotes: >-
            When we find a mismatch, we have one chance: try skipping the left char OR the right char. If either results
            in a palindrome, return true.
          difficulty: 4
        - id: v6
          title: Rotate String Left
          description: >-
            Write <code>func rotateLeft(s string, k int) string</code> that rotates a string left by k positions.
            Characters that fall off the left reappear on the right.
          functionSignature: func rotateLeft(s string, k int) string
          testCases:
            - input: "\"abcdef\", 2"
              output: "\"cdefab\""
            - input: "\"hello\", 1"
              output: "\"elloh\""
            - input: "\"Go\", 4"
              output: "\"Go\""
              note: k=4 is same as k=0 for len=2
          solution: |-
            func rotateLeft(s string, k int) string {
                if len(s) == 0 {
                    return s
                }
                runes := []rune(s)
                k = k % len(runes)
                
                reverse := func(start, end int) {
                    for start < end {
                        runes[start], runes[end] = runes[end], runes[start]
                        start++
                        end--
                    }
                }
                
                reverse(0, k-1)
                reverse(k, len(runes)-1)
                reverse(0, len(runes)-1)
                
                return string(runes)
            }
          solutionNotes: >-
            The "reversal algorithm" for rotation: reverse the first k elements, reverse the rest, then reverse the
            entire array. Three reversals achieve a rotation!
          difficulty: 4
    - id: challenge_9
      block: 3
      difficulty: 3
      concept: Two-Pointer Comparison
      docLinks:
        - url: https://go.dev/ref/spec#For_statements
          title: "Go Spec: For statements"
          note: two-variable initialization (i, j := ...)
        - url: https://go.dev/ref/spec#Comparison_operators
          title: "Go Spec: Comparison operators"
          note: "!= for mismatch detection"
      patternPrimer:
        bruteForce: Create a reversed copy of the array, then compare element-by-element with the original.
        bestApproach: Compare from both ends simultaneously, moving inward; stop as soon as mismatch found.
        typical: Typically O(n) time, O(1) extra space
      variants:
        - id: v1
          title: Palindrome Check
          description: Write <code>func isPalindrome(nums []int) bool</code> - same forwards/backwards.
          functionSignature: func isPalindrome(nums []int) bool
          testCases:
            - input: "[]int{1,2,3,2,1}"
              output: "true"
          hints:
            - title: ðŸ¤” Think about it
              content: >-
                To check if something reads the same forwards and backwards, where should you start comparing? Do you
                need to check every element?
            - title: ðŸ’¡ Hint
              content: >-
                Compare from both ends moving inward. Start with pointers at index 0 and len-1. If any pair doesn't
                match, it's not a palindrome. If you make it to the middle without mismatches, it is.
            - title: ðŸ”§ Pattern
              content: |-
                <pre>1. left pointer at start, right pointer at end
                2. While left < right:
                   - Compare elements at both pointers
                   - Mismatch? â†’ return false
                   - Move both pointers inward
                3. Return true (all pairs matched)</pre>
          solution: |-
            func isPalindrome(nums []int) bool {
                for i, j := 0, len(nums)-1; i < j; i, j = i+1, j-1 {
                    if nums[i] != nums[j] { return false }
                }
                return true
            }
          difficulty: 3
        - id: v2
          title: String Palindrome
          description: Write <code>func isSymmetric(s string) bool</code>.
          functionSignature: func isSymmetric(s string) bool
          testCases:
            - input: "\"racecar\""
              output: "true"
          hints:
            - title: ðŸ¤” Think about it
              content: >-
                To check if something reads the same forwards and backwards, where should you start comparing? Do you
                need to check every element?
            - title: ðŸ’¡ Hint
              content: >-
                Compare from both ends moving inward. Start with pointers at index 0 and len-1. If any pair doesn't
                match, it's not a palindrome. If you make it to the middle without mismatches, it is.
            - title: ðŸ”§ Pattern
              content: |-
                <pre>1. left pointer at start, right pointer at end
                2. While left < right:
                   - Compare elements at both pointers
                   - Mismatch? â†’ return false
                   - Move both pointers inward
                3. Return true (all pairs matched)</pre>
          solution: |-
            func isSymmetric(s string) bool {
                r := []rune(s)
                for i, j := 0, len(r)-1; i < j; i, j = i+1, j-1 {
                    if r[i] != r[j] { return false }
                }
                return true
            }
          difficulty: 3
        - id: v3
          title: Is Sorted Ascending
          description: Write <code>func isSorted(nums []int) bool</code> - true if each element <= the next.
          functionSignature: func isSorted(nums []int) bool
          testCases:
            - input: "[]int{1,2,3,4}"
              output: "true"
            - input: "[]int{1,3,2,4}"
              output: "false"
          hints:
            - title: ðŸ¤” Think about it
              content: >-
                To verify sorted order, what pairs of elements do you need to compare? Do you need to compare every
                element to every other element?
            - title: ðŸ’¡ Hint
              content: >-
                Check adjacent pairs: compare nums[i] with nums[i+1]. If any pair is out of order (nums[i] > nums[i+1]),
                return false immediately.
            - title: ðŸ”§ Pattern
              content: |-
                <pre>1. Loop through indices 0 to len-2
                2. Compare each element with the next
                3. If nums[i] > nums[i+1] â†’ return false
                4. Return true (all pairs in order)</pre>
          solution: |-
            func isSorted(nums []int) bool {
                for i := 0; i < len(nums)-1; i++ {
                    if nums[i] > nums[i+1] { return false }
                }
                return true
            }
          difficulty: 2
        - id: v4
          title: Has Adjacent Duplicates
          description: Write <code>func hasAdjacentDups(nums []int) bool</code> - true if any two adjacent elements are equal.
          functionSignature: func hasAdjacentDups(nums []int) bool
          testCases:
            - input: "[]int{1, 2, 2, 3}"
              output: "true"
            - input: "[]int{1, 2, 3, 4}"
              output: "false"
          hints:
            - title: ðŸ¤” Think about it
              content: You need to compare each element with its neighbor. What pairs should you check?
            - title: ðŸ’¡ Hint
              content: >-
                Loop through indices 0 to len-2. Compare nums[i] with nums[i+1]. If they're equal, you found adjacent
                duplicates.
            - title: ðŸ”§ Pattern
              content: |-
                <pre>1. Loop through indices 0 to len-2
                2. Compare each element with the next
                3. If nums[i] == nums[i+1] â†’ return true
                4. Return false (no adjacent duplicates)</pre>
          solution: |-
            func hasAdjacentDups(nums []int) bool {
                for i := 0; i < len(nums)-1; i++ {
                    if nums[i] == nums[i+1] { return true }
                }
                return false
            }
          difficulty: 2
        - id: v5
          title: All Increasing
          description: Write <code>func allIncreasing(nums []int) bool</code> - true if strictly increasing (each element < next).
          functionSignature: func allIncreasing(nums []int) bool
          testCases:
            - input: "[]int{1, 2, 3, 4}"
              output: "true"
            - input: "[]int{1, 2, 2, 3}"
              output: "false"
          hints:
            - title: ðŸ¤” Think about it
              content: Strictly increasing means each element must be LESS than (not equal to) the next.
            - title: ðŸ’¡ Hint
              content: Compare adjacent pairs. If nums[i] >= nums[i+1], it's not strictly increasing.
            - title: ðŸ”§ Pattern
              content: |-
                <pre>1. Loop through indices 0 to len-2
                2. Compare each element with the next
                3. If nums[i] >= nums[i+1] â†’ return false
                4. Return true (all strictly increasing)</pre>
          solution: |-
            func allIncreasing(nums []int) bool {
                for i := 0; i < len(nums)-1; i++ {
                    if nums[i] >= nums[i+1] { return false }
                }
                return true
            }
          difficulty: 2
        - id: v6
          title: Starts And Ends Same
          description: >-
            Write <code>func startsEndsSame(nums []int, k int) bool</code> - true if first k elements match last k
            elements.
          functionSignature: func startsEndsSame(nums []int, k int) bool
          testCases:
            - input: "[]int{1, 2, 3, 1, 2}, 2"
              output: "true"
            - input: "[]int{1, 2, 3, 4, 5}, 2"
              output: "false"
          hints:
            - title: ðŸ¤” Think about it
              content: You need to compare the first k elements with the last k elements. What are the corresponding indices?
            - title: ðŸ’¡ Hint
              content: Element at index i should match element at index len-k+i. Check all k pairs.
            - title: ðŸ”§ Pattern
              content: |-
                <pre>1. Loop i from 0 to k-1
                2. Compare nums[i] with nums[len-k+i]
                3. If mismatch â†’ return false
                4. Return true (all pairs match)</pre>
          solution: |-
            func startsEndsSame(nums []int, k int) bool {
                n := len(nums)
                for i := 0; i < k; i++ {
                    if nums[i] != nums[n-k+i] { return false }
                }
                return true
            }
          difficulty: 1
        - id: v7
          title: Mirror Halves
          description: >-
            Write <code>func mirrorHalves(nums []int) bool</code> - true if first half mirrors second half. Assume even
            length.
          functionSignature: func mirrorHalves(nums []int) bool
          testCases:
            - input: "[]int{1, 2, 2, 1}"
              output: "true"
            - input: "[]int{5, 3, 3, 5}"
              output: "true"
            - input: "[]int{1, 2, 3, 4}"
              output: "false"
          hints:
            - title: ðŸ¤” Think about it
              content: Compare first half with second half in reverse. Element at index i should match element at index n-1-i.
            - title: ðŸ’¡ Hint
              content: Use two pointers starting at both ends, moving inward. Compare only the first n/2 pairs.
            - title: ðŸ”§ Pattern
              content: |-
                <pre>1. left = 0, right = len-1
                2. While left < right:
                   - nums[left] != nums[right]? â†’ return false
                   - left++, right--
                3. Return true</pre>
          solution: |-
            func mirrorHalves(nums []int) bool {
                for i, j := 0, len(nums)-1; i < j; i, j = i+1, j-1 {
                    if nums[i] != nums[j] { return false }
                }
                return true
            }
          difficulty: 2
        - id: v8
          title: Valid Score Sequence
          description: >-
            Write <code>func validScoreSeq(scores []int) bool</code> - true if scores never decrease by more than 10
            points between adjacent rounds.
          functionSignature: func validScoreSeq(scores []int) bool
          testCases:
            - input: "[]int{100, 95, 98, 90}"
              output: "true"
            - input: "[]int{100, 85, 90}"
              output: "false"
              note: 100 to 85 is -15
          hints:
            - title: ðŸ¤” Think about it
              content: Compare adjacent scores. If any drop is more than 10, return false.
            - title: ðŸ’¡ Hint
              content: Loop through indices, compare scores[i] with scores[i+1]. Check if scores[i] - scores[i+1] > 10.
            - title: ðŸ”§ Pattern
              content: |-
                <pre>1. For i from 0 to len-2:
                   - scores[i] - scores[i+1] > 10?
                     â†’ return false
                2. Return true</pre>
          solution: |-
            func validScoreSeq(scores []int) bool {
                for i := 0; i < len(scores)-1; i++ {
                    if scores[i] - scores[i+1] > 10 { return false }
                }
                return true
            }
          difficulty: 2
        - id: v9
          title: Balanced Brackets
          description: >-
            Write <code>func balancedBrackets(s string) bool</code> - true if string has equal '[' and ']' counts AND
            they're balanced left-to-right.
          functionSignature: func balancedBrackets(s string) bool
          testCases:
            - input: "\"[[][]]\""
              output: "true"
            - input: "\"[[]\""
              output: "false"
            - input: "\"][[\""
              output: "false"
          hints:
            - title: ðŸ¤” Think about it
              content: "Track a running count: +1 for '[', -1 for ']'. Count should never go negative, and should be 0 at end."
            - title: ðŸ’¡ Hint
              content: Use a counter variable. If it ever goes negative, we have ']' before matching '['. Must end at 0.
            - title: ðŸ”§ Pattern
              content: |-
                <pre>1. count := 0
                2. For each char:
                   - '[' â†’ count++
                   - ']' â†’ count--
                   - count < 0? â†’ return false
                3. Return count == 0</pre>
          solution: |-
            func balancedBrackets(s string) bool {
                count := 0
                for _, c := range s {
                    if c == '[' { count++ }
                    if c == ']' { count-- }
                    if count < 0 { return false }
                }
                return count == 0
            }
          difficulty: 3
        - id: v10
          title: First Last Equal
          description: Write <code>func firstLastEqual(nums []int) bool</code> - true if first element equals last element.
          functionSignature: func firstLastEqual(nums []int) bool
          testCases:
            - input: "[]int{5, 2, 3, 5}"
              output: "true"
            - input: "[]int{1, 2, 3}"
              output: "false"
          hints:
            - title: ðŸ¤” Think about it
              content: You need to compare the first and last elements. What are their indices?
            - title: ðŸ’¡ Hint
              content: First element is at index 0, last is at index len(nums)-1. Just compare them directly.
            - title: ðŸ”§ Pattern
              content: |-
                <pre>1. Get first element: nums[0]
                2. Get last element: nums[len(nums)-1]
                3. Return whether they're equal</pre>
          solution: |-
            func firstLastEqual(nums []int) bool {
                if len(nums) == 0 { return true }
                return nums[0] == nums[len(nums)-1]
            }
          difficulty: 1
        - id: v11
          title: No Decreases
          description: >-
            Write <code>func noDecreases(nums []int) bool</code> - true if array never decreases (each element >=
            previous). Adjacent pair comparison.
          functionSignature: func noDecreases(nums []int) bool
          testCases:
            - input: "[]int{1, 2, 2, 3}"
              output: "true"
            - input: "[]int{1, 3, 2, 4}"
              output: "false"
              note: 3â†’2 is a decrease
          hints:
            - title: ðŸ¤” Think about it
              content: "Check adjacent pairs: each element should be >= the one before it."
            - title: ðŸ’¡ Hint
              content: Loop from index 1 onwards. Compare nums[i] with nums[i-1]. If nums[i] < nums[i-1], return false.
            - title: ðŸ”§ Pattern
              content: |-
                <pre>1. For i from 1 to len:
                   - If nums[i] < nums[i-1] â†’ return false
                2. Return true</pre>
          solution: |-
            func noDecreases(nums []int) bool {
                for i := 1; i < len(nums); i++ {
                    if nums[i] < nums[i-1] { return false }
                }
                return true
            }
          difficulty: 1
        - id: v12
          title: Sum Symmetry
          description: >-
            Write <code>func sumSymmetry(nums []int) bool</code> - true if sum of first half equals sum of second half.
            Assume even length. Two-pointer to compare halves.
          functionSignature: func sumSymmetry(nums []int) bool
          testCases:
            - input: "[]int{1, 2, 3, 3, 2, 1}"
              output: "true"
              note: 1+2+3 = 3+2+1
            - input: "[]int{1, 2, 3, 4}"
              output: "false"
              note: 1+2 â‰  3+4
          hints:
            - title: ðŸ¤” Think about it
              content: Calculate sum of first half, then sum of second half, then compare.
            - title: ðŸ’¡ Hint
              content: Loop from 0 to mid to get first sum. Loop from mid to end to get second sum. Compare them.
            - title: ðŸ”§ Pattern
              content: |-
                <pre>1. mid := len/2
                2. sum1 := sum of nums[0:mid]
                3. sum2 := sum of nums[mid:]
                4. Return sum1 == sum2</pre>
          solution: |-
            func sumSymmetry(nums []int) bool {
                mid := len(nums) / 2
                sum1, sum2 := 0, 0
                for i := 0; i < mid; i++ {
                    sum1 += nums[i]
                }
                for i := mid; i < len(nums); i++ {
                    sum2 += nums[i]
                }
                return sum1 == sum2
            }
          difficulty: 1
        - id: v13
          title: Distance Increasing
          description: >-
            Write <code>func distanceIncreasing(nums []int) bool</code> - true if distance between adjacent elements is
            always increasing. Distance = abs(nums[i] - nums[i-1]).
          functionSignature: func distanceIncreasing(nums []int) bool
          testCases:
            - input: "[]int{1, 2, 5, 10}"
              output: "true"
              note: "Distances: 1, 3, 5 (increasing)"
            - input: "[]int{1, 3, 4, 8}"
              output: "false"
              note: "Distances: 2, 1, 4 (not increasing)"
          hints:
            - title: ðŸ¤” Think about it
              content: Calculate distance between each adjacent pair. Check if distances form an increasing sequence.
            - title: ðŸ’¡ Hint
              content: >-
                Track previous distance. For each pair, calculate current distance, compare with previous, update
                previous.
            - title: ðŸ”§ Pattern
              content: |-
                <pre>1. prevDist := first pair distance
                2. For each subsequent pair:
                   - Calculate currDist
                   - If currDist <= prevDist â†’ return false
                   - prevDist = currDist
                3. Return true</pre>
          solution: |-
            func distanceIncreasing(nums []int) bool {
                if len(nums) < 3 { return true }
                abs := func(x int) int {
                    if x < 0 { return -x }
                    return x
                }
                prevDist := abs(nums[1] - nums[0])
                for i := 2; i < len(nums); i++ {
                    currDist := abs(nums[i] - nums[i-1])
                    if currDist <= prevDist { return false }
                    prevDist = currDist
                }
                return true
            }
          difficulty: 1
        - id: v1
          title: Maximum Sum Subarray of Size K
          description: >-
            Given an array of integers and a number k, find the maximum sum of any contiguous subarray of size k.
            <code>func maxSumSubarray(nums []int, k int) int</code>
          functionSignature: func maxSumSubarray(nums []int, k int) int
          testCases:
            - input: "[]int{2, 1, 5, 1, 3, 2}, 3"
              output: "9"
              note: subarray [5,1,3]
            - input: "[]int{2, 3, 4, 1, 5}, 2"
              output: "7"
              note: subarray [3,4]
            - input: "[]int{1, 1, 1, 1}, 2"
              output: "2"
          solution: |-
            func maxSumSubarray(nums []int, k int) int {
                if len(nums) < k {
                    return 0
                }
                windowSum := 0
                for i := 0; i < k; i++ {
                    windowSum += nums[i]
                }
                maxSum := windowSum
                
                for i := k; i < len(nums); i++ {
                    windowSum += nums[i] - nums[i-k]
                    if windowSum > maxSum {
                        maxSum = windowSum
                    }
                }
                return maxSum
            }
          solutionNotes: >-
            Fixed-size window: calculate first window sum, then slide by adding new element and subtracting leaving
            element. O(n) time, O(1) space.
          difficulty: 4
        - id: v2
          title: Longest Substring Without Repeating
          description: >-
            Find the length of the longest substring without repeating characters. <code>func lengthOfLongestSubstring(s
            string) int</code>
          functionSignature: func lengthOfLongestSubstring(s string) int
          testCases:
            - input: "\"abcabcbb\""
              output: "3"
              note: "\"abc\""
            - input: "\"bbbbb\""
              output: "1"
              note: "\"b\""
            - input: "\"pwwkew\""
              output: "3"
              note: "\"wke\""
          solution: |-
            func lengthOfLongestSubstring(s string) int {
                seen := make(map[byte]int)
                maxLen := 0
                left := 0
                
                for right := 0; right < len(s); right++ {
                    char := s[right]
                    if lastIdx, ok := seen[char]; ok && lastIdx >= left {
                        left = lastIdx + 1
                    }
                    seen[char] = right
                    if right - left + 1 > maxLen {
                        maxLen = right - left + 1
                    }
                }
                return maxLen
            }
          solutionNotes: >-
            Variable-size window: expand right, shrink left when duplicate found. Track last seen index of each
            character to know where to shrink to.
          difficulty: 4
        - id: v3
          title: Minimum Size Subarray Sum
          description: >-
            Find the minimal length of a contiguous subarray whose sum is >= target. Return 0 if no such subarray.
            <code>func minSubarrayLen(target int, nums []int) int</code>
          functionSignature: func minSubarrayLen(target int, nums []int) int
          testCases:
            - input: 7, []int{2, 3, 1, 2, 4, 3}
              output: "2"
              note: "[4,3] sums to 7"
            - input: 4, []int{1, 4, 4}
              output: "1"
              note: "[4] alone >= 4"
            - input: 11, []int{1, 1, 1, 1}
              output: "0"
              note: can't reach 11
          solution: |-
            func minSubarrayLen(target int, nums []int) int {
                minLen := len(nums) + 1
                left := 0
                sum := 0
                
                for right := 0; right < len(nums); right++ {
                    sum += nums[right]
                    
                    for sum >= target {
                        if right - left + 1 < minLen {
                            minLen = right - left + 1
                        }
                        sum -= nums[left]
                        left++
                    }
                }
                
                if minLen == len(nums) + 1 {
                    return 0
                }
                return minLen
            }
          solutionNotes: >-
            Variable-size window with condition: expand to increase sum, shrink while condition met to find minimum.
            Classic 'minimum window' pattern.
          difficulty: 4
        - id: v4
          title: Average of Subarrays of Size K
          description: >-
            Given an array, find the average of all contiguous subarrays of size k. <code>func averageOfSubarrays(nums
            []int, k int) []float64</code>
          functionSignature: func averageOfSubarrays(nums []int, k int) []float64
          testCases:
            - input: "[]int{1, 3, 2, 6, -1, 4, 1, 8, 2}, 5"
              output: "[2.2, 2.8, 2.4, 3.6, 2.8]"
            - input: "[]int{1, 2, 3, 4}, 2"
              output: "[1.5, 2.5, 3.5]"
          solution: |-
            func averageOfSubarrays(nums []int, k int) []float64 {
                result := []float64{}
                windowSum := 0
                
                for i := 0; i < len(nums); i++ {
                    windowSum += nums[i]
                    
                    if i >= k-1 {
                        result = append(result, float64(windowSum)/float64(k))
                        windowSum -= nums[i-k+1]
                    }
                }
                return result
            }
          solutionNotes: Basic fixed-window pattern. Build up sum for first k elements, then slide and track averages.
          difficulty: 4
        - id: v5
          title: Contains Duplicate Within K Distance
          description: >-
            Return true if there are two distinct indices i and j where nums[i] == nums[j] and abs(i - j) <= k.
            <code>func containsNearbyDuplicate(nums []int, k int) bool</code>
          functionSignature: func containsNearbyDuplicate(nums []int, k int) bool
          testCases:
            - input: "[]int{1, 2, 3, 1}, 3"
              output: "true"
            - input: "[]int{1, 0, 1, 1}, 1"
              output: "true"
            - input: "[]int{1, 2, 3, 1, 2, 3}, 2"
              output: "false"
          solution: |-
            func containsNearbyDuplicate(nums []int, k int) bool {
                seen := make(map[int]bool)
                
                for i, num := range nums {
                    if seen[num] {
                        return true
                    }
                    seen[num] = true
                    
                    if i >= k {
                        delete(seen, nums[i-k])
                    }
                }
                return false
            }
          solutionNotes: >-
            Maintain a sliding window of size k as a set. If we see a duplicate within the window, return true. Remove
            elements that leave the window.
          difficulty: 4
        - id: v6
          title: Max Consecutive Ones III
          description: >-
            Given a binary array and integer k, return the maximum number of consecutive 1's if you can flip at most k
            0's. <code>func longestOnes(nums []int, k int) int</code>
          functionSignature: func longestOnes(nums []int, k int) int
          testCases:
            - input: "[]int{1,1,1,0,0,0,1,1,1,1,0}, 2"
              output: "6"
              note: flip 0's at indices 5 and 10
            - input: "[]int{0,0,1,1,0,0,1,1,1,0,1,1,0,0,0,1,1,1,1}, 3"
              output: "10"
          solution: |-
            func longestOnes(nums []int, k int) int {
                left := 0
                zeros := 0
                maxLen := 0
                
                for right := 0; right < len(nums); right++ {
                    if nums[right] == 0 {
                        zeros++
                    }
                    
                    for zeros > k {
                        if nums[left] == 0 {
                            zeros--
                        }
                        left++
                    }
                    
                    if right - left + 1 > maxLen {
                        maxLen = right - left + 1
                    }
                }
                return maxLen
            }
          solutionNotes: >-
            Variable window: expand right, count zeros. When zeros > k, shrink from left. Track maximum valid window
            size.
          difficulty: 4
    - id: challenge_10
      block: 4
      difficulty: 4
      concept: Two-Pointer Swap
      docLinks:
        - url: https://go.dev/ref/spec#Assignments
          title: "Go Spec: Assignments"
          note: simultaneous swap (a, b = b, a)
        - url: https://go.dev/blog/slices
          title: "Go Blog: Slices"
          note: in-place modifications
      patternPrimer:
        bruteForce: Create a new array and build it by iterating backwards through the original.
        bestApproach: Start pointers at both ends, swap elements in place, move pointers inward until they meet.
        typical: Typically O(n) time, O(1) extra space
      variants:
        - id: v1
          title: Reverse Slice
          description: Write <code>func reverse(nums []int) []int</code> that reverses in place.
          functionSignature: func reverse(nums []int) []int
          testCases:
            - input: "[]int{1,2,3,4,5}"
              output: "[5,4,3,2,1]"
          hints:
            - title: ðŸ¤” Think about it
              content: >-
                To reverse in-place, you swap elements from both ends working toward the middle. What pattern lets you
                walk two pointers toward each other?
            - title: ðŸ’¡ Hint
              content: >-
                Use the same two-pointer loop as palindrome check, but swap the elements instead of comparing them. Stop
                when the pointers meet or cross.
            - title: ðŸ”§ Pattern
              content: |-
                <pre>1. left pointer at start, right pointer at end
                2. While left < right:
                   - Swap elements at left and right
                   - Move both pointers inward
                3. Done (reversed in place)</pre>
          solution: |-
            func reverse(nums []int) []int {
                for i, j := 0, len(nums)-1; i < j; i, j = i+1, j-1 {
                    nums[i], nums[j] = nums[j], nums[i]
                }
                return nums
            }
          difficulty: 3
        - id: v2
          title: Reverse String
          description: Write <code>func reverseString(s string) string</code> that reverses a string.
          functionSignature: func reverseString(s string) string
          testCases:
            - input: "\"hello\""
              output: "\"olleh\""
            - input: "\"Go\""
              output: "\"oG\""
          hints:
            - title: ðŸ¤” Think about it
              content: >-
                To reverse in-place, you swap elements from both ends working toward the middle. What pattern lets you
                walk two pointers toward each other?
            - title: ðŸ’¡ Hint
              content: Convert to []rune first (strings are immutable). Then use the same two-pointer swap as with slices.
            - title: ðŸ”§ Pattern
              content: |-
                <pre>1. Convert string to []rune
                2. left pointer at start, right pointer at end
                3. While left < right:
                   - Swap runes at left and right
                   - Move both pointers inward
                4. Convert back to string</pre>
          solution: |-
            func reverseString(s string) string {
                r := []rune(s)
                for i, j := 0, len(r)-1; i < j; i, j = i+1, j-1 {
                    r[i], r[j] = r[j], r[i]
                }
                return string(r)
            }
          difficulty: 3
        - id: v3
          title: Reverse Segment
          description: >-
            Write <code>func reverseSegment(nums []int, start, end int)</code> that reverses elements from index start
            to end (inclusive).
          functionSignature: func reverseSegment(nums []int, start, end int)
          testCases:
            - input: "[]int{1,2,3,4,5}, 1, 3"
              output: "[1,4,3,2,5]"
          hints:
            - title: ðŸ¤” Think about it
              content: >-
                To reverse in-place, you swap elements from both ends working toward the middle. What pattern lets you
                walk two pointers toward each other?
            - title: ðŸ’¡ Hint
              content: Same two-pointer pattern, but start at 'start' instead of 0, and end at 'end' instead of len-1.
            - title: ðŸ”§ Pattern
              content: |-
                <pre>1. left pointer at start, right pointer at end
                2. While left < right:
                   - Swap elements at left and right
                   - Move both pointers inward
                3. Done (segment reversed in place)</pre>
          solution: |-
            func reverseSegment(nums []int, start, end int) {
                for i, j := start, end; i < j; i, j = i+1, j-1 {
                    nums[i], nums[j] = nums[j], nums[i]
                }
            }
          difficulty: 3
        - id: v4
          title: Swap First and Last
          description: Write <code>func swapEnds(nums []int) []int</code> that swaps the first and last elements.
          functionSignature: func swapEnds(nums []int) []int
          testCases:
            - input: "[]int{1, 2, 3, 4, 5}"
              output: "[5, 2, 3, 4, 1]"
          hints:
            - title: ðŸ¤” Think about it
              content: You only need to swap two specific elements. What are their indices?
            - title: ðŸ’¡ Hint
              content: First element is at index 0, last is at index len-1. Use Go's simultaneous assignment to swap.
            - title: ðŸ”§ Pattern
              content: |-
                <pre>1. Identify indices: first = 0, last = len-1
                2. Swap: nums[0], nums[last] = nums[last], nums[0]
                3. Return the modified slice</pre>
          solution: |-
            func swapEnds(nums []int) []int {
                n := len(nums)
                nums[0], nums[n-1] = nums[n-1], nums[0]
                return nums
            }
          difficulty: 2
        - id: v5
          title: Rotate Right by One
          description: Write <code>func rotateRight(nums []int) []int</code> that moves the last element to the front.
          functionSignature: func rotateRight(nums []int) []int
          testCases:
            - input: "[]int{1, 2, 3, 4, 5}"
              output: "[5, 1, 2, 3, 4]"
          hints:
            - title: ðŸ¤” Think about it
              content: The last element goes to index 0, and all other elements shift right by one position.
            - title: ðŸ’¡ Hint
              content: >-
                Save the last element. Then loop backwards, shifting each element to the right. Finally place the saved
                element at index 0.
            - title: ðŸ”§ Pattern
              content: |-
                <pre>1. Save last element: temp = nums[len-1]
                2. Shift all elements right: nums[i] = nums[i-1]
                3. Place saved element at front: nums[0] = temp</pre>
          solution: |-
            func rotateRight(nums []int) []int {
                n := len(nums)
                last := nums[n-1]
                for i := n-1; i > 0; i-- {
                    nums[i] = nums[i-1]
                }
                nums[0] = last
                return nums
            }
          difficulty: 2
        - id: v6
          title: Mirror Slice
          description: >-
            Write <code>func mirror(nums []int) []int</code> that makes the second half mirror the first half. For
            [1,2,3,4] â†’ [1,2,2,1].
          functionSignature: func mirror(nums []int) []int
          testCases:
            - input: "[]int{1, 2, 3, 4}"
              output: "[1, 2, 2, 1]"
            - input: "[]int{1, 2, 3, 4, 5}"
              output: "[1, 2, 3, 2, 1]"
          hints:
            - title: ðŸ¤” Think about it
              content: You need to copy elements from the first half to matching positions in the second half.
            - title: ðŸ’¡ Hint
              content: "Use two pointers: one from start, one from end. Copy nums[i] to nums[j] as long as i < j."
            - title: ðŸ”§ Pattern
              content: |-
                <pre>1. left pointer at 0, right pointer at len-1
                2. While left < right:
                   - Copy nums[left] to nums[right]
                   - Move both pointers inward
                3. Return modified slice</pre>
          solution: |-
            func mirror(nums []int) []int {
                for i, j := 0, len(nums)-1; i < j; i, j = i+1, j-1 {
                    nums[j] = nums[i]
                }
                return nums
            }
          difficulty: 3
        - id: v7
          title: Swap Ends Only
          difficulty: 1
          description: >-
            Write <code>func swapEnds(nums []int)</code> that swaps ONLY the first and last elements. Modify the slice
            in place.
          functionSignature: func swapEnds(nums []int)
          testCases:
            - input: "[]int{1, 2, 3, 4, 5}"
              output: "[5, 2, 3, 4, 1]"
              note: Only first and last swapped
            - input: "[]int{10, 20}"
              output: "[20, 10]"
          hints:
            - title: ðŸ¤” Think about it
              content: This is just a single swap operation - no loop needed!
            - title: ðŸ’¡ Hint
              content: Swap nums[0] and nums[len(nums)-1] using Go's simultaneous assignment.
            - title: ðŸ”§ Pattern
              content: <pre>nums[0], nums[len(nums)-1] = nums[len(nums)-1], nums[0]</pre>
          solution: |-
            func swapEnds(nums []int) {
                if len(nums) > 1 {
                    nums[0], nums[len(nums)-1] = nums[len(nums)-1], nums[0]
                }
            }
        - id: v8
          title: Reverse First N
          difficulty: 1
          description: >-
            Write <code>func reverseFirstN(nums []int, n int)</code> that reverses only the first n elements using two
            pointers.
          functionSignature: func reverseFirstN(nums []int, n int)
          testCases:
            - input: "[]int{1, 2, 3, 4, 5}, 3"
              output: "[3, 2, 1, 4, 5]"
              note: Only first 3 elements reversed
            - input: "[]int{10, 20, 30, 40}, 2"
              output: "[20, 10, 30, 40]"
          hints:
            - title: ðŸ¤” Think about it
              content: This is like reversing a slice, but you only go up to position n instead of the end.
            - title: ðŸ’¡ Hint
              content: >-
                Use two pointers: left starts at 0, right starts at n-1 (not len-1!). Swap and move inward until they
                meet.
            - title: ðŸ”§ Pattern
              content: |-
                <pre>1. left := 0, right := n-1
                2. While left < right:
                   - Swap nums[left] and nums[right]
                   - left++, right--</pre>
          solution: |-
            func reverseFirstN(nums []int, n int) {
                if n > len(nums) {
                    n = len(nums)
                }
                left, right := 0, n-1
                for left < right {
                    nums[left], nums[right] = nums[right], nums[left]
                    left++
                    right--
                }
            }
        - id: v9
          title: Move Zeros to End
          description: >-
            Write <code>func moveZeros(nums []int) []int</code> that moves all zeros to the end, preserving order of
            non-zeros.
          functionSignature: func moveZeros(nums []int) []int
          testCases:
            - input: "[]int{0, 1, 0, 3, 12}"
              output: "[]int{1, 3, 12, 0, 0}"
            - input: "[]int{0, 0, 1}"
              output: "[]int{1, 0, 0}"
          hints:
            - title: ðŸ¤” Think about it
              content: Collect all non-zero elements first, then append zeros to fill the rest.
            - title: ðŸ’¡ Hint
              content: Filter non-zeros into result, then append len(nums) - len(result) zeros.
            - title: ðŸ”§ Pattern
              content: |-
                <pre>1. result := []int{}
                2. For each num:
                   - num != 0? â†’ append to result
                3. While len(result) < len(nums):
                   - append 0
                4. Return result</pre>
          solution: |-
            func moveZeros(nums []int) []int {
                result := []int{}
                for _, num := range nums {
                    if num != 0 {
                        result = append(result, num)
                    }
                }
                for len(result) < len(nums) {
                    result = append(result, 0)
                }
                return result
            }
          difficulty: 2
        - id: v10
          title: Reverse Words in Place
          description: Write <code>func reverseWords(words []string)</code> that reverses the order of words in the slice in-place.
          functionSignature: func reverseWords(words []string)
          testCases:
            - input: "[]string{\"hello\", \"world\", \"go\"}"
              output: "[\"go\", \"world\", \"hello\"]"
            - input: "[]string{\"a\", \"b\"}"
              output: "[\"b\", \"a\"]"
          hints:
            - title: ðŸ¤” Think about it
              content: "Two-pointer swap pattern: swap from both ends moving toward center."
            - title: ðŸ’¡ Hint
              content: left starts at 0, right at len-1. Swap and move inward until they meet.
            - title: ðŸ”§ Pattern
              content: |-
                <pre>1. left = 0, right = len-1
                2. While left < right:
                   - Swap words[left] â†” words[right]
                   - left++, right--</pre>
          solution: |-
            func reverseWords(words []string) {
                for i, j := 0, len(words)-1; i < j; i, j = i+1, j-1 {
                    words[i], words[j] = words[j], words[i]
                }
            }
          difficulty: 2
        - id: v11
          title: Reverse Outer Pairs
          difficulty: 1
          description: >-
            Write <code>func reverseOuterPairs(nums []int, k int)</code> that swaps k pairs from both ends: swap
            nums[0]â†”nums[len-1], nums[1]â†”nums[len-2], ..., k times. Two-pointer inward movement.
          functionSignature: func reverseOuterPairs(nums []int, k int)
          testCases:
            - input: "[]int{1, 2, 3, 4, 5, 6}, 2"
              output: "[6, 5, 3, 4, 2, 1]"
              note: Swap 2 pairs from ends
            - input: "[]int{1, 2, 3, 4}, 1"
              output: "[4, 2, 3, 1]"
          hints:
            - title: ðŸ¤” Think about it
              content: Start with pointers at both ends. Swap, move both inward, repeat k times.
            - title: ðŸ’¡ Hint
              content: "left = 0, right = len-1. Loop k times: swap nums[left] with nums[right], then left++, right--."
            - title: ðŸ”§ Pattern
              content: |-
                <pre>1. left := 0, right := len-1
                2. For i from 0 to k:
                   - Swap nums[left] â†” nums[right]
                   - left++, right--</pre>
          solution: |-
            func reverseOuterPairs(nums []int, k int) {
                left, right := 0, len(nums)-1
                for i := 0; i < k && left < right; i++ {
                    nums[left], nums[right] = nums[right], nums[left]
                    left++
                    right--
                }
            }
        - id: v12
          title: Outer to Inner Copy
          difficulty: 1
          description: >-
            Write <code>func outerToInner(nums []int)</code> that copies outer elements to inner positions moving
            inward: [1,2,3,4,5,6] â†’ [1,1,6,6,5,6]. Two pointers copy inward.
          functionSignature: func outerToInner(nums []int)
          testCases:
            - input: "[]int{1, 2, 3, 4, 5, 6}"
              output: "[1, 1, 6, 6, 5, 6]"
              note: Outer values copy toward center
            - input: "[]int{10, 20, 30, 40}"
              output: "[10, 10, 40, 40]"
          hints:
            - title: ðŸ¤” Think about it
              content: Start pointers at ends. Copy the outer values to the next inner positions, move inward.
            - title: ðŸ’¡ Hint
              content: >-
                left = 0, right = len-1. While left < right-1: save outer values, move pointers inward, write saved
                values.
            - title: ðŸ”§ Pattern
              content: |-
                <pre>1. left := 0, right := len-1
                2. While left < right-1:
                   - Copy nums[left] to nums[left+1]
                   - Copy nums[right] to nums[right-1]
                   - left++, right--</pre>
          solution: |-
            func outerToInner(nums []int) {
                left, right := 0, len(nums)-1
                for left < right-1 {
                    leftVal, rightVal := nums[left], nums[right]
                    left++
                    right--
                    nums[left] = leftVal
                    nums[right] = rightVal
                }
            }
        - id: v13
          title: Reverse Alternating Pairs
          difficulty: 1
          description: >-
            Write <code>func reverseAlternating(nums []int)</code> that reverses every other pair from outside in: swap
            positions 0â†”last, skip next pair, swap 2â†”(last-2), etc. Two pointers with conditional swapping.
          functionSignature: func reverseAlternating(nums []int)
          testCases:
            - input: "[]int{1, 2, 3, 4, 5, 6, 7, 8}"
              output: "[8, 2, 7, 4, 5, 6, 3, 1]"
              note: Swap pairs at positions (0,7) and (2,5), skip (1,6) and (3,4)
            - input: "[]int{1, 2, 3, 4}"
              output: "[4, 2, 3, 1]"
              note: Swap (0,3), skip (1,2)
          hints:
            - title: ðŸ¤” Think about it
              content: Start pointers at ends. Swap, move inward by 2 (skip next pair), swap again, repeat.
            - title: ðŸ’¡ Hint
              content: "left = 0, right = len-1. While left < right: swap them, then left += 2, right -= 2 (to skip next pair)."
            - title: ðŸ”§ Pattern
              content: |-
                <pre>1. left := 0, right := len-1
                2. While left < right:
                   - Swap nums[left] â†” nums[right]
                   - left += 2, right -= 2</pre>
          solution: |-
            func reverseAlternating(nums []int) {
                left, right := 0, len(nums)-1
                for left < right {
                    nums[left], nums[right] = nums[right], nums[left]
                    left += 2
                    right -= 2
                }
            }
        - id: v1
          title: Remove Duplicates from Sorted Array
          description: >-
            Write a function <code>func removeDuplicates(nums []int) int</code> that removes duplicates from a sorted
            slice <strong>in-place</strong>. Return the number of unique elements. The first k elements should contain
            the unique values.
          functionSignature: func removeDuplicates(nums []int) int
          testCases:
            - input: "[]int{1, 1, 2}"
              output: "2"
              note: array becomes [1, 2, _]
            - input: "[]int{0, 0, 1, 1, 2, 2, 3}"
              output: "4"
              note: array becomes [0, 1, 2, 3, _, _, _]
            - input: "[]int{1, 2, 3}"
              output: "3"
          solution: |-
            func removeDuplicates(nums []int) int {
                if len(nums) == 0 {
                    return 0
                }
                slow := 0
                for fast := 1; fast < len(nums); fast++ {
                    if nums[fast] != nums[slow] {
                        slow++
                        nums[slow] = nums[fast]
                    }
                }
                return slow + 1
            }
          difficulty: 4
        - id: v2
          title: Remove Element
          description: >-
            Write a function <code>func removeElement(nums []int, val int) int</code> that removes all occurrences of
            <code>val</code> <strong>in-place</strong>. Return the number of elements remaining. Order doesn't need to
            be preserved.
          functionSignature: func removeElement(nums []int, val int) int
          testCases:
            - input: "[]int{3, 2, 2, 3}, 3"
              output: "2"
              note: array becomes [2, 2, _, _]
            - input: "[]int{0, 1, 2, 2, 3, 0, 4, 2}, 2"
              output: "5"
            - input: "[]int{1}, 1"
              output: "0"
          solution: |-
            func removeElement(nums []int, val int) int {
                slow := 0
                for fast := 0; fast < len(nums); fast++ {
                    if nums[fast] != val {
                        nums[slow] = nums[fast]
                        slow++
                    }
                }
                return slow
            }
          solutionNotes: >-
            Unlike Remove Duplicates, here we compare against a fixed value, not the previous element. And both pointers
            start at 0.
          difficulty: 4
        - id: v3
          title: Move Zeroes
          description: >-
            Write a function <code>func moveZeroes(nums []int)</code> that moves all <code>0</code>s to the end of the
            slice while maintaining the relative order of non-zero elements. Modify in-place.
          functionSignature: func moveZeroes(nums []int)
          testCases:
            - input: "[]int{0, 1, 0, 3, 12}"
              output: "[1, 3, 12, 0, 0]"
            - input: "[]int{0, 0, 1}"
              output: "[1, 0, 0]"
            - input: "[]int{1, 2, 3}"
              output: "[1, 2, 3]"
              note: no zeroes
          solution: |-
            func moveZeroes(nums []int) {
                slow := 0
                
                for fast := 0; fast < len(nums); fast++ {
                    if nums[fast] != 0 {
                        nums[slow] = nums[fast]
                        slow++
                    }
                }
                
                for i := slow; i < len(nums); i++ {
                    nums[i] = 0
                }
            }
          solutionNotes: >-
            This is a two-pass solution. First pass moves non-zeroes forward, second pass fills remaining positions with
            zeroes. Can also be done in one pass with swapping!
          difficulty: 4
        - id: v4
          title: Remove Duplicates II (Allow 2)
          description: >-
            Write a function <code>func removeDuplicatesII(nums []int) int</code> that removes duplicates from a sorted
            array such that each element appears <strong>at most twice</strong>. Return the new length.
          functionSignature: func removeDuplicatesII(nums []int) int
          testCases:
            - input: "[]int{1, 1, 1, 2, 2, 3}"
              output: "5"
              note: becomes [1, 1, 2, 2, 3, _]
            - input: "[]int{0, 0, 1, 1, 1, 1, 2, 3, 3}"
              output: "7"
            - input: "[]int{1, 1}"
              output: "2"
          solution: |-
            func removeDuplicatesII(nums []int) int {
                if len(nums) <= 2 {
                    return len(nums)
                }
                
                slow := 2
                for fast := 2; fast < len(nums); fast++ {
                    if nums[fast] != nums[slow-2] {
                        nums[slow] = nums[fast]
                        slow++
                    }
                }
                return slow
            }
          solutionNotes: >-
            The key insight: compare with nums[slow-2], not nums[slow-1]. This ensures at most 2 of each value. Start
            both pointers at index 2.
          difficulty: 4
        - id: v5
          title: Sorted Squares
          description: >-
            Write a function <code>func sortedSquares(nums []int) []int</code> that returns an array of the squares of
            each number, sorted in ascending order. Input is sorted but may contain negatives.
          functionSignature: func sortedSquares(nums []int) []int
          testCases:
            - input: "[]int{-4, -1, 0, 3, 10}"
              output: "[0, 1, 9, 16, 100]"
            - input: "[]int{-7, -3, 2, 3, 11}"
              output: "[4, 9, 9, 49, 121]"
            - input: "[]int{1, 2, 3}"
              output: "[1, 4, 9]"
          solution: |-
            func sortedSquares(nums []int) []int {
                n := len(nums)
                result := make([]int, n)
                left, right := 0, n-1
                pos := n - 1
                
                for left <= right {
                    leftSq := nums[left] * nums[left]
                    rightSq := nums[right] * nums[right]
                    
                    if leftSq > rightSq {
                        result[pos] = leftSq
                        left++
                    } else {
                        result[pos] = rightSq
                        right--
                    }
                    pos--
                }
                return result
            }
          solutionNotes: >-
            This uses two pointers from OPPOSITE ENDS (not slow/fast). The largest squares are at the edges (most
            negative or most positive). Fill result array from the back.
          difficulty: 4
        - id: v6
          title: Merge Sorted Array
          description: >-
            Write a function <code>func merge(nums1 []int, m int, nums2 []int, n int)</code> that merges nums2 into
            nums1 <strong>in-place</strong>. nums1 has length m+n, with the last n elements being 0 (placeholders).
          functionSignature: func merge(nums1 []int, m int, nums2 []int, n int)
          testCases:
            - input: "[]int{1, 2, 3, 0, 0, 0}, 3, []int{2, 5, 6}, 3"
              output: "[1, 2, 2, 3, 5, 6]"
            - input: "[]int{1}, 1, []int{}, 0"
              output: "[1]"
            - input: "[]int{0}, 0, []int{1}, 1"
              output: "[1]"
          solution: |-
            func merge(nums1 []int, m int, nums2 []int, n int) {
                p1 := m - 1
                p2 := n - 1
                pos := m + n - 1
                
                for p2 >= 0 {
                    if p1 >= 0 && nums1[p1] > nums2[p2] {
                        nums1[pos] = nums1[p1]
                        p1--
                    } else {
                        nums1[pos] = nums2[p2]
                        p2--
                    }
                    pos--
                }
            }
          solutionNotes: >-
            Work BACKWARDS to avoid overwriting elements we haven't processed. The loop continues until all of nums2 is
            merged. If nums1 elements remain, they're already in place.
          difficulty: 4
    - id: challenge_11
      block: 4
      difficulty: 4
      concept: Map Lookup + Early Return
      docLinks:
        - url: https://go.dev/blog/maps
          title: "Go Blog: Go maps in action"
          note: map as a set pattern
        - url: https://go.dev/ref/spec#Index_expressions
          title: "Go Spec: Index expressions"
          note: checking if key exists
      patternPrimer:
        bruteForce: "Nested loops: for each element, scan all previous elements to check if it appeared before."
        bestApproach: Track seen elements in a map; check map in O(1) time, return immediately when found.
        typical: Typically O(n) time, O(n) extra space
      variants:
        - id: v1
          title: First Duplicate Index
          description: Write <code>func firstDupIdx(nums []int) int</code> - index of first repeat, or -1.
          functionSignature: func firstDupIdx(nums []int) int
          testCases:
            - input: "[]int{1,2,3,2}"
              output: "3"
          hints:
            - title: ðŸ¤” Think about it
              content: >-
                You want to find the first element that appears twice. As you go through, how do you know if you've seen
                something before?
            - title: ðŸ’¡ Hint
              content: >-
                Use a map as a 'seen' set. For each element, first check if it's in the map - if yes, you found a
                duplicate! If no, add it to the map and continue.
            - title: ðŸ”§ Pattern
              content: |-
                <pre>1. Create empty "seen" tracker
                2. For each element:
                   - Already seen? â†’ return (found duplicate!)
                   - Not seen? â†’ add to tracker
                3. Loop finished? â†’ return not found</pre>
          solution: |-
            func firstDupIdx(nums []int) int {
                seen := make(map[int]bool)
                for i, n := range nums {
                    if seen[n] { return i }
                    seen[n] = true
                }
                return -1
            }
          difficulty: 2
        - id: v2
          title: First Repeat Char
          description: Write <code>func firstRepeat(s string) rune</code> - first repeated char, or 0.
          functionSignature: func firstRepeat(s string) rune
          testCases:
            - input: "\"abcab\""
              output: "'a'"
          hints:
            - title: ðŸ¤” Think about it
              content: >-
                You want to find the first element that appears twice. As you go through, how do you know if you've seen
                something before?
            - title: ðŸ’¡ Hint
              content: >-
                Use a map as a 'seen' set. For each element, first check if it's in the map - if yes, you found a
                duplicate! If no, add it to the map and continue.
            - title: ðŸ”§ Pattern
              content: |-
                <pre>1. Create empty "seen" tracker
                2. For each element:
                   - Already seen? â†’ return (found duplicate!)
                   - Not seen? â†’ add to tracker
                3. Loop finished? â†’ return not found</pre>
          solution: |-
            func firstRepeat(s string) rune {
                seen := make(map[rune]bool)
                for _, r := range s {
                    if seen[r] { return r }
                    seen[r] = true
                }
                return 0
            }
          difficulty: 2
        - id: v3
          title: Find Missing in Sequence
          description: Write <code>func findMissing(nums []int, n int) int</code> - given numbers 1 to n with one missing, find it.
          functionSignature: func findMissing(nums []int, n int) int
          testCases:
            - input: "[]int{1,2,4,5}, 5"
              output: "3"
              note: 3 is missing from 1-5
            - input: "[]int{2,3,4}, 4"
              output: "1"
          hints:
            - title: ðŸ¤” Think about it
              content: Put all the numbers you have into a set. Then check which number from 1 to n is not in the set.
            - title: ðŸ’¡ Hint
              content: "First loop: add all nums to a map. Second loop: check 1 to n, return the one not in the map."
            - title: ðŸ”§ Pattern
              content: |-
                <pre>1. Add all nums to a 'have' map
                2. For i from 1 to n:
                   - If !have[i] â†’ return i (found missing!)
                3. Return 0 (shouldn't happen)</pre>
          solution: |-
            func findMissing(nums []int, n int) int {
                have := make(map[int]bool)
                for _, num := range nums { have[num] = true }
                for i := 1; i <= n; i++ {
                    if !have[i] { return i }
                }
                return 0
            }
          difficulty: 3
        - id: v4
          title: Two Sum Exists
          description: Write <code>func twoSumExists(nums []int, target int) bool</code> - true if any two numbers add to target.
          functionSignature: func twoSumExists(nums []int, target int) bool
          testCases:
            - input: "[]int{2, 7, 11, 15}, 9"
              output: "true"
            - input: "[]int{2, 7, 11, 15}, 10"
              output: "false"
          hints:
            - title: ðŸ¤” Think about it
              content: >-
                For each number, what complement would you need to see to make the target sum? How can you check if
                you've seen that complement?
            - title: ðŸ’¡ Hint
              content: >-
                For each num, check if (target - num) is in your 'seen' set. If yes, you found a pair! If no, add num to
                seen and continue.
            - title: ðŸ”§ Pattern
              content: |-
                <pre>1. Create empty "seen" map
                2. For each num:
                   - complement = target - num
                   - seen[complement]? â†’ return true
                   - Add num to seen
                3. Return false</pre>
          solution: |-
            func twoSumExists(nums []int, target int) bool {
                seen := make(map[int]bool)
                for _, n := range nums {
                    if seen[target-n] { return true }
                    seen[n] = true
                }
                return false
            }
          difficulty: 3
        - id: v5
          title: All Unique Words
          description: Write <code>func allUnique(words []string) bool</code> - true if no word appears twice.
          functionSignature: func allUnique(words []string) bool
          testCases:
            - input: "[]string{\"go\", \"rust\", \"python\"}"
              output: "true"
            - input: "[]string{\"go\", \"rust\", \"go\"}"
              output: "false"
          hints:
            - title: ðŸ¤” Think about it
              content: This is the inverse of 'has duplicate'. When should you return false?
            - title: ðŸ’¡ Hint
              content: >-
                Use a map to track seen words. If you ever encounter a word you've already seen, return false. If you
                finish the loop, return true.
            - title: ðŸ”§ Pattern
              content: |-
                <pre>1. Create empty "seen" map
                2. For each word:
                   - Already seen? â†’ return false
                   - Add to seen
                3. Return true (all unique)</pre>
          solution: |-
            func allUnique(words []string) bool {
                seen := make(map[string]bool)
                for _, w := range words {
                    if seen[w] { return false }
                    seen[w] = true
                }
                return true
            }
          difficulty: 2
        - id: v6
          title: First Non-Repeating
          description: >-
            Write <code>func firstNonRepeating(s string) rune</code> - first character that appears exactly once, or 0
            if all repeat.
          functionSignature: func firstNonRepeating(s string) rune
          testCases:
            - input: "\"aabbccd\""
              output: "'d'"
            - input: "\"aabbcc\""
              output: "0"
          hints:
            - title: ðŸ¤” Think about it
              content: "You need TWO passes: first count all characters, then find the first one with count == 1."
            - title: ðŸ’¡ Hint
              content: >-
                First pass: build a frequency map. Second pass: iterate through string again and return the first char
                with count == 1.
            - title: ðŸ”§ Pattern
              content: |-
                <pre>1. First pass: count each character
                2. Second pass: for each character
                   - Count == 1? â†’ return it
                3. Return 0 (none found)</pre>
          solution: |-
            func firstNonRepeating(s string) rune {
                counts := make(map[rune]int)
                for _, r := range s { counts[r]++ }
                for _, r := range s {
                    if counts[r] == 1 { return r }
                }
                return 0
            }
          difficulty: 3
        - id: v7
          title: Contains Value
          difficulty: 1
          description: >-
            Write <code>func containsValue(nums []int, target int) bool</code> that returns true if target exists in the
            slice. Use a map for O(n) solution.
          functionSignature: func containsValue(nums []int, target int) bool
          testCases:
            - input: "[]int{1, 2, 3, 4, 5}, 3"
              output: "true"
            - input: "[]int{1, 2, 3, 4, 5}, 6"
              output: "false"
          hints:
            - title: ðŸ¤” Think about it
              content: >-
                You could use linear search, but this pattern is about using maps. How can a map help you check
                membership quickly?
            - title: ðŸ’¡ Hint
              content: >-
                Build a map[int]bool to track which numbers exist. Then check if target is in the map using the comma-ok
                pattern.
            - title: ðŸ”§ Pattern
              content: |-
                <pre>1. Create set map[int]bool
                2. For each num: set[num] = true
                3. Return set[target] exists</pre>
          solution: |-
            func containsValue(nums []int, target int) bool {
                seen := make(map[int]bool)
                for _, n := range nums {
                    seen[n] = true
                }
                return seen[target]
            }
        - id: v8
          title: Count Unique
          difficulty: 1
          description: >-
            Write <code>func countUnique(nums []int) int</code> that returns how many unique/distinct numbers exist in
            the slice.
          functionSignature: func countUnique(nums []int) int
          testCases:
            - input: "[]int{1, 2, 2, 3, 3, 3}"
              output: "3"
              note: "Three unique values: 1, 2, 3"
            - input: "[]int{5, 5, 5}"
              output: "1"
          hints:
            - title: ðŸ¤” Think about it
              content: Maps automatically deduplicate! What property of a map tells you how many unique keys it has?
            - title: ðŸ’¡ Hint
              content: Add all numbers to a map[int]bool as keys. The map will only keep unique keys. Return len(map).
            - title: ðŸ”§ Pattern
              content: |-
                <pre>1. Create set map[int]bool
                2. For each num: set[num] = true
                3. Return len(set)</pre>
          solution: |-
            func countUnique(nums []int) int {
                seen := make(map[int]bool)
                for _, n := range nums {
                    seen[n] = true
                }
                return len(seen)
            }
        - id: v9
          title: Employee ID Lookup
          description: >-
            Write <code>func employeeName(ids map[int]string, id int) string</code> that returns employee name or
            "Unknown".
          functionSignature: func employeeName(ids map[int]string, id int) string
          testCases:
            - input: "map[int]string{101: \"Alice\", 102: \"Bob\"}, 101"
              output: "\"Alice\""
            - input: "map[int]string{101: \"Alice\"}, 999"
              output: "\"Unknown\""
          hints:
            - title: ðŸ¤” Think about it
              content: Use comma-ok idiom to check if ID exists in map.
            - title: ðŸ’¡ Hint
              content: name, exists := ids[id]; if exists return name, else return "Unknown"
            - title: ðŸ”§ Pattern
              content: |-
                <pre>1. name, exists := ids[id]
                2. If exists â†’ return name
                3. Return "Unknown"</pre>
          solution: |-
            func employeeName(ids map[int]string, id int) string {
                if name, exists := ids[id]; exists {
                    return name
                }
                return "Unknown"
            }
          difficulty: 2
        - id: v10
          title: Country Capital
          description: >-
            Write <code>func getCapital(capitals map[string]string, country string) (string, bool)</code> that returns
            capital and whether found.
          functionSignature: func getCapital(capitals map[string]string, country string) (string, bool)
          testCases:
            - input: "map[string]string{\"USA\": \"Washington DC\", \"France\": \"Paris\"}, \"France\""
              output: "\"Paris\", true"
            - input: "map[string]string{\"USA\": \"Washington DC\"}, \"Spain\""
              output: "\"\", false"
          hints:
            - title: ðŸ¤” Think about it
              content: This is a direct map lookup with comma-ok pattern - return both value and existence.
            - title: ðŸ’¡ Hint
              content: capital, exists := capitals[country]; return capital, exists
            - title: ðŸ”§ Pattern
              content: |-
                <pre>capital, exists := capitals[country]
                return capital, exists</pre>
          solution: |-
            func getCapital(capitals map[string]string, country string) (string, bool) {
                capital, exists := capitals[country]
                return capital, exists
            }
          difficulty: 1
        - id: v1
          title: Two Sum
          description: >-
            Given a slice of ints and a target, return indices of two numbers that add up to the target. <code>func
            twoSum(nums []int, target int) []int</code>
          functionSignature: func twoSum(nums []int, target int) []int
          testCases:
            - input: "[]int{2, 7, 11, 15}, 9"
              output: "[0, 1]"
            - input: "[]int{3, 2, 4}, 6"
              output: "[1, 2]"
            - input: "[]int{3, 3}, 6"
              output: "[0, 1]"
          solution: |-
            func twoSum(nums []int, target int) []int {
                seen := make(map[int]int)
                for i, num := range nums {
                    complement := target - num
                    if j, ok := seen[complement]; ok {
                        return []int{j, i}
                    }
                    seen[num] = i
                }
                return nil
            }
          difficulty: 4
        - id: v2
          title: Two Sum II (Sorted Input)
          description: >-
            Given a <strong>sorted</strong> array and target, return indices (1-indexed) of two numbers that add to
            target. Use two pointers instead of a hash map. <code>func twoSumSorted(nums []int, target int) []int</code>
          functionSignature: func twoSumSorted(nums []int, target int) []int
          testCases:
            - input: "[]int{2, 7, 11, 15}, 9"
              output: "[1, 2]"
              note: 1-indexed!
            - input: "[]int{2, 3, 4}, 6"
              output: "[1, 3]"
            - input: "[]int{-1, 0}, -1"
              output: "[1, 2]"
          solution: |-
            func twoSumSorted(nums []int, target int) []int {
                left, right := 0, len(nums)-1
                
                for left < right {
                    sum := nums[left] + nums[right]
                    if sum == target {
                        return []int{left + 1, right + 1}
                    } else if sum < target {
                        left++
                    } else {
                        right--
                    }
                }
                return nil
            }
          solutionNotes: >-
            When input is sorted, two pointers is O(1) space vs O(n) for hash map. Move left pointer right for larger
            sum, right pointer left for smaller sum.
          difficulty: 4
        - id: v3
          title: Pair with Difference
          description: >-
            Find two numbers whose <strong>difference</strong> equals the target. Return their indices (smaller index
            first). <code>func pairWithDiff(nums []int, target int) []int</code>
          functionSignature: func pairWithDiff(nums []int, target int) []int
          testCases:
            - input: "[]int{5, 20, 3, 2, 50, 80}, 78"
              output: "[1, 5]"
              note: 80 - 2 = 78... wait
            - input: "[]int{1, 5, 3}, 2"
              output: "[0, 2]"
              note: 3 - 1 = 2
            - input: "[]int{1, 2, 3}, 10"
              output: nil
          solution: |-
            func pairWithDiff(nums []int, target int) []int {
                seen := make(map[int]int)
                
                for i, num := range nums {
                    if j, ok := seen[num-target]; ok {
                        return []int{j, i}
                    }
                    if j, ok := seen[num+target]; ok {
                        return []int{j, i}
                    }
                    seen[num] = i
                }
                return nil
            }
          solutionNotes: >-
            Unlike Two Sum where we look for target-num, here we look for BOTH num-target AND num+target because either
            could be the pair (a-b=k or b-a=k).
          difficulty: 4
        - id: v4
          title: Count Pairs with Sum
          description: >-
            Count how many pairs of numbers add up to exactly the target. Each element can only be used once. <code>func
            countPairs(nums []int, target int) int</code>
          functionSignature: func countPairs(nums []int, target int) int
          testCases:
            - input: "[]int{1, 5, 7, 1}, 6"
              output: "2"
              note: (1,5) and (1,5)
            - input: "[]int{1, 1, 1, 1}, 2"
              output: "2"
              note: two pairs of 1+1
            - input: "[]int{1, 2, 3}, 10"
              output: "0"
          solution: |-
            func countPairs(nums []int, target int) int {
                counts := make(map[int]int)
                for _, num := range nums {
                    counts[num]++
                }
                
                pairs := 0
                for num, count := range counts {
                    complement := target - num
                    if complement == num {
                        pairs += count * (count - 1) / 2
                    } else if compCount, ok := counts[complement]; ok && complement > num {
                        pairs += count * compCount
                    }
                }
                return pairs
            }
          solutionNotes: >-
            This is trickier! We count occurrences first, then for each unique number, find pairs. Handle same-number
            pairs specially (n choose 2). Use complement > num to avoid double counting.
          difficulty: 4
        - id: v5
          title: Three Sum Exists
          description: >-
            Return <code>true</code> if any three numbers in the array sum to zero. <code>func threeSumExists(nums
            []int) bool</code>
          functionSignature: func threeSumExists(nums []int) bool
          testCases:
            - input: "[]int{-1, 0, 1, 2}"
              output: "true"
              note: "-1 + 0 + 1 = 0"
            - input: "[]int{1, 2, 3}"
              output: "false"
            - input: "[]int{0, 0, 0}"
              output: "true"
          solution: |-
            import "sort"

            func threeSumExists(nums []int) bool {
                sort.Ints(nums)
                n := len(nums)
                
                for i := 0; i < n-2; i++ {
                    if i > 0 && nums[i] == nums[i-1] {
                        continue
                    }
                    
                    left, right := i+1, n-1
                    target := -nums[i]
                    
                    for left < right {
                        sum := nums[left] + nums[right]
                        if sum == target {
                            return true
                        } else if sum < target {
                            left++
                        } else {
                            right--
                        }
                    }
                }
                return false
            }
          solutionNotes: >-
            Fix one number, then use Two Sum II (sorted) for the other two. Sorting first enables the two-pointer
            approach. O(nÂ²) total.
          difficulty: 4
        - id: v6
          title: Subarray Sum Equals K
          description: >-
            Count the number of continuous subarrays whose elements sum to k. <code>func subarraySum(nums []int, k int)
            int</code>
          functionSignature: func subarraySum(nums []int, k int) int
          testCases:
            - input: "[]int{1, 1, 1}, 2"
              output: "2"
              note: "[1,1] at positions 0-1 and 1-2"
            - input: "[]int{1, 2, 3}, 3"
              output: "2"
              note: "[1,2] and [3]"
            - input: "[]int{1, -1, 0}, 0"
              output: "3"
          solution: |-
            func subarraySum(nums []int, k int) int {
                count := 0
                prefixSum := 0
                seen := make(map[int]int)
                seen[0] = 1
                
                for _, num := range nums {
                    prefixSum += num
                    if c, ok := seen[prefixSum-k]; ok {
                        count += c
                    }
                    seen[prefixSum]++
                }
                return count
            }
          solutionNotes: >-
            This uses the prefix sum technique with a hash map. If prefix[j] - prefix[i] = k, then subarray [i+1...j]
            sums to k. We track how many times each prefix sum has occurred.
          difficulty: 4
    - id: challenge_12
      block: 1
      difficulty: 1
      concept: Simple Tallying
      docLinks:
        - url: https://go.dev/blog/maps
          title: "Go Blog: Go maps in action"
          note: intro to maps
      patternPrimer:
        bruteForce: Loop through and increment a counter when condition matches.
        bestApproach: Same approach - single pass counting is already optimal.
        typical: Typically O(n) time, O(1) extra space
      variants:
        - id: v1
          title: Count Specific Value
          description: Write <code>func countValue(nums []int, target int) int</code> that counts how many times target appears.
          functionSignature: func countValue(nums []int, target int) int
          testCases:
            - input: "[]int{1, 2, 2, 3, 2}, 2"
              output: "3"
            - input: "[]int{5, 5, 5}, 5"
              output: "3"
          hints:
            - title: ðŸ¤” Think about it
              content: Start with count = 0. Each time you see the target, increment count.
            - title: ðŸ’¡ Hint
              content: Loop through the slice. If element == target, do count++.
            - title: ðŸ”§ Pattern
              content: |-
                <pre>1. count := 0
                2. For each element:
                   - element == target? â†’ count++
                3. Return count</pre>
          solution: |-
            func countValue(nums []int, target int) int {
                count := 0
                for _, n := range nums {
                    if n == target { count++ }
                }
                return count
            }
          difficulty: 1
        - id: v2
          title: Track Seen Values
          description: >-
            Write <code>func trackSeen(nums []int) map[int]bool</code> that returns a map marking which values were
            seen.
          functionSignature: func trackSeen(nums []int) map[int]bool
          testCases:
            - input: "[]int{1, 2, 2, 3}"
              output: map[1:true 2:true 3:true]
            - input: "[]int{5, 5}"
              output: map[5:true]
          hints:
            - title: ðŸ¤” Think about it
              content: Create a map, then mark each number as seen (true).
            - title: ðŸ’¡ Hint
              content: For each number, set seen[num] = true. Maps automatically handle duplicates.
            - title: ðŸ”§ Pattern
              content: |-
                <pre>1. Create map[int]bool
                2. For each num:
                   - seen[num] = true
                3. Return map</pre>
          solution: |-
            func trackSeen(nums []int) map[int]bool {
                seen := make(map[int]bool)
                for _, n := range nums { seen[n] = true }
                return seen
            }
          difficulty: 2
        - id: v3
          title: Count True Values
          description: Write <code>func countTrue(flags []bool) int</code> that counts how many true values are in the slice.
          functionSignature: func countTrue(flags []bool) int
          testCases:
            - input: "[]bool{true, false, true, true}"
              output: "3"
            - input: "[]bool{false, false}"
              output: "0"
          hints:
            - title: ðŸ¤” Think about it
              content: Same as counting any specific value - count when you see true.
            - title: ðŸ’¡ Hint
              content: if flag { count++ }
            - title: ðŸ”§ Pattern
              content: |-
                <pre>1. count := 0
                2. For each flag:
                   - flag == true? â†’ count++
                3. Return count</pre>
          solution: |-
            func countTrue(flags []bool) int {
                count := 0
                for _, f := range flags {
                    if f { count++ }
                }
                return count
            }
          difficulty: 1
        - id: v4
          title: Tally by Type
          description: >-
            Write <code>func tallyTypes(words []string) map[string]int</code> that counts how many of each word type.
            Simple tallying intro!
          functionSignature: func tallyTypes(words []string) map[string]int
          testCases:
            - input: "[]string{\"cat\", \"dog\", \"cat\", \"bird\"}"
              output: map[cat:2 dog:1 bird:1]
          hints:
            - title: ðŸ¤” Think about it
              content: For each word, increment its count in the map. Maps default to 0 when accessing non-existent keys.
            - title: ðŸ’¡ Hint
              content: counts[word]++ works even if word isn't in the map yet (starts at 0).
            - title: ðŸ”§ Pattern
              content: |-
                <pre>1. Create map[string]int
                2. For each word:
                   - counts[word]++
                3. Return map</pre>
          solution: |-
            func tallyTypes(words []string) map[string]int {
                counts := make(map[string]int)
                for _, w := range words { counts[w]++ }
                return counts
            }
          difficulty: 2
        - id: v5
          title: Count Vowels and Consonants
          description: >-
            Write <code>func countVowelsConsonants(s string) (int, int)</code> that returns vowel count and consonant
            count.
          functionSignature: func countVowelsConsonants(s string) (int, int)
          testCases:
            - input: "\"hello\""
              output: 2, 3
              note: e,o are vowels; h,l,l are consonants
            - input: "\"aaa\""
              output: 3, 0
          hints:
            - title: ðŸ¤” Think about it
              content: Check if each character is a vowel (a,e,i,o,u). Count separately.
            - title: ðŸ’¡ Hint
              content: "Create a helper check: isVowel := char == 'a' || char == 'e' || ..."
            - title: ðŸ”§ Pattern
              content: |-
                <pre>1. vowels, consonants := 0, 0
                2. For each char:
                   - Is vowel? â†’ vowels++
                   - Else â†’ consonants++
                3. Return both</pre>
          solution: |-
            func countVowelsConsonants(s string) (int, int) {
                vowels, consonants := 0, 0
                for _, r := range s {
                    lower := strings.ToLower(string(r))
                    if lower == "a" || lower == "e" || lower == "i" || lower == "o" || lower == "u" {
                        vowels++
                    } else {
                        consonants++
                    }
                }
                return vowels, consonants
            }
          difficulty: 2
        - id: v6
          title: Has Value
          description: Write <code>func hasValue(nums []int, target int) bool</code> that returns true if target is in the slice.
          functionSignature: func hasValue(nums []int, target int) bool
          testCases:
            - input: "[]int{1, 2, 3}, 2"
              output: "true"
            - input: "[]int{1, 2, 3}, 5"
              output: "false"
          hints:
            - title: ðŸ¤” Think about it
              content: As soon as you find target, return true. If loop finishes, return false.
            - title: ðŸ’¡ Hint
              content: This is early return pattern - return as soon as found.
            - title: ðŸ”§ Pattern
              content: |-
                <pre>1. For each num:
                   - num == target? â†’ return true
                2. Return false (not found)</pre>
          solution: |-
            func hasValue(nums []int, target int) bool {
                for _, n := range nums {
                    if n == target { return true }
                }
                return false
            }
          difficulty: 1
        - id: v7
          title: Count Even Numbers
          description: Write <code>func countEvens(nums []int) int</code> that counts how many even numbers are in the slice.
          functionSignature: func countEvens(nums []int) int
          testCases:
            - input: "[]int{1, 2, 3, 4, 5, 6}"
              output: "3"
            - input: "[]int{1, 3, 5}"
              output: "0"
          hints:
            - title: ðŸ¤” Think about it
              content: A number is even if num % 2 == 0. Count how many satisfy this condition.
            - title: ðŸ’¡ Hint
              content: Loop through, increment counter when num % 2 == 0.
            - title: ðŸ”§ Pattern
              content: |-
                <pre>1. count := 0
                2. For each num:
                   - num % 2 == 0? â†’ count++
                3. Return count</pre>
          solution: |-
            func countEvens(nums []int) int {
                count := 0
                for _, n := range nums {
                    if n % 2 == 0 { count++ }
                }
                return count
            }
          difficulty: 1
        - id: v8
          title: Passing Grades
          description: Write <code>func passingGrades(grades []int) int</code> that counts how many grades are 60 or above.
          functionSignature: func passingGrades(grades []int) int
          testCases:
            - input: "[]int{85, 55, 90, 45, 70}"
              output: "3"
            - input: "[]int{30, 40, 50}"
              output: "0"
          hints:
            - title: ðŸ¤” Think about it
              content: Count grades that are >= 60.
            - title: ðŸ’¡ Hint
              content: "Simple counter: if grade >= 60, increment count."
            - title: ðŸ”§ Pattern
              content: |-
                <pre>1. count := 0
                2. For each grade:
                   - grade >= 60? â†’ count++
                3. Return count</pre>
          solution: |-
            func passingGrades(grades []int) int {
                count := 0
                for _, g := range grades {
                    if g >= 60 { count++ }
                }
                return count
            }
          difficulty: 1
        - id: v9
          title: Inventory Below Threshold
          description: >-
            Write <code>func lowStock(inventory map[string]int, threshold int) []string</code> that returns item names
            with stock below threshold.
          functionSignature: func lowStock(inventory map[string]int, threshold int) []string
          testCases:
            - input: "map[string]int{\"apples\": 5, \"oranges\": 15, \"bananas\": 3}, 10"
              output: "[\"apples\", \"bananas\"]"
            - input: "map[string]int{\"pens\": 100, \"paper\": 200}, 50"
              output: "[]"
          hints:
            - title: ðŸ¤” Think about it
              content: Loop through the map, collect items where count < threshold.
            - title: ðŸ’¡ Hint
              content: For each key-value pair, if value < threshold, append key to result slice.
            - title: ðŸ”§ Pattern
              content: |-
                <pre>1. result := []string{}
                2. For item, count in inventory:
                   - count < threshold?
                     â†’ append item to result
                3. Return result</pre>
          solution: |-
            func lowStock(inventory map[string]int, threshold int) []string {
                result := []string{}
                for item, count := range inventory {
                    if count < threshold {
                        result = append(result, item)
                    }
                }
                return result
            }
          difficulty: 2
        - id: v10
          title: Group By First Letter
          description: >-
            Write <code>func groupByFirstLetter(words []string) map[rune][]string</code> that groups words by their
            first letter. Returns a map where keys are first letters and values are slices of all words starting with
            that letter.
          functionSignature: func groupByFirstLetter(words []string) map[rune][]string
          testCases:
            - input: "[\"go\", \"rust\", \"ruby\", \"python\", \"perl\"]"
              output: map['g':["go"] 'r':["rust", "ruby"] 'p':["python", "perl"]]
            - input: "[\"apple\", \"ant\", \"bat\", \"bear\"]"
              output: map['a':["apple", "ant"] 'b':["bat", "bear"]]
          hints:
            - title: ðŸ¤” Think about it
              content: >-
                You need to build a map where each key points to a slice. For each word, get its first letter and append
                the word to that letter's slice.
            - title: ðŸ’¡ Hint
              content: >-
                Create map[rune][]string. For each word, get first letter with rune(word[0]). Append word to
                groups[firstLetter]. If the slice doesn't exist yet, append creates it.
            - title: ðŸ”§ Pattern
              content: |-
                <pre>1. Create map[rune][]string
                2. For each word:
                   - Get first letter: rune(word[0])
                   - Append word to map[firstLetter]
                3. Return map</pre>
          solution: |-
            func groupByFirstLetter(words []string) map[rune][]string {
                groups := make(map[rune][]string)
                for _, word := range words {
                    if len(word) > 0 {
                        firstLetter := rune(word[0])
                        groups[firstLetter] = append(groups[firstLetter], word)
                    }
                }
                return groups
            }
          difficulty: 3
        - id: v11
          title: Frequency Sorted Keys
          description: >-
            Write <code>func frequencySortedKeys(items []string) []string</code> that returns unique items sorted by
            frequency (most common first). If frequencies are tied, maintain the order items were first seen.
          functionSignature: func frequencySortedKeys(items []string) []string
          testCases:
            - input: "[\"cat\", \"dog\", \"cat\", \"bird\", \"cat\", \"dog\"]"
              output: "[\"cat\", \"dog\", \"bird\"]"
              note: cat appears 3x, dog 2x, bird 1x
            - input: "[\"a\", \"b\", \"a\", \"c\", \"a\", \"b\"]"
              output: "[\"a\", \"b\", \"c\"]"
          hints:
            - title: ðŸ¤” Think about it
              content: >-
                First build a frequency map to count occurrences. Then you need to create a result by iterating through
                unique items and sorting by their frequency. Track the order items first appeared.
            - title: ðŸ’¡ Hint
              content: >-
                Build two things: a frequency map and a list of unique items in order seen. Then sort the unique list by
                looking up frequencies. Use a simple comparison to sort.
            - title: ðŸ”§ Pattern
              content: |-
                <pre>1. Build frequency map
                2. Track unique items in order
                3. Sort unique items by frequency
                   (most frequent first)
                4. Return sorted list</pre>
          solution: |-
            func frequencySortedKeys(items []string) []string {
                freq := make(map[string]int)
                var order []string
                seen := make(map[string]bool)
                
                for _, item := range items {
                    freq[item]++
                    if !seen[item] {
                        order = append(order, item)
                        seen[item] = true
                    }
                }
                
                // Simple bubble sort by frequency
                for i := 0; i < len(order); i++ {
                    for j := i + 1; j < len(order); j++ {
                        if freq[order[j]] > freq[order[i]] {
                            order[i], order[j] = order[j], order[i]
                        }
                    }
                }
                
                return order
            }
          difficulty: 3
        - id: v12
          title: Count Multi-Condition
          description: >-
            Write <code>func countMultiCondition(nums []int, min, max, divisor int) map[string]int</code> that
            categorizes numbers into four groups: "in_range" (min <= n <= max), "divisible" (n % divisor == 0), "both"
            (satisfies both conditions), and "neither".
          functionSignature: func countMultiCondition(nums []int, min, max, divisor int) map[string]int
          testCases:
            - input: "[]int{5, 10, 15, 20}, 10, 20, 5"
              output: map["in_range":3 "divisible":4 "both":3 "neither":0]
              note: 10,15,20 in range; all divisible by 5; 10,15,20 satisfy both; 5 satisfies neither
            - input: "[]int{1, 2, 3}, 5, 10, 2"
              output: map["in_range":0 "divisible":1 "both":0 "neither":2]
          hints:
            - title: ðŸ¤” Think about it
              content: >-
                For each number, check both conditions independently. Count how many satisfy: just range, just
                divisible, both, or neither. All four counts are independent.
            - title: ðŸ’¡ Hint
              content: >-
                Create a map with 4 keys initialized to 0. For each number, check inRange := (n >= min && n <= max) and
                isDivisible := (n % divisor == 0). Then increment the appropriate counters.
            - title: ðŸ”§ Pattern
              content: |-
                <pre>1. Create map with 4 categories = 0
                2. For each num:
                   - Check if in range
                   - Check if divisible
                   - Increment all matching categories
                3. Return map</pre>
          solution: |-
            func countMultiCondition(nums []int, min, max, divisor int) map[string]int {
                counts := map[string]int{"in_range": 0, "divisible": 0, "both": 0, "neither": 0}
                
                for _, n := range nums {
                    inRange := n >= min && n <= max
                    isDivisible := n % divisor == 0
                    
                    if inRange {
                        counts["in_range"]++
                    }
                    if isDivisible {
                        counts["divisible"]++
                    }
                    if inRange && isDivisible {
                        counts["both"]++
                    }
                    if !inRange && !isDivisible {
                        counts["neither"]++
                    }
                }
                
                return counts
            }
          difficulty: 3
        - id: v13
          title: Tally By Category
          description: >-
            Write <code>func tallyByCategory(items []string, categories map[string]string) map[string]int</code> that
            counts items per category. Given items and a map of itemâ†’category, return count of items per category.
          functionSignature: func tallyByCategory(items []string, categories map[string]string) map[string]int
          testCases:
            - input: >-
                ["apple", "banana", "carrot", "broccoli"], map["apple":"fruit", "banana":"fruit", "carrot":"veggie",
                "broccoli":"veggie"]
              output: map["fruit":2 "veggie":2]
            - input: "[\"a\", \"b\", \"c\"], map[\"a\":\"x\", \"b\":\"x\", \"c\":\"y\"]"
              output: map["x":2 "y":1]
          hints:
            - title: ðŸ¤” Think about it
              content: >-
                For each item, look up its category in the categories map, then increment that category's count in your
                result map.
            - title: ðŸ’¡ Hint
              content: >-
                Create a result map for counting. For each item, get category := categories[item], then do
                counts[category]++. The map lookup gives you the indirect key to increment.
            - title: ðŸ”§ Pattern
              content: |-
                <pre>1. Create counts map[string]int
                2. For each item:
                   - Look up category from categories map
                   - Increment counts[category]
                3. Return counts</pre>
          solution: |-
            func tallyByCategory(items []string, categories map[string]string) map[string]int {
                counts := make(map[string]int)
                for _, item := range items {
                    category := categories[item]
                    counts[category]++
                }
                return counts
            }
          difficulty: 3
    - id: challenge_13
      block: 1
      difficulty: 1
      concept: Basic Swap Operations
      docLinks:
        - url: https://go.dev/ref/spec#Assignments
          title: "Go Spec: Assignments"
          note: simultaneous assignment
      patternPrimer:
        bruteForce: "Use a temp variable: temp = a, a = b, b = temp (works but verbose)."
        bestApproach: "Go's simultaneous assignment: a, b = b, a (cleaner, evaluates right side first)."
        typical: Typically O(1) time, O(1) extra space
      variants:
        - id: v1
          title: Swap Two Variables
          description: Write <code>func swapVars(a, b int) (int, int)</code> that returns the values swapped.
          functionSignature: func swapVars(a, b int) (int, int)
          testCases:
            - input: 3, 7
              output: 7, 3
            - input: 10, 20
              output: 20, 10
          hints:
            - title: ðŸ¤” Think about it
              content: Go's simultaneous assignment makes this trivial.
            - title: ðŸ’¡ Hint
              content: return b, a - just return them in opposite order!
            - title: ðŸ”§ Pattern
              content: <pre>return b, a</pre>
          solution: |-
            func swapVars(a, b int) (int, int) {
                return b, a
            }
          difficulty: 1
        - id: v2
          title: Swap First Two Elements
          description: >-
            Write <code>func swapFirstTwo(nums []int)</code> that swaps the first two elements in place. Assume at least
            2 elements.
          functionSignature: func swapFirstTwo(nums []int)
          testCases:
            - input: "[]int{1, 2, 3}"
              output: "[2, 1, 3]"
            - input: "[]int{5, 10}"
              output: "[10, 5]"
          hints:
            - title: ðŸ¤” Think about it
              content: Use simultaneous assignment on slice indices.
            - title: ðŸ’¡ Hint
              content: nums[0], nums[1] = nums[1], nums[0]
            - title: ðŸ”§ Pattern
              content: <pre>nums[0], nums[1] = nums[1], nums[0]</pre>
          solution: |-
            func swapFirstTwo(nums []int) {
                nums[0], nums[1] = nums[1], nums[0]
            }
          difficulty: 1
        - id: v3
          title: Swap Ends
          description: Write <code>func swapEnds(nums []int)</code> that swaps first and last elements.
          functionSignature: func swapEnds(nums []int)
          testCases:
            - input: "[]int{1, 2, 3, 4}"
              output: "[4, 2, 3, 1]"
            - input: "[]int{5, 10}"
              output: "[10, 5]"
          hints:
            - title: ðŸ¤” Think about it
              content: Last element is at index len(nums)-1.
            - title: ðŸ’¡ Hint
              content: Swap nums[0] with nums[len(nums)-1].
            - title: ðŸ”§ Pattern
              content: <pre>nums[0], nums[len(nums)-1] = nums[len(nums)-1], nums[0]</pre>
          solution: |-
            func swapEnds(nums []int) {
                nums[0], nums[len(nums)-1] = nums[len(nums)-1], nums[0]
            }
          difficulty: 1
        - id: v4
          title: Swap at Indices
          description: Write <code>func swapAt(nums []int, i, j int)</code> that swaps elements at positions i and j.
          functionSignature: func swapAt(nums []int, i, j int)
          testCases:
            - input: "[]int{1, 2, 3, 4}, 0, 2"
              output: "[3, 2, 1, 4]"
            - input: "[]int{5, 10, 15}, 1, 2"
              output: "[5, 15, 10]"
          hints:
            - title: ðŸ¤” Think about it
              content: Just swap the elements at the given indices.
            - title: ðŸ’¡ Hint
              content: nums[i], nums[j] = nums[j], nums[i]
            - title: ðŸ”§ Pattern
              content: <pre>nums[i], nums[j] = nums[j], nums[i]</pre>
          solution: |-
            func swapAt(nums []int, i, j int) {
                nums[i], nums[j] = nums[j], nums[i]
            }
          difficulty: 1
        - id: v5
          title: Swap String Parts
          description: Write <code>func swapStrings(a, b string) (string, string)</code> that swaps two strings.
          functionSignature: func swapStrings(a, b string) (string, string)
          testCases:
            - input: "\"hello\", \"world\""
              output: "\"world\", \"hello\""
            - input: "\"go\", \"rust\""
              output: "\"rust\", \"go\""
          hints:
            - title: ðŸ¤” Think about it
              content: Same as swapping ints - just return in opposite order.
            - title: ðŸ’¡ Hint
              content: return b, a
            - title: ðŸ”§ Pattern
              content: <pre>return b, a</pre>
          solution: |-
            func swapStrings(a, b string) (string, string) {
                return b, a
            }
          difficulty: 2
        - id: v6
          title: Conditional Swap
          description: >-
            Write <code>func swapIfGreater(a, b int) (int, int)</code> that swaps only if a > b, ensuring smaller comes
            first.
          functionSignature: func swapIfGreater(a, b int) (int, int)
          testCases:
            - input: 5, 2
              output: 2, 5
              note: 5 > 2, so swap
            - input: 3, 7
              output: 3, 7
              note: 3 < 7, no swap
          hints:
            - title: ðŸ¤” Think about it
              content: Check if a > b. If so, swap. Else, leave as-is.
            - title: ðŸ’¡ Hint
              content: if a > b { return b, a } else { return a, b }
            - title: ðŸ”§ Pattern
              content: |-
                <pre>if a > b {
                    return b, a
                }
                return a, b</pre>
          solution: |-
            func swapIfGreater(a, b int) (int, int) {
                if a > b {
                    return b, a
                }
                return a, b
            }
          difficulty: 2
        - id: v7
          title: Swap Pairs
          description: Write <code>func swapPairs(nums []int)</code> that swaps adjacent pairs (0â†”1, 2â†”3, etc). Assume even length.
          functionSignature: func swapPairs(nums []int)
          testCases:
            - input: "[]int{1, 2, 3, 4}"
              output: "[2, 1, 4, 3]"
            - input: "[]int{5, 10, 15, 20}"
              output: "[10, 5, 20, 15]"
          hints:
            - title: ðŸ¤” Think about it
              content: Loop with step size 2, swapping nums[i] with nums[i+1].
            - title: ðŸ’¡ Hint
              content: for i := 0; i < len(nums); i += 2 { swap nums[i] and nums[i+1] }
            - title: ðŸ”§ Pattern
              content: |-
                <pre>1. For i = 0, 2, 4, ... (step 2):
                   - Swap nums[i] â†” nums[i+1]
                2. Done</pre>
          solution: |-
            func swapPairs(nums []int) {
                for i := 0; i < len(nums); i += 2 {
                    nums[i], nums[i+1] = nums[i+1], nums[i]
                }
            }
          difficulty: 2
        - id: v8
          title: Rotate Three
          description: "Write <code>func rotateThree(a, b, c int) (int, int, int)</code> that rotates values: aâ†’b, bâ†’c, câ†’a."
          functionSignature: func rotateThree(a, b, c int) (int, int, int)
          testCases:
            - input: 1, 2, 3
              output: 3, 1, 2
            - input: 10, 20, 30
              output: 30, 10, 20
          hints:
            - title: ðŸ¤” Think about it
              content: This is a circular rotation. Use simultaneous assignment.
            - title: ðŸ’¡ Hint
              content: "The pattern is: return c, a, b"
            - title: ðŸ”§ Pattern
              content: <pre>return c, a, b</pre>
          solution: |-
            func rotateThree(a, b, c int) (int, int, int) {
                return c, a, b
            }
          difficulty: 2
        - id: v9
          title: Swap Min and Max
          description: Write <code>func swapMinMax(nums []int)</code> that swaps the positions of minimum and maximum values.
          functionSignature: func swapMinMax(nums []int)
          testCases:
            - input: "[]int{3, 1, 4, 9, 2}"
              output: "[3, 9, 4, 1, 2]"
              note: min=1 at idx 1, max=9 at idx 3
            - input: "[]int{5, 2, 8, 2}"
              output: "[5, 8, 2, 2]"
              note: first occurrence of min
          hints:
            - title: ðŸ¤” Think about it
              content: First find indices of min and max values, then swap elements at those indices.
            - title: ðŸ’¡ Hint
              content: "Loop twice: once to find minIdx and maxIdx, then swap nums[minIdx] with nums[maxIdx]."
            - title: ðŸ”§ Pattern
              content: |-
                <pre>1. Find minIdx and maxIdx
                2. Swap nums[minIdx] â†” nums[maxIdx]
                3. Done</pre>
          solution: |-
            func swapMinMax(nums []int) {
                minIdx, maxIdx := 0, 0
                for i := range nums {
                    if nums[i] < nums[minIdx] { minIdx = i }
                    if nums[i] > nums[maxIdx] { maxIdx = i }
                }
                nums[minIdx], nums[maxIdx] = nums[maxIdx], nums[minIdx]
            }
          difficulty: 3
        - id: v10
          title: Rotate Slice Left
          description: >-
            Write <code>func rotateLeft(nums []int, k int) []int</code> that rotates the slice left by k positions. For
            example, [1,2,3,4,5] rotated left by 2 becomes [3,4,5,1,2].
          functionSignature: func rotateLeft(nums []int, k int) []int
          testCases:
            - input: "[]int{10, 20, 30, 40}, 1"
              output: "[20, 30, 40, 10]"
            - input: "[]int{1, 2, 3, 4, 5}, 2"
              output: "[3, 4, 5, 1, 2]"
          hints:
            - title: ðŸ¤” Think about it
              content: >-
                Rotating left by k means taking the first k elements and moving them to the end. You can use slice
                operations to split and recombine.
            - title: ðŸ’¡ Hint
              content: >-
                Split the slice at position k: first part is nums[:k], second part is nums[k:]. Concatenate them in
                reverse order: append(nums[k:], nums[:k]...).
            - title: ðŸ”§ Pattern
              content: |-
                <pre>1. Split at k: left = nums[:k], right = nums[k:]
                2. Concatenate: result = append(right, left...)
                3. Return result</pre>
          solution: |-
            func rotateLeft(nums []int, k int) []int {
                k = k % len(nums)
                return append(nums[k:], nums[:k]...)
            }
          difficulty: 3
        - id: v11
          title: Swap All Pairs
          description: >-
            Write <code>func swapAllPairs(nums []int) []int</code> that swaps every pair of adjacent elements. If the
            slice has odd length, the last element stays in place. For example, [1,2,3,4,5] becomes [2,1,4,3,5].
          functionSignature: func swapAllPairs(nums []int) []int
          testCases:
            - input: "[]int{10, 20, 30, 40}"
              output: "[20, 10, 40, 30]"
            - input: "[]int{1, 2, 3}"
              output: "[2, 1, 3]"
              note: last element stays
          hints:
            - title: ðŸ¤” Think about it
              content: >-
                Loop through pairs (i=0, 2, 4...) and swap each pair. Make sure to stop before going out of bounds on
                odd-length slices.
            - title: ðŸ’¡ Hint
              content: Create a copy of nums. Loop with i += 2, and swap result[i] with result[i+1] if i+1 < len(result).
            - title: ðŸ”§ Pattern
              content: |-
                <pre>1. Create copy of nums
                2. For i = 0, 2, 4, ... (step by 2):
                   - If i+1 exists:
                     â†’ swap result[i] with result[i+1]
                3. Return result</pre>
          solution: |-
            func swapAllPairs(nums []int) []int {
                result := make([]int, len(nums))
                copy(result, nums)
                
                for i := 0; i < len(result)-1; i += 2 {
                    result[i], result[i+1] = result[i+1], result[i]
                }
                
                return result
            }
          difficulty: 3
        - id: v12
          title: Bubble Sort One Pass
          description: >-
            Write <code>func bubbleSortOnePass(nums []int) []int</code> that performs one pass of bubble sort. Compare
            each pair of adjacent elements and swap if they're in wrong order. This makes the largest element "bubble"
            to the end.
          functionSignature: func bubbleSortOnePass(nums []int) []int
          testCases:
            - input: "[]int{3, 1, 4, 2}"
              output: "[1, 3, 2, 4]"
              note: after one pass, 4 bubbles to end
            - input: "[]int{5, 3, 8, 1}"
              output: "[3, 5, 1, 8]"
          hints:
            - title: ðŸ¤” Think about it
              content: >-
                Compare each adjacent pair. If left > right, swap them. After one full pass, the largest element will be
                at the end.
            - title: ðŸ’¡ Hint
              content: Create a copy. Loop through i from 0 to len-2. For each i, if result[i] > result[i+1], swap them.
            - title: ðŸ”§ Pattern
              content: |-
                <pre>1. Create copy of nums
                2. For i from 0 to len-2:
                   - result[i] > result[i+1]?
                     â†’ swap them
                3. Return result</pre>
          solution: |-
            func bubbleSortOnePass(nums []int) []int {
                result := make([]int, len(nums))
                copy(result, nums)
                
                for i := 0; i < len(result)-1; i++ {
                    if result[i] > result[i+1] {
                        result[i], result[i+1] = result[i+1], result[i]
                    }
                }
                
                return result
            }
          difficulty: 3
    - id: challenge_14
      block: 2
      difficulty: 2
      concept: Element Comparison
      docLinks:
        - url: https://go.dev/ref/spec#For_statements
          title: "Go Spec: For statements"
          note: iteration patterns
      patternPrimer:
        bruteForce: Compare adjacent elements or compare all to first element; early return on mismatch.
        bestApproach: Same approach - single pass with comparisons is already optimal.
        typical: Typically O(n) time, O(1) extra space
      variants:
        - id: v1
          title: Are Equal
          description: Write <code>func areEqual(nums []int) bool</code> that returns true if all elements are the same.
          functionSignature: func areEqual(nums []int) bool
          testCases:
            - input: "[]int{5, 5, 5}"
              output: "true"
            - input: "[]int{5, 5, 6}"
              output: "false"
          hints:
            - title: ðŸ¤” Think about it
              content: If all are equal, they all equal the first element.
            - title: ðŸ’¡ Hint
              content: Compare each element to nums[0]. If any differs, return false.
            - title: ðŸ”§ Pattern
              content: |-
                <pre>1. For each num:
                   - num != nums[0]? â†’ return false
                2. Return true (all equal)</pre>
          solution: |-
            func areEqual(nums []int) bool {
                for _, n := range nums {
                    if n != nums[0] { return false }
                }
                return true
            }
          difficulty: 1
        - id: v2
          title: Has Adjacent Equal
          description: Write <code>func hasAdjacentEqual(nums []int) bool</code> - true if any two adjacent elements are equal.
          functionSignature: func hasAdjacentEqual(nums []int) bool
          testCases:
            - input: "[]int{1, 2, 2, 3}"
              output: "true"
            - input: "[]int{1, 2, 3, 4}"
              output: "false"
          hints:
            - title: ðŸ¤” Think about it
              content: Loop through, comparing each element to the next one.
            - title: ðŸ’¡ Hint
              content: for i := 0; i < len(nums)-1; i++ - compare nums[i] to nums[i+1].
            - title: ðŸ”§ Pattern
              content: |-
                <pre>1. For i from 0 to len-2:
                   - nums[i] == nums[i+1]? â†’ return true
                2. Return false</pre>
          solution: |-
            func hasAdjacentEqual(nums []int) bool {
                for i := 0; i < len(nums)-1; i++ {
                    if nums[i] == nums[i+1] { return true }
                }
                return false
            }
          difficulty: 2
        - id: v3
          title: Is Increasing
          description: Write <code>func isIncreasing(nums []int) bool</code> - true if each element is greater than the previous.
          functionSignature: func isIncreasing(nums []int) bool
          testCases:
            - input: "[]int{1, 2, 3, 4}"
              output: "true"
            - input: "[]int{1, 3, 2, 4}"
              output: "false"
          hints:
            - title: ðŸ¤” Think about it
              content: Compare adjacent elements - each should be > previous.
            - title: ðŸ’¡ Hint
              content: If nums[i+1] <= nums[i], it's not strictly increasing.
            - title: ðŸ”§ Pattern
              content: |-
                <pre>1. For i from 0 to len-2:
                   - nums[i+1] <= nums[i]? â†’ return false
                2. Return true</pre>
          solution: |-
            func isIncreasing(nums []int) bool {
                for i := 0; i < len(nums)-1; i++ {
                    if nums[i+1] <= nums[i] { return false }
                }
                return true
            }
          difficulty: 2
        - id: v4
          title: First Greater Index
          description: >-
            Write <code>func firstGreater(nums []int, threshold int) int</code> - index of first element > threshold, or
            -1.
          functionSignature: func firstGreater(nums []int, threshold int) int
          testCases:
            - input: "[]int{1, 3, 5, 7}, 4"
              output: "2"
              note: 5 is first > 4
            - input: "[]int{1, 2, 3}, 10"
              output: "-1"
          hints:
            - title: ðŸ¤” Think about it
              content: Loop through with index, return index when you find one > threshold.
            - title: ðŸ’¡ Hint
              content: for i, n := range nums - if n > threshold return i.
            - title: ðŸ”§ Pattern
              content: |-
                <pre>1. For i, num:
                   - num > threshold? â†’ return i
                2. Return -1</pre>
          solution: |-
            func firstGreater(nums []int, threshold int) int {
                for i, n := range nums {
                    if n > threshold { return i }
                }
                return -1
            }
          difficulty: 2
        - id: v5
          title: Starts With Same
          description: Write <code>func startsWithSame(nums []int, k int) bool</code> - true if first k elements are all equal.
          functionSignature: func startsWithSame(nums []int, k int) bool
          testCases:
            - input: "[]int{5, 5, 5, 7}, 3"
              output: "true"
            - input: "[]int{5, 5, 6, 7}, 3"
              output: "false"
          hints:
            - title: ðŸ¤” Think about it
              content: Check if first k elements all equal nums[0].
            - title: ðŸ’¡ Hint
              content: Loop i from 0 to k-1, compare nums[i] to nums[0].
            - title: ðŸ”§ Pattern
              content: |-
                <pre>1. For i from 0 to k-1:
                   - nums[i] != nums[0]? â†’ return false
                2. Return true</pre>
          solution: |-
            func startsWithSame(nums []int, k int) bool {
                for i := 0; i < k; i++ {
                    if nums[i] != nums[0] { return false }
                }
                return true
            }
          difficulty: 1
        - id: v6
          title: Longest Streak of Value
          description: >-
            Write <code>func longestStreak(nums []int, target int) int</code> - length of longest consecutive run of
            target.
          functionSignature: func longestStreak(nums []int, target int) int
          testCases:
            - input: "[]int{1, 2, 2, 2, 1, 2, 2}, 2"
              output: "3"
              note: three 2's in a row
            - input: "[]int{1, 1, 3, 1}, 1"
              output: "2"
          hints:
            - title: ðŸ¤” Think about it
              content: >-
                Track current streak and max streak. When you see target, increment current. When you don't, reset
                current.
            - title: ðŸ’¡ Hint
              content: Keep current and max variables. Update max whenever current > max.
            - title: ðŸ”§ Pattern
              content: |-
                <pre>1. current, max := 0, 0
                2. For each num:
                   - num == target? â†’ current++, update max
                   - else â†’ current = 0
                3. Return max</pre>
          solution: |-
            func longestStreak(nums []int, target int) int {
                current, max := 0, 0
                for _, n := range nums {
                    if n == target {
                        current++
                        if current > max { max = current }
                    } else {
                        current = 0
                    }
                }
                return max
            }
          difficulty: 3
        - id: v7
          title: All Positive
          description: Write <code>func allPositive(nums []int) bool</code> that returns true if all numbers are greater than 0.
          functionSignature: func allPositive(nums []int) bool
          testCases:
            - input: "[]int{1, 5, 10, 3}"
              output: "true"
            - input: "[]int{1, 0, 5}"
              output: "false"
          hints:
            - title: ðŸ¤” Think about it
              content: Check each number. If any is <= 0, return false immediately.
            - title: ðŸ’¡ Hint
              content: "Early return pattern: as soon as you find non-positive, return false."
            - title: ðŸ”§ Pattern
              content: |-
                <pre>1. For each num:
                   - num <= 0? â†’ return false
                2. Return true</pre>
          solution: |-
            func allPositive(nums []int) bool {
                for _, n := range nums {
                    if n <= 0 { return false }
                }
                return true
            }
          difficulty: 1
        - id: v8
          title: Price Drop Count
          description: >-
            Write <code>func priceDrops(prices []float64) int</code> that counts how many times price decreased from one
            day to next.
          functionSignature: func priceDrops(prices []float64) int
          testCases:
            - input: "[]float64{100.0, 95.0, 97.0, 90.0}"
              output: "2"
              note: 100â†’95 and 97â†’90
            - input: "[]float64{50.0, 55.0, 60.0}"
              output: "0"
          hints:
            - title: ðŸ¤” Think about it
              content: Compare adjacent prices. Count when prices[i+1] < prices[i].
            - title: ðŸ’¡ Hint
              content: Loop through indices, increment counter when next price is lower than current.
            - title: ðŸ”§ Pattern
              content: |-
                <pre>1. count := 0
                2. For i from 0 to len-2:
                   - prices[i+1] < prices[i]? â†’ count++
                3. Return count</pre>
          solution: |-
            func priceDrops(prices []float64) int {
                count := 0
                for i := 0; i < len(prices)-1; i++ {
                    if prices[i+1] < prices[i] { count++ }
                }
                return count
            }
          difficulty: 2
        - id: v9
          title: Length Matches Position
          description: >-
            Write <code>func lengthMatchesPos(words []string) bool</code> - true if each word's length equals its
            position+1.
          functionSignature: func lengthMatchesPos(words []string) bool
          testCases:
            - input: "[]string{\"a\", \"hi\", \"cat\", \"dogs\"}"
              output: "true"
              note: "lengths: 1,2,3,4"
            - input: "[]string{\"a\", \"ab\", \"abc\"}"
              output: "false"
              note: >-
                position 1: "ab" has length 2, needs 2 âœ“; position 2: "abc" has length 3, needs 3 âœ“... wait this should
                be true!
          hints:
            - title: ðŸ¤” Think about it
              content: For each word at index i, check if len(word) == i+1.
            - title: ðŸ’¡ Hint
              content: "Loop with index: if len(words[i]) != i+1, return false."
            - title: ðŸ”§ Pattern
              content: |-
                <pre>1. For i, word:
                   - len(word) != i+1? â†’ return false
                2. Return true</pre>
          solution: |-
            func lengthMatchesPos(words []string) bool {
                for i, word := range words {
                    if len(word) != i+1 { return false }
                }
                return true
            }
          difficulty: 2
        - id: v10
          title: Find All Peaks
          description: >-
            Write <code>func findAllPeaks(nums []int) []int</code> that returns the indices where an element is greater
            than both its neighbors. First and last elements cannot be peaks.
          functionSignature: func findAllPeaks(nums []int) []int
          testCases:
            - input: "[]int{1, 3, 2, 4, 1}"
              output: "[1, 3]"
              note: nums[1]=3 > neighbors (1,2); nums[3]=4 > neighbors (2,1)
            - input: "[]int{1, 2, 3, 4}"
              output: "[]"
              note: monotonic increasing, no peaks
          hints:
            - title: ðŸ¤” Think about it
              content: >-
                A peak is at index i where nums[i] > nums[i-1] AND nums[i] > nums[i+1]. Loop from index 1 to len-2
                (excluding first and last).
            - title: ðŸ’¡ Hint
              content: >-
                Create empty result slice. Loop i from 1 to len(nums)-2. If nums[i] > nums[i-1] && nums[i] > nums[i+1],
                append i to result.
            - title: ðŸ”§ Pattern
              content: |-
                <pre>1. result := []int{}
                2. For i from 1 to len-2:
                   - nums[i] > both neighbors?
                     â†’ append i to result
                3. Return result</pre>
          solution: |-
            func findAllPeaks(nums []int) []int {
                result := []int{}
                
                for i := 1; i < len(nums)-1; i++ {
                    if nums[i] > nums[i-1] && nums[i] > nums[i+1] {
                        result = append(result, i)
                    }
                }
                
                return result
            }
          difficulty: 3
        - id: v11
          title: Longest Increasing Sequence
          description: >-
            Write <code>func longestIncreasingLength(nums []int) int</code> that finds the length of the longest
            consecutive increasing subsequence.
          functionSignature: func longestIncreasingLength(nums []int) int
          testCases:
            - input: "[]int{1, 2, 3, 1, 2, 3, 4, 5}"
              output: "5"
              note: sequence 1,2,3,4,5 at end
            - input: "[]int{5, 4, 3, 2, 1}"
              output: "1"
              note: all decreasing, max streak is 1
          hints:
            - title: ðŸ¤” Think about it
              content: >-
                Track the current streak length and the maximum streak seen so far. When nums[i] > nums[i-1], increment
                streak. Otherwise, reset streak to 1.
            - title: ðŸ’¡ Hint
              content: >-
                currentStreak := 1, maxStreak := 1. For each i from 1 to end: if nums[i] > nums[i-1], currentStreak++,
                else currentStreak = 1. Update maxStreak if currentStreak is larger.
            - title: ðŸ”§ Pattern
              content: |-
                <pre>1. currentStreak = 1, maxStreak = 1
                2. For i from 1 to len:
                   - Increasing? â†’ currentStreak++
                   - Not? â†’ currentStreak = 1
                   - Update maxStreak
                3. Return maxStreak</pre>
          solution: |-
            func longestIncreasingLength(nums []int) int {
                if len(nums) == 0 { return 0 }
                
                currentStreak := 1
                maxStreak := 1
                
                for i := 1; i < len(nums); i++ {
                    if nums[i] > nums[i-1] {
                        currentStreak++
                        if currentStreak > maxStreak {
                            maxStreak = currentStreak
                        }
                    } else {
                        currentStreak = 1
                    }
                }
                
                return maxStreak
            }
          difficulty: 3
        - id: v12
          title: Count Direction Changes
          description: >-
            Write <code>func countDirectionChanges(nums []int) int</code> that counts how many times the sequence
            changes from increasing to decreasing or vice versa.
          functionSignature: func countDirectionChanges(nums []int) int
          testCases:
            - input: "[]int{1, 3, 2, 4, 3}"
              output: "3"
              note: up(1â†’3), down(3â†’2), up(2â†’4), down(4â†’3) = 3 changes
            - input: "[]int{1, 2, 3}"
              output: "0"
              note: monotonic increasing, no direction changes
          hints:
            - title: ðŸ¤” Think about it
              content: >-
                Track whether you're currently going up or down. When the direction switches, increment the change
                counter.
            - title: ðŸ’¡ Hint
              content: >-
                Start with direction based on first two elements. For each next element, determine new direction. If it
                differs from previous direction, count a change.
            - title: ðŸ”§ Pattern
              content: |-
                <pre>1. Determine initial direction
                2. changes := 0
                3. For each next pair:
                   - Determine new direction
                   - Different from previous? â†’ changes++
                   - Update previous direction
                4. Return changes</pre>
          solution: |-
            func countDirectionChanges(nums []int) int {
                if len(nums) < 2 { return 0 }
                
                changes := 0
                var prevDirection string
                
                for i := 1; i < len(nums); i++ {
                    var currentDirection string
                    if nums[i] > nums[i-1] {
                        currentDirection = "up"
                    } else if nums[i] < nums[i-1] {
                        currentDirection = "down"
                    } else {
                        continue
                    }
                    
                    if prevDirection != "" && currentDirection != prevDirection {
                        changes++
                    }
                    prevDirection = currentDirection
                }
                
                return changes
            }
          difficulty: 3
