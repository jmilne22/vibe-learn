conceptLinks:
  Variable Declaration: "#lesson-variables"
  Type Conversion: "#lesson-variables"
  Function Basics: "#lesson-functions"
  Multiple Returns: "#lesson-functions"
  Building Slices: "#lesson-slices"
  Slice Operations: "#lesson-slices"
  For Loops: "#lesson-loops"
  Map Basics: "#lesson-maps"
  Comma-Ok Pattern: "#lesson-comma-ok"
  Strings & Runes: "#lesson-variables"
  Go Fundamentals Combined: "#lesson-variables"
  If/Else: "#lesson-if"

sharedContent: {}

variants:
  warmups:
    # ‚îÄ‚îÄ warmup_1: For Loops ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    - id: warmup_1
      concept: For Loops
      variants:
        - id: v1
          title: Print 1 to 10
          description: >-
            Write a program that prints the numbers 1 through 10, one per line, using a classic
            <code>for</code> loop with an index variable.
          hints:
            - "Use <code>for i := 1; i &lt;= 10; i++</code>"
            - "Print each number with <code>fmt.Println(i)</code>"
          solution: |-
            for i := 1; i <= 10; i++ {
                fmt.Println(i)
            }

        - id: v2
          title: Print Server Names
          description: >-
            Given the slice <code>servers := []string{"web-01", "web-02", "db-01", "cache-01"}</code>,
            use a <code>range</code> loop to print each server with its index, like
            <code>0: web-01</code>.
          hints:
            - "Use <code>for i, name := range servers</code>"
            - "Print with <code>fmt.Printf(\"%d: %s\\n\", i, name)</code>"
          solution: |-
            servers := []string{"web-01", "web-02", "db-01", "cache-01"}
            for i, name := range servers {
                fmt.Printf("%d: %s\n", i, name)
            }

        - id: v3
          title: Alert Countdown
          description: >-
            Write a program that counts down from 10 to 1. On multiples of 3, print
            <code>ALERT!</code> instead of the number.
          hints:
            - "Use <code>for i := 10; i >= 1; i--</code>"
            - "Check multiples with <code>if i % 3 == 0</code>"
          solution: |-
            for i := 10; i >= 1; i-- {
                if i%3 == 0 {
                    fmt.Println("ALERT!")
                } else {
                    fmt.Println(i)
                }
            }

        - id: v4
          title: Multiplication Table
          description: >-
            Write a program that prints a 3x3 multiplication table. For rows 1-3 and columns 1-3,
            print each product separated by a tab, with a newline after each row.
            Output should look like:<br><code>1  2  3</code><br><code>2  4  6</code><br><code>3  6  9</code>
          hints:
            - "Use a nested loop: outer for rows, inner for columns"
            - "Use <code>fmt.Printf(\"%d\\t\", i*j)</code> for each cell and <code>fmt.Println()</code> after each row"
          solution: |-
            for i := 1; i <= 3; i++ {
                for j := 1; j <= 3; j++ {
                    fmt.Printf("%d\t", i*j)
                }
                fmt.Println()
            }

    # ‚îÄ‚îÄ warmup_2: If/Else ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    - id: warmup_2
      concept: If/Else
      variants:
        - id: v1
          title: Privileged Port Check
          description: >-
            Write <code>func isPrivileged(port int) string</code> that returns
            <code>"privileged"</code> if the port is less than 1024, or
            <code>"unprivileged"</code> otherwise.
          hints:
            - "Ports below 1024 are privileged: <code>if port &lt; 1024</code>"
          solution: |-
            func isPrivileged(port int) string {
                if port < 1024 {
                    return "privileged"
                }
                return "unprivileged"
            }

        - id: v2
          title: HTTP Status Classifier
          description: >-
            Write <code>func classifyStatus(code int) string</code> that returns
            <code>"success"</code> for 200-299, <code>"redirect"</code> for 300-399,
            <code>"client error"</code> for 400-499, <code>"server error"</code> for 500-599,
            or <code>"unknown"</code> for anything else.
          hints:
            - "Use <code>if/else if</code> chains to check ranges"
            - "Check <code>code >= 200 && code &lt;= 299</code> for success, etc."
          solution: |-
            func classifyStatus(code int) string {
                if code >= 200 && code <= 299 {
                    return "success"
                } else if code >= 300 && code <= 399 {
                    return "redirect"
                } else if code >= 400 && code <= 499 {
                    return "client error"
                } else if code >= 500 && code <= 599 {
                    return "server error"
                }
                return "unknown"
            }

        - id: v3
          title: Valid Log Level
          description: >-
            Write <code>func isValidLevel(level string) bool</code> that returns
            <code>true</code> if level is one of <code>"INFO"</code>, <code>"WARN"</code>,
            <code>"ERROR"</code>, or <code>"DEBUG"</code>. Use compound conditions with
            <code>||</code>.
          hints:
            - "Use <code>if level == \"INFO\" || level == \"WARN\" || ...</code>"
            - "Return <code>true</code> inside the if, <code>false</code> at the end"
          solution: |-
            func isValidLevel(level string) bool {
                if level == "INFO" || level == "WARN" || level == "ERROR" || level == "DEBUG" {
                    return true
                }
                return false
            }

        - id: v4
          title: Validate Config Value
          description: >-
            Write <code>func validateConfig(value string) string</code> that checks a config value
            and returns an error message or <code>"ok"</code>. Return <code>"empty"</code> if the
            string is empty, <code>"too long"</code> if longer than 64 characters,
            <code>"has spaces"</code> if it contains a space (use <code>strings.Contains</code>),
            or <code>"ok"</code> if it passes all checks.
          hints:
            - "Use early returns ‚Äî check the simplest conditions first"
            - "Use <code>strings.Contains(value, \" \")</code> to check for spaces"
            - "Use <code>len(value)</code> to check length"
          solution: |-
            func validateConfig(value string) string {
                if value == "" {
                    return "empty"
                }
                if len(value) > 64 {
                    return "too long"
                }
                if strings.Contains(value, " ") {
                    return "has spaces"
                }
                return "ok"
            }

    # ‚îÄ‚îÄ warmup_3: Building Slices ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    - id: warmup_3
      concept: Building Slices
      variants:
        - id: v1
          title: Print Log Levels
          description: >-
            Declare a slice literal containing the strings <code>"INFO"</code>,
            <code>"WARN"</code>, <code>"ERROR"</code>, <code>"DEBUG"</code>.
            Iterate over it with <code>range</code> and print each level.
          hints:
            - "Use <code>levels := []string{\"INFO\", \"WARN\", \"ERROR\", \"DEBUG\"}</code>"
            - "Use <code>for _, level := range levels</code> to iterate"
          solution: |-
            levels := []string{"INFO", "WARN", "ERROR", "DEBUG"}
            for _, level := range levels {
                fmt.Println(level)
            }

        - id: v2
          title: Collect Even Numbers
          description: >-
            Write a program that loops from 1 to 20 and uses <code>append</code> to collect
            all even numbers into a slice. Print the final slice.
          hints:
            - "Start with an empty slice: <code>var evens []int</code>"
            - "Inside the loop, use <code>if i % 2 == 0 { evens = append(evens, i) }</code>"
          solution: |-
            var evens []int
            for i := 1; i <= 20; i++ {
                if i%2 == 0 {
                    evens = append(evens, i)
                }
            }
            fmt.Println(evens)

        - id: v3
          title: Last Three Lines
          description: >-
            Given <code>lines := []string{"line1", "line2", "line3", "line4", "line5"}</code>,
            use slice syntax to grab the last 3 elements and print them.
          hints:
            - "Use <code>lines[len(lines)-3:]</code> to get the last 3 elements"
          solution: |-
            lines := []string{"line1", "line2", "line3", "line4", "line5"}
            last3 := lines[len(lines)-3:]
            fmt.Println(last3)

        - id: v4
          title: Pre-Allocate with make
          description: >-
            Use <code>make([]int, 5)</code> to create a slice of 5 integers.
            Fill each element with its index squared (<code>i*i</code>), then print the slice.
          hints:
            - "Use <code>squares := make([]int, 5)</code> to pre-allocate"
            - "Fill with <code>for i := 0; i &lt; len(squares); i++ { squares[i] = i * i }</code>"
          solution: |-
            squares := make([]int, 5)
            for i := 0; i < len(squares); i++ {
                squares[i] = i * i
            }
            fmt.Println(squares)

    # ‚îÄ‚îÄ warmup_4: Map Basics ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    - id: warmup_4
      concept: Map Basics
      variants:
        - id: v1
          title: Iterate a Map
          description: >-
            Create a map literal mapping HTTP methods to descriptions:
            <code>"GET"</code> ‚Üí <code>"read"</code>,
            <code>"POST"</code> ‚Üí <code>"create"</code>,
            <code>"DELETE"</code> ‚Üí <code>"remove"</code>.
            Iterate with <code>range</code> and print each key-value pair.
          hints:
            - "Use <code>methods := map[string]string{\"GET\": \"read\", ...}</code>"
            - "Use <code>for k, v := range methods</code> to iterate"
          solution: |-
            methods := map[string]string{
                "GET":    "read",
                "POST":   "create",
                "DELETE": "remove",
            }
            for k, v := range methods {
                fmt.Printf("%s: %s\n", k, v)
            }

        - id: v2
          title: Build a Map from Slices
          description: >-
            Given <code>keys := []string{"a", "b", "c"}</code> and
            <code>values := []int{1, 2, 3}</code>, build a
            <code>map[string]int</code> by looping over the slices, then print the map.
          hints:
            - "Create the map first: <code>m := make(map[string]int)</code>"
            - "Use <code>for i := 0; i &lt; len(keys); i++ { m[keys[i]] = values[i] }</code>"
          solution: |-
            keys := []string{"a", "b", "c"}
            values := []int{1, 2, 3}
            m := make(map[string]int)
            for i := 0; i < len(keys); i++ {
                m[keys[i]] = values[i]
            }
            fmt.Println(m)

        - id: v3
          title: Comma-Ok Lookup
          description: >-
            Given <code>config := map[string]string{"host": "localhost", "port": "8080"}</code>,
            look up the key <code>"timeout"</code> using the comma-ok pattern. If missing,
            print <code>"not set"</code>; otherwise print the value.
          hints:
            - "Use <code>val, ok := config[\"timeout\"]</code>"
            - "Check <code>if !ok { fmt.Println(\"not set\") }</code>"
          solution: |-
            config := map[string]string{"host": "localhost", "port": "8080"}
            val, ok := config["timeout"]
            if !ok {
                fmt.Println("not set")
            } else {
                fmt.Println(val)
            }

        - id: v4
          title: Count Word Frequency
          description: >-
            Given <code>words := []string{"go", "is", "fun", "go", "is", "great", "go"}</code>,
            count the frequency of each word using a map. Print the resulting map.
          hints:
            - "Create <code>freq := make(map[string]int)</code>"
            - "For each word, <code>freq[word]++</code> increments the count (zero value for int is 0)"
          solution: |-
            words := []string{"go", "is", "fun", "go", "is", "great", "go"}
            freq := make(map[string]int)
            for _, word := range words {
                freq[word]++
            }
            fmt.Println(freq)

    # ‚îÄ‚îÄ warmup_5: Strings & Runes ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    - id: warmup_5
      concept: Strings & Runes
      variants:
        - id: v1
          title: Bytes vs Characters
          description: >-
            Given <code>s := "caf√©"</code>, print <code>len(s)</code> (byte length) and
            <code>len([]rune(s))</code> (character count). They're different! Then print
            each rune using <code>range</code> to see the byte index jumps.
          hints:
            - "<code>len(\"caf√©\")</code> is 5 (bytes), not 4 ‚Äî the <code>√©</code> is 2 bytes in UTF-8"
            - "<code>range</code> over a string yields runes, not bytes: <code>for i, ch := range s</code>"
          solution: |-
            s := "caf√©"
            fmt.Println("bytes:", len(s))           // 5
            fmt.Println("runes:", len([]rune(s)))    // 4
            for i, ch := range s {
                fmt.Printf("index %d: %c\n", i, ch)
            }
            // index 0: c, index 1: a, index 2: f, index 3: √©
          annotations:
            - type: gotcha
              label: Strings Are Bytes
              text: >-
                Go strings are byte sequences, not character sequences. <code>len(s)</code> returns
                bytes, and <code>s[i]</code> gives a byte. Use <code>[]rune(s)</code> or <code>range</code>
                for Unicode-safe character work.

        - id: v2
          title: Safe Character Slicing
          description: >-
            Write a program that safely extracts the first 3 <em>characters</em> from
            <code>"Êó•Êú¨Ë™û„ÉÜ„Çπ„Éà"</code> (Japanese for "Japanese test"). Using <code>s[:3]</code>
            would slice bytes and produce garbage. Convert to <code>[]rune</code>, slice, and
            convert back to a string.
          hints:
            - "Convert first: <code>runes := []rune(s)</code>"
            - "Slice runes, then convert back: <code>string(runes[:3])</code>"
          solution: |-
            s := "Êó•Êú¨Ë™û„ÉÜ„Çπ„Éà"
            runes := []rune(s)
            first3 := string(runes[:3])
            fmt.Println(first3)  // Êó•Êú¨Ë™û
          annotations:
            - type: pattern
              label: Rune Round-Trip
              text: >-
                The pattern <code>[]rune(s)</code> ‚Üí manipulate ‚Üí <code>string(runes)</code> is how
                you safely work with characters in Go. Use it whenever you need to index or slice
                by character position rather than byte position.

        - id: v3
          title: Count Non-ASCII Characters
          description: >-
            Write a program that counts how many characters in <code>"Hello, ‰∏ñÁïå! üåç"</code>
            are non-ASCII (byte value > 127). Use <code>range</code> to iterate by rune and
            check if each rune is greater than 127.
          hints:
            - "Use <code>for _, ch := range s</code> ‚Äî <code>ch</code> is a <code>rune</code> (int32)"
            - "Check <code>if ch > 127</code> to detect non-ASCII characters"
          solution: |-
            s := "Hello, ‰∏ñÁïå! üåç"
            count := 0
            for _, ch := range s {
                if ch > 127 {
                    count++
                }
            }
            fmt.Println(count)  // 3 (‰∏ñ, Áïå, üåç)

  challenges:
    # ‚îÄ‚îÄ challenge_1: Variable Declaration ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    - id: challenge_1
      block: 1
      difficulty: 1
      concept: Variable Declaration
      docLinks:
        - url: https://go.dev/tour/basics/9
          title: "Go Tour: Short variable declarations"
          note: := syntax
        - url: https://go.dev/ref/spec#Short_variable_declarations
          title: "Go Spec: Short variable declarations"
          note: specification details
      patternPrimer:
        bruteForce: Use explicit var declarations with types for every variable.
        bestApproach: Use := for concise declaration inside functions; use var when zero values or package-level scope needed.
        typical: Variable declaration is O(1) ‚Äî focus on choosing the right declaration style.
      variants:
        - id: v1
          title: Declare and Return Integer
          description: Write <code>func declareInt() int</code> that uses <code>:=</code> to declare <code>x</code> as 42 and return it.
          functionSignature: func declareInt() int
          difficulty: 1
          testCases:
            - input: "declareInt()"
              output: "42"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                The := operator declares a new variable and infers its type from the value on the right side. What value do you need to assign?
            - title: "\U0001F4A1 Hint"
              content: >-
                Use <code>x := 42</code> to declare and initialize x, then return it.
          solution: |-
            func declareInt() int {
                x := 42
                return x
            }
          annotations:
            - type: idiom
              label: Short Declaration
              text: >-
                The <code>:=</code> operator is Go's most common way to declare variables inside functions.
                The compiler infers the type from the value on the right.

        - id: v2
          title: Declare and Concatenate
          description: >-
            Write <code>func fullGreeting() string</code> that declares <code>greeting := "Hello"</code> and
            <code>target := "Gopher"</code> on separate lines, then returns them joined with a space.
          functionSignature: func fullGreeting() string
          difficulty: 1
          testCases:
            - input: "fullGreeting()"
              output: "\"Hello Gopher\""
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                You can use := multiple times in the same function. How do you join two strings with a space between them?
            - title: "\U0001F4A1 Hint"
              content: >-
                Declare both variables, then <code>return greeting + " " + target</code>.
          solution: |-
            func fullGreeting() string {
                greeting := "Hello"
                target := "Gopher"
                return greeting + " " + target
            }

        - id: v3
          title: Zero Values
          description: >-
            Write <code>func zeroValues() (int, string, bool)</code> that uses <code>var</code> to
            declare an int, string, and bool <em>without</em> assigning values, then returns all three.
            This demonstrates Go's zero-value guarantee.
          functionSignature: func zeroValues() (int, string, bool)
          difficulty: 2
          testCases:
            - input: "zeroValues()"
              output: "0, \"\", false"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                When you use <code>var x int</code> without assigning a value, Go initializes it to the zero value for that type. What are the zero values for int, string, and bool?
            - title: "\U0001F4A1 Hint"
              content: >-
                Use <code>var n int</code>, <code>var s string</code>, <code>var b bool</code>, then return all three.
          solution: |-
            func zeroValues() (int, string, bool) {
                var n int
                var s string
                var b bool
                return n, s, b
            }
          annotations:
            - type: idiom
              label: Zero Values
              text: >-
                Go guarantees every variable has a well-defined initial value. For numeric types it's 0,
                for strings it's <code>""</code>, and for bools it's <code>false</code>. This eliminates
                an entire class of "uninitialized variable" bugs.

        - id: v4
          title: Multi-Assignment Swap
          description: >-
            Write <code>func swap(a, b int) (int, int)</code> that uses multi-assignment
            (<code>a, b = b, a</code>) to swap the values and return them.
          functionSignature: func swap(a, b int) (int, int)
          difficulty: 2
          testCases:
            - input: "swap(10, 20)"
              output: "20, 10"
            - input: "swap(-1, 1)"
              output: "1, -1"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                Go evaluates the right side of an assignment fully before writing to the left side. This means you can swap without a temp variable.
            - title: "\U0001F4A1 Hint"
              content: >-
                Use <code>a, b = b, a</code> ‚Äî Go's parallel assignment handles the swap.
          solution: |-
            func swap(a, b int) (int, int) {
                a, b = b, a
                return a, b
            }
          annotations:
            - type: idiom
              label: Parallel Assignment
              text: >-
                Go evaluates all right-hand values before assigning, so <code>a, b = b, a</code> swaps
                without needing a temporary variable.

    # ‚îÄ‚îÄ challenge_2: Type Conversion ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    - id: challenge_2
      block: 1
      difficulty: 1
      concept: Type Conversion
      docLinks:
        - url: https://go.dev/tour/basics/13
          title: "Go Tour: Type conversions"
          note: basic conversion syntax
        - url: https://pkg.go.dev/strconv
          title: "Package strconv"
          note: string/number conversions
      patternPrimer:
        bruteForce: Manually format values using fmt.Sprintf for everything.
        bestApproach: Use strconv for string/number conversions and explicit type casts for numeric types. Always handle errors from parsing functions.
        typical: Type conversion is O(1) for numeric types, O(n) for string conversions where n is string length.
      variants:
        - id: v1
          title: Int to String
          description: >-
            Write <code>func intToString(n int) string</code> that converts an integer to its string
            representation using <code>strconv.Itoa</code>.
          functionSignature: func intToString(n int) string
          difficulty: 1
          testCases:
            - input: "intToString(42)"
              output: "\"42\""
            - input: "intToString(-7)"
              output: "\"-7\""
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                <code>strconv.Itoa</code> converts an int to its ASCII string representation. Don't confuse it with <code>string(n)</code>, which treats n as a Unicode code point.
            - title: "\U0001F4A1 Hint"
              content: >-
                <code>return strconv.Itoa(n)</code>
          solution: |-
            func intToString(n int) string {
                return strconv.Itoa(n)
            }
          annotations:
            - type: gotcha
              label: string(int) Trap
              text: >-
                <code>string(65)</code> gives <code>"A"</code> (the Unicode character), not <code>"65"</code>.
                Always use <code>strconv.Itoa</code> to convert numbers to their string representation.

        - id: v2
          title: String to Int
          description: >-
            Write <code>func stringToInt(s string) (int, error)</code> that converts a string to an
            integer using <code>strconv.Atoi</code>. Return both the value and the error.
          functionSignature: func stringToInt(s string) (int, error)
          difficulty: 1
          testCases:
            - input: "stringToInt(\"123\")"
              output: "123, nil"
            - input: "stringToInt(\"abc\")"
              output: "0, error"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                <code>strconv.Atoi</code> returns two values: the parsed integer and an error. What happens when the input isn't a valid number?
            - title: "\U0001F4A1 Hint"
              content: >-
                <code>return strconv.Atoi(s)</code> ‚Äî it already returns (int, error).
          solution: |-
            func stringToInt(s string) (int, error) {
                return strconv.Atoi(s)
            }
          annotations:
            - type: idiom
              label: Error Returns
              text: >-
                Go's convention is to return errors as the last value. <code>strconv.Atoi</code> returns
                <code>(int, error)</code> ‚Äî callers must check the error before using the value.

        - id: v3
          title: Float Truncation vs Round
          description: >-
            Write <code>func truncateAndRound(f float64) (int, int)</code> that returns two values:
            the result of <code>int(f)</code> (truncation) and <code>int(math.Round(f))</code> (rounding).
          functionSignature: func truncateAndRound(f float64) (int, int)
          difficulty: 2
          testCases:
            - input: "truncateAndRound(3.7)"
              output: "3, 4"
            - input: "truncateAndRound(-2.3)"
              output: "-2, -2"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                <code>int(f)</code> truncates toward zero ‚Äî it just drops the decimal. <code>math.Round(f)</code> rounds to the nearest integer. They give different results for most inputs.
            - title: "\U0001F4A1 Hint"
              content: >-
                Return <code>int(f), int(math.Round(f))</code>.
          solution: |-
            func truncateAndRound(f float64) (int, int) {
                return int(f), int(math.Round(f))
            }
          annotations:
            - type: gotcha
              label: Truncation Surprise
              text: >-
                <code>int(3.9)</code> is <code>3</code>, not <code>4</code>. Go truncates toward zero,
                which catches many newcomers. Use <code>math.Round</code> when you want rounding.

        - id: v4
          title: Chain Conversions
          description: >-
            Write <code>func doubleString(s string) (string, error)</code> that parses a numeric string,
            doubles it, and returns the result as a string. Return an error if the input isn't a valid integer.
          functionSignature: func doubleString(s string) (string, error)
          difficulty: 2
          testCases:
            - input: "doubleString(\"21\")"
              output: "\"42\", nil"
            - input: "doubleString(\"abc\")"
              output: "\"\", error"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                You need three steps: parse string ‚Üí do math ‚Üí format back to string. Handle the error from parsing.
            - title: "\U0001F4A1 Hint"
              content: >-
                Use <code>strconv.Atoi</code> to parse, multiply by 2, then <code>strconv.Itoa</code> to convert back.
          solution: |-
            func doubleString(s string) (string, error) {
                n, err := strconv.Atoi(s)
                if err != nil {
                    return "", err
                }
                return strconv.Itoa(n * 2), nil
            }
          annotations:
            - type: pattern
              label: Parse-Process-Format
              text: >-
                A common pattern: parse input ‚Üí process ‚Üí format output. Always handle the parse error
                before proceeding to the processing step.

    # ‚îÄ‚îÄ challenge_3: Function Basics (Log Parser Begins) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    - id: challenge_3
      block: 1
      difficulty: 1
      concept: Function Basics
      docLinks:
        - url: https://go.dev/tour/moretypes/2
          title: "Go Tour: Functions"
          note: function syntax
        - url: https://pkg.go.dev/strings
          title: "Package strings"
          note: string manipulation functions
      patternPrimer:
        bruteForce: Write inline code without functions, duplicating logic everywhere.
        bestApproach: Extract small, focused functions with clear inputs and outputs. Each function does one thing well.
        typical: Keep functions short and composable. Good function design makes code testable and reusable.
      variants:
        - id: v1
          title: Format Log Entry
          description: >-
            Write <code>func formatLogEntry(level, message string) string</code> that returns a
            formatted log string like <code>"[ERROR] connection timeout"</code>. Wrap the level
            in square brackets, followed by a space and the message.
          functionSignature: func formatLogEntry(level, message string) string
          difficulty: 1
          testCases:
            - input: "formatLogEntry(\"ERROR\", \"connection timeout\")"
              output: "\"[ERROR] connection timeout\""
            - input: "formatLogEntry(\"INFO\", \"server started\")"
              output: "\"[INFO] server started\""
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                You need to build a string with brackets around the level. How do you concatenate strings in Go?
            - title: "\U0001F4A1 Hint"
              content: >-
                Use <code>fmt.Sprintf("[%s] %s", level, message)</code> or string concatenation.
          solution: |-
            func formatLogEntry(level, message string) string {
                return fmt.Sprintf("[%s] %s", level, message)
            }
          annotations:
            - type: idiom
              label: fmt.Sprintf
              text: >-
                <code>fmt.Sprintf</code> is Go's string formatting function ‚Äî like <code>Printf</code>
                but returns a string instead of printing. It's the idiomatic way to build formatted strings.

        - id: v2
          title: Is Error Level
          description: >-
            Write <code>func isError(level string) bool</code> that returns <code>true</code>
            if the level is <code>"ERROR"</code> or <code>"FATAL"</code>, and <code>false</code> otherwise.
          functionSignature: func isError(level string) bool
          difficulty: 1
          testCases:
            - input: "isError(\"ERROR\")"
              output: "true"
            - input: "isError(\"FATAL\")"
              output: "true"
            - input: "isError(\"INFO\")"
              output: "false"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                You need to check if the level matches either of two values. Use <code>||</code> to combine conditions.
            - title: "\U0001F4A1 Hint"
              content: >-
                <code>return level == "ERROR" || level == "FATAL"</code>
          solution: |-
            func isError(level string) bool {
                return level == "ERROR" || level == "FATAL"
            }

        - id: v3
          title: Truncate Message
          description: >-
            Write <code>func truncateMessage(msg string, maxLen int) string</code>. If the message
            is longer than <code>maxLen</code>, return the first <code>maxLen</code> characters followed
            by <code>"..."</code>. Otherwise return the message unchanged.
          functionSignature: func truncateMessage(msg string, maxLen int) string
          difficulty: 2
          testCases:
            - input: "truncateMessage(\"connection timeout after 30s\", 10)"
              output: "\"connection...\""
            - input: "truncateMessage(\"ok\", 10)"
              output: "\"ok\""
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                Use <code>len(msg)</code> to check the length. Slice the string with <code>msg[:maxLen]</code> to get the first N characters.
            - title: "\U0001F4A1 Hint"
              content: >-
                <code>if len(msg) > maxLen { return msg[:maxLen] + "..." }</code>
          solution: |-
            func truncateMessage(msg string, maxLen int) string {
                if len(msg) > maxLen {
                    return msg[:maxLen] + "..."
                }
                return msg
            }

        - id: v4
          title: Extract Timestamp
          description: >-
            Write <code>func extractTimestamp(line string) string</code>. Log lines start with a
            timestamp in the format <code>"2024-01-15 10:30:45"</code> (19 characters). Return the
            first 19 characters of the line. If the line is shorter than 19 characters, return the
            entire line.
          functionSignature: func extractTimestamp(line string) string
          difficulty: 2
          testCases:
            - input: "extractTimestamp(\"2024-01-15 10:30:45 ERROR connection timeout\")"
              output: "\"2024-01-15 10:30:45\""
            - input: "extractTimestamp(\"short\")"
              output: "\"short\""
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                You need to safely slice the string. What happens if you try <code>line[:19]</code> on a string shorter than 19 characters?
            - title: "\U0001F4A1 Hint"
              content: >-
                Check <code>len(line) &lt; 19</code> first to avoid a slice bounds panic.
          solution: |-
            func extractTimestamp(line string) string {
                if len(line) < 19 {
                    return line
                }
                return line[:19]
            }
          annotations:
            - type: gotcha
              label: Slice Bounds
              text: >-
                Slicing beyond a string's length causes a runtime panic. Always check
                <code>len(s)</code> before slicing with a fixed index.

    # ‚îÄ‚îÄ challenge_4: Multiple Returns & Error Handling (Log Parser) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    - id: challenge_4
      block: 2
      difficulty: 2
      concept: Multiple Returns
      docLinks:
        - url: https://go.dev/tour/moretypes/6
          title: "Go Tour: Multiple results"
          note: returning multiple values
        - url: https://go.dev/blog/error-handling-and-go
          title: "Error handling and Go"
          note: idiomatic error handling
      patternPrimer:
        bruteForce: Return a single value and use sentinel values (-1, empty string) to indicate errors.
        bestApproach: Return (value, error) pairs. Check errors immediately after the call. Return early on error.
        typical: The (value, error) return pattern is Go's primary error handling mechanism. Master it early.
      variants:
        - id: v1
          title: Parse Log Level
          description: >-
            Write <code>func parseLogLevel(line string) (string, error)</code>. A log line has the
            format <code>"2024-01-15 10:30:45 ERROR connection timeout"</code>. Extract the log level
            (the word after the timestamp, at index 20). Return an error if the line has fewer than
            21 characters. Use <code>strings.Fields</code> to split or slice at known positions.
          functionSignature: func parseLogLevel(line string) (string, error)
          difficulty: 1
          testCases:
            - input: "parseLogLevel(\"2024-01-15 10:30:45 ERROR connection timeout\")"
              output: "\"ERROR\", nil"
            - input: "parseLogLevel(\"short\")"
              output: "\"\", error"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                The timestamp is 19 characters, then a space, then the level. Use <code>strings.Fields</code> to split or
                index from position 20.
            - title: "\U0001F4A1 Hint"
              content: >-
                Split with <code>fields := strings.Fields(line)</code> and check <code>len(fields) >= 3</code>.
                The level is <code>fields[2]</code> (index 0 = date, 1 = time, 2 = level).
          solution: |-
            func parseLogLevel(line string) (string, error) {
                fields := strings.Fields(line)
                if len(fields) < 3 {
                    return "", fmt.Errorf("malformed log line: too short")
                }
                return fields[2], nil
            }
          annotations:
            - type: idiom
              label: Error Returns
              text: >-
                Go functions signal failure by returning an <code>error</code> as the last value.
                Callers check <code>if err != nil</code> before using the result.

        - id: v2
          title: Split Log Line
          description: >-
            Write <code>func splitLogLine(line string) (string, string, string, error)</code>.
            Split a log line into its three parts: timestamp (first two fields joined with a space),
            level (third field), and message (everything else). Return an error if the line has
            fewer than 4 fields.
          functionSignature: func splitLogLine(line string) (string, string, string, error)
          difficulty: 2
          testCases:
            - input: "splitLogLine(\"2024-01-15 10:30:45 ERROR connection timeout\")"
              output: "\"2024-01-15 10:30:45\", \"ERROR\", \"connection timeout\", nil"
            - input: "splitLogLine(\"bad line\")"
              output: "\"\", \"\", \"\", error"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                Use <code>strings.Fields</code> to split the line, then reassemble the parts.
                The timestamp is fields[0] + " " + fields[1], level is fields[2], message is the rest joined.
            - title: "\U0001F4A1 Hint"
              content: >-
                Use <code>strings.Join(fields[3:], " ")</code> to reconstruct the message from the remaining fields.
          solution: |-
            func splitLogLine(line string) (string, string, string, error) {
                fields := strings.Fields(line)
                if len(fields) < 4 {
                    return "", "", "", fmt.Errorf("malformed log line: need at least 4 fields, got %d", len(fields))
                }
                timestamp := fields[0] + " " + fields[1]
                level := fields[2]
                message := strings.Join(fields[3:], " ")
                return timestamp, level, message, nil
            }
          annotations:
            - type: pattern
              label: Destructure & Validate
              text: >-
                Split input into parts, validate you have enough parts, then work with them.
                This pattern prevents index-out-of-bounds panics.

        - id: v3
          title: Parse Port Number
          description: >-
            Write <code>func parsePort(s string) (int, error)</code>. Parse a string to an integer.
            Return an error if it's not a valid integer or if the port is outside the range 1‚Äì65535.
          functionSignature: func parsePort(s string) (int, error)
          difficulty: 2
          testCases:
            - input: "parsePort(\"8080\")"
              output: "8080, nil"
            - input: "parsePort(\"0\")"
              output: "0, error"
            - input: "parsePort(\"99999\")"
              output: "0, error"
            - input: "parsePort(\"abc\")"
              output: "0, error"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                Use <code>strconv.Atoi</code> first, then validate the range. Return different errors for each failure case.
            - title: "\U0001F4A1 Hint"
              content: >-
                Parse with <code>strconv.Atoi</code>, check <code>err != nil</code>, then check <code>port &lt; 1 || port > 65535</code>.
          solution: |-
            func parsePort(s string) (int, error) {
                port, err := strconv.Atoi(s)
                if err != nil {
                    return 0, fmt.Errorf("invalid port %q: %w", s, err)
                }
                if port < 1 || port > 65535 {
                    return 0, fmt.Errorf("port %d out of range 1-65535", port)
                }
                return port, nil
            }
          annotations:
            - type: idiom
              label: Error Wrapping
              text: >-
                Use <code>%w</code> in <code>fmt.Errorf</code> to wrap errors. This preserves the original
                error while adding context, enabling callers to use <code>errors.Is</code> and <code>errors.As</code>.

        - id: v4
          title: Safe Map Lookup
          description: >-
            Write <code>func safeLookup(m map[string]string, key string) (string, bool)</code>.
            Look up the key in the map using the comma-ok pattern and return both values.
          functionSignature: func safeLookup(m map[string]string, key string) (string, bool)
          difficulty: 3
          testCases:
            - input: "safeLookup(map[string]string{\"host\": \"localhost\"}, \"host\")"
              output: "\"localhost\", true"
            - input: "safeLookup(map[string]string{\"host\": \"localhost\"}, \"port\")"
              output: "\"\", false"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                Go maps return two values when accessed with <code>val, ok := m[key]</code>. The second value indicates whether the key was found.
            - title: "\U0001F4A1 Hint"
              content: >-
                <code>val, ok := m[key]; return val, ok</code>
          solution: |-
            func safeLookup(m map[string]string, key string) (string, bool) {
                val, ok := m[key]
                return val, ok
            }
          annotations:
            - type: idiom
              label: Comma-Ok Pattern
              text: >-
                The comma-ok pattern ‚Äî <code>val, ok := m[key]</code> ‚Äî is how Go distinguishes between
                "key not found" and "key exists with zero value". You'll see this pattern with maps,
                type assertions, and channel receives.

    # ‚îÄ‚îÄ challenge_5: Slices & Loops (Log Parser) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    - id: challenge_5
      block: 2
      difficulty: 2
      concept: Slice Operations
      docLinks:
        - url: https://go.dev/blog/slices-intro
          title: "Go Slices: usage and internals"
          note: how slices work under the hood
        - url: https://pkg.go.dev/strings#Contains
          title: "strings.Contains"
          note: check if a string contains a substring
      patternPrimer:
        bruteForce: Use nested loops and manual index tracking to filter and process slices.
        bestApproach: Use range loops with append to build result slices. Use slice expressions for sub-slices.
        typical: Filter-and-collect with range + append is O(n). Slice expressions are O(1) since they share underlying arrays.
      variants:
        - id: v1
          title: Count Errors
          description: >-
            Write <code>func countErrors(lines []string) int</code>. Loop through the log lines
            and count how many contain the substring <code>"ERROR"</code>. Use
            <code>strings.Contains</code>.
          functionSignature: func countErrors(lines []string) int
          difficulty: 1
          testCases:
            - input: "countErrors([]string{\"2024-01-15 10:30:45 ERROR timeout\", \"2024-01-15 10:30:46 INFO ok\", \"2024-01-15 10:30:47 ERROR disk full\"})"
              output: "2"
            - input: "countErrors([]string{\"2024-01-15 10:30:45 INFO ok\"})"
              output: "0"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                Initialize a counter to 0. Loop through lines with range. For each line, check if it contains "ERROR" and increment the counter.
            - title: "\U0001F4A1 Hint"
              content: >-
                Use <code>strings.Contains(line, "ERROR")</code> inside the loop.
          solution: |-
            func countErrors(lines []string) int {
                count := 0
                for _, line := range lines {
                    if strings.Contains(line, "ERROR") {
                        count++
                    }
                }
                return count
            }

        - id: v2
          title: Filter by Level
          description: >-
            Write <code>func filterByLevel(lines []string, level string) []string</code>. Return
            only the log lines that contain the given level string. Use <code>strings.Contains</code>.
          functionSignature: func filterByLevel(lines []string, level string) []string
          difficulty: 2
          testCases:
            - input: "filterByLevel([]string{\"2024-01-15 10:30:45 ERROR timeout\", \"2024-01-15 10:30:46 INFO ok\", \"2024-01-15 10:30:47 ERROR disk full\"}, \"ERROR\")"
              output: "[\"2024-01-15 10:30:45 ERROR timeout\", \"2024-01-15 10:30:47 ERROR disk full\"]"
            - input: "filterByLevel([]string{\"2024-01-15 10:30:45 INFO ok\"}, \"ERROR\")"
              output: "[]"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                This is the filter-and-collect pattern: create an empty result slice, loop, and append matching items.
            - title: "\U0001F4A1 Hint"
              content: >-
                <code>var result []string</code>, then in the loop: <code>if strings.Contains(line, level) { result = append(result, line) }</code>
          solution: |-
            func filterByLevel(lines []string, level string) []string {
                var result []string
                for _, line := range lines {
                    if strings.Contains(line, level) {
                        result = append(result, line)
                    }
                }
                return result
            }
          annotations:
            - type: pattern
              label: Filter & Collect
              text: >-
                The filter-and-collect pattern ‚Äî <code>var result []T</code> + loop + conditional <code>append</code> ‚Äî
                is one of Go's most common idioms. It's clear, efficient, and hard to get wrong.

        - id: v3
          title: Last N Entries
          description: >-
            Write <code>func lastN(lines []string, n int) []string</code>. Return the last
            <code>n</code> log entries. If <code>n</code> is greater than the number of lines,
            return all lines.
          functionSignature: func lastN(lines []string, n int) []string
          difficulty: 2
          testCases:
            - input: "lastN([]string{\"a\", \"b\", \"c\", \"d\", \"e\"}, 3)"
              output: "[\"c\", \"d\", \"e\"]"
            - input: "lastN([]string{\"a\", \"b\"}, 5)"
              output: "[\"a\", \"b\"]"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                Use slice syntax <code>lines[start:]</code>. Calculate the start index as <code>len(lines) - n</code>,
                but make sure it doesn't go below 0.
            - title: "\U0001F4A1 Hint"
              content: >-
                <code>if n > len(lines) { n = len(lines) }</code> then <code>return lines[len(lines)-n:]</code>
          solution: |-
            func lastN(lines []string, n int) []string {
                if n > len(lines) {
                    n = len(lines)
                }
                return lines[len(lines)-n:]
            }
          annotations:
            - type: idiom
              label: Defensive Slicing
              text: >-
                Always clamp your index before slicing. <code>lines[len(lines)-n:]</code> panics if
                <code>n > len(lines)</code>. A simple bounds check prevents runtime panics.

        - id: v4
          title: Unique Levels
          description: >-
            Write <code>func uniqueLevels(lines []string) []string</code>. Extract the log level
            from each line (third field via <code>strings.Fields</code>) and return a deduplicated
            slice of all levels found.
          functionSignature: func uniqueLevels(lines []string) []string
          difficulty: 3
          testCases:
            - input: "uniqueLevels([]string{\"2024-01-15 10:30:45 ERROR timeout\", \"2024-01-15 10:30:46 INFO ok\", \"2024-01-15 10:30:47 ERROR disk full\"})"
              output: "[\"ERROR\", \"INFO\"] (order may vary)"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                Use a <code>map[string]bool</code> as a set to track which levels you've already seen.
                Then collect the map keys into a slice.
            - title: "\U0001F4A1 Hint"
              content: >-
                For each line, split with <code>strings.Fields</code>, take the third field as the level,
                add it to a <code>seen</code> map. After the loop, collect the keys.
          solution: |-
            func uniqueLevels(lines []string) []string {
                seen := make(map[string]bool)
                for _, line := range lines {
                    fields := strings.Fields(line)
                    if len(fields) >= 3 {
                        seen[fields[2]] = true
                    }
                }
                var levels []string
                for level := range seen {
                    levels = append(levels, level)
                }
                return levels
            }
          annotations:
            - type: pattern
              label: Map as Set
              text: >-
                Go doesn't have a built-in set type. The idiomatic approach is <code>map[T]bool</code> ‚Äî
                use <code>m[key] = true</code> to add, and <code>if m[key]</code> to check membership.

    # ‚îÄ‚îÄ challenge_6: Maps & Aggregation (Log Parser) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    - id: challenge_6
      block: 2
      difficulty: 2
      concept: Map Basics
      docLinks:
        - url: https://go.dev/blog/maps
          title: "Go maps in action"
          note: map usage patterns
        - url: https://go.dev/tour/moretypes/19
          title: "Go Tour: Maps"
          note: map basics
      patternPrimer:
        bruteForce: Use nested loops to count occurrences or find maximums manually.
        bestApproach: Use maps for counting and aggregation. The zero value of int (0) makes frequency counting natural with map[key]++.
        typical: Map operations (insert, lookup, delete) are O(1) average. Iterating a map is O(n). Building frequency maps is O(n).
      variants:
        - id: v1
          title: Count by Level
          description: >-
            Write <code>func countByLevel(lines []string) map[string]int</code>. Extract the log
            level from each line (third field) and return a map counting occurrences of each level.
          functionSignature: func countByLevel(lines []string) map[string]int
          difficulty: 1
          testCases:
            - input: "countByLevel([]string{\"2024-01-15 10:30:45 ERROR timeout\", \"2024-01-15 10:30:46 INFO ok\", \"2024-01-15 10:30:47 ERROR disk full\"})"
              output: "map[ERROR:2 INFO:1]"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                Create a <code>map[string]int</code>. For each line, extract the level and increment:
                <code>counts[level]++</code>. The zero value of int makes this work without initialization.
            - title: "\U0001F4A1 Hint"
              content: >-
                Split each line with <code>strings.Fields</code>, take <code>fields[2]</code> as the level,
                and <code>counts[level]++</code>.
          solution: |-
            func countByLevel(lines []string) map[string]int {
                counts := make(map[string]int)
                for _, line := range lines {
                    fields := strings.Fields(line)
                    if len(fields) >= 3 {
                        counts[fields[2]]++
                    }
                }
                return counts
            }
          annotations:
            - type: idiom
              label: Frequency Map
              text: >-
                <code>m[key]++</code> works because Go map values default to their zero value.
                For <code>int</code>, that's 0 ‚Äî so the first increment gives 1. No need to check if the key exists.

        - id: v2
          title: Most Common Level
          description: >-
            Write <code>func mostCommonLevel(lines []string) string</code>. Find and return the log
            level that appears most frequently. If there are no lines, return an empty string.
          functionSignature: func mostCommonLevel(lines []string) string
          difficulty: 2
          testCases:
            - input: "mostCommonLevel([]string{\"2024-01-15 10:30:45 ERROR timeout\", \"2024-01-15 10:30:46 INFO ok\", \"2024-01-15 10:30:47 ERROR disk full\", \"2024-01-15 10:30:48 INFO started\", \"2024-01-15 10:30:49 ERROR retry\"})"
              output: "\"ERROR\""
            - input: "mostCommonLevel([]string{})"
              output: "\"\""
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                First build a frequency map (like challenge_6 v1), then iterate the map to find the key with the highest count.
            - title: "\U0001F4A1 Hint"
              content: >-
                Track <code>maxCount</code> and <code>maxLevel</code> while iterating the frequency map.
                Update them when you find a count larger than the current max.
          solution: |-
            func mostCommonLevel(lines []string) string {
                counts := make(map[string]int)
                for _, line := range lines {
                    fields := strings.Fields(line)
                    if len(fields) >= 3 {
                        counts[fields[2]]++
                    }
                }
                maxLevel := ""
                maxCount := 0
                for level, count := range counts {
                    if count > maxCount {
                        maxCount = count
                        maxLevel = level
                    }
                }
                return maxLevel
            }

        - id: v3
          title: Error Message Counts
          description: >-
            Write <code>func errorMessages(lines []string) map[string]int</code>. For lines with
            level <code>"ERROR"</code>, extract the message (everything after the level) and count
            how many times each unique error message appears.
          functionSignature: func errorMessages(lines []string) map[string]int
          difficulty: 2
          testCases:
            - input: "errorMessages([]string{\"2024-01-15 10:30:45 ERROR timeout\", \"2024-01-15 10:30:46 INFO ok\", \"2024-01-15 10:30:47 ERROR timeout\", \"2024-01-15 10:30:48 ERROR disk full\"})"
              output: "map[timeout:2 disk full:1]"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                Split each line into fields. Check if <code>fields[2] == "ERROR"</code>. If so, reconstruct the message
                from <code>fields[3:]</code> and count it.
            - title: "\U0001F4A1 Hint"
              content: >-
                Use <code>strings.Join(fields[3:], " ")</code> to get the message, then <code>counts[msg]++</code>.
          solution: |-
            func errorMessages(lines []string) map[string]int {
                counts := make(map[string]int)
                for _, line := range lines {
                    fields := strings.Fields(line)
                    if len(fields) >= 4 && fields[2] == "ERROR" {
                        msg := strings.Join(fields[3:], " ")
                        counts[msg]++
                    }
                }
                return counts
            }

        - id: v4
          title: Hourly Breakdown
          description: >-
            Write <code>func hourlyBreakdown(lines []string) map[string]int</code>. Extract the
            hour from each log line's timestamp (characters 11-12, e.g., <code>"10"</code> from
            <code>"2024-01-15 10:30:45"</code>) and return a map counting entries per hour.
          functionSignature: func hourlyBreakdown(lines []string) map[string]int
          difficulty: 3
          testCases:
            - input: "hourlyBreakdown([]string{\"2024-01-15 10:30:45 ERROR timeout\", \"2024-01-15 10:45:00 INFO ok\", \"2024-01-15 14:00:00 WARN slow\"})"
              output: "map[10:2 14:1]"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                The timestamp starts at position 0 and the hour is at positions 11-12 (inclusive).
                Use <code>line[11:13]</code> to extract the two-digit hour.
            - title: "\U0001F4A1 Hint"
              content: >-
                Check <code>len(line) >= 13</code> first, then <code>hour := line[11:13]</code> and <code>counts[hour]++</code>.
          solution: |-
            func hourlyBreakdown(lines []string) map[string]int {
                counts := make(map[string]int)
                for _, line := range lines {
                    if len(line) >= 13 {
                        hour := line[11:13]
                        counts[hour]++
                    }
                }
                return counts
            }
          annotations:
            - type: gotcha
              label: String Indexing
              text: >-
                <code>line[11:13]</code> gives bytes, not characters. This works for ASCII digits but would
                break with multi-byte UTF-8 characters. For timestamps with ASCII digits, byte indexing is fine.

    # ‚îÄ‚îÄ challenge_7: Go Fundamentals Combined (Log Parser Capstone) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    - id: challenge_7
      block: 3
      difficulty: 3
      concept: Go Fundamentals Combined
      docLinks:
        - url: https://go.dev/doc/effective_go
          title: "Effective Go"
          note: idiomatic Go patterns
        - url: https://pkg.go.dev/fmt#Sprintf
          title: "fmt.Sprintf"
          note: string formatting
      patternPrimer:
        bruteForce: Write one giant function that does everything inline with deeply nested loops and conditions.
        bestApproach: Compose small helper functions. Each function does one thing. Build complex behavior by calling simpler functions.
        typical: These problems combine iteration, maps, string processing, and error handling. Focus on clarity over cleverness.
      variants:
        - id: v1
          title: Log Summary Counts
          description: >-
            Write <code>func logSummary(lines []string) (int, int, int)</code>. Return the count of
            <code>INFO</code>, <code>WARN</code>, and <code>ERROR</code> entries (in that order).
            Extract the level from the third field of each log line.
          functionSignature: func logSummary(lines []string) (int, int, int)
          difficulty: 2
          testCases:
            - input: "logSummary([]string{\"2024-01-15 10:30:45 ERROR timeout\", \"2024-01-15 10:30:46 INFO ok\", \"2024-01-15 10:30:47 WARN slow\", \"2024-01-15 10:30:48 INFO started\", \"2024-01-15 10:30:49 ERROR retry\"})"
              output: "2, 1, 2"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                Declare three counters. Loop through lines, extract the level, and increment the appropriate counter.
            - title: "\U0001F4A1 Hint"
              content: >-
                Use a switch or if/else chain on <code>fields[2]</code> to increment the right counter.
          solution: |-
            func logSummary(lines []string) (int, int, int) {
                infoCount, warnCount, errorCount := 0, 0, 0
                for _, line := range lines {
                    fields := strings.Fields(line)
                    if len(fields) < 3 {
                        continue
                    }
                    switch fields[2] {
                    case "INFO":
                        infoCount++
                    case "WARN":
                        warnCount++
                    case "ERROR":
                        errorCount++
                    }
                }
                return infoCount, warnCount, errorCount
            }
          annotations:
            - type: idiom
              label: Switch Statement
              text: >-
                Go's <code>switch</code> doesn't need <code>break</code> ‚Äî each case automatically breaks.
                Use switch for clean multi-way branching on a single value.

        - id: v2
          title: Log Report
          description: >-
            Write <code>func logReport(lines []string) string</code>. Build a formatted report
            string containing: the total number of entries, the count per level, and the most common level.
            Format:<br><code>Total: 5<br>INFO: 2<br>WARN: 1<br>ERROR: 2<br>Most common: ERROR</code><br>
            If multiple levels tie, return any one of them.
          functionSignature: func logReport(lines []string) string
          difficulty: 3
          testCases:
            - input: "logReport([]string{\"2024-01-15 10:30:45 ERROR timeout\", \"2024-01-15 10:30:46 INFO ok\", \"2024-01-15 10:30:47 WARN slow\", \"2024-01-15 10:30:48 INFO started\", \"2024-01-15 10:30:49 ERROR retry\"})"
              output: "\"Total: 5\\nINFO: 2\\nWARN: 1\\nERROR: 2\\nMost common: INFO\" (or ERROR ‚Äî either tied level is acceptable)"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                Build a frequency map first, then find the max, then format the output string.
                This combines maps, loops, and string formatting.
            - title: "\U0001F4A1 Hint"
              content: >-
                Use <code>fmt.Sprintf</code> to build each line of the report and concatenate with <code>\n</code>.
          solution: |-
            func logReport(lines []string) string {
                counts := make(map[string]int)
                for _, line := range lines {
                    fields := strings.Fields(line)
                    if len(fields) >= 3 {
                        counts[fields[2]]++
                    }
                }
                maxLevel := ""
                maxCount := 0
                for level, count := range counts {
                    if count > maxCount {
                        maxCount = count
                        maxLevel = level
                    }
                }
                report := fmt.Sprintf("Total: %d", len(lines))
                for _, level := range []string{"INFO", "WARN", "ERROR"} {
                    report += fmt.Sprintf("\n%s: %d", level, counts[level])
                }
                report += fmt.Sprintf("\nMost common: %s", maxLevel)
                return report
            }
          annotations:
            - type: pattern
              label: Ordered Iteration
              text: >-
                Map iteration order is random in Go. When you need a specific order (like INFO, WARN, ERROR),
                iterate over a predefined slice of keys instead of ranging over the map directly.

        - id: v3
          title: Find Anomalies
          description: >-
            Write <code>func findAnomalies(lines []string, threshold int) []string</code>. Find
            error messages that appear more than <code>threshold</code> times. Return a slice of
            those messages (just the message text, not the full log line).
          functionSignature: func findAnomalies(lines []string, threshold int) []string
          difficulty: 3
          testCases:
            - input: "findAnomalies([]string{\"2024-01-15 10:30:45 ERROR timeout\", \"2024-01-15 10:30:46 ERROR timeout\", \"2024-01-15 10:30:47 ERROR timeout\", \"2024-01-15 10:30:48 ERROR disk full\", \"2024-01-15 10:30:49 INFO ok\"}, 2)"
              output: "[\"timeout\"]"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                First build a frequency map of error messages (like challenge_6 v3). Then filter the map
                for entries exceeding the threshold.
            - title: "\U0001F4A1 Hint"
              content: >-
                Two passes: (1) count error messages, (2) collect messages where <code>count > threshold</code>.
          solution: |-
            func findAnomalies(lines []string, threshold int) []string {
                counts := make(map[string]int)
                for _, line := range lines {
                    fields := strings.Fields(line)
                    if len(fields) >= 4 && fields[2] == "ERROR" {
                        msg := strings.Join(fields[3:], " ")
                        counts[msg]++
                    }
                }
                var anomalies []string
                for msg, count := range counts {
                    if count > threshold {
                        anomalies = append(anomalies, msg)
                    }
                }
                return anomalies
            }
          annotations:
            - type: pattern
              label: Two-Pass Processing
              text: >-
                Many aggregation problems need two passes: one to collect data, one to analyze it.
                This is cleaner than trying to do everything in a single loop.

        - id: v4
          title: Parse and Filter
          description: >-
            Write <code>func parseAndFilter(lines []string, level string, keyword string) []string</code>.
            Filter log lines that match both the given level AND contain the keyword in the message.
            Return the matching lines formatted as <code>"[LEVEL] message"</code> (without the timestamp).
          functionSignature: func parseAndFilter(lines []string, level string, keyword string) []string
          difficulty: 3
          testCases:
            - input: "parseAndFilter([]string{\"2024-01-15 10:30:45 ERROR connection timeout\", \"2024-01-15 10:30:46 ERROR disk full\", \"2024-01-15 10:30:47 INFO connection ok\", \"2024-01-15 10:30:48 ERROR connection refused\"}, \"ERROR\", \"connection\")"
              output: "[\"[ERROR] connection timeout\", \"[ERROR] connection refused\"]"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                Split each line, check the level matches, reconstruct the message, check for the keyword,
                then format the output. This combines parsing, filtering, and formatting.
            - title: "\U0001F4A1 Hint"
              content: >-
                Use <code>strings.Fields</code> to split, check <code>fields[2] == level</code>,
                join <code>fields[3:]</code> for the message, check <code>strings.Contains(msg, keyword)</code>,
                then format with <code>fmt.Sprintf("[%s] %s", level, msg)</code>.
          solution: |-
            func parseAndFilter(lines []string, level string, keyword string) []string {
                var result []string
                for _, line := range lines {
                    fields := strings.Fields(line)
                    if len(fields) < 4 {
                        continue
                    }
                    if fields[2] != level {
                        continue
                    }
                    msg := strings.Join(fields[3:], " ")
                    if !strings.Contains(msg, keyword) {
                        continue
                    }
                    result = append(result, fmt.Sprintf("[%s] %s", level, msg))
                }
                return result
            }
          annotations:
            - type: idiom
              label: Early Continue
              text: >-
                Use <code>continue</code> to skip non-matching items early. This keeps the "happy path"
                at the lowest indentation level, making the code easier to read than nested if statements.
