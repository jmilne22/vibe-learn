conceptLinks:
  Variable Declaration: "#variables--types"
  Type Conversion: "#type-conversion"
  String Formatting: "#functions"
  Function Basics: "#functions"
  Multiple Returns: "#multiple-return-values"
  Error Handling: "#functions"
  For Loops: "#for-loops-the-only-loop"
  Range Loops: "#more-loop-forms"
  If/Else: "#if-statements"
  Variables & Assignment: "#variables--types"

sharedContent: {}

variants:
  warmups:
    # ── warmup_1: For Loops ──────────────────────────────────────────────
    - id: warmup_1
      concept: For Loops
      variants:
        - id: v1
          title: Launch Countdown
          description: >-
            Print a rocket launch countdown from 10 to 1, then print <code>"Liftoff!"</code>.
          hints:
            - "Use <code>for i := 10; i >= 1; i--</code>"
            - "Print <code>\"Liftoff!\"</code> after the loop"
          solution: |-
            for i := 10; i >= 1; i-- {
                fmt.Println(i)
            }
            fmt.Println("Liftoff!")

        - id: v2
          title: Fibonacci First 10
          description: >-
            Print the first 10 Fibonacci numbers (1, 1, 2, 3, 5, 8, 13, 21, 34, 55).
            Use two variables <code>a</code> and <code>b</code> and update them each iteration.
          hints:
            - "Start with <code>a, b := 1, 1</code>"
            - "Each step: print <code>a</code>, then <code>a, b = b, a+b</code>"
          solution: |-
            a, b := 1, 1
            for i := 0; i < 10; i++ {
                fmt.Println(a)
                a, b = b, a+b
            }

        - id: v3
          title: Server Health Pings
          description: >-
            Given <code>servers := []string{"api-1", "api-2", "db-1", "cache-1"}</code>,
            print <code>"pinging api-1..."</code> for each server using a <code>range</code> loop.
          hints:
            - "Use <code>for _, s := range servers</code>"
            - "Use <code>fmt.Printf(\"pinging %s...\\n\", s)</code>"
          solution: |-
            servers := []string{"api-1", "api-2", "db-1", "cache-1"}
            for _, s := range servers {
                fmt.Printf("pinging %s...\n", s)
            }

        - id: v4
          title: Star Triangle
          description: >-
            Print a right triangle of stars with 5 rows. Row 1 has 1 star, row 2 has 2, etc.
            Use nested loops — outer for rows, inner for stars per row.
          hints:
            - "Outer loop: <code>for row := 1; row &lt;= 5; row++</code>"
            - "Inner loop prints <code>row</code> stars, then <code>fmt.Println()</code>"
          solution: |-
            for row := 1; row <= 5; row++ {
                for col := 0; col < row; col++ {
                    fmt.Print("*")
                }
                fmt.Println()
            }

        - id: v5
          title: CPU Round-Robin
          description: >-
            Simulate 3 rounds of a round-robin CPU scheduler with 4 processes:
            <code>procs := []string{"nginx", "postgres", "redis", "node"}</code>.
            Print <code>"[round 1] running nginx"</code> etc. for each round and process.
          hints:
            - "Outer loop for rounds 1-3, inner <code>range</code> over procs"
            - "Use <code>fmt.Printf(\"[round %d] running %s\\n\", r, p)</code>"
          solution: |-
            procs := []string{"nginx", "postgres", "redis", "node"}
            for r := 1; r <= 3; r++ {
                for _, p := range procs {
                    fmt.Printf("[round %d] running %s\n", r, p)
                }
            }

        - id: v6
          title: Sum Until Threshold
          description: >-
            Starting from 1, keep adding numbers to a running sum. Stop as soon as the
            sum exceeds 100. Print the final sum and which number pushed it over.
          hints:
            - "Use a <code>for</code> loop with no condition (infinite loop) and <code>break</code>"
            - "Or use <code>for sum &lt;= 100</code> as the condition"
          solution: |-
            sum := 0
            n := 0
            for sum <= 100 {
                n++
                sum += n
            }
            fmt.Printf("sum=%d, pushed over by %d\n", sum, n)

        - id: v7
          title: Prime Sieve to 50
          description: >-
            Print all prime numbers up to 50. For each candidate, check divisibility
            against all numbers from 2 to its square root. Use a labeled outer loop
            or a helper boolean.
          hints:
            - "For each <code>n</code> from 2-50, try dividing by 2 through <code>int(math.Sqrt(float64(n)))</code>"
            - "If no divisor found, it's prime"
          solution: |-
            for n := 2; n <= 50; n++ {
                isPrime := true
                for d := 2; d*d <= n; d++ {
                    if n%d == 0 {
                        isPrime = false
                        break
                    }
                }
                if isPrime {
                    fmt.Println(n)
                }
            }

        - id: v8
          title: Binary Search Steps
          description: >-
            Simulate binary search for the value 37 in a sorted slice
            <code>data := []int{2, 5, 11, 19, 23, 37, 42, 58, 61, 79}</code>.
            Print each step showing <code>lo</code>, <code>hi</code>, and <code>mid</code>.
            Stop when you find it or <code>lo > hi</code>.
          hints:
            - "Start <code>lo, hi := 0, len(data)-1</code>, compute <code>mid := (lo+hi)/2</code>"
            - "If <code>data[mid] &lt; target</code>, set <code>lo = mid+1</code>; if greater, <code>hi = mid-1</code>"
          solution: |-
            data := []int{2, 5, 11, 19, 23, 37, 42, 58, 61, 79}
            target := 37
            lo, hi := 0, len(data)-1
            for lo <= hi {
                mid := (lo + hi) / 2
                fmt.Printf("lo=%d hi=%d mid=%d val=%d\n", lo, hi, mid, data[mid])
                if data[mid] == target {
                    fmt.Printf("found at index %d\n", mid)
                    break
                } else if data[mid] < target {
                    lo = mid + 1
                } else {
                    hi = mid - 1
                }
            }

        - id: v9
          title: Collatz Sequence
          description: >-
            Print the Collatz sequence starting from 27. If <code>n</code> is even, halve it;
            if odd, compute <code>3*n + 1</code>. Stop when <code>n</code> reaches 1.
            Also count the total steps.
          hints:
            - "Use <code>for n != 1</code> as the loop condition"
            - "Even check: <code>n % 2 == 0</code>"
          solution: |-
            n := 27
            steps := 0
            for n != 1 {
                fmt.Println(n)
                if n%2 == 0 {
                    n = n / 2
                } else {
                    n = 3*n + 1
                }
                steps++
            }
            fmt.Printf("1 (reached in %d steps)\n", steps)

        - id: v10
          title: Powers of Two Table
          description: >-
            Print a table of powers of 2 from 2^0 to 2^15, formatted as
            <code>"2^0  = 1"</code>, <code>"2^1  = 2"</code>, etc. Use bit shifting
            (<code>1 &lt;&lt; i</code>) instead of <code>math.Pow</code>.
          hints:
            - "Use <code>1 &lt;&lt; i</code> for 2^i — it's an integer operation, no floats needed"
            - "Format with <code>fmt.Printf(\"2^%-2d = %d\\n\", i, 1&lt;&lt;i)</code>"
          solution: |-
            for i := 0; i <= 15; i++ {
                fmt.Printf("2^%-2d = %d\n", i, 1<<i)
            }

        - id: v11
          title: Log Rotation
          description: >-
            Given <code>logs := []string{"app.log", "app.log.1", "app.log.2", "app.log.3"}</code>,
            simulate log rotation: print each log being renamed to the next number (app.log.3 deleted,
            app.log.2 → app.log.3, etc.). Iterate the slice in reverse.
          hints:
            - "Loop from <code>len(logs)-1</code> down to 0"
            - "Use index-based access: <code>logs[i]</code>"
          solution: |-
            logs := []string{"app.log", "app.log.1", "app.log.2", "app.log.3"}
            for i := len(logs) - 1; i >= 0; i-- {
                if i == len(logs)-1 {
                    fmt.Printf("delete %s\n", logs[i])
                } else {
                    fmt.Printf("rename %s -> %s\n", logs[i], logs[i+1])
                }
            }

        - id: v12
          title: Pagination Display
          description: >-
            Given 47 total items and a page size of 10, print the item range for each page:
            <code>"Page 1: items 1-10"</code>, <code>"Page 2: items 11-20"</code>, etc.
            The last page may have fewer items.
          hints:
            - "Loop while <code>start &lt;= total</code>, incrementing by pageSize"
            - "Clamp <code>end</code> with <code>if end > total { end = total }</code>"
          solution: |-
            total := 47
            pageSize := 10
            page := 1
            for start := 1; start <= total; start += pageSize {
                end := start + pageSize - 1
                if end > total {
                    end = total
                }
                fmt.Printf("Page %d: items %d-%d\n", page, start, end)
                page++
            }

        - id: v13
          title: Diamond Pattern
          description: >-
            Print a diamond pattern of stars with a max width of 7 (rows have 1, 3, 5, 7, 5, 3, 1 stars).
            Center each row with leading spaces. Use two loops — one expanding, one contracting.
          hints:
            - "For the top half: stars = 2*row - 1, spaces = (7 - stars) / 2"
            - "The bottom half mirrors the top — loop from maxWidth-2 down to 1, step 2"
          solution: |-
            maxWidth := 7
            for stars := 1; stars <= maxWidth; stars += 2 {
                spaces := (maxWidth - stars) / 2
                for s := 0; s < spaces; s++ {
                    fmt.Print(" ")
                }
                for st := 0; st < stars; st++ {
                    fmt.Print("*")
                }
                fmt.Println()
            }
            for stars := maxWidth - 2; stars >= 1; stars -= 2 {
                spaces := (maxWidth - stars) / 2
                for s := 0; s < spaces; s++ {
                    fmt.Print(" ")
                }
                for st := 0; st < stars; st++ {
                    fmt.Print("*")
                }
                fmt.Println()
            }

    # ── warmup_2: If/Else ────────────────────────────────────────────────
    - id: warmup_2
      concept: If/Else
      variants:
        - id: v1
          title: Privileged Port Check
          description: >-
            Write a function that takes a port number and returns <code>"privileged"</code>
            if below 1024, or <code>"unprivileged"</code> otherwise.
          hints:
            - "Use <code>if port &lt; 1024</code>"
          solution: |-
            func checkPort(port int) string {
                if port < 1024 {
                    return "privileged"
                }
                return "unprivileged"
            }

        - id: v2
          title: HTTP Status Classifier
          description: >-
            Write a function that classifies an HTTP status code: <code>"info"</code> for 100-199,
            <code>"success"</code> for 200-299, <code>"redirect"</code> for 300-399,
            <code>"client error"</code> for 400-499, <code>"server error"</code> for 500-599.
          hints:
            - "Use <code>if/else if</code> chains checking ranges"
            - "Check <code>code >= 200 && code &lt;= 299</code> etc."
          solution: |-
            func classifyHTTP(code int) string {
                if code >= 100 && code <= 199 {
                    return "info"
                } else if code >= 200 && code <= 299 {
                    return "success"
                } else if code >= 300 && code <= 399 {
                    return "redirect"
                } else if code >= 400 && code <= 499 {
                    return "client error"
                } else if code >= 500 && code <= 599 {
                    return "server error"
                }
                return "unknown"
            }

        - id: v3
          title: FizzBuzz
          description: >-
            Print numbers 1 to 20. For multiples of 3 print <code>"Fizz"</code>, for multiples
            of 5 print <code>"Buzz"</code>, for both print <code>"FizzBuzz"</code>.
          hints:
            - "Check divisible-by-15 first (both 3 and 5)"
            - "Use <code>i % 3 == 0</code> and <code>i % 5 == 0</code>"
          solution: |-
            for i := 1; i <= 20; i++ {
                if i%15 == 0 {
                    fmt.Println("FizzBuzz")
                } else if i%3 == 0 {
                    fmt.Println("Fizz")
                } else if i%5 == 0 {
                    fmt.Println("Buzz")
                } else {
                    fmt.Println(i)
                }
            }

        - id: v4
          title: Server Temp Alert
          description: >-
            Write a function that takes a CPU temperature (Celsius) and returns
            <code>"normal"</code> (below 60), <code>"warm"</code> (60-79),
            <code>"hot"</code> (80-94), or <code>"critical"</code> (95+).
          hints:
            - "Use <code>if/else if</code> from highest threshold down, or lowest up"
          solution: |-
            func tempAlert(temp int) string {
                if temp >= 95 {
                    return "critical"
                } else if temp >= 80 {
                    return "hot"
                } else if temp >= 60 {
                    return "warm"
                }
                return "normal"
            }

        - id: v5
          title: Password Strength
          description: >-
            Write a function that rates a password: <code>"weak"</code> if shorter than 6 chars,
            <code>"fair"</code> if 6-9 chars, <code>"strong"</code> if 10-15 chars,
            <code>"very strong"</code> if over 15 chars.
          hints:
            - "Use <code>len(password)</code> to get the length"
            - "Chain <code>if/else if</code> from shortest to longest"
          solution: |-
            func passwordStrength(password string) string {
                n := len(password)
                if n < 6 {
                    return "weak"
                } else if n <= 9 {
                    return "fair"
                } else if n <= 15 {
                    return "strong"
                }
                return "very strong"
            }

        - id: v6
          title: Git Merge Decision
          description: >-
            Write a function that decides a merge strategy given <code>behindMain int</code>
            and <code>hasConflicts bool</code>. Return <code>"fast-forward"</code> if behind is 0
            and no conflicts, <code>"rebase"</code> if behind > 0 but no conflicts,
            <code>"manual merge"</code> if there are conflicts.
          hints:
            - "Check <code>hasConflicts</code> first — it always means manual"
            - "Then check <code>behindMain == 0</code> for fast-forward"
          solution: |-
            func mergeStrategy(behindMain int, hasConflicts bool) string {
                if hasConflicts {
                    return "manual merge"
                }
                if behindMain == 0 {
                    return "fast-forward"
                }
                return "rebase"
            }

        - id: v7
          title: Tax Bracket Calculator
          description: >-
            Write a function that returns the US tax rate for a given income:
            10% for $0-$11,000, 12% for $11,001-$44,725, 22% for $44,726-$95,375,
            24% for $95,376-$182,100, 32% above that. Return the rate as an int.
          hints:
            - "Use <code>if/else if</code> from highest bracket down"
            - "Compare <code>income > 182100</code> first, then descend"
          solution: |-
            func taxRate(income int) int {
                if income > 182100 {
                    return 32
                } else if income > 95375 {
                    return 24
                } else if income > 44725 {
                    return 22
                } else if income > 11000 {
                    return 12
                }
                return 10
            }

        - id: v8
          title: Container Resource Check
          description: >-
            Write a function that checks container resource requests. Given <code>cpuMilli int</code>
            and <code>memMB int</code>, return <code>"ok"</code> if CPU ≤ 4000 and mem ≤ 8192,
            <code>"cpu exceeded"</code> if only CPU is over, <code>"mem exceeded"</code> if only
            memory is over, or <code>"both exceeded"</code>.
          hints:
            - "Check both conditions and combine with <code>&&</code> and <code>||</code>"
            - "Or use two booleans: <code>cpuOver := cpuMilli > 4000</code>"
          solution: |-
            func checkResources(cpuMilli, memMB int) string {
                cpuOver := cpuMilli > 4000
                memOver := memMB > 8192
                if cpuOver && memOver {
                    return "both exceeded"
                } else if cpuOver {
                    return "cpu exceeded"
                } else if memOver {
                    return "mem exceeded"
                }
                return "ok"
            }

        - id: v9
          title: Leap Year Check
          description: >-
            Write a function that returns <code>true</code> if a year is a leap year.
            A year is a leap year if divisible by 4, except centuries — unless also divisible by 400.
          hints:
            - "Divisible by 400 → leap. Divisible by 100 → not leap. Divisible by 4 → leap."
            - "Order matters — check the most specific rule first"
          solution: |-
            func isLeapYear(year int) bool {
                if year%400 == 0 {
                    return true
                }
                if year%100 == 0 {
                    return false
                }
                return year%4 == 0
            }

        - id: v10
          title: Validate Config Line
          description: >-
            Write a function that validates a config line string. Return <code>"empty"</code>
            if blank, <code>"comment"</code> if it starts with <code>#</code>,
            <code>"invalid"</code> if it doesn't contain <code>=</code>, or
            <code>"ok"</code> otherwise.
          hints:
            - "Use <code>strings.HasPrefix</code> and <code>strings.Contains</code>"
            - "Check empty first, then comment, then missing ="
          solution: |-
            func validateConfigLine(line string) string {
                if line == "" {
                    return "empty"
                }
                if strings.HasPrefix(line, "#") {
                    return "comment"
                }
                if !strings.Contains(line, "=") {
                    return "invalid"
                }
                return "ok"
            }

        - id: v11
          title: Timezone Offset Validator
          description: >-
            Write a function that validates a UTC offset (hours). Return <code>"invalid"</code>
            if outside -12 to +14, <code>"behind UTC"</code> if negative, <code>"UTC"</code>
            if zero, <code>"ahead of UTC"</code> if positive.
          hints:
            - "Check bounds first to reject invalid, then check sign"
          solution: |-
            func classifyOffset(hours int) string {
                if hours < -12 || hours > 14 {
                    return "invalid"
                }
                if hours < 0 {
                    return "behind UTC"
                }
                if hours == 0 {
                    return "UTC"
                }
                return "ahead of UTC"
            }

        - id: v12
          title: Poker Hand Rank
          description: >-
            Write a function that takes <code>pairs int</code>, <code>threeOfKind bool</code>,
            and <code>flush bool</code>, and returns the hand rank: <code>"flush"</code> if flush
            is true (highest priority), <code>"full house"</code> if one pair and three-of-a-kind,
            <code>"three of a kind"</code>, <code>"two pair"</code> if pairs == 2,
            <code>"pair"</code> if pairs == 1, or <code>"high card"</code>.
          hints:
            - "Check flush first — it beats everything else here"
            - "Then check combinations of pairs and threeOfKind"
          solution: |-
            func handRank(pairs int, threeOfKind, flush bool) string {
                if flush {
                    return "flush"
                }
                if pairs == 1 && threeOfKind {
                    return "full house"
                }
                if threeOfKind {
                    return "three of a kind"
                }
                if pairs == 2 {
                    return "two pair"
                }
                if pairs == 1 {
                    return "pair"
                }
                return "high card"
            }

        - id: v13
          title: Traffic Light State Machine
          description: >-
            Write a function that takes the current light color and seconds elapsed, and returns
            the next state. Green lasts 30s, yellow 5s, red 20s. If time is up, return the next
            color; otherwise return the same color. Cycle: green → yellow → red → green.
          hints:
            - "Use a switch on the current color, check if elapsed >= duration"
            - "If time isn't up yet, return the same color"
          solution: |-
            func nextLight(color string, elapsed int) string {
                switch color {
                case "green":
                    if elapsed >= 30 {
                        return "yellow"
                    }
                case "yellow":
                    if elapsed >= 5 {
                        return "red"
                    }
                case "red":
                    if elapsed >= 20 {
                        return "green"
                    }
                }
                return color
            }

    # ── warmup_3: Variables & Assignment ──────────────────────────────────
    - id: warmup_3
      concept: Variables & Assignment
      variants:
        - id: v1
          title: Zero Values
          description: >-
            Declare an <code>int</code>, a <code>string</code>, and a <code>bool</code> using
            <code>var</code> without assigning values. Print all three to see Go's zero values.
          hints:
            - "Use <code>var n int</code>, <code>var s string</code>, <code>var b bool</code>"
            - "Zero values are 0, \"\", and false"
          solution: |-
            var n int
            var s string
            var b bool
            fmt.Println(n, s, b)

        - id: v2
          title: Short Declaration
          description: >-
            Use short declarations (<code>:=</code>) to create a string, an int, and a float64
            in one line each. Print them with their types using <code>%T</code>.
          hints:
            - "Use <code>name := \"gopher\"</code> — Go infers the type"
            - "Print type with <code>fmt.Printf(\"%T: %v\\n\", name, name)</code>"
          solution: |-
            name := "gopher"
            count := 42
            ratio := 3.14
            fmt.Printf("%T: %v\n", name, name)
            fmt.Printf("%T: %v\n", count, count)
            fmt.Printf("%T: %v\n", ratio, ratio)

        - id: v3
          title: Multi-Assignment Swap
          description: >-
            Declare <code>a := 10</code> and <code>b := 20</code>. Swap them using Go's
            parallel assignment (<code>a, b = b, a</code>) — no temp variable needed. Print before and after.
          hints:
            - "Go evaluates the right side fully before assigning to the left"
          solution: |-
            a, b := 10, 20
            fmt.Println("before:", a, b)
            a, b = b, a
            fmt.Println("after:", a, b)

        - id: v4
          title: Shadowing Trap
          description: >-
            Read this code carefully and predict the output without running it:<br>
            <code>x := 10</code><br>
            <code>if true {</code><br>
            <code>&nbsp;&nbsp;x := x + 5</code><br>
            <code>&nbsp;&nbsp;x = x * 2</code><br>
            <code>}</code><br>
            <code>fmt.Println(x)</code><br>
            Write the code and confirm: the answer is 10 because <code>:=</code> in the inner
            block creates a new variable.
          hints:
            - "The inner <code>:=</code> creates a NEW x that shadows the outer one"
            - "The outer x is never modified — it stays 10"
          solution: |-
            x := 10
            if true {
                x := x + 5
                x = x * 2
                _ = x // 30, but scoped to this block
            }
            fmt.Println(x) // 10

        - id: v5
          title: Constants with iota
          description: >-
            Define log level constants using <code>iota</code>: <code>DEBUG = 0</code>,
            <code>INFO = 1</code>, <code>WARN = 2</code>, <code>ERROR = 3</code>.
            Print each constant with its value.
          hints:
            - "Use a <code>const ( ... )</code> block with <code>iota</code>"
            - "<code>iota</code> starts at 0 and increments by 1 for each constant"
          solution: |-
            const (
                DEBUG = iota
                INFO
                WARN
                ERROR
            )
            fmt.Println("DEBUG:", DEBUG)
            fmt.Println("INFO:", INFO)
            fmt.Println("WARN:", WARN)
            fmt.Println("ERROR:", ERROR)

        - id: v6
          title: Blank Identifier
          description: >-
            Call <code>fmt.Println("hello")</code> which returns <code>(n int, err error)</code>.
            Use the blank identifier <code>_</code> to discard both return values.
            Then call it again keeping only <code>n</code> and discarding the error.
          hints:
            - "Use <code>_, _ = fmt.Println(\"hello\")</code> to discard both"
            - "Use <code>n, _ := fmt.Println(\"world\")</code> to keep n"
          solution: |-
            _, _ = fmt.Println("hello")
            n, _ := fmt.Println("world")
            fmt.Println("bytes written:", n)

        - id: v7
          title: Type Inference Chain
          description: >-
            Demonstrate type inference: assign <code>42</code> to a variable (inferred as int),
            then compute <code>float64(x) / 7.0</code> and assign to a new variable.
            Print both variables and their types with <code>%T</code>.
          hints:
            - "Integer division vs float division: <code>42/7</code> is 6, <code>float64(42)/7.0</code> is 6.0"
          solution: |-
            x := 42
            y := float64(x) / 7.0
            fmt.Printf("x: %T = %v\n", x, x)
            fmt.Printf("y: %T = %v\n", y, y)

        - id: v8
          title: Multiple Return Capture
          description: >-
            Use <code>strconv.Atoi("123")</code> to parse a string to int. Capture both the
            value and the error. Print the value if successful, or the error if not.
            Then try parsing <code>"abc"</code>.
          hints:
            - "<code>strconv.Atoi</code> returns <code>(int, error)</code>"
            - "Check <code>if err != nil</code> before using the value"
          solution: |-
            n, err := strconv.Atoi("123")
            if err != nil {
                fmt.Println("error:", err)
            } else {
                fmt.Println("parsed:", n)
            }
            n2, err2 := strconv.Atoi("abc")
            if err2 != nil {
                fmt.Println("error:", err2)
            } else {
                fmt.Println("parsed:", n2)
            }

        - id: v9
          title: Untyped Constants
          description: >-
            Define an untyped constant <code>const pi = 3.14159</code>. Show that it can be
            used in both <code>float64</code> and <code>float32</code> contexts without explicit
            conversion. Assign it to a <code>float32</code> variable and print both.
          hints:
            - "Untyped constants adapt to the type they're assigned to"
            - "Use <code>var f32 float32 = pi</code>"
          solution: |-
            const pi = 3.14159
            var f64 float64 = pi
            var f32 float32 = pi
            fmt.Printf("float64: %v\n", f64)
            fmt.Printf("float32: %v\n", f32)

        - id: v10
          title: Block Scoping
          description: >-
            Demonstrate block scoping: declare <code>x := "outer"</code>, then inside an
            <code>if true { }</code> block declare <code>y := "inner"</code> and print both.
            After the block, show that <code>y</code> is no longer accessible by printing
            only <code>x</code>.
          hints:
            - "Variables declared inside a block are only visible inside that block"
            - "Trying to use <code>y</code> outside would be a compile error"
          solution: |-
            x := "outer"
            if true {
                y := "inner"
                fmt.Println(x, y) // both accessible
            }
            fmt.Println(x) // y is not accessible here

        - id: v11
          title: Multiple Short Declaration
          description: >-
            Use a single short declaration to assign three variables at once:
            <code>host, port, protocol := "localhost", 8080, "https"</code>.
            Then reassign <code>port</code> and add a new variable <code>path</code> using
            <code>port, path := 9090, "/api"</code> (valid because path is new).
          hints:
            - "<code>:=</code> is valid as long as at least one variable on the left is new"
            - "This is a common pattern for error handling: <code>val, err := ...</code>"
          solution: |-
            host, port, protocol := "localhost", 8080, "https"
            fmt.Println(host, port, protocol)
            port, path := 9090, "/api"
            fmt.Println(port, path)

        - id: v12
          title: Byte and Rune Literals
          description: >-
            Assign the character <code>'A'</code> to a variable and print its type (it's a <code>rune</code>,
            aka <code>int32</code>). Then assign <code>byte('A')</code> and print its type (<code>uint8</code>).
            Show the numeric values of both.
          hints:
            - "Character literals like <code>'A'</code> are runes (int32) in Go"
            - "Use <code>byte('A')</code> to get the uint8 value"
          solution: |-
            r := 'A'
            b := byte('A')
            fmt.Printf("rune: %T = %v (%c)\n", r, r, r)
            fmt.Printf("byte: %T = %v (%c)\n", b, b, b)

        - id: v13
          title: Enum with String Method
          description: >-
            Define a <code>Season</code> type based on <code>int</code> with constants
            <code>Spring, Summer, Autumn, Winter</code> using <code>iota</code>. Create a
            <code>String()</code> method that returns the name. Print each season.
          hints:
            - "Use a <code>switch</code> inside the String method"
            - "This makes your enum printable with <code>fmt.Println</code>"
          solution: |-
            type Season int
            const (
                Spring Season = iota
                Summer
                Autumn
                Winter
            )
            func (s Season) String() string {
                switch s {
                case Spring:
                    return "Spring"
                case Summer:
                    return "Summer"
                case Autumn:
                    return "Autumn"
                case Winter:
                    return "Winter"
                }
                return "Unknown"
            }

    # ── warmup_4: Multiple Returns ───────────────────────────────────────
    - id: warmup_4
      concept: Multiple Returns
      variants:
        - id: v1
          title: Safe Divide
          description: >-
            Write a function that divides two integers and returns the result and an error.
            Return an error if the divisor is zero.
          hints:
            - "Check <code>if b == 0</code> and return <code>0, fmt.Errorf(\"division by zero\")</code>"
          solution: |-
            func safeDivide(a, b int) (int, error) {
                if b == 0 {
                    return 0, fmt.Errorf("division by zero")
                }
                return a / b, nil
            }

        - id: v2
          title: Min and Max
          description: >-
            Write a function that takes a slice of ints and returns both the minimum and
            maximum values.
          hints:
            - "Initialize min and max to the first element"
            - "Loop through the rest, updating as needed"
          solution: |-
            func minMax(nums []int) (int, int) {
                min, max := nums[0], nums[0]
                for _, n := range nums[1:] {
                    if n < min {
                        min = n
                    }
                    if n > max {
                        max = n
                    }
                }
                return min, max
            }

        - id: v3
          title: Head and Tail
          description: >-
            Write a function that returns the first element and the rest of a string slice.
            Return an empty string and nil if the slice is empty.
          hints:
            - "Check <code>len(items) == 0</code> first"
            - "Return <code>items[0], items[1:]</code>"
          solution: |-
            func headTail(items []string) (string, []string) {
                if len(items) == 0 {
                    return "", nil
                }
                return items[0], items[1:]
            }

        - id: v4
          title: Parse Config Line
          description: >-
            Write a function that splits a <code>"key=value"</code> string and returns
            both parts. Return an error if there's no <code>=</code> sign.
          hints:
            - "Use <code>strings.Cut(line, \"=\")</code> which returns (before, after, found)"
          solution: |-
            func parseConfig(line string) (string, string, error) {
                key, value, ok := strings.Cut(line, "=")
                if !ok {
                    return "", "", fmt.Errorf("missing = in %q", line)
                }
                return key, value, nil
            }

        - id: v5
          title: Parse Host and Port
          description: >-
            Write a function that takes <code>"localhost:8080"</code> and returns the host
            as a string and port as an int. Return an error if the format is wrong or port
            isn't a valid number.
          hints:
            - "Use <code>strings.Cut</code> to split on \":\" then <code>strconv.Atoi</code> for the port"
          solution: |-
            func parseHostPort(addr string) (string, int, error) {
                host, portStr, ok := strings.Cut(addr, ":")
                if !ok {
                    return "", 0, fmt.Errorf("missing : in %q", addr)
                }
                port, err := strconv.Atoi(portStr)
                if err != nil {
                    return "", 0, fmt.Errorf("invalid port %q: %w", portStr, err)
                }
                return host, port, nil
            }

        - id: v6
          title: Validate Email
          description: >-
            Write a function that does a basic email validation: return the username and
            domain parts, or an error if there's no <code>@</code> sign or either part is empty.
          hints:
            - "Use <code>strings.Cut(email, \"@\")</code>"
            - "Check both parts are non-empty after splitting"
          solution: |-
            func validateEmail(email string) (string, string, error) {
                user, domain, ok := strings.Cut(email, "@")
                if !ok {
                    return "", "", fmt.Errorf("missing @ in %q", email)
                }
                if user == "" || domain == "" {
                    return "", "", fmt.Errorf("empty user or domain in %q", email)
                }
                return user, domain, nil
            }

        - id: v7
          title: Safe Slice Access
          description: >-
            Write a function that safely accesses a slice index, returning the value and a
            bool indicating if the index was valid. No panics on out-of-bounds.
          hints:
            - "Check <code>index &lt; 0 || index >= len(items)</code>"
            - "Return zero value and false if out of bounds"
          solution: |-
            func safeGet(items []string, index int) (string, bool) {
                if index < 0 || index >= len(items) {
                    return "", false
                }
                return items[index], true
            }

        - id: v8
          title: Parse Hex Color
          description: >-
            Write a function that takes a hex color like <code>"#FF8800"</code> and returns
            R, G, B as ints (0-255) and an error. Strip the <code>#</code> prefix, then parse
            each 2-char pair with <code>strconv.ParseInt(pair, 16, 64)</code>.
          hints:
            - "Check length is 7 and starts with #"
            - "Slice pairs: <code>s[1:3]</code>, <code>s[3:5]</code>, <code>s[5:7]</code>"
          solution: |-
            func parseHex(s string) (int, int, int, error) {
                if len(s) != 7 || s[0] != '#' {
                    return 0, 0, 0, fmt.Errorf("invalid hex color %q", s)
                }
                r, err := strconv.ParseInt(s[1:3], 16, 64)
                if err != nil {
                    return 0, 0, 0, err
                }
                g, err := strconv.ParseInt(s[3:5], 16, 64)
                if err != nil {
                    return 0, 0, 0, err
                }
                b, err := strconv.ParseInt(s[5:7], 16, 64)
                if err != nil {
                    return 0, 0, 0, err
                }
                return int(r), int(g), int(b), nil
            }

        - id: v9
          title: Extract Domain
          description: >-
            Write a function that extracts the domain from a URL like
            <code>"https://news.ycombinator.com/item?id=123"</code>. Return the domain
            and the path, or an error if the URL doesn't start with <code>http</code>.
          hints:
            - "Strip the scheme with <code>strings.Cut</code> on <code>\"://\"</code>"
            - "Split host and path on the first <code>/</code>"
          solution: |-
            func extractDomain(url string) (string, string, error) {
                _, rest, ok := strings.Cut(url, "://")
                if !ok {
                    return "", "", fmt.Errorf("missing :// in %q", url)
                }
                domain, path, _ := strings.Cut(rest, "/")
                return domain, "/" + path, nil
            }

        - id: v10
          title: Convert Temperature
          description: >-
            Write a function that converts between Celsius and Fahrenheit. Takes a value
            and a unit string (<code>"C"</code> or <code>"F"</code>). Returns the converted
            value, the new unit, and an error for unknown units.
          hints:
            - "C to F: <code>value*9/5 + 32</code>, F to C: <code>(value-32) * 5/9</code>"
          solution: |-
            func convertTemp(value float64, unit string) (float64, string, error) {
                switch unit {
                case "C":
                    return value*9/5 + 32, "F", nil
                case "F":
                    return (value - 32) * 5 / 9, "C", nil
                default:
                    return 0, "", fmt.Errorf("unknown unit %q", unit)
                }
            }

        - id: v11
          title: Parse Log Level
          description: >-
            Write a function that parses a log line like <code>"[ERROR] disk full"</code> into
            the level and the message. Return an error if the line doesn't start with <code>[</code>
            or doesn't contain <code>]</code>.
          hints:
            - "Find <code>]</code> with <code>strings.Index</code>"
            - "Level is between <code>[</code> and <code>]</code>, message is the rest trimmed"
          solution: |-
            func parseLog(line string) (string, string, error) {
                if len(line) == 0 || line[0] != '[' {
                    return "", "", fmt.Errorf("missing [ prefix")
                }
                end := strings.Index(line, "]")
                if end == -1 {
                    return "", "", fmt.Errorf("missing ] in %q", line)
                }
                level := line[1:end]
                msg := strings.TrimSpace(line[end+1:])
                return level, msg, nil
            }

        - id: v12
          title: Parse CLI Flag
          description: >-
            Write a function that parses a CLI flag like <code>"--port=8080"</code> into the
            flag name and value. Support both <code>--flag=value</code> and <code>-flag=value</code>.
            Return an error if no <code>=</code> or doesn't start with <code>-</code>.
          hints:
            - "Strip leading dashes, then split on <code>=</code>"
          solution: |-
            func parseFlag(arg string) (string, string, error) {
                if !strings.HasPrefix(arg, "-") {
                    return "", "", fmt.Errorf("not a flag: %q", arg)
                }
                trimmed := strings.TrimLeft(arg, "-")
                name, value, ok := strings.Cut(trimmed, "=")
                if !ok {
                    return "", "", fmt.Errorf("missing = in flag %q", arg)
                }
                return name, value, nil
            }

        - id: v13
          title: Validate and Parse JWT Header
          description: >-
            Write a function that takes a simplified JWT-like string <code>"header.payload.signature"</code>
            and returns all three parts. Return an error if there aren't exactly 3 parts
            separated by dots, or if any part is empty.
          hints:
            - "Use <code>strings.Split(token, \".\")</code> and check <code>len(parts) == 3</code>"
            - "Check each part isn't empty"
          solution: |-
            func parseJWT(token string) (string, string, string, error) {
                parts := strings.Split(token, ".")
                if len(parts) != 3 {
                    return "", "", "", fmt.Errorf("expected 3 parts, got %d", len(parts))
                }
                if parts[0] == "" || parts[1] == "" || parts[2] == "" {
                    return "", "", "", fmt.Errorf("empty segment in token")
                }
                return parts[0], parts[1], parts[2], nil
            }

  challenges:
    # ── challenge_1: Variable Declaration ────────────────────────────────
    - id: challenge_1
      block: 1
      difficulty: 1
      concept: Variable Declaration
      docLinks:
        - url: https://go.dev/tour/basics/9
          title: "Go Tour: Short variable declarations"
          note: := syntax
        - url: https://go.dev/ref/spec#Short_variable_declarations
          title: "Go Spec: Short variable declarations"
          note: specification details
      variants:
        - id: v1
          title: HTTP Method Enum
          description: >-
            Write <code>func httpMethod(code int) string</code> that maps
            iota constants to HTTP method names. Define constants
            <code>GET = iota, POST, PUT, DELETE, PATCH</code> and return
            the matching string. Return <code>"UNKNOWN"</code> for invalid codes.
          functionSignature: func httpMethod(code int) string
          difficulty: 1
          testCases:
            - input: "httpMethod(0)"
              output: "GET"
            - input: "httpMethod(1)"
              output: "POST"
            - input: "httpMethod(4)"
              output: "PATCH"
            - input: "httpMethod(99)"
              output: "UNKNOWN"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                How would you define a group of related integer constants
                that auto-increment from zero?
            - title: "\U0001F4A1 Hint"
              content: >-
                Use a <code>const ( ... )</code> block with <code>iota</code>,
                then <code>switch</code> on the code parameter.
          solution: |-
            const (
                GET = iota
                POST
                PUT
                DELETE
                PATCH
            )

            func httpMethod(code int) string {
                switch code {
                case GET:
                    return "GET"
                case POST:
                    return "POST"
                case PUT:
                    return "PUT"
                case DELETE:
                    return "DELETE"
                case PATCH:
                    return "PATCH"
                }
                return "UNKNOWN"
            }
          annotations:
            - type: idiom
              label: Iota Enums
              text: >-
                Go uses <code>iota</code> inside <code>const</code> blocks to create
                auto-incrementing integer constants — the idiomatic way to define enums.

        - id: v2
          title: Log Level Priority
          description: >-
            Write <code>func logPriority(level int) string</code> that returns
            a priority label for log level constants defined with iota:
            <code>TRACE, DEBUG, INFO, WARN, ERROR, FATAL</code>. Return
            <code>"low"</code> for TRACE/DEBUG, <code>"medium"</code> for INFO/WARN,
            <code>"high"</code> for ERROR/FATAL.
          functionSignature: func logPriority(level int) string
          difficulty: 1
          testCases:
            - input: "logPriority(0)"
              output: "low"
            - input: "logPriority(2)"
              output: "medium"
            - input: "logPriority(4)"
              output: "high"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                Can you group iota values by range instead of checking
                each one individually?
            - title: "\U0001F4A1 Hint"
              content: >-
                Use <code>if level &lt;= DEBUG</code> for low,
                <code>level &lt;= WARN</code> for medium, etc.
          solution: |-
            const (
                TRACE = iota
                DEBUG
                INFO
                WARN
                ERROR
                FATAL
            )

            func logPriority(level int) string {
                if level <= DEBUG {
                    return "low"
                }
                if level <= WARN {
                    return "medium"
                }
                return "high"
            }
          annotations:
            - type: pattern
              label: Range Grouping
              text: >-
                Instead of switching on every constant, group iota values
                by range — this scales better when new levels are added.

        - id: v3
          title: Unix File Permission Bits
          description: >-
            Write <code>func describePermission(perm int) string</code> using
            iota with bit-shifting: <code>Read = 1 &lt;&lt; iota, Write, Execute</code>.
            Return a string like <code>"r-x"</code> based on which bits are set
            in the given permission integer.
          functionSignature: func describePermission(perm int) string
          difficulty: 1
          testCases:
            - input: "describePermission(5)"
              output: "r-x"
            - input: "describePermission(7)"
              output: "rwx"
            - input: "describePermission(0)"
              output: "---"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                How do you check if a specific bit is set in an integer?
            - title: "\U0001F4A1 Hint"
              content: >-
                Use bitwise AND: <code>if perm&Read != 0</code> means the
                read bit is set. Build the string character by character.
          solution: |-
            const (
                Read    = 1 << iota // 1
                Write               // 2
                Execute             // 4
            )

            func describePermission(perm int) string {
                result := ""
                if perm&Read != 0 {
                    result += "r"
                } else {
                    result += "-"
                }
                if perm&Write != 0 {
                    result += "w"
                } else {
                    result += "-"
                }
                if perm&Execute != 0 {
                    result += "x"
                } else {
                    result += "-"
                }
                return result
            }
          annotations:
            - type: idiom
              label: Bit Flag Enums
              text: >-
                Using <code>1 &lt;&lt; iota</code> creates powers of two, perfect
                for bit flags that can be combined with bitwise OR.

        - id: v4
          title: Shadowing Detector
          description: >-
            Write <code>func shadowTest() (int, int)</code> that demonstrates
            variable shadowing. Declare <code>x := 10</code>, then inside a block
            declare <code>x := 20</code>. Return the inner x and the outer x
            (after the block closes). The function should return <code>(20, 10)</code>.
          functionSignature: func shadowTest() (int, int)
          difficulty: 1
          testCases:
            - input: "shadowTest()"
              output: "(20, 10)"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                What happens when you use <code>:=</code> inside a new block
                for a variable that already exists in the outer scope?
            - title: "\U0001F4A1 Hint"
              content: >-
                Capture the inner value in a separate variable before the
                block closes, since the shadowed x disappears after the block.
          solution: |-
            func shadowTest() (int, int) {
                x := 10
                var inner int
                {
                    x := 20
                    inner = x
                }
                return inner, x
            }
          annotations:
            - type: gotcha
              label: Variable Shadowing
              text: >-
                Using <code>:=</code> inside a block creates a new variable that
                shadows the outer one. The outer variable is unchanged — this is
                a common source of bugs.

        - id: v5
          title: Zero Value Inventory
          description: >-
            Write <code>func zeroValues() (int, float64, string, bool)</code>
            that declares four variables using <code>var</code> without
            initialization and returns them. This demonstrates Go's zero
            value guarantee.
          functionSignature: func zeroValues() (int, float64, string, bool)
          difficulty: 1
          testCases:
            - input: "zeroValues()"
              output: "(0, 0, \"\", false)"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                What value does Go assign to a variable if you don't
                explicitly initialize it?
            - title: "\U0001F4A1 Hint"
              content: >-
                Use <code>var n int</code>, <code>var f float64</code>, etc.
                Go guarantees every type has a usable zero value.
          solution: |-
            func zeroValues() (int, float64, string, bool) {
                var n int
                var f float64
                var s string
                var b bool
                return n, f, s, b
            }
          annotations:
            - type: idiom
              label: Zero Values
              text: >-
                Go initializes every variable to its zero value: 0 for numbers,
                "" for strings, false for bools, nil for pointers/slices/maps.
                This eliminates uninitialized variable bugs.

        - id: v6
          title: Multi-Assignment Swap
          description: >-
            Write <code>func multiSwap(a, b, c int) (int, int, int)</code> that
            rotates three values: a gets b's value, b gets c's, c gets a's.
            Use Go's parallel assignment to do it in one line.
          functionSignature: func multiSwap(a, b, c int) (int, int, int)
          difficulty: 2
          testCases:
            - input: "multiSwap(1, 2, 3)"
              output: "(2, 3, 1)"
            - input: "multiSwap(10, 20, 30)"
              output: "(20, 30, 10)"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                Go evaluates the entire right side of an assignment before
                assigning to the left. How does that help with swapping?
            - title: "\U0001F4A1 Hint"
              content: >-
                Use <code>a, b, c = b, c, a</code> — Go evaluates b, c, a
                first (using original values), then assigns all at once.
          solution: |-
            func multiSwap(a, b, c int) (int, int, int) {
                a, b, c = b, c, a
                return a, b, c
            }
          annotations:
            - type: idiom
              label: Parallel Assignment
              text: >-
                Go's parallel assignment evaluates the right side completely
                before any assignment, making multi-variable swaps clean
                and safe without temporary variables.

        - id: v7
          title: Const Block with Byte Sizes
          description: >-
            Write <code>func byteSize(unit int) string</code> that uses a
            const block with iota and bit-shifting to define
            <code>_ = iota; KB = 1 &lt;&lt; (10 * iota); MB; GB; TB</code>.
            Return a string describing the byte count for the given unit constant.
          functionSignature: func byteSize(unit int) string
          difficulty: 2
          testCases:
            - input: "byteSize(1)"
              output: "1024"
            - input: "byteSize(2)"
              output: "1048576"
            - input: "byteSize(3)"
              output: "1073741824"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                How can you use <code>iota</code> with multiplication inside
                a bit-shift expression to create powers of 1024?
            - title: "\U0001F4A1 Hint"
              content: >-
                Use <code>1 &lt;&lt; (10 * iota)</code> — when iota=1 you get
                1024 (KB), iota=2 gives 1048576 (MB), etc.
          solution: |-
            const (
                _  = iota
                KB = 1 << (10 * iota)
                MB
                GB
                TB
            )

            func byteSize(unit int) string {
                sizes := map[int]int{1: KB, 2: MB, 3: GB, 4: TB}
                if v, ok := sizes[unit]; ok {
                    return fmt.Sprintf("%d", v)
                }
                return "unknown"
            }
          annotations:
            - type: idiom
              label: Iota Expressions
              text: >-
                You can use arbitrary expressions with iota. The pattern
                <code>1 &lt;&lt; (10 * iota)</code> is the standard way to define
                byte size constants in Go.

        - id: v8
          title: Type Alias for Domain Modeling
          description: >-
            Write <code>func categorize(status Status) string</code> where
            <code>Status</code> is a custom type based on <code>int</code>.
            Define constants <code>Pending, Active, Suspended, Closed Status = iota, ...</code>.
            Return <code>"open"</code> for Pending/Active, <code>"closed"</code> for
            Suspended/Closed.
          functionSignature: func categorize(status Status) string
          difficulty: 2
          testCases:
            - input: "categorize(Pending)"
              output: "open"
            - input: "categorize(Active)"
              output: "open"
            - input: "categorize(Suspended)"
              output: "closed"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                What's the difference between <code>type Status int</code>
                and just using a bare <code>int</code>?
            - title: "\U0001F4A1 Hint"
              content: >-
                A type definition creates a distinct type — you can't accidentally
                pass a random int where a Status is expected.
          solution: |-
            type Status int

            const (
                Pending Status = iota
                Active
                Suspended
                Closed
            )

            func categorize(status Status) string {
                switch status {
                case Pending, Active:
                    return "open"
                case Suspended, Closed:
                    return "closed"
                }
                return "unknown"
            }
          annotations:
            - type: idiom
              label: Type Definitions
              text: >-
                Defining <code>type Status int</code> creates a new named type.
                This provides type safety — the compiler will reject mixing
                Status with plain ints.

        - id: v9
          title: Named Return Values
          description: >-
            Write <code>func divide(a, b float64) (result float64, err error)</code>
            using named return values. If b is zero, set err and use a bare
            <code>return</code>. Otherwise set result and bare return.
          functionSignature: "func divide(a, b float64) (result float64, err error)"
          difficulty: 2
          testCases:
            - input: "divide(10, 3)"
              output: "(3.3333333333333335, nil)"
            - input: "divide(10, 0)"
              output: "(0, division by zero)"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                Named return values are pre-initialized to their zero values.
                How does a bare <code>return</code> know what to return?
            - title: "\U0001F4A1 Hint"
              content: >-
                A bare <code>return</code> returns whatever the named return
                variables currently hold. Set <code>err</code> for the error
                case and <code>result</code> for the happy path.
          solution: |-
            func divide(a, b float64) (result float64, err error) {
                if b == 0 {
                    err = fmt.Errorf("division by zero")
                    return
                }
                result = a / b
                return
            }
          annotations:
            - type: idiom
              label: Named Returns
              text: >-
                Named return values document what a function returns and enable
                bare returns. Use them sparingly — they help in short functions
                but can reduce clarity in longer ones.

        - id: v10
          title: Pointer Basics
          description: >-
            Write <code>func increment(p *int)</code> that increments the integer
            pointed to by p. Also write <code>func tryIncrement(n int)</code> that
            attempts to increment but has no effect on the caller. Return both
            results to demonstrate the difference.
          functionSignature: func increment(p *int)
          difficulty: 2
          testCases:
            - input: "x := 5; increment(&x); x"
              output: "6"
            - input: "x := 5; tryIncrement(x); x"
              output: "5"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                What's the difference between passing a value and passing
                a pointer to a function?
            - title: "\U0001F4A1 Hint"
              content: >-
                Use <code>*p</code> to dereference a pointer and modify the
                underlying value. Without a pointer, the function only
                modifies a copy.
          solution: |-
            func increment(p *int) {
                *p++
            }

            func tryIncrement(n int) {
                n++
            }
          annotations:
            - type: idiom
              label: Pointer Parameters
              text: >-
                Go is pass-by-value. To modify a caller's variable, pass a pointer.
                The <code>&</code> operator takes an address, <code>*</code> dereferences it.

        - id: v11
          title: Grouped Var Declarations
          description: >-
            Write <code>func serverConfig() (string, int, bool, string)</code>
            that uses a grouped <code>var ( ... )</code> block to declare
            host (string), port (int), debug (bool), and logPath (string)
            with specific default values, then returns all four.
          functionSignature: func serverConfig() (string, int, bool, string)
          difficulty: 2
          testCases:
            - input: "serverConfig()"
              output: "(localhost, 8080, false, /var/log/app.log)"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                When would you prefer <code>var ( ... )</code> over individual
                <code>:=</code> declarations?
            - title: "\U0001F4A1 Hint"
              content: >-
                A <code>var</code> block groups related declarations together,
                making configuration-style code cleaner and more readable.
          solution: |-
            func serverConfig() (string, int, bool, string) {
                var (
                    host    string = "localhost"
                    port    int    = 8080
                    debug   bool   = false
                    logPath string = "/var/log/app.log"
                )
                return host, port, debug, logPath
            }
          annotations:
            - type: pattern
              label: Grouped Declarations
              text: >-
                Grouped <code>var</code> blocks visually associate related variables.
                They're commonly used for package-level config or when you want
                explicit types.

        - id: v12
          title: Blank Identifier Patterns
          description: >-
            Write <code>func countElements(items []string) int</code> that uses
            a range loop with the blank identifier to count elements without
            using the index or value. Also write <code>func secondElement(items []string) string</code>
            that uses the blank identifier to skip the index when ranging.
          functionSignature: func countElements(items []string) int
          difficulty: 3
          testCases:
            - input: "countElements([]string{\"a\", \"b\", \"c\"})"
              output: "3"
            - input: "secondElement([]string{\"a\", \"b\", \"c\"})"
              output: "b"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                The blank identifier <code>_</code> discards a value. When would
                you need both the index and value from range, and when would
                you discard one?
            - title: "\U0001F4A1 Hint"
              content: >-
                Use <code>for range items</code> (Go 1.22+) or
                <code>for _ = range items</code> to just count iterations.
          solution: |-
            func countElements(items []string) int {
                count := 0
                for range items {
                    count++
                }
                return count
            }

            func secondElement(items []string) string {
                for i, v := range items {
                    if i == 1 {
                        return v
                    }
                }
                return ""
            }
          annotations:
            - type: idiom
              label: Blank Identifier
              text: >-
                The blank identifier <code>_</code> tells Go you intentionally
                don't need a value. It avoids "unused variable" compile errors
                and signals intent to readers.

        - id: v13
          title: Nested Scope Chain
          description: >-
            Write <code>func scopeChain() string</code> that builds a string
            by appending values from nested scopes. Start with <code>result := ""</code>,
            then create three nested blocks. In each block, declare a new variable
            with <code>:=</code> and append it to result. Demonstrate that inner
            blocks can see outer variables but not vice versa.
          functionSignature: func scopeChain() string
          difficulty: 3
          testCases:
            - input: "scopeChain()"
              output: "level0-level1-level2"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                Each <code>{ }</code> block creates a new scope. Variables
                declared inside are invisible outside, but can the inner
                block still read and write variables from the outer scope?
            - title: "\U0001F4A1 Hint"
              content: >-
                Use <code>result</code> (without <code>:=</code>) inside inner
                blocks to modify the outer variable. Use <code>:=</code> only
                for new block-local variables.
          solution: |-
            func scopeChain() string {
                result := ""
                {
                    tag := "level0"
                    result += tag
                    {
                        tag := "level1"
                        result += "-" + tag
                        {
                            tag := "level2"
                            result += "-" + tag
                        }
                    }
                }
                return result
            }
          annotations:
            - type: gotcha
              label: Scope Visibility
              text: >-
                Inner blocks can access and modify outer variables, but
                outer blocks cannot see inner declarations. Using <code>:=</code>
                inside a block always creates a new variable — it never modifies
                the outer one.

    # ── challenge_2: Type Conversion ─────────────────────────────────────
    - id: challenge_2
      block: 1
      difficulty: 1
      concept: Type Conversion
      docLinks:
        - url: https://go.dev/tour/basics/13
          title: "Go Tour: Type conversions"
          note: basic conversion syntax
        - url: https://pkg.go.dev/strconv
          title: "Package strconv"
          note: string/number conversions
      variants:
        - id: v1
          title: String to Int Pipeline
          description: >-
            Write <code>func parseAndDouble(s string) (int, error)</code> that
            parses a string to an integer using <code>strconv.Atoi</code>,
            doubles it, and returns the result. Return the error if parsing fails.
          functionSignature: func parseAndDouble(s string) (int, error)
          difficulty: 1
          testCases:
            - input: "parseAndDouble(\"21\")"
              output: "(42, nil)"
            - input: "parseAndDouble(\"abc\")"
              output: "(0, error)"
            - input: "parseAndDouble(\"0\")"
              output: "(0, nil)"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                What two things does <code>strconv.Atoi</code> return,
                and which should you check first?
            - title: "\U0001F4A1 Hint"
              content: >-
                Call <code>strconv.Atoi(s)</code>, check the error,
                then multiply the value by 2.
          solution: |-
            func parseAndDouble(s string) (int, error) {
                n, err := strconv.Atoi(s)
                if err != nil {
                    return 0, err
                }
                return n * 2, nil
            }
          annotations:
            - type: idiom
              label: Parse-Check-Use
              text: >-
                The Go pattern for conversions: parse, check the error immediately,
                then use the value. Never use the value without checking the error first.

        - id: v2
          title: Int to String Formatter
          description: >-
            Write <code>func formatID(id int) string</code> that converts an
            integer to a zero-padded 6-digit string using <code>strconv.Itoa</code>
            and string padding. For example, 42 becomes <code>"000042"</code>.
          functionSignature: func formatID(id int) string
          difficulty: 1
          testCases:
            - input: "formatID(42)"
              output: "000042"
            - input: "formatID(123456)"
              output: "123456"
            - input: "formatID(0)"
              output: "000000"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                <code>strconv.Itoa</code> converts to a string, but how
                do you pad it with leading zeros?
            - title: "\U0001F4A1 Hint"
              content: >-
                Use <code>fmt.Sprintf("%06d", id)</code> for zero-padded
                formatting, or convert with Itoa and manually pad.
          solution: |-
            func formatID(id int) string {
                return fmt.Sprintf("%06d", id)
            }
          annotations:
            - type: idiom
              label: Sprintf Formatting
              text: >-
                <code>fmt.Sprintf</code> is often simpler than <code>strconv.Itoa</code>
                when you need formatted output. The <code>%06d</code> verb zero-pads
                to 6 digits.

        - id: v3
          title: Float Truncation vs Rounding
          description: >-
            Write <code>func truncateAndRound(f float64) (int, int)</code> that
            returns both the truncated value (simple <code>int(f)</code> cast)
            and the rounded value (using <code>math.Round</code>). Show the
            difference between the two approaches.
          functionSignature: func truncateAndRound(f float64) (int, int)
          difficulty: 1
          testCases:
            - input: "truncateAndRound(3.7)"
              output: "(3, 4)"
            - input: "truncateAndRound(3.2)"
              output: "(3, 3)"
            - input: "truncateAndRound(-2.8)"
              output: "(-2, -3)"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                What does <code>int(3.7)</code> give you? Is it the same
                as rounding?
            - title: "\U0001F4A1 Hint"
              content: >-
                <code>int(f)</code> truncates toward zero (drops the decimal).
                <code>math.Round(f)</code> rounds to the nearest integer.
          solution: |-
            func truncateAndRound(f float64) (int, int) {
                truncated := int(f)
                rounded := int(math.Round(f))
                return truncated, rounded
            }
          annotations:
            - type: gotcha
              label: Truncation vs Rounding
              text: >-
                <code>int(f)</code> truncates toward zero, not toward negative infinity.
                <code>int(-2.8)</code> gives -2, not -3. Use <code>math.Round</code>,
                <code>math.Floor</code>, or <code>math.Ceil</code> for other behaviors.

        - id: v4
          title: Parse Hex Color Values
          description: >-
            Write <code>func hexToRGB(hex string) (int64, int64, int64, error)</code>
            that parses a hex color string like <code>"FF8800"</code> (without #)
            into R, G, B values using <code>strconv.ParseInt</code> with base 16.
          functionSignature: "func hexToRGB(hex string) (int64, int64, int64, error)"
          difficulty: 1
          testCases:
            - input: "hexToRGB(\"FF8800\")"
              output: "(255, 136, 0, nil)"
            - input: "hexToRGB(\"000000\")"
              output: "(0, 0, 0, nil)"
            - input: "hexToRGB(\"ZZZZZZ\")"
              output: "(0, 0, 0, error)"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                Each color channel is a 2-character hex string. How do you
                slice a string into pairs?
            - title: "\U0001F4A1 Hint"
              content: >-
                Slice with <code>hex[0:2]</code>, <code>hex[2:4]</code>,
                <code>hex[4:6]</code> and parse each with
                <code>strconv.ParseInt(pair, 16, 64)</code>.
          solution: |-
            func hexToRGB(hex string) (int64, int64, int64, error) {
                if len(hex) != 6 {
                    return 0, 0, 0, fmt.Errorf("invalid hex length: %d", len(hex))
                }
                r, err := strconv.ParseInt(hex[0:2], 16, 64)
                if err != nil {
                    return 0, 0, 0, err
                }
                g, err := strconv.ParseInt(hex[2:4], 16, 64)
                if err != nil {
                    return 0, 0, 0, err
                }
                b, err := strconv.ParseInt(hex[4:6], 16, 64)
                if err != nil {
                    return 0, 0, 0, err
                }
                return r, g, b, nil
            }
          annotations:
            - type: idiom
              label: ParseInt Bases
              text: >-
                <code>strconv.ParseInt(s, base, bitSize)</code> handles any base
                from 2 to 36. Base 16 for hex, 8 for octal, 2 for binary.

        - id: v5
          title: Temperature Unit Pipeline
          description: >-
            Write <code>func celsiusToFahrenheit(input string) (string, error)</code>
            that takes a Celsius temperature as a string (e.g. <code>"100"</code>),
            parses it to float64, converts to Fahrenheit, and returns the result
            formatted to 1 decimal place as a string.
          functionSignature: "func celsiusToFahrenheit(input string) (string, error)"
          difficulty: 1
          testCases:
            - input: "celsiusToFahrenheit(\"100\")"
              output: "(\"212.0\", nil)"
            - input: "celsiusToFahrenheit(\"0\")"
              output: "(\"32.0\", nil)"
            - input: "celsiusToFahrenheit(\"abc\")"
              output: "(\"\", error)"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                This is a parse-transform-format pipeline. What function
                parses a string to float64?
            - title: "\U0001F4A1 Hint"
              content: >-
                Use <code>strconv.ParseFloat(input, 64)</code> to parse,
                apply the formula <code>c*9/5 + 32</code>, then
                <code>fmt.Sprintf("%.1f", f)</code> to format.
          solution: |-
            func celsiusToFahrenheit(input string) (string, error) {
                c, err := strconv.ParseFloat(input, 64)
                if err != nil {
                    return "", err
                }
                f := c*9/5 + 32
                return fmt.Sprintf("%.1f", f), nil
            }
          annotations:
            - type: pattern
              label: Parse-Transform-Format
              text: >-
                A common pipeline: parse string input, transform the typed value,
                format back to string. Each step can fail, so check errors at each stage.

        - id: v6
          title: Currency Cents to Dollars
          description: >-
            Write <code>func centsToDollars(cents int) string</code> that converts
            an integer cents amount to a dollar string like <code>"$12.50"</code>.
            Always show exactly 2 decimal places. Handle negative amounts with
            a leading minus sign.
          functionSignature: func centsToDollars(cents int) string
          difficulty: 2
          testCases:
            - input: "centsToDollars(1250)"
              output: "$12.50"
            - input: "centsToDollars(5)"
              output: "$0.05"
            - input: "centsToDollars(-999)"
              output: "-$9.99"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                How do you split cents into dollars and remaining cents
                using integer division and modulo?
            - title: "\U0001F4A1 Hint"
              content: >-
                Convert cents to float64 and divide by 100, or use integer
                math: <code>cents/100</code> for dollars, <code>cents%100</code>
                for remaining cents. Handle negatives carefully.
          solution: |-
            func centsToDollars(cents int) string {
                if cents < 0 {
                    return "-" + centsToDollars(-cents)
                }
                dollars := cents / 100
                remainder := cents % 100
                return fmt.Sprintf("$%d.%02d", dollars, remainder)
            }
          annotations:
            - type: idiom
              label: Integer Currency
              text: >-
                Store currency as integer cents to avoid floating-point precision
                issues. Convert to dollars only for display — never do arithmetic
                on float dollar amounts.

        - id: v7
          title: ParseBool Config Parser
          description: >-
            Write <code>func parseConfig(value string) (bool, error)</code> that
            uses <code>strconv.ParseBool</code> to handle various truthy/falsy
            strings. It accepts "1", "t", "T", "TRUE", "true", "True",
            "0", "f", "F", "FALSE", "false", "False".
          functionSignature: func parseConfig(value string) (bool, error)
          difficulty: 2
          testCases:
            - input: "parseConfig(\"true\")"
              output: "(true, nil)"
            - input: "parseConfig(\"0\")"
              output: "(false, nil)"
            - input: "parseConfig(\"yes\")"
              output: "(false, error)"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                Does Go's <code>strconv.ParseBool</code> handle "yes"/"no"?
                What strings does it actually accept?
            - title: "\U0001F4A1 Hint"
              content: >-
                <code>strconv.ParseBool</code> only handles specific strings.
                It does NOT accept "yes", "no", "on", "off". You get those
                values for free — everything else returns an error.
          solution: |-
            func parseConfig(value string) (bool, error) {
                return strconv.ParseBool(value)
            }
          annotations:
            - type: gotcha
              label: ParseBool Limitations
              text: >-
                <code>strconv.ParseBool</code> only accepts "1"/"0", "t"/"f",
                "T"/"F", "TRUE"/"FALSE", "true"/"false", "True"/"False".
                It rejects "yes", "no", "on", "off" — you'd need a custom parser for those.

        - id: v8
          title: Numeric Overflow Detection
          description: >-
            Write <code>func safeIntToUint8(n int) (uint8, error)</code> that
            converts an int to uint8, returning an error if the value is
            outside the 0-255 range instead of silently wrapping.
          functionSignature: func safeIntToUint8(n int) (uint8, error)
          difficulty: 2
          testCases:
            - input: "safeIntToUint8(200)"
              output: "(200, nil)"
            - input: "safeIntToUint8(256)"
              output: "(0, error)"
            - input: "safeIntToUint8(-1)"
              output: "(0, error)"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                What happens if you convert 256 to uint8 directly in Go?
                Is it a compile error or silent truncation?
            - title: "\U0001F4A1 Hint"
              content: >-
                Go silently truncates on conversion: <code>uint8(256)</code>
                gives 0. Always validate the range before converting to a
                narrower type.
          solution: |-
            func safeIntToUint8(n int) (uint8, error) {
                if n < 0 || n > 255 {
                    return 0, fmt.Errorf("value %d out of uint8 range (0-255)", n)
                }
                return uint8(n), nil
            }
          annotations:
            - type: gotcha
              label: Silent Overflow
              text: >-
                Go does NOT panic on integer overflow during conversion.
                <code>uint8(256)</code> silently gives 0. Always validate
                ranges before narrowing conversions.

        - id: v9
          title: FormatFloat Precision Control
          description: >-
            Write <code>func formatPrice(price float64, precision int) string</code>
            that formats a float to the specified number of decimal places using
            <code>strconv.FormatFloat</code> with format 'f'.
          functionSignature: func formatPrice(price float64, precision int) string
          difficulty: 2
          testCases:
            - input: "formatPrice(19.99, 2)"
              output: "19.99"
            - input: "formatPrice(3.14159, 4)"
              output: "3.1416"
            - input: "formatPrice(100.0, 0)"
              output: "100"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                <code>strconv.FormatFloat</code> takes a format byte and
                a precision. What does format 'f' mean?
            - title: "\U0001F4A1 Hint"
              content: >-
                Use <code>strconv.FormatFloat(price, 'f', precision, 64)</code>.
                Format 'f' is decimal notation without exponent.
          solution: |-
            func formatPrice(price float64, precision int) string {
                return strconv.FormatFloat(price, 'f', precision, 64)
            }
          annotations:
            - type: idiom
              label: FormatFloat
              text: >-
                <code>strconv.FormatFloat(f, fmt, prec, bitSize)</code> gives
                fine control. Format 'f' for decimal, 'e' for scientific,
                'g' for shortest representation.

        - id: v10
          title: Binary and Octal Parsing
          description: >-
            Write <code>func parseMultiBase(s string, base int) (int64, error)</code>
            that parses a string as a number in the given base (2, 8, 10, or 16).
            Return an error for unsupported bases.
          functionSignature: func parseMultiBase(s string, base int) (int64, error)
          difficulty: 2
          testCases:
            - input: "parseMultiBase(\"1010\", 2)"
              output: "(10, nil)"
            - input: "parseMultiBase(\"777\", 8)"
              output: "(511, nil)"
            - input: "parseMultiBase(\"FF\", 16)"
              output: "(255, nil)"
            - input: "parseMultiBase(\"42\", 3)"
              output: "(0, error)"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                <code>strconv.ParseInt</code> supports bases 2-36, but
                you only want to allow certain bases. How do you restrict this?
            - title: "\U0001F4A1 Hint"
              content: >-
                Validate the base first with a switch, then call
                <code>strconv.ParseInt(s, base, 64)</code>.
          solution: |-
            func parseMultiBase(s string, base int) (int64, error) {
                switch base {
                case 2, 8, 10, 16:
                    return strconv.ParseInt(s, base, 64)
                default:
                    return 0, fmt.Errorf("unsupported base: %d", base)
                }
            }
          annotations:
            - type: idiom
              label: Multi-Base Parsing
              text: >-
                <code>strconv.ParseInt</code> handles any base from 2 to 36.
                Base 0 auto-detects from prefixes: "0x" for hex, "0o" for octal,
                "0b" for binary.

        - id: v11
          title: Byte Slice to String Round-Trip
          description: >-
            Write <code>func rotateBytes(s string, n int) string</code> that
            converts a string to a byte slice, rotates each byte by n positions
            (wrapping at 256), and converts back to a string. This is a simple
            Caesar cipher on bytes.
          functionSignature: func rotateBytes(s string, n int) string
          difficulty: 3
          testCases:
            - input: "rotateBytes(\"abc\", 1)"
              output: "bcd"
            - input: "rotateBytes(\"xyz\", 3)"
              output: "{|}"
            - input: "rotateBytes(\"hello\", 0)"
              output: "hello"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                How do you convert between <code>string</code> and
                <code>[]byte</code> in Go? Is it a copy or a reference?
            - title: "\U0001F4A1 Hint"
              content: >-
                Use <code>[]byte(s)</code> to convert, modify each byte with
                <code>b[i] = byte(int(b[i]) + n)</code>, then
                <code>string(b)</code> to convert back.
          solution: |-
            func rotateBytes(s string, n int) string {
                b := []byte(s)
                for i := range b {
                    b[i] = byte((int(b[i]) + n) % 256)
                }
                return string(b)
            }
          annotations:
            - type: gotcha
              label: String Immutability
              text: >-
                Strings in Go are immutable. Converting to <code>[]byte</code>
                creates a copy you can modify. Converting back creates another copy.
                For large strings, this matters for performance.

        - id: v12
          title: Rune Exploration
          description: >-
            Write <code>func runeInfo(s string) (int, int)</code> that returns
            both the byte length and the rune (character) count of a string.
            Demonstrate the difference with multi-byte UTF-8 characters.
          functionSignature: func runeInfo(s string) (int, int)
          difficulty: 3
          testCases:
            - input: "runeInfo(\"hello\")"
              output: "(5, 5)"
            - input: "runeInfo(\"Go\u8BED\u8A00\")"
              output: "(8, 4)"
            - input: "runeInfo(\"\")"
              output: "(0, 0)"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                Why might <code>len(s)</code> and the number of characters
                in a string be different?
            - title: "\U0001F4A1 Hint"
              content: >-
                <code>len(s)</code> returns bytes. Use <code>utf8.RuneCountInString(s)</code>
                or <code>len([]rune(s))</code> for character count.
          solution: |-
            func runeInfo(s string) (int, int) {
                return len(s), utf8.RuneCountInString(s)
            }
          annotations:
            - type: gotcha
              label: Bytes vs Runes
              text: >-
                Go strings are byte slices, not character arrays. A Chinese character
                takes 3 bytes in UTF-8. Always use <code>utf8.RuneCountInString</code>
                when you need the actual character count.

        - id: v13
          title: Full Encoding Pipeline
          description: >-
            Write <code>func encodingPipeline(input string) (string, error)</code>
            that takes a comma-separated string of integers (e.g. <code>"72,101,108"</code>),
            parses each number, converts to the corresponding ASCII character,
            and returns the assembled string. Return an error if any number
            is invalid.
          functionSignature: "func encodingPipeline(input string) (string, error)"
          difficulty: 3
          testCases:
            - input: "encodingPipeline(\"72,101,108,108,111\")"
              output: "(\"Hello\", nil)"
            - input: "encodingPipeline(\"71,111\")"
              output: "(\"Go\", nil)"
            - input: "encodingPipeline(\"72,abc\")"
              output: "(\"\", error)"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                This combines string splitting, integer parsing, and
                byte-to-character conversion. What's the order of operations?
            - title: "\U0001F4A1 Hint"
              content: >-
                Split on <code>","</code> with <code>strings.Split</code>,
                parse each with <code>strconv.Atoi</code>, convert to
                <code>byte</code>, accumulate into a <code>[]byte</code>.
          solution: |-
            func encodingPipeline(input string) (string, error) {
                parts := strings.Split(input, ",")
                result := make([]byte, 0, len(parts))
                for _, p := range parts {
                    n, err := strconv.Atoi(strings.TrimSpace(p))
                    if err != nil {
                        return "", fmt.Errorf("invalid number %q: %w", p, err)
                    }
                    result = append(result, byte(n))
                }
                return string(result), nil
            }
          annotations:
            - type: pattern
              label: Pipeline Processing
              text: >-
                Complex conversions are best expressed as pipelines: split, parse,
                transform, assemble. Each step is simple and testable. Check errors
                at every parsing step.

    # ── challenge_3: String Formatting ───────────────────────────────────
    - id: challenge_3
      block: 1
      difficulty: 1
      concept: String Formatting
      docLinks:
        - url: https://pkg.go.dev/fmt
          title: "Package fmt"
          note: formatting verbs and functions
        - url: https://go.dev/blog/strings
          title: "Go Blog: Strings, bytes, runes"
          note: string internals
      variants:
        - id: v1
          title: Format a Receipt Line
          description: >-
            Write <code>func receiptLine(item string, qty int, price float64) string</code>
            that formats a receipt line like <code>"Coffee          x3   $7.50"</code>.
            Left-align the item name in 16 chars, right-align quantity in 2 chars,
            right-align price in 7 chars with 2 decimal places.
          functionSignature: "func receiptLine(item string, qty int, price float64) string"
          difficulty: 1
          testCases:
            - input: "receiptLine(\"Coffee\", 3, 7.50)"
              output: "Coffee           x3  $7.50"
            - input: "receiptLine(\"Bagel\", 1, 2.99)"
              output: "Bagel            x1  $2.99"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                How do you left-align and right-align strings using
                <code>fmt.Sprintf</code> width specifiers?
            - title: "\U0001F4A1 Hint"
              content: >-
                Use <code>%-16s</code> for left-aligned string,
                <code>x%d</code> for quantity, <code>$%5.2f</code> for
                right-aligned price with 2 decimals.
          solution: |-
            func receiptLine(item string, qty int, price float64) string {
                return fmt.Sprintf("%-16s x%d  $%.2f", item, qty, price)
            }
          annotations:
            - type: idiom
              label: Width Specifiers
              text: >-
                In <code>fmt.Sprintf</code>, <code>%-16s</code> means left-aligned
                in 16 chars (the minus left-aligns). <code>%5.2f</code> means at
                least 5 chars wide with 2 decimal places.

        - id: v2
          title: Progress Bar Builder
          description: >-
            Write <code>func progressBar(percent int) string</code> that returns
            a 20-character progress bar like <code>"[=========>          ] 50%"</code>.
            Fill with <code>=</code> for completed, spaces for remaining, and
            place <code>></code> at the boundary.
          functionSignature: func progressBar(percent int) string
          difficulty: 1
          testCases:
            - input: "progressBar(50)"
              output: "[=========>          ] 50%"
            - input: "progressBar(100)"
              output: "[====================] 100%"
            - input: "progressBar(0)"
              output: "[>                   ] 0%"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                If the bar is 20 characters wide and you're at 50%,
                how many <code>=</code> signs do you need?
            - title: "\U0001F4A1 Hint"
              content: >-
                Calculate <code>filled := percent * 20 / 100</code>.
                Use <code>strings.Repeat</code> for the <code>=</code> and space characters.
          solution: |-
            func progressBar(percent int) string {
                width := 20
                filled := percent * width / 100
                if filled > width {
                    filled = width
                }
                bar := strings.Repeat("=", filled)
                if filled < width {
                    bar += ">"
                    bar += strings.Repeat(" ", width-filled)
                }
                return fmt.Sprintf("[%s] %d%%", bar, percent)
            }
          annotations:
            - type: pattern
              label: String Building
              text: >-
                Use <code>strings.Repeat</code> to generate repeated characters.
                Combined with <code>fmt.Sprintf</code>, it's an easy way to build
                fixed-width visual elements.

        - id: v3
          title: Format File Sizes
          description: >-
            Write <code>func formatBytes(bytes int64) string</code> that returns
            a human-readable file size: <code>"1.5 KB"</code>, <code>"3.2 MB"</code>,
            <code>"1.0 GB"</code>. Use the largest unit where the value is >= 1.
            Show 1 decimal place.
          functionSignature: func formatBytes(bytes int64) string
          difficulty: 1
          testCases:
            - input: "formatBytes(1536)"
              output: "1.5 KB"
            - input: "formatBytes(3355443)"
              output: "3.2 MB"
            - input: "formatBytes(500)"
              output: "500 B"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                What's the pattern for choosing the right unit? Start from
                the largest and work down, or start from bytes and divide up?
            - title: "\U0001F4A1 Hint"
              content: >-
                Check if bytes >= 1GB, then >= 1MB, then >= 1KB. Divide by the
                unit size and format with <code>%.1f</code>.
          solution: |-
            func formatBytes(bytes int64) string {
                const (
                    KB = 1024
                    MB = 1024 * KB
                    GB = 1024 * MB
                )
                switch {
                case bytes >= GB:
                    return fmt.Sprintf("%.1f GB", float64(bytes)/float64(GB))
                case bytes >= MB:
                    return fmt.Sprintf("%.1f MB", float64(bytes)/float64(MB))
                case bytes >= KB:
                    return fmt.Sprintf("%.1f KB", float64(bytes)/float64(KB))
                default:
                    return fmt.Sprintf("%d B", bytes)
                }
            }
          annotations:
            - type: idiom
              label: Unit Formatting
              text: >-
                A typeless <code>switch</code> with descending thresholds is
                the cleanest way to select the right display unit. Each case
                is a simple comparison and format.

        - id: v4
          title: Format Duration
          description: >-
            Write <code>func formatDuration(seconds int) string</code> that
            formats seconds into a human-readable duration like <code>"1h23m45s"</code>.
            Omit zero components: 3600 is <code>"1h"</code>, not <code>"1h0m0s"</code>.
          functionSignature: func formatDuration(seconds int) string
          difficulty: 1
          testCases:
            - input: "formatDuration(5025)"
              output: "1h23m45s"
            - input: "formatDuration(3600)"
              output: "1h"
            - input: "formatDuration(90)"
              output: "1m30s"
            - input: "formatDuration(0)"
              output: "0s"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                How do you extract hours, minutes, and seconds from a
                total seconds count using division and modulo?
            - title: "\U0001F4A1 Hint"
              content: >-
                <code>h := seconds / 3600</code>, <code>m := (seconds % 3600) / 60</code>,
                <code>s := seconds % 60</code>. Conditionally append each part.
          solution: |-
            func formatDuration(seconds int) string {
                if seconds == 0 {
                    return "0s"
                }
                h := seconds / 3600
                m := (seconds % 3600) / 60
                s := seconds % 60
                result := ""
                if h > 0 {
                    result += fmt.Sprintf("%dh", h)
                }
                if m > 0 {
                    result += fmt.Sprintf("%dm", m)
                }
                if s > 0 {
                    result += fmt.Sprintf("%ds", s)
                }
                return result
            }
          annotations:
            - type: pattern
              label: Component Extraction
              text: >-
                Integer division and modulo are the standard way to decompose
                a value into components (hours/minutes/seconds, dollars/cents, etc.).

        - id: v5
          title: Format IP Address
          description: >-
            Write <code>func formatIP(a, b, c, d int) string</code> that formats
            four octets into a dotted-decimal IP address string like
            <code>"192.168.1.1"</code>. Validate each octet is 0-255, returning
            <code>"invalid"</code> if not.
          functionSignature: func formatIP(a, b, c, d int) string
          difficulty: 2
          testCases:
            - input: "formatIP(192, 168, 1, 1)"
              output: "192.168.1.1"
            - input: "formatIP(0, 0, 0, 0)"
              output: "0.0.0.0"
            - input: "formatIP(256, 0, 0, 1)"
              output: "invalid"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                How do you validate that all four values are in range
                without writing four separate if statements?
            - title: "\U0001F4A1 Hint"
              content: >-
                Write a helper check or use a loop over the values.
                Format with <code>fmt.Sprintf("%d.%d.%d.%d", a, b, c, d)</code>.
          solution: |-
            func formatIP(a, b, c, d int) string {
                for _, octet := range []int{a, b, c, d} {
                    if octet < 0 || octet > 255 {
                        return "invalid"
                    }
                }
                return fmt.Sprintf("%d.%d.%d.%d", a, b, c, d)
            }
          annotations:
            - type: idiom
              label: Validation First
              text: >-
                Validate inputs before formatting. Putting all values in a slice
                lets you loop over them for range checks instead of writing
                repetitive if statements.

        - id: v6
          title: Build a Table Row
          description: >-
            Write <code>func tableRow(cols []string, widths []int) string</code>
            that formats column values into a pipe-separated table row with
            each column padded to its specified width. Example output:
            <code>"| Name       | Age | City      |"</code>.
          functionSignature: func tableRow(cols []string, widths []int) string
          difficulty: 2
          testCases:
            - input: "tableRow([]string{\"Alice\", \"30\", \"NYC\"}, []int{10, 5, 10})"
              output: "| Alice      | 30    | NYC        |"
            - input: "tableRow([]string{\"Bob\"}, []int{8})"
              output: "| Bob      |"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                How do you dynamically set the width in a format string
                when it varies per column?
            - title: "\U0001F4A1 Hint"
              content: >-
                Use <code>fmt.Sprintf("%-*s", width, value)</code> where
                <code>*</code> takes the width from an argument.
          solution: |-
            func tableRow(cols []string, widths []int) string {
                result := "|"
                for i, col := range cols {
                    w := widths[i]
                    result += fmt.Sprintf(" %-*s |", w, col)
                }
                return result
            }
          annotations:
            - type: idiom
              label: Dynamic Width
              text: >-
                The <code>*</code> in <code>%-*s</code> reads the width from the
                next argument. This lets you parameterize column widths instead
                of hardcoding them in format strings.

        - id: v7
          title: Format Log Line
          description: >-
            Write <code>func logLine(level string, ts int64, msg string) string</code>
            that formats a log line like <code>"2024-01-15 10:30:00 [ERROR] disk full"</code>.
            The timestamp is a Unix epoch; use <code>time.Unix</code> to format it.
            Left-pad the level in brackets to 7 chars.
          functionSignature: func logLine(level string, ts int64, msg string) string
          difficulty: 2
          testCases:
            - input: "logLine(\"ERROR\", 1705312200, \"disk full\")"
              output: "2024-01-15 10:30:00 [ ERROR] disk full"
            - input: "logLine(\"INFO\", 1705312200, \"started\")"
              output: "2024-01-15 10:30:00 [  INFO] started"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                Go's <code>time</code> package uses a reference time for formatting.
                What's the magic date you use as a format template?
            - title: "\U0001F4A1 Hint"
              content: >-
                Use <code>time.Unix(ts, 0).UTC().Format("2006-01-02 15:04:05")</code>.
                The reference time is <code>Mon Jan 2 15:04:05 MST 2006</code>.
          solution: |-
            func logLine(level string, ts int64, msg string) string {
                t := time.Unix(ts, 0).UTC().Format("2006-01-02 15:04:05")
                return fmt.Sprintf("%s [%5s] %s", t, level, msg)
            }
          annotations:
            - type: idiom
              label: Time Formatting
              text: >-
                Go's time formatting uses a reference time (Jan 2, 2006 at 3:04:05 PM)
                instead of strftime codes. Each component has a specific number to remember:
                1 for month, 2 for day, 3 for hour, etc.

        - id: v8
          title: Format Git Commit Summary
          description: >-
            Write <code>func commitSummary(hash string, author string, msg string) string</code>
            that formats a git commit like <code>"a1b2c3d Alice: Fix login bug"</code>.
            Truncate the hash to 7 characters and the message to 50 characters
            (adding "..." if truncated).
          functionSignature: "func commitSummary(hash string, author string, msg string) string"
          difficulty: 2
          testCases:
            - input: "commitSummary(\"a1b2c3d4e5f6\", \"Alice\", \"Fix login bug\")"
              output: "a1b2c3d Alice: Fix login bug"
            - input: "commitSummary(\"abc1234\", \"Bob\", \"This is a very long commit message that should be truncated at fifty characters\")"
              output: "abc1234 Bob: This is a very long commit message that sho..."
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                How do you safely truncate a string in Go without panicking
                if it's shorter than the max length?
            - title: "\U0001F4A1 Hint"
              content: >-
                Check <code>len(s) > max</code> before slicing. Use
                <code>s[:max] + "..."</code> for truncation.
          solution: |-
            func commitSummary(hash string, author string, msg string) string {
                if len(hash) > 7 {
                    hash = hash[:7]
                }
                if len(msg) > 50 {
                    msg = msg[:50] + "..."
                }
                return fmt.Sprintf("%s %s: %s", hash, author, msg)
            }
          annotations:
            - type: pattern
              label: Safe Truncation
              text: >-
                Always check the string length before slicing to avoid panics.
                The pattern <code>if len(s) > max { s = s[:max] + "..." }</code>
                is a safe truncation idiom.

        - id: v9
          title: Build CSV Row
          description: >-
            Write <code>func csvRow(fields []string) string</code> that joins
            fields into a CSV row. Fields containing commas or quotes must be
            wrapped in double quotes, with internal quotes doubled.
          functionSignature: func csvRow(fields []string) string
          difficulty: 2
          testCases:
            - input: "csvRow([]string{\"Alice\", \"30\", \"New York\"})"
              output: "Alice,30,New York"
            - input: "csvRow([]string{\"Bob\", \"said \\\"hello\\\"\", \"a,b\"})"
              output: "Bob,\"said \"\"hello\"\"\",\"a,b\""
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                When does a CSV field need quoting? What happens to quotes
                that are already inside the field?
            - title: "\U0001F4A1 Hint"
              content: >-
                Check each field for commas or quotes using <code>strings.Contains</code>.
                Double any existing quotes with <code>strings.ReplaceAll(f, "\"", "\"\"")</code>,
                then wrap in quotes.
          solution: |-
            func csvRow(fields []string) string {
                escaped := make([]string, len(fields))
                for i, f := range fields {
                    if strings.Contains(f, ",") || strings.Contains(f, "\"") {
                        f = strings.ReplaceAll(f, "\"", "\"\"")
                        f = "\"" + f + "\""
                    }
                    escaped[i] = f
                }
                return strings.Join(escaped, ",")
            }
          annotations:
            - type: pattern
              label: CSV Escaping
              text: >-
                CSV escaping rules: wrap fields in quotes if they contain commas
                or quotes. Double any internal quotes. This is RFC 4180 compliant.

        - id: v10
          title: Format Error with Context
          description: >-
            Write <code>func formatError(op string, path string, err error) string</code>
            that formats a contextual error message like
            <code>"read /etc/config: permission denied"</code>. If err is nil,
            return <code>"op path: ok"</code>.
          functionSignature: "func formatError(op string, path string, err error) string"
          difficulty: 3
          testCases:
            - input: "formatError(\"read\", \"/etc/config\", fmt.Errorf(\"permission denied\"))"
              output: "read /etc/config: permission denied"
            - input: "formatError(\"open\", \"/tmp/log\", nil)"
              output: "open /tmp/log: ok"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                How do you include an error's message in a format string?
                What verb prints an error?
            - title: "\U0001F4A1 Hint"
              content: >-
                Use <code>%v</code> to format the error. Check for nil first.
                This pattern mirrors how Go's <code>os</code> package formats
                its PathError type.
          solution: |-
            func formatError(op string, path string, err error) string {
                if err == nil {
                    return fmt.Sprintf("%s %s: ok", op, path)
                }
                return fmt.Sprintf("%s %s: %v", op, path, err)
            }
          annotations:
            - type: idiom
              label: Error Context
              text: >-
                Go's convention is <code>"operation target: detail"</code> for error
                messages. The <code>%v</code> verb calls an error's <code>Error()</code>
                method. This pattern is used throughout the standard library.

        - id: v11
          title: Format Leaderboard
          description: >-
            Write <code>func leaderboard(names []string, scores []int) string</code>
            that formats a numbered leaderboard. Each line should be like
            <code>" 1. Alice        9500"</code> with rank right-aligned in 2 chars,
            name left-aligned in 12 chars, and score right-aligned in 8 chars.
            Lines are joined with newlines.
          functionSignature: func leaderboard(names []string, scores []int) string
          difficulty: 3
          testCases:
            - input: "leaderboard([]string{\"Alice\", \"Bob\"}, []int{9500, 8200})"
              output: " 1. Alice        9500\n 2. Bob          8200"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                How do you build a multi-line string in Go? Can you use
                <code>strings.Builder</code> or just concatenation?
            - title: "\U0001F4A1 Hint"
              content: >-
                Use a slice of formatted lines and <code>strings.Join</code>
                with <code>"\n"</code>. Format each line with
                <code>"%2d. %-12s %4d"</code>.
          solution: |-
            func leaderboard(names []string, scores []int) string {
                lines := make([]string, len(names))
                for i := range names {
                    lines[i] = fmt.Sprintf("%2d. %-12s %4d", i+1, names[i], scores[i])
                }
                return strings.Join(lines, "\n")
            }
          annotations:
            - type: idiom
              label: Collect and Join
              text: >-
                Build a slice of formatted lines, then <code>strings.Join</code> them.
                This is cleaner than manual newline concatenation and avoids a trailing
                newline.

        - id: v12
          title: Hex Dump Formatter
          description: >-
            Write <code>func hexDump(data []byte) string</code> that formats bytes
            as a hex dump with offsets. Each line shows: 8-char hex offset, up to
            16 bytes in hex pairs, and the ASCII representation. Non-printable
            bytes show as <code>.</code>.
          functionSignature: func hexDump(data []byte) string
          difficulty: 3
          testCases:
            - input: "hexDump([]byte(\"Hello, World!\"))"
              output: "00000000  48 65 6c 6c 6f 2c 20 57 6f 72 6c 64 21           |Hello, World!|"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                How do you format a byte as a 2-digit hex value?
                How do you check if a byte is printable ASCII?
            - title: "\U0001F4A1 Hint"
              content: >-
                Use <code>%02x</code> for hex formatting. Printable ASCII
                is bytes 32-126. Process 16 bytes per line.
          solution: |-
            func hexDump(data []byte) string {
                var lines []string
                for i := 0; i < len(data); i += 16 {
                    end := i + 16
                    if end > len(data) {
                        end = len(data)
                    }
                    chunk := data[i:end]
                    hex := ""
                    for _, b := range chunk {
                        hex += fmt.Sprintf("%02x ", b)
                    }
                    ascii := ""
                    for _, b := range chunk {
                        if b >= 32 && b <= 126 {
                            ascii += string(b)
                        } else {
                            ascii += "."
                        }
                    }
                    lines = append(lines, fmt.Sprintf("%08x  %-48s |%s|", i, hex, ascii))
                }
                return strings.Join(lines, "\n")
            }
          annotations:
            - type: pattern
              label: Hex Formatting
              text: >-
                <code>%02x</code> formats a byte as a 2-digit lowercase hex value.
                Use <code>%08x</code> for 8-digit offsets. The <code>%-48s</code>
                left-aligns the hex column for consistent spacing.

        - id: v13
          title: SQL Query Builder
          description: >-
            Write <code>func selectQuery(table string, cols []string, where map[string]string) string</code>
            that builds a SQL-like query string. Example output:
            <code>"SELECT name, age FROM users WHERE active = 'true' AND role = 'admin'"</code>.
            Sort WHERE clauses alphabetically by key for deterministic output.
          functionSignature: "func selectQuery(table string, cols []string, where map[string]string) string"
          difficulty: 3
          testCases:
            - input: "selectQuery(\"users\", []string{\"name\", \"age\"}, map[string]string{\"active\": \"true\"})"
              output: "SELECT name, age FROM users WHERE active = 'true'"
            - input: "selectQuery(\"logs\", []string{\"*\"}, map[string]string{})"
              output: "SELECT * FROM logs"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                Maps in Go have random iteration order. How do you ensure
                the WHERE clauses come out in a deterministic order?
            - title: "\U0001F4A1 Hint"
              content: >-
                Extract map keys into a slice, sort with <code>sort.Strings</code>,
                then iterate the sorted keys. Use <code>strings.Join</code> for columns.
          solution: |-
            func selectQuery(table string, cols []string, where map[string]string) string {
                q := fmt.Sprintf("SELECT %s FROM %s", strings.Join(cols, ", "), table)
                if len(where) > 0 {
                    keys := make([]string, 0, len(where))
                    for k := range where {
                        keys = append(keys, k)
                    }
                    sort.Strings(keys)
                    clauses := make([]string, len(keys))
                    for i, k := range keys {
                        clauses[i] = fmt.Sprintf("%s = '%s'", k, where[k])
                    }
                    q += " WHERE " + strings.Join(clauses, " AND ")
                }
                return q
            }
          annotations:
            - type: gotcha
              label: Map Iteration Order
              text: >-
                Go maps have intentionally random iteration order. When you need
                deterministic output (tests, logs, queries), always sort the keys first.

    # ── challenge_4: Function Basics ─────────────────────────────────────
    - id: challenge_4
      block: 1
      difficulty: 1
      concept: Function Basics
      docLinks:
        - url: https://go.dev/tour/moretypes/2
          title: "Go Tour: Structs and functions"
          note: function syntax
        - url: https://pkg.go.dev/strings
          title: "Package strings"
          note: string manipulation helpers
      variants:
        - id: v1
          title: Clamp Value
          description: >-
            Write <code>func clamp(value, min, max int) int</code> that constrains
            a value to a range. If value is below min, return min. If above max,
            return max. Otherwise return value unchanged.
          functionSignature: func clamp(value, min, max int) int
          difficulty: 1
          testCases:
            - input: "clamp(15, 0, 10)"
              output: "10"
            - input: "clamp(-5, 0, 10)"
              output: "0"
            - input: "clamp(5, 0, 10)"
              output: "5"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                This is a simple bounded range check. Which boundary
                should you check first?
            - title: "\U0001F4A1 Hint"
              content: >-
                Two if statements: <code>if value &lt; min { return min }</code>,
                <code>if value > max { return max }</code>, then return value.
          solution: |-
            func clamp(value, min, max int) int {
                if value < min {
                    return min
                }
                if value > max {
                    return max
                }
                return value
            }
          annotations:
            - type: idiom
              label: Early Return
              text: >-
                Multiple early returns make guard clauses clean and readable.
                Each boundary check handles one case and returns immediately,
                leaving the happy path at the end.

        - id: v2
          title: Absolute Value
          description: >-
            Write <code>func abs(n int) int</code> that returns the absolute
            value of an integer without using <code>math.Abs</code> (which works
            on float64). Handle the edge case of the most negative int if you want.
          functionSignature: func abs(n int) int
          difficulty: 1
          testCases:
            - input: "abs(-5)"
              output: "5"
            - input: "abs(5)"
              output: "5"
            - input: "abs(0)"
              output: "0"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                Why can't you just use <code>math.Abs</code> for integers?
            - title: "\U0001F4A1 Hint"
              content: >-
                <code>math.Abs</code> takes float64 and returns float64.
                For ints, just check <code>if n &lt; 0 { return -n }</code>.
          solution: |-
            func abs(n int) int {
                if n < 0 {
                    return -n
                }
                return n
            }
          annotations:
            - type: gotcha
              label: No Generic Abs
              text: >-
                Go's <code>math.Abs</code> only works on float64. For integers,
                you must write your own. This is a common surprise for newcomers
                from languages with overloaded abs functions.

        - id: v3
          title: GCD Calculator
          description: >-
            Write <code>func gcd(a, b int) int</code> that computes the greatest
            common divisor using Euclid's algorithm. Handle negative inputs by
            taking absolute values first.
          functionSignature: func gcd(a, b int) int
          difficulty: 1
          testCases:
            - input: "gcd(48, 18)"
              output: "6"
            - input: "gcd(100, 75)"
              output: "25"
            - input: "gcd(7, 13)"
              output: "1"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                Euclid's algorithm repeatedly replaces the larger number
                with the remainder. When does it stop?
            - title: "\U0001F4A1 Hint"
              content: >-
                Loop while <code>b != 0</code>: <code>a, b = b, a%b</code>.
                When b is 0, a is the GCD.
          solution: |-
            func gcd(a, b int) int {
                if a < 0 {
                    a = -a
                }
                if b < 0 {
                    b = -b
                }
                for b != 0 {
                    a, b = b, a%b
                }
                return a
            }
          annotations:
            - type: idiom
              label: Euclid's Algorithm
              text: >-
                Go's parallel assignment <code>a, b = b, a%b</code> makes Euclid's
                algorithm a clean one-liner in the loop body. This is one of the
                oldest algorithms still in daily use.

        - id: v4
          title: Switch-Based Day Classifier
          description: >-
            Write <code>func dayType(day string) string</code> that uses a switch
            statement to classify a day. Return <code>"weekday"</code> for Mon-Fri,
            <code>"weekend"</code> for Sat/Sun, <code>"unknown"</code> otherwise.
            Accept both full names and 3-letter abbreviations.
          functionSignature: func dayType(day string) string
          difficulty: 1
          testCases:
            - input: "dayType(\"Monday\")"
              output: "weekday"
            - input: "dayType(\"Sat\")"
              output: "weekend"
            - input: "dayType(\"Holiday\")"
              output: "unknown"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                Can a single <code>case</code> in a Go switch match
                multiple values?
            - title: "\U0001F4A1 Hint"
              content: >-
                Yes! Use <code>case "Monday", "Mon", "Tuesday", "Tue":</code>
                to match multiple values in one case.
          solution: |-
            func dayType(day string) string {
                switch day {
                case "Monday", "Mon", "Tuesday", "Tue", "Wednesday", "Wed",
                    "Thursday", "Thu", "Friday", "Fri":
                    return "weekday"
                case "Saturday", "Sat", "Sunday", "Sun":
                    return "weekend"
                default:
                    return "unknown"
                }
            }
          annotations:
            - type: idiom
              label: Multi-Value Case
              text: >-
                Go's switch cases can match multiple values with commas.
                Unlike C/Java, Go cases don't fall through by default — no
                <code>break</code> needed.

        - id: v5
          title: Early Return Guard
          description: >-
            Write <code>func processOrder(qty int, price float64) (float64, error)</code>
            that validates inputs with early returns. Return errors for qty &lt;= 0,
            price &lt;= 0, or qty > 1000. Apply a 10% discount for qty >= 100.
            Return the total.
          functionSignature: "func processOrder(qty int, price float64) (float64, error)"
          difficulty: 2
          testCases:
            - input: "processOrder(5, 10.0)"
              output: "(50.0, nil)"
            - input: "processOrder(100, 10.0)"
              output: "(900.0, nil)"
            - input: "processOrder(0, 10.0)"
              output: "(0, error)"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                What's the advantage of checking all error conditions
                first, before the main logic?
            - title: "\U0001F4A1 Hint"
              content: >-
                Guard clauses at the top handle all invalid cases. The happy
                path logic is at the bottom, unindented and clear.
          solution: |-
            func processOrder(qty int, price float64) (float64, error) {
                if qty <= 0 {
                    return 0, fmt.Errorf("invalid quantity: %d", qty)
                }
                if price <= 0 {
                    return 0, fmt.Errorf("invalid price: %.2f", price)
                }
                if qty > 1000 {
                    return 0, fmt.Errorf("quantity exceeds max: %d", qty)
                }
                total := float64(qty) * price
                if qty >= 100 {
                    total *= 0.9
                }
                return total, nil
            }
          annotations:
            - type: pattern
              label: Guard Clauses
              text: >-
                Guard clauses (early returns for invalid cases) keep the happy
                path at the lowest indentation level. This is strongly preferred
                in Go over deeply nested if/else chains.

        - id: v6
          title: Variadic Sum
          description: >-
            Write <code>func sum(nums ...int) int</code> that takes any number
            of integers and returns their sum. An empty call returns 0.
          functionSignature: func sum(nums ...int) int
          difficulty: 2
          testCases:
            - input: "sum(1, 2, 3)"
              output: "6"
            - input: "sum()"
              output: "0"
            - input: "sum(42)"
              output: "42"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                What type is <code>nums</code> inside the function when
                you declare it as <code>...int</code>?
            - title: "\U0001F4A1 Hint"
              content: >-
                <code>nums</code> is a <code>[]int</code> slice inside the function.
                Range over it and accumulate the total.
          solution: |-
            func sum(nums ...int) int {
                total := 0
                for _, n := range nums {
                    total += n
                }
                return total
            }
          annotations:
            - type: idiom
              label: Variadic Functions
              text: >-
                The <code>...</code> syntax makes the last parameter variadic.
                Inside the function it's a slice. Call with individual args or
                expand a slice with <code>sum(nums...)</code>.

        - id: v7
          title: String Title Case
          description: >-
            Write <code>func titleCase(s string) string</code> that capitalizes
            the first letter of each word in a string. Use only standard library
            functions. Words are separated by spaces.
          functionSignature: func titleCase(s string) string
          difficulty: 2
          testCases:
            - input: "titleCase(\"hello world\")"
              output: "Hello World"
            - input: "titleCase(\"go is great\")"
              output: "Go Is Great"
            - input: "titleCase(\"\")"
              output: ""
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                How do you capitalize just the first letter of a word
                while keeping the rest unchanged?
            - title: "\U0001F4A1 Hint"
              content: >-
                Split on spaces, for each word use
                <code>strings.ToUpper(w[:1]) + w[1:]</code>, then join back.
          solution: |-
            func titleCase(s string) string {
                if s == "" {
                    return ""
                }
                words := strings.Fields(s)
                for i, w := range words {
                    if len(w) > 0 {
                        words[i] = strings.ToUpper(w[:1]) + w[1:]
                    }
                }
                return strings.Join(words, " ")
            }
          annotations:
            - type: idiom
              label: Split-Transform-Join
              text: >-
                The split-transform-join pattern is fundamental in Go string
                processing. <code>strings.Fields</code> splits on any whitespace,
                <code>strings.Join</code> reassembles.

        - id: v8
          title: Closure Counter
          description: >-
            Write <code>func makeCounter(start int) func() int</code> that returns
            a closure. Each call to the returned function increments and returns
            the counter value. The first call returns start + 1.
          functionSignature: func makeCounter(start int) func() int
          difficulty: 2
          testCases:
            - input: "c := makeCounter(0); c(); c(); c()"
              output: "3"
            - input: "c := makeCounter(10); c()"
              output: "11"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                How does a closure capture variables from its enclosing scope?
                Is it a copy or a reference?
            - title: "\U0001F4A1 Hint"
              content: >-
                The closure captures <code>start</code> by reference. Each call
                modifies the same variable. Return <code>func() int { start++; return start }</code>.
          solution: |-
            func makeCounter(start int) func() int {
                return func() int {
                    start++
                    return start
                }
            }
          annotations:
            - type: idiom
              label: Closures
              text: >-
                Go closures capture variables by reference, not by value. The
                returned function and its enclosing scope share the same variable.
                This is the foundation for many Go patterns like middleware and iterators.

        - id: v9
          title: Recursive Factorial
          description: >-
            Write <code>func factorial(n int) int</code> that computes n! recursively.
            Return 1 for n &lt;= 1. No need to handle negative numbers.
          functionSignature: func factorial(n int) int
          difficulty: 2
          testCases:
            - input: "factorial(5)"
              output: "120"
            - input: "factorial(0)"
              output: "1"
            - input: "factorial(10)"
              output: "3628800"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                Every recursive function needs a base case. What's the
                base case for factorial?
            - title: "\U0001F4A1 Hint"
              content: >-
                Base case: <code>if n &lt;= 1 { return 1 }</code>.
                Recursive case: <code>return n * factorial(n-1)</code>.
          solution: |-
            func factorial(n int) int {
                if n <= 1 {
                    return 1
                }
                return n * factorial(n-1)
            }
          annotations:
            - type: pattern
              label: Recursion
              text: >-
                Go supports recursion with no special syntax. Note that Go does NOT
                optimize tail calls, so deep recursion can overflow the stack.
                For large n, prefer iteration.

        - id: v10
          title: Function Composition
          description: >-
            Write <code>func compose(f, g func(int) int) func(int) int</code>
            that returns a new function computing <code>f(g(x))</code>. Test with
            double and addOne functions.
          functionSignature: "func compose(f, g func(int) int) func(int) int"
          difficulty: 3
          testCases:
            - input: "double := func(x int) int { return x * 2 }; addOne := func(x int) int { return x + 1 }; compose(double, addOne)(5)"
              output: "12"
            - input: "square := func(x int) int { return x * x }; negate := func(x int) int { return -x }; compose(negate, square)(3)"
              output: "-9"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                Functions in Go are first-class values. You can pass them
                as arguments and return them. How do you call a function variable?
            - title: "\U0001F4A1 Hint"
              content: >-
                Return <code>func(x int) int { return f(g(x)) }</code>.
                The closure captures both f and g.
          solution: |-
            func compose(f, g func(int) int) func(int) int {
                return func(x int) int {
                    return f(g(x))
                }
            }
          annotations:
            - type: idiom
              label: Higher-Order Functions
              text: >-
                Functions that take or return other functions are called
                higher-order functions. Go's first-class functions make
                composition, middleware, and decorators straightforward.

        - id: v11
          title: Validator Chain
          description: >-
            Write <code>func validate(s string, validators ...func(string) error) error</code>
            that runs a string through a chain of validator functions, returning
            the first error encountered or nil if all pass.
          functionSignature: "func validate(s string, validators ...func(string) error) error"
          difficulty: 3
          testCases:
            - input: "notEmpty := func(s string) error { if s == \"\" { return fmt.Errorf(\"empty\") }; return nil }; validate(\"hello\", notEmpty)"
              output: "nil"
            - input: "notEmpty := func(s string) error { if s == \"\" { return fmt.Errorf(\"empty\") }; return nil }; validate(\"\", notEmpty)"
              output: "empty"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                How do you combine variadic parameters with function values?
                What does <code>...func(string) error</code> look like inside the function?
            - title: "\U0001F4A1 Hint"
              content: >-
                Range over validators, call each with s, return the first
                non-nil error. If all pass, return nil.
          solution: |-
            func validate(s string, validators ...func(string) error) error {
                for _, v := range validators {
                    if err := v(s); err != nil {
                        return err
                    }
                }
                return nil
            }
          annotations:
            - type: pattern
              label: Validator Chain
              text: >-
                Passing validation functions as variadic arguments creates a
                composable validation pipeline. Each validator is independent
                and reusable across different contexts.

        - id: v12
          title: Higher-Order Filter
          description: >-
            Write <code>func filter(items []int, predicate func(int) bool) []int</code>
            that returns a new slice containing only elements where the predicate
            returns true. Do not modify the original slice.
          functionSignature: "func filter(items []int, predicate func(int) bool) []int"
          difficulty: 3
          testCases:
            - input: "filter([]int{1,2,3,4,5}, func(n int) bool { return n%2 == 0 })"
              output: "[2, 4]"
            - input: "filter([]int{10,20,30}, func(n int) bool { return n > 15 })"
              output: "[20, 30]"
            - input: "filter([]int{1,2,3}, func(n int) bool { return false })"
              output: "[]"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                How do you build a new slice without knowing the final
                size in advance?
            - title: "\U0001F4A1 Hint"
              content: >-
                Create an empty slice and <code>append</code> matching elements.
                Go's append handles the growing automatically.
          solution: |-
            func filter(items []int, predicate func(int) bool) []int {
                result := []int{}
                for _, item := range items {
                    if predicate(item) {
                        result = append(result, item)
                    }
                }
                return result
            }
          annotations:
            - type: idiom
              label: Filter Pattern
              text: >-
                Go doesn't have built-in filter/map. Writing your own is
                straightforward with first-class functions. Initialize with
                <code>[]int{}</code> (not nil) to return an empty slice, not null.

        - id: v13
          title: Middleware-Style Pipeline
          description: >-
            Write <code>func pipeline(input string, transforms ...func(string) string) string</code>
            that passes a string through a chain of transformation functions,
            each receiving the output of the previous one. Return the final result.
          functionSignature: "func pipeline(input string, transforms ...func(string) string) string"
          difficulty: 3
          testCases:
            - input: "pipeline(\"  Hello World  \", strings.TrimSpace, strings.ToLower)"
              output: "hello world"
            - input: "pipeline(\"hello\", strings.ToUpper, func(s string) string { return s + \"!\" })"
              output: "HELLO!"
            - input: "pipeline(\"unchanged\")"
              output: "unchanged"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                This is similar to Unix pipes: the output of one function
                feeds into the next. How do you thread a value through
                a chain of functions?
            - title: "\U0001F4A1 Hint"
              content: >-
                Loop over transforms, applying each to the current value:
                <code>input = t(input)</code>. The final value is the result.
          solution: |-
            func pipeline(input string, transforms ...func(string) string) string {
                for _, t := range transforms {
                    input = t(input)
                }
                return input
            }
          annotations:
            - type: pattern
              label: Pipeline Pattern
              text: >-
                Threading a value through a chain of functions is the pipeline
                pattern. It's the basis of Go middleware (HTTP handlers),
                compiler passes, and data processing workflows.

    # ── challenge_5: Multiple Returns ──────────────────────────────────────
    - id: challenge_5
      block: 1
      difficulty: 1
      concept: Multiple Returns
      docLinks:
        - url: https://go.dev/tour/moretypes/6
          title: "Go Tour: Multiple return values"
          note: returning multiple values
        - url: https://go.dev/blog/error-handling-and-go
          title: "Error handling and Go"
          note: value-error return pattern
      variants:
        - id: v1
          title: Parse Score Line
          description: >-
            Write <code>func parseScore(line string) (string, int, error)</code>
            that parses a line like <code>"Alice:95"</code> into the name and score.
            Split on <code>":"</code>, convert the score to int, and return both
            plus any error from conversion.
          functionSignature: func parseScore(line string) (string, int, error)
          difficulty: 1
          testCases:
            - input: "parseScore(\"Alice:95\")"
              output: "(\"Alice\", 95, nil)"
            - input: "parseScore(\"Bob:abc\")"
              output: "(\"\", 0, error)"
            - input: "parseScore(\"Charlie:0\")"
              output: "(\"Charlie\", 0, nil)"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                How do you split a string on a delimiter and then convert
                one of the parts to an integer?
            - title: "\U0001F4A1 Hint"
              content: >-
                Use <code>strings.SplitN(line, ":", 2)</code> to get name and score
                parts, then <code>strconv.Atoi</code> on the score part.
          solution: |-
            func parseScore(line string) (string, int, error) {
                parts := strings.SplitN(line, ":", 2)
                if len(parts) != 2 {
                    return "", 0, fmt.Errorf("invalid format")
                }
                score, err := strconv.Atoi(parts[1])
                if err != nil {
                    return "", 0, err
                }
                return parts[0], score, nil
            }
          annotations:
            - type: idiom
              label: Value-Error Returns
              text: >-
                Returning <code>(value, error)</code> is Go's fundamental pattern
                for operations that can fail. Callers always check the error
                before using the value.

        - id: v2
          title: Split Full Name
          description: >-
            Write <code>func splitName(full string) (string, string)</code>
            that splits a full name like <code>"Jane Doe"</code> into first
            and last name. If there's no space, return the full string as
            first name and an empty string as last name.
          functionSignature: func splitName(full string) (string, string)
          difficulty: 1
          testCases:
            - input: "splitName(\"Jane Doe\")"
              output: "(\"Jane\", \"Doe\")"
            - input: "splitName(\"Cher\")"
              output: "(\"Cher\", \"\")"
            - input: "splitName(\"Mary Jane Watson\")"
              output: "(\"Mary\", \"Jane Watson\")"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                How can you split only on the first space, keeping
                everything after it as the last name?
            - title: "\U0001F4A1 Hint"
              content: >-
                Use <code>strings.SplitN(full, " ", 2)</code> to split
                into at most 2 parts. Check the length of the result.
          solution: |-
            func splitName(full string) (string, string) {
                parts := strings.SplitN(full, " ", 2)
                if len(parts) == 1 {
                    return parts[0], ""
                }
                return parts[0], parts[1]
            }
          annotations:
            - type: idiom
              label: SplitN for Structured Text
              text: >-
                <code>strings.SplitN</code> with a limit of 2 splits only on
                the first occurrence — useful for key:value or first/rest patterns.

        - id: v3
          title: Parse Port Number
          description: >-
            Write <code>func parsePort(addr string) (string, int, error)</code>
            that takes an address like <code>"localhost:8080"</code> and returns
            the host, port number, and any error. Port must be between 1 and 65535.
          functionSignature: func parsePort(addr string) (string, int, error)
          difficulty: 1
          testCases:
            - input: "parsePort(\"localhost:8080\")"
              output: "(\"localhost\", 8080, nil)"
            - input: "parsePort(\"db:99999\")"
              output: "(\"\", 0, error)"
            - input: "parsePort(\"api:abc\")"
              output: "(\"\", 0, error)"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                After splitting and converting, what additional validation
                do you need for a port number?
            - title: "\U0001F4A1 Hint"
              content: >-
                Split on <code>":"</code>, convert with <code>strconv.Atoi</code>,
                then check <code>port >= 1 && port <= 65535</code>.
          solution: |-
            func parsePort(addr string) (string, int, error) {
                parts := strings.SplitN(addr, ":", 2)
                if len(parts) != 2 {
                    return "", 0, fmt.Errorf("missing port")
                }
                port, err := strconv.Atoi(parts[1])
                if err != nil {
                    return "", 0, err
                }
                if port < 1 || port > 65535 {
                    return "", 0, fmt.Errorf("port %d out of range", port)
                }
                return parts[0], port, nil
            }
          annotations:
            - type: pattern
              label: Parse then Validate
              text: >-
                After parsing, always validate the result. A successful parse
                doesn't mean the value is valid — ports must be 1-65535,
                ages must be positive, etc.

        - id: v4
          title: Divide with Remainder
          description: >-
            Write <code>func divmod(a, b int) (int, int, error)</code> that
            returns the quotient, remainder, and an error if <code>b</code> is zero.
          functionSignature: func divmod(a, b int) (int, int, error)
          difficulty: 1
          testCases:
            - input: "divmod(17, 5)"
              output: "(3, 2, nil)"
            - input: "divmod(10, 0)"
              output: "(0, 0, error)"
            - input: "divmod(20, 4)"
              output: "(5, 0, nil)"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                What should you check before performing division,
                and what two operators give you quotient and remainder?
            - title: "\U0001F4A1 Hint"
              content: >-
                Check <code>b == 0</code> first, then return
                <code>a / b, a % b, nil</code>.
          solution: |-
            func divmod(a, b int) (int, int, error) {
                if b == 0 {
                    return 0, 0, fmt.Errorf("division by zero")
                }
                return a / b, a % b, nil
            }
          annotations:
            - type: idiom
              label: Guard Clause
              text: >-
                Check error conditions first and return early. This keeps
                the happy path at the lowest indentation level.

        - id: v5
          title: Lookup with Fallback
          description: >-
            Write <code>func lookup(m map[string]int, key string, fallback int) (int, bool)</code>
            that looks up a key in a map. Return the value and <code>true</code>
            if found, or the fallback value and <code>false</code> if not.
          functionSignature: func lookup(m map[string]int, key string, fallback int) (int, bool)
          difficulty: 1
          testCases:
            - input: "lookup(map[string]int{\"a\": 1}, \"a\", 0)"
              output: "(1, true)"
            - input: "lookup(map[string]int{\"a\": 1}, \"b\", -1)"
              output: "(-1, false)"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                Go map lookups return two values. How do you use the
                second value to decide what to return?
            - title: "\U0001F4A1 Hint"
              content: >-
                Use <code>v, ok := m[key]</code>. If <code>ok</code>,
                return <code>v, true</code>; otherwise return <code>fallback, false</code>.
          solution: |-
            func lookup(m map[string]int, key string, fallback int) (int, bool) {
                v, ok := m[key]
                if ok {
                    return v, true
                }
                return fallback, false
            }
          annotations:
            - type: idiom
              label: Comma-OK Pattern
              text: >-
                The <code>v, ok := m[key]</code> pattern is Go's way of
                distinguishing "key not found" from "key maps to zero value."

        - id: v6
          title: Parse Key-Value Config
          description: >-
            Write <code>func parseConfig(line string) (string, string, error)</code>
            that parses a config line like <code>"timeout=30s"</code> into key and
            value. Return an error if there's no <code>"="</code> sign.
          functionSignature: func parseConfig(line string) (string, string, error)
          difficulty: 2
          testCases:
            - input: "parseConfig(\"timeout=30s\")"
              output: "(\"timeout\", \"30s\", nil)"
            - input: "parseConfig(\"invalid-line\")"
              output: "(\"\", \"\", error)"
            - input: "parseConfig(\"key=val=ue\")"
              output: "(\"key\", \"val=ue\", nil)"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                What happens if the value itself contains an <code>=</code> sign?
                How do you split only on the first occurrence?
            - title: "\U0001F4A1 Hint"
              content: >-
                Use <code>strings.SplitN(line, "=", 2)</code> to handle values
                that contain <code>=</code>.
          solution: |-
            func parseConfig(line string) (string, string, error) {
                parts := strings.SplitN(line, "=", 2)
                if len(parts) != 2 {
                    return "", "", fmt.Errorf("missing '=' in config line")
                }
                return parts[0], parts[1], nil
            }
          annotations:
            - type: pattern
              label: Robust Parsing
              text: >-
                When parsing structured text, always use <code>SplitN</code>
                with a limit to avoid breaking on delimiters that appear
                in the value portion.

        - id: v7
          title: Parse URL Parts
          description: >-
            Write <code>func parseURL(raw string) (string, string, string, error)</code>
            that parses a URL like <code>"https://example.com/path"</code> into
            scheme, host, and path. Return an error for malformed URLs.
          functionSignature: func parseURL(raw string) (string, string, string, error)
          difficulty: 2
          testCases:
            - input: "parseURL(\"https://example.com/path\")"
              output: "(\"https\", \"example.com\", \"/path\", nil)"
            - input: "parseURL(\"http://localhost:8080/api/v1\")"
              output: "(\"http\", \"localhost:8080\", \"/api/v1\", nil)"
            - input: "parseURL(\"no-scheme\")"
              output: "(\"\", \"\", \"\", error)"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                A URL has the form <code>scheme://host/path</code>. How would
                you split on <code>://</code> first, then find the path?
            - title: "\U0001F4A1 Hint"
              content: >-
                Split on <code>"://"</code> to get scheme and the rest.
                Then use <code>strings.Index</code> to find the first <code>"/"</code>
                in the remainder to separate host from path.
          solution: |-
            func parseURL(raw string) (string, string, string, error) {
                parts := strings.SplitN(raw, "://", 2)
                if len(parts) != 2 {
                    return "", "", "", fmt.Errorf("missing scheme")
                }
                scheme := parts[0]
                rest := parts[1]
                slashIdx := strings.Index(rest, "/")
                if slashIdx == -1 {
                    return scheme, rest, "/", nil
                }
                return scheme, rest[:slashIdx], rest[slashIdx:], nil
            }
          annotations:
            - type: pattern
              label: Multi-step Parsing
              text: >-
                Complex formats are parsed in stages — first extract the
                scheme, then separate host from path. Each step reduces
                the problem.

        - id: v8
          title: Safe Array Access
          description: >-
            Write <code>func safeGet(items []string, index int) (string, bool)</code>
            that returns the element at the given index and <code>true</code>,
            or an empty string and <code>false</code> if the index is out of bounds.
          functionSignature: func safeGet(items []string, index int) (string, bool)
          difficulty: 2
          testCases:
            - input: "safeGet([]string{\"a\", \"b\", \"c\"}, 1)"
              output: "(\"b\", true)"
            - input: "safeGet([]string{\"a\", \"b\"}, 5)"
              output: "(\"\", false)"
            - input: "safeGet([]string{\"a\"}, -1)"
              output: "(\"\", false)"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                What two conditions make an index invalid for a slice?
            - title: "\U0001F4A1 Hint"
              content: >-
                Check <code>index < 0 || index >= len(items)</code>
                before accessing <code>items[index]</code>.
          solution: |-
            func safeGet(items []string, index int) (string, bool) {
                if index < 0 || index >= len(items) {
                    return "", false
                }
                return items[index], true
            }
          annotations:
            - type: idiom
              label: Bounds-Checked Access
              text: >-
                Go panics on out-of-bounds access. Wrapping it with a
                bounds check and returning <code>(value, ok)</code> follows
                the same pattern as map lookups.

        - id: v9
          title: Min-Max of Slice
          description: >-
            Write <code>func minMax(nums []int) (int, int, error)</code> that
            returns the minimum and maximum values in a slice. Return an error
            if the slice is empty.
          functionSignature: func minMax(nums []int) (int, int, error)
          difficulty: 2
          testCases:
            - input: "minMax([]int{3, 1, 4, 1, 5, 9})"
              output: "(1, 9, nil)"
            - input: "minMax([]int{42})"
              output: "(42, 42, nil)"
            - input: "minMax([]int{})"
              output: "(0, 0, error)"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                What should you initialize min and max to? Using the first
                element avoids edge cases with arbitrary initial values.
            - title: "\U0001F4A1 Hint"
              content: >-
                Set <code>min, max := nums[0], nums[0]</code>, then loop
                from index 1 comparing each element.
          solution: |-
            func minMax(nums []int) (int, int, error) {
                if len(nums) == 0 {
                    return 0, 0, fmt.Errorf("empty slice")
                }
                mn, mx := nums[0], nums[0]
                for _, n := range nums[1:] {
                    if n < mn {
                        mn = n
                    }
                    if n > mx {
                        mx = n
                    }
                }
                return mn, mx, nil
            }
          annotations:
            - type: idiom
              label: Initialize from First Element
              text: >-
                When computing min/max, initialize from the first element
                rather than <code>math.MaxInt</code>. It's cleaner and works
                for any comparable type.

        - id: v10
          title: Binary Search with Found
          description: >-
            Write <code>func binarySearch(sorted []int, target int) (int, bool)</code>
            that returns the index where <code>target</code> was found and
            <code>true</code>, or <code>-1</code> and <code>false</code> if not present.
          functionSignature: func binarySearch(sorted []int, target int) (int, bool)
          difficulty: 2
          testCases:
            - input: "binarySearch([]int{1, 3, 5, 7, 9}, 5)"
              output: "(2, true)"
            - input: "binarySearch([]int{1, 3, 5, 7, 9}, 4)"
              output: "(-1, false)"
            - input: "binarySearch([]int{}, 1)"
              output: "(-1, false)"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                Binary search narrows the search range by half each step.
                What are the three cases when comparing the middle element?
            - title: "\U0001F4A1 Hint"
              content: >-
                Use <code>lo, hi := 0, len(sorted)-1</code>. Compare
                <code>sorted[mid]</code> with target to adjust lo or hi.
          solution: |-
            func binarySearch(sorted []int, target int) (int, bool) {
                lo, hi := 0, len(sorted)-1
                for lo <= hi {
                    mid := lo + (hi-lo)/2
                    if sorted[mid] == target {
                        return mid, true
                    } else if sorted[mid] < target {
                        lo = mid + 1
                    } else {
                        hi = mid - 1
                    }
                }
                return -1, false
            }
          annotations:
            - type: pattern
              label: Binary Search
              text: >-
                Use <code>lo + (hi-lo)/2</code> instead of <code>(lo+hi)/2</code>
                to avoid integer overflow. Return <code>(index, found)</code> to
                distinguish "not found" from "found at index 0."

        - id: v11
          title: Parse CSV Header
          description: >-
            Write <code>func parseCSVHeader(header string, required []string) ([]int, error)</code>
            that splits a CSV header line on commas, then for each required column
            returns its index. Return an error if any required column is missing.
          functionSignature: func parseCSVHeader(header string, required []string) ([]int, error)
          difficulty: 3
          testCases:
            - input: "parseCSVHeader(\"name,age,email\", []string{\"age\", \"name\"})"
              output: "([1, 0], nil)"
            - input: "parseCSVHeader(\"name,age\", []string{\"email\"})"
              output: "(nil, error)"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                How do you efficiently look up column names? Building
                a map from the header gives O(1) lookups.
            - title: "\U0001F4A1 Hint"
              content: >-
                Split the header into columns, build a <code>map[string]int</code>
                of column name to index, then look up each required column.
          solution: |-
            func parseCSVHeader(header string, required []string) ([]int, error) {
                cols := strings.Split(header, ",")
                colIdx := make(map[string]int)
                for i, col := range cols {
                    colIdx[strings.TrimSpace(col)] = i
                }
                indices := make([]int, len(required))
                for i, req := range required {
                    idx, ok := colIdx[req]
                    if !ok {
                        return nil, fmt.Errorf("missing column: %s", req)
                    }
                    indices[i] = idx
                }
                return indices, nil
            }
          annotations:
            - type: pattern
              label: Index Map
              text: >-
                Building a map from names to indices is a common pattern
                for CSV/table processing. It decouples column order from
                access logic.

        - id: v12
          title: Parse Semver
          description: >-
            Write <code>func parseSemver(version string) (int, int, int, error)</code>
            that parses a semantic version string like <code>"1.2.3"</code> into
            major, minor, and patch integers. Return an error if the format is invalid.
          functionSignature: func parseSemver(version string) (int, int, int, error)
          difficulty: 3
          testCases:
            - input: "parseSemver(\"1.2.3\")"
              output: "(1, 2, 3, nil)"
            - input: "parseSemver(\"10.0.1\")"
              output: "(10, 0, 1, nil)"
            - input: "parseSemver(\"1.2\")"
              output: "(0, 0, 0, error)"
            - input: "parseSemver(\"a.b.c\")"
              output: "(0, 0, 0, error)"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                You need exactly three parts, all valid integers.
                What's the cleanest way to validate this?
            - title: "\U0001F4A1 Hint"
              content: >-
                Split on <code>"."</code>, check length is 3, convert each
                with <code>strconv.Atoi</code>, and check all three errors.
          solution: |-
            func parseSemver(version string) (int, int, int, error) {
                parts := strings.Split(version, ".")
                if len(parts) != 3 {
                    return 0, 0, 0, fmt.Errorf("expected 3 parts, got %d", len(parts))
                }
                major, err := strconv.Atoi(parts[0])
                if err != nil {
                    return 0, 0, 0, err
                }
                minor, err := strconv.Atoi(parts[1])
                if err != nil {
                    return 0, 0, 0, err
                }
                patch, err := strconv.Atoi(parts[2])
                if err != nil {
                    return 0, 0, 0, err
                }
                return major, minor, patch, nil
            }
          annotations:
            - type: pattern
              label: Sequential Validation
              text: >-
                When parsing multiple fields, validate each one and return
                early on the first error. This keeps the code flat and
                makes error messages specific.

        - id: v13
          title: Decode Basic Auth
          description: >-
            Write <code>func decodeBasicAuth(encoded string) (string, string, error)</code>
            that takes a Base64-encoded string representing <code>"user:password"</code>,
            decodes it, and returns the username and password separately.
            Return an error if decoding fails or the format is wrong.
          functionSignature: func decodeBasicAuth(encoded string) (string, string, error)
          difficulty: 3
          testCases:
            - input: "decodeBasicAuth(\"YWRtaW46c2VjcmV0\")"
              output: "(\"admin\", \"secret\", nil)"
            - input: "decodeBasicAuth(\"dXNlcjpwQHNz\")"
              output: "(\"user\", \"p@ss\", nil)"
            - input: "decodeBasicAuth(\"!!!invalid\")"
              output: "(\"\", \"\", error)"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                Base64 decoding gives you bytes. After converting to a
                string, how do you split the <code>"user:password"</code> format?
            - title: "\U0001F4A1 Hint"
              content: >-
                Use <code>encoding/base64.StdEncoding.DecodeString</code>,
                convert bytes to string, then <code>strings.SplitN</code>
                with limit 2 on <code>":"</code>.
          solution: |-
            func decodeBasicAuth(encoded string) (string, string, error) {
                decoded, err := base64.StdEncoding.DecodeString(encoded)
                if err != nil {
                    return "", "", err
                }
                parts := strings.SplitN(string(decoded), ":", 2)
                if len(parts) != 2 {
                    return "", "", fmt.Errorf("invalid format: missing ':'")
                }
                return parts[0], parts[1], nil
            }
          annotations:
            - type: pattern
              label: Layered Decoding
              text: >-
                Complex formats often require layered decoding — first decode
                the encoding (Base64), then parse the structure (user:pass).
                Each layer has its own error to check.

    # ── challenge_6: Error Handling ────────────────────────────────────────
    - id: challenge_6
      block: 1
      difficulty: 2
      concept: Error Handling
      docLinks:
        - url: https://go.dev/blog/error-handling-and-go
          title: "Error handling and Go"
          note: idiomatic error handling
        - url: https://pkg.go.dev/errors
          title: "Package errors"
          note: errors.New, errors.Is, errors.As
      variants:
        - id: v1
          title: Wrap Error with Context
          description: >-
            Write <code>func readConfig(path string) (string, error)</code>
            that simulates reading a config file. If the path is empty, return
            an error wrapped with context: <code>"readConfig: empty path"</code>.
            Otherwise return the path as a placeholder value.
          functionSignature: func readConfig(path string) (string, error)
          difficulty: 1
          testCases:
            - input: "readConfig(\"\")"
              output: "(\"\", error)"
            - input: "readConfig(\"/etc/app.conf\")"
              output: "(\"/etc/app.conf\", nil)"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                How do you create an error message that includes context
                about which function failed and why?
            - title: "\U0001F4A1 Hint"
              content: >-
                Use <code>fmt.Errorf("readConfig: %s", reason)</code> to
                wrap the error with the function name as context.
          solution: |-
            func readConfig(path string) (string, error) {
                if path == "" {
                    return "", fmt.Errorf("readConfig: empty path")
                }
                return path, nil
            }
          annotations:
            - type: idiom
              label: Error Context
              text: >-
                Prefix error messages with the function name to create a
                call chain: <code>"readConfig: open: no such file"</code>.
                This makes debugging much easier.

        - id: v2
          title: Validate Age Range
          description: >-
            Write <code>func validateAge(age int) error</code> that returns
            <code>nil</code> if age is between 0 and 150 (inclusive), or an
            error describing what's wrong (negative, too large).
          functionSignature: func validateAge(age int) error
          difficulty: 1
          testCases:
            - input: "validateAge(25)"
              output: "nil"
            - input: "validateAge(-1)"
              output: "error"
            - input: "validateAge(200)"
              output: "error"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                A validation function returns <code>nil</code> for valid
                input. How do you express the two different failure modes?
            - title: "\U0001F4A1 Hint"
              content: >-
                Use <code>if age < 0</code> and <code>if age > 150</code>
                with specific error messages for each case.
          solution: |-
            func validateAge(age int) error {
                if age < 0 {
                    return fmt.Errorf("age cannot be negative: %d", age)
                }
                if age > 150 {
                    return fmt.Errorf("age unreasonably large: %d", age)
                }
                return nil
            }
          annotations:
            - type: idiom
              label: Validation Functions
              text: >-
                Functions that validate return <code>error</code> only.
                Callers check <code>if err := validate(x); err != nil</code>.
                Each failure mode gets a distinct message.

        - id: v3
          title: Chain Username Validations
          description: >-
            Write <code>func validateUsername(name string) error</code> that
            checks: length 3-20, starts with a letter, contains only
            letters/digits/underscores. Return the first failing rule's error.
          functionSignature: func validateUsername(name string) error
          difficulty: 1
          testCases:
            - input: "validateUsername(\"go_dev42\")"
              output: "nil"
            - input: "validateUsername(\"ab\")"
              output: "error"
            - input: "validateUsername(\"3invalid\")"
              output: "error"
            - input: "validateUsername(\"has space\")"
              output: "error"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                When multiple rules apply, what's the cleanest order
                to check them, and should you stop at the first failure?
            - title: "\U0001F4A1 Hint"
              content: >-
                Check length first, then the first character with
                <code>unicode.IsLetter</code>, then loop through all
                characters checking each is valid.
          solution: |-
            func validateUsername(name string) error {
                if len(name) < 3 || len(name) > 20 {
                    return fmt.Errorf("length must be 3-20, got %d", len(name))
                }
                if !unicode.IsLetter(rune(name[0])) {
                    return fmt.Errorf("must start with a letter")
                }
                for _, ch := range name {
                    if !unicode.IsLetter(ch) && !unicode.IsDigit(ch) && ch != '_' {
                        return fmt.Errorf("invalid character: %c", ch)
                    }
                }
                return nil
            }
          annotations:
            - type: pattern
              label: Ordered Validation
              text: >-
                Check the cheapest validations first (length) before
                expensive ones (character scanning). Return on the first
                failure for clear error messages.

        - id: v4
          title: Parse Config Entry
          description: >-
            Write <code>func parseConfigEntry(line string) (string, int, error)</code>
            that parses a config line like <code>"max_retries=5"</code>. The key
            must be non-empty, the value must be a positive integer. Return specific
            errors for each failure: missing <code>=</code>, empty key, invalid number,
            non-positive value.
          functionSignature: func parseConfigEntry(line string) (string, int, error)
          difficulty: 2
          testCases:
            - input: "parseConfigEntry(\"max_retries=5\")"
              output: "(\"max_retries\", 5, nil)"
            - input: "parseConfigEntry(\"no-equals\")"
              output: "(\"\", 0, error)"
            - input: "parseConfigEntry(\"=100\")"
              output: "(\"\", 0, error)"
            - input: "parseConfigEntry(\"timeout=-1\")"
              output: "(\"\", 0, error)"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                There are four different things that can go wrong.
                How do you check them in order and give useful messages?
            - title: "\U0001F4A1 Hint"
              content: >-
                Split on <code>"="</code>, check parts count, check key
                non-empty, parse value with <code>strconv.Atoi</code>,
                check positivity.
          solution: |-
            func parseConfigEntry(line string) (string, int, error) {
                parts := strings.SplitN(line, "=", 2)
                if len(parts) != 2 {
                    return "", 0, fmt.Errorf("missing '=' delimiter")
                }
                key := parts[0]
                if key == "" {
                    return "", 0, fmt.Errorf("empty key")
                }
                val, err := strconv.Atoi(parts[1])
                if err != nil {
                    return "", 0, fmt.Errorf("invalid number: %s", parts[1])
                }
                if val <= 0 {
                    return "", 0, fmt.Errorf("value must be positive: %d", val)
                }
                return key, val, nil
            }
          annotations:
            - type: pattern
              label: Layered Validation
              text: >-
                Each step validates one aspect and returns a specific error.
                This makes debugging easy — the error tells you exactly
                which validation failed.

        - id: v5
          title: Sentinel Error Pattern
          description: >-
            Define sentinel errors <code>ErrNotFound</code> and <code>ErrForbidden</code>.
            Write <code>func getResource(id int) (string, error)</code>: return
            <code>ErrNotFound</code> for id &lt; 0, <code>ErrForbidden</code> for
            id == 0, and a resource string for positive ids.
          functionSignature: func getResource(id int) (string, error)
          difficulty: 2
          testCases:
            - input: "getResource(1)"
              output: "(\"resource-1\", nil)"
            - input: "errors.Is(err, ErrNotFound) where _, err = getResource(-1)"
              output: "true"
            - input: "errors.Is(err, ErrForbidden) where _, err = getResource(0)"
              output: "true"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                Sentinel errors are package-level variables. How does
                the caller check which specific error was returned?
            - title: "\U0001F4A1 Hint"
              content: >-
                Define <code>var ErrNotFound = errors.New("not found")</code>
                at package level. Callers use <code>errors.Is(err, ErrNotFound)</code>.
          solution: |-
            var (
                ErrNotFound  = errors.New("not found")
                ErrForbidden = errors.New("forbidden")
            )

            func getResource(id int) (string, error) {
                if id < 0 {
                    return "", ErrNotFound
                }
                if id == 0 {
                    return "", ErrForbidden
                }
                return fmt.Sprintf("resource-%d", id), nil
            }
          annotations:
            - type: idiom
              label: Sentinel Errors
              text: >-
                Sentinel errors like <code>io.EOF</code> are predefined
                values callers compare against with <code>errors.Is</code>.
                They represent expected, well-known failure conditions.

        - id: v6
          title: Custom Error Type
          description: >-
            Define a <code>ValidationError</code> struct with <code>Field</code>
            and <code>Message</code> fields that implements the <code>error</code>
            interface. Write <code>func validateEmail(email string) error</code>
            that returns a <code>*ValidationError</code> if the email lacks an
            <code>"@"</code> sign.
          functionSignature: func validateEmail(email string) error
          difficulty: 2
          testCases:
            - input: "validateEmail(\"user@example.com\")"
              output: "nil"
            - input: "validateEmail(\"invalid\")"
              output: "error"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                Custom error types carry structured data. How does a struct
                satisfy the <code>error</code> interface?
            - title: "\U0001F4A1 Hint"
              content: >-
                Add an <code>Error() string</code> method to your struct.
                Return <code>&ValidationError{Field: "email", Message: "..."}</code>.
          solution: |-
            type ValidationError struct {
                Field   string
                Message string
            }

            func (e *ValidationError) Error() string {
                return fmt.Sprintf("%s: %s", e.Field, e.Message)
            }

            func validateEmail(email string) error {
                if !strings.Contains(email, "@") {
                    return &ValidationError{
                        Field:   "email",
                        Message: "missing '@' symbol",
                    }
                }
                return nil
            }
          annotations:
            - type: idiom
              label: Custom Error Types
              text: >-
                Custom error types carry structured data beyond a message.
                Callers use <code>errors.As</code> to extract the concrete
                type and inspect its fields.

        - id: v7
          title: Retry Logic Counter
          description: >-
            Write <code>func retry(maxAttempts int, fn func() error) (int, error)</code>
            that calls <code>fn</code> up to <code>maxAttempts</code> times. If it
            succeeds, return the number of attempts used and <code>nil</code>.
            If all attempts fail, return <code>maxAttempts</code> and the last error.
          functionSignature: func retry(maxAttempts int, fn func() error) (int, error)
          difficulty: 2
          testCases:
            - input: "retry(3, func() error { return nil })"
              output: "(1, nil)"
            - input: "retry(3, alwaysFails)"
              output: "(3, error)"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                You need to track both the attempt count and the last
                error seen. When should the loop stop?
            - title: "\U0001F4A1 Hint"
              content: >-
                Loop from 1 to maxAttempts. Call fn, if nil return the count.
                Otherwise save the error and continue. After the loop,
                return the last error.
          solution: |-
            func retry(maxAttempts int, fn func() error) (int, error) {
                var lastErr error
                for i := 1; i <= maxAttempts; i++ {
                    lastErr = fn()
                    if lastErr == nil {
                        return i, nil
                    }
                }
                return maxAttempts, lastErr
            }
          annotations:
            - type: pattern
              label: Retry Pattern
              text: >-
                The retry pattern wraps an unreliable operation in a loop.
                Always cap attempts and return the last error so callers
                know why all retries failed.

        - id: v8
          title: Validate IP Address
          description: >-
            Write <code>func validateIP(ip string) error</code> that validates
            an IPv4 address. It must have exactly 4 octets separated by dots,
            each being an integer 0-255 with no leading zeros.
          functionSignature: func validateIP(ip string) error
          difficulty: 2
          testCases:
            - input: "validateIP(\"192.168.1.1\")"
              output: "nil"
            - input: "validateIP(\"256.1.1.1\")"
              output: "error"
            - input: "validateIP(\"1.2.3\")"
              output: "error"
            - input: "validateIP(\"01.2.3.4\")"
              output: "error"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                What are all the ways an IP address can be invalid?
                Count, range, and leading zeros are the main checks.
            - title: "\U0001F4A1 Hint"
              content: >-
                Split on <code>"."</code>, check length is 4, for each
                octet convert to int, check 0-255, and check the string
                form matches <code>strconv.Itoa</code> of the number (no leading zeros).
          solution: |-
            func validateIP(ip string) error {
                parts := strings.Split(ip, ".")
                if len(parts) != 4 {
                    return fmt.Errorf("expected 4 octets, got %d", len(parts))
                }
                for i, part := range parts {
                    n, err := strconv.Atoi(part)
                    if err != nil {
                        return fmt.Errorf("octet %d: not a number", i)
                    }
                    if n < 0 || n > 255 {
                        return fmt.Errorf("octet %d: %d out of range", i, n)
                    }
                    if part != strconv.Itoa(n) {
                        return fmt.Errorf("octet %d: leading zeros", i)
                    }
                }
                return nil
            }
          annotations:
            - type: pattern
              label: Round-Trip Validation
              text: >-
                Comparing <code>part != strconv.Itoa(n)</code> is a round-trip
                check — convert to int and back. If the strings differ,
                there were leading zeros or whitespace.

        - id: v9
          title: Error Accumulator
          description: >-
            Write <code>func validateForm(fields map[string]string) []error</code>
            that checks multiple fields and collects all errors, not just the first.
            Check: "name" is non-empty, "email" contains "@", "age" is a
            valid positive integer.
          functionSignature: func validateForm(fields map[string]string) []error
          difficulty: 2
          testCases:
            - input: "len(validateForm(map[string]string{\"name\": \"Jo\", \"email\": \"a@b\", \"age\": \"25\"}))"
              output: "0"
            - input: "len(validateForm(map[string]string{\"name\": \"\", \"email\": \"bad\", \"age\": \"-1\"}))"
              output: "3"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                Instead of returning on the first error, how do you
                collect all errors and return them together?
            - title: "\U0001F4A1 Hint"
              content: >-
                Create a <code>var errs []error</code> slice. For each
                validation, if it fails, <code>append</code> the error.
                Return the slice (nil if empty).
          solution: |-
            func validateForm(fields map[string]string) []error {
                var errs []error
                if fields["name"] == "" {
                    errs = append(errs, fmt.Errorf("name: required"))
                }
                if !strings.Contains(fields["email"], "@") {
                    errs = append(errs, fmt.Errorf("email: must contain '@'"))
                }
                age, err := strconv.Atoi(fields["age"])
                if err != nil {
                    errs = append(errs, fmt.Errorf("age: not a number"))
                } else if age <= 0 {
                    errs = append(errs, fmt.Errorf("age: must be positive"))
                }
                return errs
            }
          annotations:
            - type: pattern
              label: Error Accumulation
              text: >-
                Collecting all errors (instead of failing fast) gives users
                complete feedback. Return <code>[]error</code> — a nil slice
                means no errors.

        - id: v10
          title: Parse Multi-Line Config
          description: >-
            Write <code>func parseMultiConfig(input string) (map[string]string, error)</code>
            that parses a multi-line config (one <code>key=value</code> per line).
            Skip blank lines and lines starting with <code>#</code>. Return an error
            listing all malformed lines with their line numbers.
          functionSignature: func parseMultiConfig(input string) (map[string]string, error)
          difficulty: 3
          testCases:
            - input: "parseMultiConfig(\"host=localhost\\nport=8080\")"
              output: "(map[host:localhost port:8080], nil)"
            - input: "parseMultiConfig(\"# comment\\n\\nkey=val\")"
              output: "(map[key:val], nil)"
            - input: "parseMultiConfig(\"good=yes\\nbadline\")"
              output: "(nil, error)"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                You need to track line numbers for errors and handle
                three cases: comments, blank lines, and key=value lines.
            - title: "\U0001F4A1 Hint"
              content: >-
                Split on <code>"\\n"</code>, loop with index. Use
                <code>strings.HasPrefix</code> for comments, <code>strings.TrimSpace</code>
                for blank lines, and <code>strings.SplitN</code> for key=value.
          solution: |-
            func parseMultiConfig(input string) (map[string]string, error) {
                result := make(map[string]string)
                var errs []string
                lines := strings.Split(input, "\n")
                for i, line := range lines {
                    line = strings.TrimSpace(line)
                    if line == "" || strings.HasPrefix(line, "#") {
                        continue
                    }
                    parts := strings.SplitN(line, "=", 2)
                    if len(parts) != 2 {
                        errs = append(errs, fmt.Sprintf("line %d: missing '='", i+1))
                        continue
                    }
                    result[parts[0]] = parts[1]
                }
                if len(errs) > 0 {
                    return nil, fmt.Errorf("%s", strings.Join(errs, "; "))
                }
                return result, nil
            }
          annotations:
            - type: pattern
              label: Lenient Parsing
              text: >-
                Skip blank lines and comments, accumulate errors with line
                numbers, and report them all at once. This is more helpful
                than stopping at the first error.

        - id: v11
          title: Validate Credit Card (Luhn)
          description: >-
            Write <code>func validateCard(number string) error</code> that
            implements the Luhn algorithm to validate a credit card number string.
            Ignore spaces. Return an error if the number contains non-digits
            (after removing spaces) or fails the Luhn check.
          functionSignature: func validateCard(number string) error
          difficulty: 3
          testCases:
            - input: "validateCard(\"4539 1488 0343 6467\")"
              output: "nil"
            - input: "validateCard(\"1234 5678 9012 3456\")"
              output: "error"
            - input: "validateCard(\"abcd\")"
              output: "error"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                The Luhn algorithm doubles every second digit from the right.
                If doubling produces a number over 9, subtract 9.
            - title: "\U0001F4A1 Hint"
              content: >-
                Strip spaces, validate all chars are digits, then iterate
                from right to left. Double every other digit, sum all,
                check if total % 10 == 0.
          solution: |-
            func validateCard(number string) error {
                cleaned := strings.ReplaceAll(number, " ", "")
                if len(cleaned) < 2 {
                    return fmt.Errorf("number too short")
                }
                sum := 0
                double := false
                for i := len(cleaned) - 1; i >= 0; i-- {
                    d := int(cleaned[i] - '0')
                    if d < 0 || d > 9 {
                        return fmt.Errorf("non-digit character: %c", cleaned[i])
                    }
                    if double {
                        d *= 2
                        if d > 9 {
                            d -= 9
                        }
                    }
                    sum += d
                    double = !double
                }
                if sum%10 != 0 {
                    return fmt.Errorf("Luhn check failed")
                }
                return nil
            }
          annotations:
            - type: pattern
              label: Checksum Validation
              text: >-
                The Luhn algorithm is a checksum — a single formula that
                catches most typos. Many IDs (credit cards, IMEIs) use
                similar check-digit schemes.

        - id: v12
          title: Build Error Tree
          description: >-
            Write <code>func validateServer(config map[string]string) error</code>
            that validates "host", "port", and "protocol" fields. Wrap each
            sub-error with <code>fmt.Errorf("field: %w", err)</code> so callers
            can unwrap the chain. Return the first error found.
          functionSignature: func validateServer(config map[string]string) error
          difficulty: 3
          testCases:
            - input: "validateServer(map[string]string{\"host\": \"localhost\", \"port\": \"8080\", \"protocol\": \"tcp\"})"
              output: "nil"
            - input: "validateServer(map[string]string{\"host\": \"\", \"port\": \"8080\", \"protocol\": \"tcp\"})"
              output: "error"
            - input: "validateServer(map[string]string{\"host\": \"localhost\", \"port\": \"abc\", \"protocol\": \"tcp\"})"
              output: "error"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                The <code>%w</code> verb in <code>fmt.Errorf</code> wraps
                an error so it can be unwrapped later. How does this
                create an error chain?
            - title: "\U0001F4A1 Hint"
              content: >-
                Validate each field with a helper, and if it fails, wrap:
                <code>fmt.Errorf("port: %w", err)</code>. This preserves
                the original error for <code>errors.Is</code>/<code>errors.As</code>.
          solution: |-
            func validateServer(config map[string]string) error {
                if config["host"] == "" {
                    return fmt.Errorf("host: %w", fmt.Errorf("required"))
                }
                port, err := strconv.Atoi(config["port"])
                if err != nil {
                    return fmt.Errorf("port: %w", err)
                }
                if port < 1 || port > 65535 {
                    return fmt.Errorf("port: %w", fmt.Errorf("out of range: %d", port))
                }
                proto := config["protocol"]
                if proto != "tcp" && proto != "udp" {
                    return fmt.Errorf("protocol: %w", fmt.Errorf("must be tcp or udp"))
                }
                return nil
            }
          annotations:
            - type: idiom
              label: Error Wrapping
              text: >-
                The <code>%w</code> verb wraps errors, creating a chain.
                Callers use <code>errors.Is</code> and <code>errors.As</code>
                to inspect wrapped errors without string matching.

        - id: v13
          title: Transaction Rollback
          description: >-
            Write <code>func executeTransaction(steps []func() error) error</code>
            that runs each step in order. If any step fails, return an error
            indicating which step failed (by index) and the original error,
            wrapped with <code>%w</code>. Simulate rollback by returning early.
          functionSignature: func executeTransaction(steps []func() error) error
          difficulty: 3
          testCases:
            - input: "executeTransaction([]func() error{ok, ok, ok})"
              output: "nil"
            - input: "executeTransaction([]func() error{ok, fail, ok})"
              output: "error"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                In a transaction, if step 3 of 5 fails, you stop and
                report the failure. How do you track which step it was?
            - title: "\U0001F4A1 Hint"
              content: >-
                Loop with index over steps. If <code>step()</code> returns
                an error, wrap it: <code>fmt.Errorf("step %d: %w", i, err)</code>
                and return immediately.
          solution: |-
            func executeTransaction(steps []func() error) error {
                for i, step := range steps {
                    if err := step(); err != nil {
                        return fmt.Errorf("step %d failed: %w", i, err)
                    }
                }
                return nil
            }
          annotations:
            - type: pattern
              label: Transaction Pattern
              text: >-
                Run steps sequentially and abort on first failure. The
                wrapped error tells callers which step failed and why,
                enabling targeted recovery.

    # ── challenge_7: For Loops ─────────────────────────────────────────────
    - id: challenge_7
      block: 1
      difficulty: 1
      concept: For Loops
      docLinks:
        - url: https://go.dev/tour/flowcontrol/1
          title: "Go Tour: For"
          note: the only looping construct
        - url: https://go.dev/ref/spec#For_statements
          title: "Go Spec: For statements"
          note: specification details
      variants:
        - id: v1
          title: Sum Digits
          description: >-
            Write <code>func sumDigits(n int) int</code> that returns the sum
            of all digits in a non-negative integer. For example,
            <code>sumDigits(1234)</code> returns <code>10</code>.
          functionSignature: func sumDigits(n int) int
          difficulty: 1
          testCases:
            - input: "sumDigits(1234)"
              output: "10"
            - input: "sumDigits(0)"
              output: "0"
            - input: "sumDigits(999)"
              output: "27"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                How do you extract the last digit of a number, and
                how do you remove it to get the remaining digits?
            - title: "\U0001F4A1 Hint"
              content: >-
                Use <code>n % 10</code> to get the last digit and
                <code>n / 10</code> to remove it. Loop while <code>n > 0</code>.
          solution: |-
            func sumDigits(n int) int {
                sum := 0
                for n > 0 {
                    sum += n % 10
                    n /= 10
                }
                return sum
            }
          annotations:
            - type: idiom
              label: Digit Extraction
              text: >-
                The <code>% 10</code> and <code>/ 10</code> pattern extracts
                digits right-to-left. It's the basis of many number-processing
                algorithms.

        - id: v2
          title: Count Words
          description: >-
            Write <code>func countWords(s string) int</code> that counts
            the number of words in a sentence, where words are separated
            by spaces. Multiple consecutive spaces should count as one separator.
            An empty string has zero words.
          functionSignature: func countWords(s string) int
          difficulty: 1
          testCases:
            - input: "countWords(\"hello world\")"
              output: "2"
            - input: "countWords(\"  multiple   spaces  \")"
              output: "2"
            - input: "countWords(\"\")"
              output: "0"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                <code>strings.Fields</code> splits on any whitespace and
                ignores leading/trailing spaces. Could that simplify this?
            - title: "\U0001F4A1 Hint"
              content: >-
                Use <code>strings.Fields(s)</code> which splits on whitespace
                and returns a slice of words. Return <code>len</code> of that slice.
          solution: |-
            func countWords(s string) int {
                return len(strings.Fields(s))
            }
          annotations:
            - type: idiom
              label: strings.Fields
              text: >-
                <code>strings.Fields</code> is better than <code>strings.Split</code>
                for word counting — it handles multiple spaces and trims
                automatically.

        - id: v3
          title: Multiplication Table
          description: >-
            Write <code>func mulTable(n int) []string</code> that generates
            lines of the multiplication table for <code>n</code>, from
            <code>n×1</code> to <code>n×10</code>. Each line is formatted as
            <code>"5 x 3 = 15"</code>.
          functionSignature: func mulTable(n int) []string
          difficulty: 1
          testCases:
            - input: "mulTable(3)[0]"
              output: "3 x 1 = 3"
            - input: "mulTable(3)[9]"
              output: "3 x 10 = 30"
            - input: "len(mulTable(7))"
              output: "10"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                You need a loop from 1 to 10, building a formatted string
                each iteration. What's the best way to collect the results?
            - title: "\U0001F4A1 Hint"
              content: >-
                Loop <code>for i := 1; i <= 10; i++</code> and append
                <code>fmt.Sprintf("%d x %d = %d", n, i, n*i)</code> to a slice.
          solution: |-
            func mulTable(n int) []string {
                var lines []string
                for i := 1; i <= 10; i++ {
                    lines = append(lines, fmt.Sprintf("%d x %d = %d", n, i, n*i))
                }
                return lines
            }
          annotations:
            - type: pattern
              label: Collect into Slice
              text: >-
                Building a slice with <code>append</code> in a loop is
                Go's standard pattern for generating sequences. The slice
                grows automatically.

        - id: v4
          title: GCD (Euclidean Algorithm)
          description: >-
            Write <code>func gcd(a, b int) int</code> that computes the
            greatest common divisor using the Euclidean algorithm.
            Repeatedly replace the larger number with the remainder until
            one becomes zero.
          functionSignature: func gcd(a, b int) int
          difficulty: 1
          testCases:
            - input: "gcd(48, 18)"
              output: "6"
            - input: "gcd(100, 75)"
              output: "25"
            - input: "gcd(17, 5)"
              output: "1"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                The Euclidean algorithm says <code>gcd(a, b) = gcd(b, a%b)</code>.
                When does <code>a%b</code> become zero?
            - title: "\U0001F4A1 Hint"
              content: >-
                Loop <code>for b != 0</code>, each step:
                <code>a, b = b, a%b</code>. When done, <code>a</code> is the GCD.
          solution: |-
            func gcd(a, b int) int {
                for b != 0 {
                    a, b = b, a%b
                }
                return a
            }
          annotations:
            - type: idiom
              label: Parallel Assignment
              text: >-
                Go's <code>a, b = b, a%b</code> swaps and computes in one
                statement — no temp variable needed. This makes the
                Euclidean algorithm a clean two-liner.

        - id: v5
          title: Tower of Hanoi Counter
          description: >-
            Write <code>func hanoiMoves(disks int) int</code> that returns
            the minimum number of moves to solve the Tower of Hanoi with
            <code>n</code> disks. The answer is <code>2^n - 1</code>, but
            compute it iteratively using a loop (doubling and adding 1 each level).
          functionSignature: func hanoiMoves(disks int) int
          difficulty: 2
          testCases:
            - input: "hanoiMoves(1)"
              output: "1"
            - input: "hanoiMoves(3)"
              output: "7"
            - input: "hanoiMoves(10)"
              output: "1023"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                Each extra disk doubles the moves and adds one.
                How do you build this up from 0 disks?
            - title: "\U0001F4A1 Hint"
              content: >-
                Start with <code>moves := 0</code>. For each disk,
                <code>moves = 2*moves + 1</code>.
          solution: |-
            func hanoiMoves(disks int) int {
                moves := 0
                for i := 0; i < disks; i++ {
                    moves = 2*moves + 1
                }
                return moves
            }
          annotations:
            - type: pattern
              label: Iterative Recurrence
              text: >-
                Many recursive formulas can be computed iteratively by
                building up from the base case. This avoids recursion
                overhead and stack limits.

        - id: v6
          title: Bouncing Ball
          description: >-
            Write <code>func bounceBall(height float64, bounceFactor float64, minHeight float64) int</code>
            that simulates a ball dropping from <code>height</code>. Each bounce
            reaches <code>bounceFactor</code> of the previous height. Count how many
            bounces until the height is below <code>minHeight</code>.
          functionSignature: func bounceBall(height float64, bounceFactor float64, minHeight float64) int
          difficulty: 2
          testCases:
            - input: "bounceBall(100.0, 0.5, 1.0)"
              output: "7"
            - input: "bounceBall(10.0, 0.5, 5.0)"
              output: "1"
            - input: "bounceBall(1.0, 0.5, 2.0)"
              output: "0"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                Each bounce multiplies by the factor. How do you count
                bounces until the height drops below the threshold?
            - title: "\U0001F4A1 Hint"
              content: >-
                Loop <code>for height >= minHeight</code>, each iteration
                multiply <code>height *= bounceFactor</code> and increment count.
          solution: |-
            func bounceBall(height float64, bounceFactor float64, minHeight float64) int {
                bounces := 0
                for height >= minHeight {
                    height *= bounceFactor
                    bounces++
                }
                return bounces
            }
          annotations:
            - type: pattern
              label: Convergence Loop
              text: >-
                Loops that repeatedly apply a factor converge toward zero
                (or infinity). Always include a termination condition to
                avoid infinite loops.

        - id: v7
          title: Roman Numeral Converter
          description: >-
            Write <code>func toRoman(n int) string</code> that converts an
            integer (1-3999) to a Roman numeral string. Use the subtractive
            notation (e.g., 4 = "IV", 9 = "IX").
          functionSignature: func toRoman(n int) string
          difficulty: 2
          testCases:
            - input: "toRoman(42)"
              output: "XLII"
            - input: "toRoman(1994)"
              output: "MCMXCIV"
            - input: "toRoman(3999)"
              output: "MMMCMXCIX"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                Roman numerals are built greedily — subtract the largest
                possible value first. What values do you need in your table?
            - title: "\U0001F4A1 Hint"
              content: >-
                Create parallel slices of values and symbols:
                <code>[1000, 900, 500, 400, 100, 90, ...]</code> and
                <code>["M", "CM", "D", "CD", ...]</code>. Loop, subtracting
                and appending.
          solution: |-
            func toRoman(n int) string {
                values := []int{1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1}
                symbols := []string{"M", "CM", "D", "CD", "C", "XC", "L", "XL", "X", "IX", "V", "IV", "I"}
                result := ""
                for i, val := range values {
                    for n >= val {
                        result += symbols[i]
                        n -= val
                    }
                }
                return result
            }
          annotations:
            - type: pattern
              label: Greedy Algorithm
              text: >-
                The greedy approach works for Roman numerals because the
                value table is complete with subtractive forms. Always
                subtract the largest possible value first.

        - id: v8
          title: Matrix Transpose
          description: >-
            Write <code>func transpose(matrix [][]int) [][]int</code> that
            returns the transpose of a 2D integer matrix. Rows become columns
            and vice versa.
          functionSignature: func transpose(matrix [][]int) [][]int
          difficulty: 2
          testCases:
            - input: "transpose([][]int{{1,2,3},{4,5,6}})"
              output: "[[1,4],[2,5],[3,6]]"
            - input: "transpose([][]int{{1}})"
              output: "[[1]]"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                If the input is M rows by N columns, the output is
                N rows by M columns. How do you index the swap?
            - title: "\U0001F4A1 Hint"
              content: >-
                Create a result with <code>len(matrix[0])</code> rows and
                <code>len(matrix)</code> columns. Set <code>result[j][i] = matrix[i][j]</code>.
          solution: |-
            func transpose(matrix [][]int) [][]int {
                if len(matrix) == 0 {
                    return nil
                }
                rows := len(matrix)
                cols := len(matrix[0])
                result := make([][]int, cols)
                for j := 0; j < cols; j++ {
                    result[j] = make([]int, rows)
                    for i := 0; i < rows; i++ {
                        result[j][i] = matrix[i][j]
                    }
                }
                return result
            }
          annotations:
            - type: pattern
              label: 2D Slice Allocation
              text: >-
                Go's 2D slices are slices of slices. Allocate the outer
                slice first, then each inner slice in a loop. There's no
                built-in matrix type.

        - id: v9
          title: Spiral Print Order
          description: >-
            Write <code>func spiralOrder(matrix [][]int) []int</code> that
            returns the elements of a 2D matrix in spiral order (right, down,
            left, up, repeat inward).
          functionSignature: func spiralOrder(matrix [][]int) []int
          difficulty: 2
          testCases:
            - input: "spiralOrder([][]int{{1,2,3},{4,5,6},{7,8,9}})"
              output: "[1,2,3,6,9,8,7,4,5]"
            - input: "spiralOrder([][]int{{1,2},{3,4}})"
              output: "[1,2,4,3]"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                Track four boundaries: top, bottom, left, right. After
                traversing each edge, shrink the boundary inward.
            - title: "\U0001F4A1 Hint"
              content: >-
                Use <code>top, bottom, left, right</code> variables. Traverse
                right along top row (then top++), down along right column
                (then right--), etc. Stop when boundaries cross.
          solution: |-
            func spiralOrder(matrix [][]int) []int {
                if len(matrix) == 0 {
                    return nil
                }
                var result []int
                top, bottom := 0, len(matrix)-1
                left, right := 0, len(matrix[0])-1
                for top <= bottom && left <= right {
                    for c := left; c <= right; c++ {
                        result = append(result, matrix[top][c])
                    }
                    top++
                    for r := top; r <= bottom; r++ {
                        result = append(result, matrix[r][right])
                    }
                    right--
                    if top <= bottom {
                        for c := right; c >= left; c-- {
                            result = append(result, matrix[bottom][c])
                        }
                        bottom--
                    }
                    if left <= right {
                        for r := bottom; r >= top; r-- {
                            result = append(result, matrix[r][left])
                        }
                        left++
                    }
                }
                return result
            }
          annotations:
            - type: pattern
              label: Boundary Shrinking
              text: >-
                Spiral traversal uses four shrinking boundaries. After
                each edge traversal, check that boundaries haven't crossed
                before continuing.

        - id: v10
          title: Password Generator
          description: >-
            Write <code>func generatePassword(length int, seed int) string</code>
            that builds a password character by character. Use the seed to
            deterministically pick from uppercase, lowercase, and digit
            characters. Cycle through character sets to ensure variety.
          functionSignature: func generatePassword(length int, seed int) string
          difficulty: 2
          testCases:
            - input: "len(generatePassword(12, 42))"
              output: "12"
            - input: "generatePassword(4, 0)"
              output: "Aa0B"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                You need to build a string character by character,
                picking from different sets. How do you use the seed
                to make it deterministic?
            - title: "\U0001F4A1 Hint"
              content: >-
                Define a charset string with all valid characters.
                Use <code>(seed + i) % len(charset)</code> to pick each
                character, or cycle through upper/lower/digit sets.
          solution: |-
            func generatePassword(length int, seed int) string {
                sets := []string{
                    "ABCDEFGHIJKLMNOPQRSTUVWXYZ",
                    "abcdefghijklmnopqrstuvwxyz",
                    "0123456789",
                }
                result := make([]byte, length)
                for i := 0; i < length; i++ {
                    set := sets[i%len(sets)]
                    idx := (seed + i) % len(set)
                    result[i] = set[idx]
                }
                return string(result)
            }
          annotations:
            - type: pattern
              label: Deterministic Generation
              text: >-
                Using a seed instead of randomness makes output reproducible
                for testing. Cycle through character sets with modular
                arithmetic to ensure variety.

        - id: v11
          title: Run-Length Decode
          description: >-
            Write <code>func rlDecode(encoded string) string</code> that
            decodes a run-length encoded string. Format: digit followed by
            character, e.g., <code>"3a2b1c"</code> becomes <code>"aaabbc"</code>.
          functionSignature: func rlDecode(encoded string) string
          difficulty: 3
          testCases:
            - input: "rlDecode(\"3a2b1c\")"
              output: "aaabbc"
            - input: "rlDecode(\"1x\")"
              output: "x"
            - input: "rlDecode(\"5z\")"
              output: "zzzzz"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                The encoded string alternates between a count digit and
                the character to repeat. How do you step through it
                two characters at a time?
            - title: "\U0001F4A1 Hint"
              content: >-
                Loop with <code>for i := 0; i < len(encoded); i += 2</code>.
                Parse <code>encoded[i]</code> as a digit count, then repeat
                <code>encoded[i+1]</code> that many times.
          solution: |-
            func rlDecode(encoded string) string {
                var result strings.Builder
                for i := 0; i < len(encoded); i += 2 {
                    count := int(encoded[i] - '0')
                    ch := encoded[i+1]
                    for j := 0; j < count; j++ {
                        result.WriteByte(ch)
                    }
                }
                return result.String()
            }
          annotations:
            - type: idiom
              label: strings.Builder
              text: >-
                Use <code>strings.Builder</code> for efficient string
                concatenation in loops. It avoids creating a new string
                on each append.

        - id: v12
          title: Simple CPU Simulator
          description: >-
            Write <code>func runCPU(program []string) int</code> that simulates
            a simple CPU with an accumulator. Instructions: <code>"ADD n"</code>,
            <code>"SUB n"</code>, <code>"MUL n"</code>, <code>"HALT"</code>.
            Return the accumulator value when HALT is reached.
          functionSignature: func runCPU(program []string) int
          difficulty: 3
          testCases:
            - input: "runCPU([]string{\"ADD 5\", \"MUL 3\", \"SUB 2\", \"HALT\"})"
              output: "13"
            - input: "runCPU([]string{\"ADD 10\", \"HALT\", \"ADD 20\"})"
              output: "10"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                Each instruction is a string you need to parse. How do
                you split the opcode from the operand?
            - title: "\U0001F4A1 Hint"
              content: >-
                Loop over instructions. Split each on space. Switch on
                the opcode, parse the operand with <code>strconv.Atoi</code>.
                Break on <code>"HALT"</code>.
          solution: |-
            func runCPU(program []string) int {
                acc := 0
                for _, instr := range program {
                    parts := strings.SplitN(instr, " ", 2)
                    op := parts[0]
                    if op == "HALT" {
                        break
                    }
                    n, _ := strconv.Atoi(parts[1])
                    switch op {
                    case "ADD":
                        acc += n
                    case "SUB":
                        acc -= n
                    case "MUL":
                        acc *= n
                    }
                }
                return acc
            }
          annotations:
            - type: pattern
              label: Instruction Loop
              text: >-
                An instruction loop (fetch-decode-execute) is the core
                of interpreters, VMs, and game engines. Parse the opcode,
                dispatch with switch, and update state.

        - id: v13
          title: Conway 1D Single Step
          description: >-
            Write <code>func conway1D(cells []bool) []bool</code> that computes
            one step of a 1D cellular automaton. A cell is alive in the next
            generation if it has exactly one alive neighbor. Edge cells have
            only one neighbor.
          functionSignature: func conway1D(cells []bool) []bool
          difficulty: 3
          testCases:
            - input: "conway1D([]bool{false, true, false, false, true})"
              output: "[true, false, true, true, false]"
            - input: "conway1D([]bool{true, true, true})"
              output: "[true, false, true]"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                Each cell looks at its left and right neighbors. Edge cells
                only have one neighbor. How do you count alive neighbors
                without going out of bounds?
            - title: "\U0001F4A1 Hint"
              content: >-
                Create a new slice. For each cell, count alive neighbors
                (check <code>i-1</code> and <code>i+1</code> with bounds
                checks). Cell is alive if count is exactly 1.
          solution: |-
            func conway1D(cells []bool) []bool {
                next := make([]bool, len(cells))
                for i := range cells {
                    neighbors := 0
                    if i > 0 && cells[i-1] {
                        neighbors++
                    }
                    if i < len(cells)-1 && cells[i+1] {
                        neighbors++
                    }
                    next[i] = neighbors == 1
                }
                return next
            }
          annotations:
            - type: pattern
              label: Double Buffering
              text: >-
                Cellular automata use a new slice for the next generation
                to avoid reading cells that were already updated. This
                "double buffer" pattern appears in graphics and simulation.

    # ── challenge_8: Range Loops ───────────────────────────────────────────
    - id: challenge_8
      block: 1
      difficulty: 1
      concept: Range Loops
      docLinks:
        - url: https://go.dev/tour/moretypes/16
          title: "Go Tour: Range"
          note: range over slices and maps
        - url: https://go.dev/ref/spec#For_range
          title: "Go Spec: For range"
          note: specification details
      variants:
        - id: v1
          title: Sum Positives
          description: >-
            Write <code>func sumPositives(nums []int) int</code> that returns
            the sum of only the positive numbers in a slice, skipping
            negatives and zeros.
          functionSignature: func sumPositives(nums []int) int
          difficulty: 1
          testCases:
            - input: "sumPositives([]int{3, -1, 4, -5, 2})"
              output: "9"
            - input: "sumPositives([]int{-1, -2, -3})"
              output: "0"
            - input: "sumPositives([]int{})"
              output: "0"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                How do you selectively include elements during iteration?
                What keyword skips the current iteration?
            - title: "\U0001F4A1 Hint"
              content: >-
                Use <code>for _, n := range nums</code> with
                <code>if n > 0 { sum += n }</code> inside the loop.
          solution: |-
            func sumPositives(nums []int) int {
                sum := 0
                for _, n := range nums {
                    if n > 0 {
                        sum += n
                    }
                }
                return sum
            }
          annotations:
            - type: idiom
              label: Filtered Accumulation
              text: >-
                Combining <code>range</code> with a conditional is the standard
                pattern for filtered sums, counts, or any selective accumulation.

        - id: v2
          title: Find First Duplicate
          description: >-
            Write <code>func firstDuplicate(nums []int) (int, bool)</code>
            that returns the first number that appears more than once and
            <code>true</code>, or <code>0, false</code> if all are unique.
          functionSignature: func firstDuplicate(nums []int) (int, bool)
          difficulty: 1
          testCases:
            - input: "firstDuplicate([]int{1, 2, 3, 2, 1})"
              output: "(2, true)"
            - input: "firstDuplicate([]int{1, 2, 3})"
              output: "(0, false)"
            - input: "firstDuplicate([]int{5, 5})"
              output: "(5, true)"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                How do you efficiently check if you've seen a number
                before during iteration?
            - title: "\U0001F4A1 Hint"
              content: >-
                Use a <code>map[int]bool</code> as a "seen" set. For each
                number, check if it's in the map; if so, return it.
          solution: |-
            func firstDuplicate(nums []int) (int, bool) {
                seen := make(map[int]bool)
                for _, n := range nums {
                    if seen[n] {
                        return n, true
                    }
                    seen[n] = true
                }
                return 0, false
            }
          annotations:
            - type: idiom
              label: Seen-Set Pattern
              text: >-
                A <code>map[T]bool</code> used as a set is the standard way
                to detect duplicates in a single pass. Checking and inserting
                are both O(1).

        - id: v3
          title: Count Unique Words
          description: >-
            Write <code>func uniqueWords(text string) int</code> that counts
            the number of unique words in a text. Convert to lowercase first
            so <code>"Go"</code> and <code>"go"</code> count as the same word.
          functionSignature: func uniqueWords(text string) int
          difficulty: 1
          testCases:
            - input: "uniqueWords(\"the cat and the dog\")"
              output: "4"
            - input: "uniqueWords(\"Go go GO\")"
              output: "1"
            - input: "uniqueWords(\"\")"
              output: "0"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                A map's keys are unique by definition. How can you
                use this to count distinct words?
            - title: "\U0001F4A1 Hint"
              content: >-
                Lowercase with <code>strings.ToLower</code>, split with
                <code>strings.Fields</code>, range over words inserting
                into a <code>map[string]bool</code>. Return <code>len(map)</code>.
          solution: |-
            func uniqueWords(text string) int {
                words := strings.Fields(strings.ToLower(text))
                unique := make(map[string]bool)
                for _, w := range words {
                    unique[w] = true
                }
                return len(unique)
            }
          annotations:
            - type: idiom
              label: Map as Set
              text: >-
                Using a map to count unique items is idiomatic Go. The
                map's length gives the count of distinct keys.

        - id: v4
          title: Moving Average
          description: >-
            Write <code>func movingAverage(data []float64, window int) []float64</code>
            that computes the moving average with the given window size. For each
            position, average the current element and the previous <code>window-1</code>
            elements. Positions with fewer elements use what's available.
          functionSignature: func movingAverage(data []float64, window int) []float64
          difficulty: 2
          testCases:
            - input: "movingAverage([]float64{1, 2, 3, 4, 5}, 3)"
              output: "[1, 1.5, 2, 3, 4]"
            - input: "movingAverage([]float64{10, 20, 30}, 2)"
              output: "[10, 15, 25]"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                For position i with window w, you average elements from
                <code>max(0, i-w+1)</code> to <code>i</code>. How do you
                handle the start where fewer elements are available?
            - title: "\U0001F4A1 Hint"
              content: >-
                For each index, compute the start as <code>max(0, i-window+1)</code>,
                sum from start to i, divide by the count of elements.
          solution: |-
            func movingAverage(data []float64, window int) []float64 {
                result := make([]float64, len(data))
                for i := range data {
                    start := i - window + 1
                    if start < 0 {
                        start = 0
                    }
                    sum := 0.0
                    for j := start; j <= i; j++ {
                        sum += data[j]
                    }
                    result[i] = sum / float64(i-start+1)
                }
                return result
            }
          annotations:
            - type: pattern
              label: Sliding Window
              text: >-
                The sliding window pattern processes a fixed-size view
                that moves across data. Handling edges (start/end) where
                the window is partial is the key challenge.

        - id: v5
          title: Group Consecutive Equal
          description: >-
            Write <code>func groupConsecutive(items []string) [][]string</code>
            that groups consecutive equal elements together. For example,
            <code>["a","a","b","b","b","a"]</code> becomes
            <code>[["a","a"],["b","b","b"],["a"]]</code>.
          functionSignature: func groupConsecutive(items []string) [][]string
          difficulty: 2
          testCases:
            - input: "groupConsecutive([]string{\"a\",\"a\",\"b\",\"b\",\"b\",\"a\"})"
              output: "[[a,a],[b,b,b],[a]]"
            - input: "groupConsecutive([]string{\"x\"})"
              output: "[[x]]"
            - input: "groupConsecutive([]string{})"
              output: "[]"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                When does a new group start? It's when the current element
                differs from the previous one. How do you track the current group?
            - title: "\U0001F4A1 Hint"
              content: >-
                Maintain a current group slice. When the value changes
                (or at the end), append the current group to results and
                start a new one.
          solution: |-
            func groupConsecutive(items []string) [][]string {
                if len(items) == 0 {
                    return [][]string{}
                }
                var groups [][]string
                current := []string{items[0]}
                for _, item := range items[1:] {
                    if item == current[0] {
                        current = append(current, item)
                    } else {
                        groups = append(groups, current)
                        current = []string{item}
                    }
                }
                groups = append(groups, current)
                return groups
            }
          annotations:
            - type: pattern
              label: Run Grouping
              text: >-
                Grouping consecutive equal elements (runs) is common in
                data compression, event processing, and text analysis.
                Don't forget to flush the last group after the loop.

        - id: v6
          title: Find Peaks
          description: >-
            Write <code>func findPeaks(data []int) []int</code> that returns
            the indices of local maxima — elements that are strictly greater
            than both their neighbors. First and last elements cannot be peaks.
          functionSignature: func findPeaks(data []int) []int
          difficulty: 2
          testCases:
            - input: "findPeaks([]int{1, 3, 2, 5, 1})"
              output: "[1, 3]"
            - input: "findPeaks([]int{1, 2, 3})"
              output: "[]"
            - input: "findPeaks([]int{5, 1, 5, 1, 5})"
              output: "[2]"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                A peak at index i means <code>data[i] > data[i-1]</code> and
                <code>data[i] > data[i+1]</code>. Why can't edges be peaks?
            - title: "\U0001F4A1 Hint"
              content: >-
                Loop from index 1 to <code>len(data)-2</code>. Check both
                neighbors. Collect matching indices.
          solution: |-
            func findPeaks(data []int) []int {
                var peaks []int
                for i := 1; i < len(data)-1; i++ {
                    if data[i] > data[i-1] && data[i] > data[i+1] {
                        peaks = append(peaks, i)
                    }
                }
                if peaks == nil {
                    return []int{}
                }
                return peaks
            }
          annotations:
            - type: pattern
              label: Neighbor Comparison
              text: >-
                Comparing each element with its neighbors is a sliding
                window of size 3. Skipping edges (start/end) avoids
                bounds errors.

        - id: v7
          title: Enumerate with Offset
          description: >-
            Write <code>func enumerate(items []string, start int) []string</code>
            that returns strings like <code>"5: apple"</code> where numbering
            begins at <code>start</code>. Use <code>range</code> to get the
            index and add the start offset.
          functionSignature: func enumerate(items []string, start int) []string
          difficulty: 2
          testCases:
            - input: "enumerate([]string{\"a\", \"b\", \"c\"}, 1)"
              output: "[\"1: a\", \"2: b\", \"3: c\"]"
            - input: "enumerate([]string{\"x\"}, 10)"
              output: "[\"10: x\"]"
            - input: "enumerate([]string{}, 0)"
              output: "[]"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                The <code>range</code> index starts at 0. How do you
                offset it to start at a custom number?
            - title: "\U0001F4A1 Hint"
              content: >-
                Use <code>for i, item := range items</code> and format
                with <code>fmt.Sprintf("%d: %s", i+start, item)</code>.
          solution: |-
            func enumerate(items []string, start int) []string {
                result := make([]string, len(items))
                for i, item := range items {
                    result[i] = fmt.Sprintf("%d: %s", i+start, item)
                }
                return result
            }
          annotations:
            - type: idiom
              label: Index Offset
              text: >-
                Adding an offset to the range index is a simple way to
                get custom numbering. Pre-allocate the result slice with
                <code>make</code> when the length is known.

        - id: v8
          title: Parallel Min-Max
          description: >-
            Write <code>func parallelMinMax(nums []int) (int, int)</code>
            that finds both the minimum and maximum in a single pass through
            the slice. Compare elements in pairs to reduce comparisons.
          functionSignature: func parallelMinMax(nums []int) (int, int)
          difficulty: 2
          testCases:
            - input: "parallelMinMax([]int{3, 1, 4, 1, 5, 9})"
              output: "(1, 9)"
            - input: "parallelMinMax([]int{42})"
              output: "(42, 42)"
            - input: "parallelMinMax([]int{5, 3})"
              output: "(3, 5)"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                Processing two elements at a time and comparing them
                to each other first reduces the total number of comparisons.
            - title: "\U0001F4A1 Hint"
              content: >-
                Initialize min and max from the first element. Loop through
                remaining elements, updating min and max with each comparison.
          solution: |-
            func parallelMinMax(nums []int) (int, int) {
                mn, mx := nums[0], nums[0]
                for _, n := range nums[1:] {
                    if n < mn {
                        mn = n
                    }
                    if n > mx {
                        mx = n
                    }
                }
                return mn, mx
            }
          annotations:
            - type: pattern
              label: Single-Pass Aggregation
              text: >-
                Computing multiple aggregates (min, max, sum, count) in
                a single pass is more efficient than multiple loops. Track
                all aggregates with separate variables.

        - id: v9
          title: Character Histogram
          description: >-
            Write <code>func charHistogram(s string) map[rune]int</code>
            that returns a frequency count of each character in the string,
            ignoring spaces.
          functionSignature: func charHistogram(s string) map[rune]int
          difficulty: 2
          testCases:
            - input: "charHistogram(\"hello\")['l']"
              output: "2"
            - input: "charHistogram(\"ab cd\")['a']"
              output: "1"
            - input: "len(charHistogram(\"aaa\"))"
              output: "1"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                Ranging over a string in Go gives you runes, not bytes.
                How do you count occurrences using a map?
            - title: "\U0001F4A1 Hint"
              content: >-
                Use <code>for _, ch := range s</code>. Skip spaces with
                <code>if ch == ' ' { continue }</code>. Increment
                <code>counts[ch]++</code>.
          solution: |-
            func charHistogram(s string) map[rune]int {
                counts := make(map[rune]int)
                for _, ch := range s {
                    if ch == ' ' {
                        continue
                    }
                    counts[ch]++
                }
                return counts
            }
          annotations:
            - type: idiom
              label: Frequency Map
              text: >-
                <code>map[T]int</code> with <code>counts[key]++</code> is
                Go's frequency counter. Zero-value initialization means
                new keys start at 0 automatically.

        - id: v10
          title: Find Missing Number
          description: >-
            Write <code>func findMissing(nums []int, n int) int</code> that
            finds the one missing number from a sequence 1 to n. The input
            slice contains n-1 numbers (all unique, from 1 to n).
          functionSignature: func findMissing(nums []int, n int) int
          difficulty: 2
          testCases:
            - input: "findMissing([]int{1, 3, 4, 5}, 5)"
              output: "2"
            - input: "findMissing([]int{2, 3}, 3)"
              output: "1"
            - input: "findMissing([]int{1}, 2)"
              output: "2"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                The sum of 1 to n is <code>n*(n+1)/2</code>. How does
                comparing this to the actual sum reveal the missing number?
            - title: "\U0001F4A1 Hint"
              content: >-
                Compute expected sum <code>n*(n+1)/2</code>, subtract the
                actual sum from ranging over the slice. The difference is
                the missing number.
          solution: |-
            func findMissing(nums []int, n int) int {
                expected := n * (n + 1) / 2
                actual := 0
                for _, num := range nums {
                    actual += num
                }
                return expected - actual
            }
          annotations:
            - type: pattern
              label: Sum Formula Trick
              text: >-
                Using the mathematical formula for expected sum lets you
                find the missing element in O(n) time and O(1) space —
                no sets or sorting needed.

        - id: v11
          title: Detect Sort Order
          description: >-
            Write <code>func sortOrder(nums []int) string</code> that returns
            <code>"ascending"</code>, <code>"descending"</code>, or <code>"unsorted"</code>
            based on the order of elements. A single element or empty slice is
            <code>"ascending"</code>.
          functionSignature: func sortOrder(nums []int) string
          difficulty: 3
          testCases:
            - input: "sortOrder([]int{1, 2, 3, 4})"
              output: "ascending"
            - input: "sortOrder([]int{4, 3, 2, 1})"
              output: "descending"
            - input: "sortOrder([]int{1, 3, 2})"
              output: "unsorted"
            - input: "sortOrder([]int{})"
              output: "ascending"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                Track two booleans: "has ascending pair" and "has descending
                pair." If both are true, it's unsorted.
            - title: "\U0001F4A1 Hint"
              content: >-
                Range from index 1, compare each element to the previous.
                Track <code>hasAsc</code> and <code>hasDesc</code>. If both
                are set, return "unsorted."
          solution: |-
            func sortOrder(nums []int) string {
                hasAsc := false
                hasDesc := false
                for i := 1; i < len(nums); i++ {
                    if nums[i] > nums[i-1] {
                        hasAsc = true
                    }
                    if nums[i] < nums[i-1] {
                        hasDesc = true
                    }
                }
                if hasAsc && hasDesc {
                    return "unsorted"
                }
                if hasDesc {
                    return "descending"
                }
                return "ascending"
            }
          annotations:
            - type: pattern
              label: Order Detection
              text: >-
                Tracking two flags (ascending seen, descending seen) in
                a single pass determines sort order with three outcomes.
                This is more efficient than sorting and comparing.

        - id: v12
          title: Matrix Row Sums
          description: >-
            Write <code>func rowSums(matrix [][]int) []int</code> that returns
            a slice where each element is the sum of the corresponding row
            in the matrix. Use nested range loops.
          functionSignature: func rowSums(matrix [][]int) []int
          difficulty: 3
          testCases:
            - input: "rowSums([][]int{{1,2,3},{4,5,6}})"
              output: "[6, 15]"
            - input: "rowSums([][]int{{10},{20},{30}})"
              output: "[10, 20, 30]"
            - input: "rowSums([][]int{})"
              output: "[]"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                Nested range loops naturally match the 2D structure.
                The outer loop gives rows, the inner loop gives elements.
            - title: "\U0001F4A1 Hint"
              content: >-
                Use <code>for _, row := range matrix</code> and an inner
                <code>for _, val := range row</code> to sum each row.
          solution: |-
            func rowSums(matrix [][]int) []int {
                sums := make([]int, len(matrix))
                for i, row := range matrix {
                    for _, val := range row {
                        sums[i] += val
                    }
                }
                return sums
            }
          annotations:
            - type: idiom
              label: Nested Range
              text: >-
                Nested <code>range</code> loops over 2D slices mirror the
                row-column structure. The outer range gives you the row
                index and slice, the inner gives individual values.

        - id: v13
          title: Round-Robin Schedule
          description: >-
            Write <code>func roundRobin(teams []string) []string</code> that
            generates all unique matchups for a round-robin tournament.
            Each pair plays once. Return strings like <code>"Team A vs Team B"</code>.
            Teams are paired in order: team 0 vs 1, 0 vs 2, ..., 1 vs 2, etc.
          functionSignature: func roundRobin(teams []string) []string
          difficulty: 3
          testCases:
            - input: "roundRobin([]string{\"A\", \"B\", \"C\"})"
              output: "[\"A vs B\", \"A vs C\", \"B vs C\"]"
            - input: "len(roundRobin([]string{\"W\", \"X\", \"Y\", \"Z\"}))"
              output: "6"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                To avoid duplicate matchups (A vs B and B vs A), the inner
                loop should start after the outer loop's index.
            - title: "\U0001F4A1 Hint"
              content: >-
                Use <code>for i := 0; i < len(teams); i++</code> and
                <code>for j := i + 1; j < len(teams); j++</code> to
                generate unique pairs.
          solution: |-
            func roundRobin(teams []string) []string {
                var matches []string
                for i := 0; i < len(teams); i++ {
                    for j := i + 1; j < len(teams); j++ {
                        matches = append(matches, fmt.Sprintf("%s vs %s", teams[i], teams[j]))
                    }
                }
                return matches
            }
          annotations:
            - type: pattern
              label: Triangular Iteration
              text: >-
                Starting the inner loop at <code>i+1</code> generates all
                unique pairs without duplicates. This "upper triangle"
                pattern produces n*(n-1)/2 pairs from n items.
