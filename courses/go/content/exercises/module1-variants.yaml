conceptLinks:
  Variable Declaration: "#lesson-variables"
  Type Conversion: "#lesson-variables"
  String Formatting: "#lesson-functions"
  Function Basics: "#lesson-functions"
  Multiple Returns: "#lesson-functions"
  Error Handling: "#lesson-functions"
  Building Slices: "#lesson-slices"
  Slice Operations: "#lesson-slices"
  For Loops: "#lesson-loops"
  Range Loops: "#lesson-loops"
  Map Basics: "#lesson-maps"
  Comma-Ok Pattern: "#lesson-comma-ok"
  Strings & Runes: "#lesson-variables"
  Go Fundamentals Combined: "#lesson-variables"
  If/Else: "#lesson-if"
  Slices & Range: "#lesson-slices"
  Maps: "#lesson-maps"
  make() Function: "#lesson-slices"
  Range with Index: "#lesson-loops"
variants:
  warmups:
    - id: warmup_1
      concept: For Loops
      variants:
        - id: v1
          title: Print 1 to 10
          description: Write a program that prints the numbers 1 to 10, one per line.
          hints:
            - Use <code>for i := 1; i <= 10; i++</code>
          solution: |-
            for i := 1; i <= 10; i++ {
                fmt.Println(i)
            }
        - id: v2
          title: Countdown from 5
          description: Write a program that counts down from 5 to 1, then prints "Go!"
          hints:
            - Use <code>for i := 5; i >= 1; i--</code>
            - Print "Go!" after the loop
          solution: |-
            for i := 5; i >= 1; i-- {
                fmt.Println(i)
            }
            fmt.Println("Go!")
        - id: v3
          title: Print Even Numbers
          description: Write a program that prints even numbers from 2 to 10.
          hints:
            - Use <code>for i := 2; i <= 10; i += 2</code>
          solution: |-
            for i := 2; i <= 10; i += 2 {
                fmt.Println(i)
            }
        - id: v4
          title: Count by Twos
          description: Write a program that prints odd numbers from 1 to 9.
          hints:
            - Use <code>for i := 1; i <= 9; i += 2</code>
          solution: |-
            for i := 1; i <= 9; i += 2 {
                fmt.Println(i)
            }
        - id: v5
          title: Sum First N Numbers
          description: Write a program that calculates and prints the sum of numbers from 1 to 5.
          hints:
            - Create a <code>sum</code> variable
            - "Add each number: <code>sum += i</code>"
          solution: |-
            sum := 0
            for i := 1; i <= 5; i++ {
                sum += i
            }
            fmt.Println(sum)  // 15
        - id: v6
          title: Multiplication Table Row
          description: Write a program that prints the 3 times table from 3x1 to 3x5.
          hints:
            - Loop from 1 to 5
            - Print <code>3 * i</code> each time
          solution: |-
            for i := 1; i <= 5; i++ {
                fmt.Printf("3 x %d = %d\n", i, 3*i)
            }
        - id: v7
          title: Print Squares
          description: Write a program that prints the square of numbers from 1 to 4.
          hints:
            - Square is <code>i * i</code>
          solution: |-
            for i := 1; i <= 4; i++ {
                fmt.Println(i * i)
            }
        - id: v8
          title: Count Down by Threes
          description: Write a program that counts down from 15 to 0 by threes (15, 12, 9, 6, 3, 0).
          hints:
            - Start at 15, use <code>i -= 3</code>
          solution: |-
            for i := 15; i >= 0; i -= 3 {
                fmt.Println(i)
            }
        - id: v9
          title: Fibonacci First N
          description: Write a program that prints the first 7 Fibonacci numbers (1, 1, 2, 3, 5, 8, 13).
          hints:
            - Start with <code>a, b := 1, 1</code>
            - Each new number is the sum of the previous two
          solution: |-
            a, b := 1, 1
            for i := 0; i < 7; i++ {
                fmt.Println(a)
                a, b = b, a+b
            }
        - id: v10
          title: Factorial
          description: Write a program that calculates and prints 5! (5 factorial = 5 Ã— 4 Ã— 3 Ã— 2 Ã— 1 = 120).
          hints:
            - Start with <code>result := 1</code>
            - "Multiply by each number: <code>result *= i</code>"
          solution: |-
            result := 1
            for i := 1; i <= 5; i++ {
                result *= i
            }
            fmt.Println(result)  // 120
        - id: v11
          title: Skip Count by Fives
          description: Write a program that counts from 0 to 25 by fives (0, 5, 10, 15, 20, 25).
          hints:
            - Use <code>for i := 0; i <= 25; i += 5</code>
          solution: |-
            for i := 0; i <= 25; i += 5 {
                fmt.Println(i)
            }
        - id: v12
          title: Print Star Pattern
          description: Write a program that prints a triangle pattern of stars (1 star, then 2 stars, then 3 stars).
          hints:
            - Outer loop controls rows
            - "Inner loop prints stars: <code>for j := 0; j < i; j++</code>"
          solution: |-
            for i := 1; i <= 3; i++ {
                for j := 0; j < i; j++ {
                    fmt.Print("*")
                }
                fmt.Println()
            }
        - id: v13
          title: Power of Two
          description: Write a program that prints powers of 2 from 2^0 to 2^5 (1, 2, 4, 8, 16, 32).
          hints:
            - Start with <code>power := 1</code>
            - "Double each time: <code>power *= 2</code>"
          solution: |-
            power := 1
            for i := 0; i <= 5; i++ {
                fmt.Println(power)
                power *= 2
            }
    - id: warmup_2
      concept: If/Else
      variants:
        - id: v1
          title: Odd or Even
          description: Write <code>func oddOrEven(n int) string</code> that returns "even" if n is divisible by 2, else "odd".
          hints:
            - "Use modulo: <code>if n % 2 == 0</code> means even"
          solution: |-
            func oddOrEven(n int) string {
                if n % 2 == 0 {
                    return "even"
                }
                return "odd"
            }
        - id: v2
          title: Pass or Fail
          description: Write <code>func passOrFail(score int) string</code> that returns "pass" if score >= 60, else "fail".
          hints:
            - "Simple if/else: <code>if score >= 60 { return \"pass\" }</code>"
          solution: |-
            func passOrFail(score int) string {
                if score >= 60 {
                    return "pass"
                }
                return "fail"
            }
        - id: v3
          title: Temperature Feel
          description: >-
            Write <code>func tempFeel(celsius int) string</code> that returns "freezing" (< 0), "cold" (0-15), "warm"
            (16-25), or "hot" (> 25).
          hints:
            - Chain if/else if based on temperature thresholds
          solution: |-
            func tempFeel(celsius int) string {
                if celsius < 0 {
                    return "freezing"
                } else if celsius <= 15 {
                    return "cold"
                } else if celsius <= 25 {
                    return "warm"
                }
                return "hot"
            }
        - id: v4
          title: Grade Letter
          description: >-
            Write <code>func gradeLetter(score int) string</code> that returns "A" (>=90), "B" (>=80), "C" (>=70), "D"
            (>=60), or "F" (<60).
          hints:
            - Use chained if/else if statements
            - Check highest grade first
          solution: |-
            func gradeLetter(score int) string {
                if score >= 90 {
                    return "A"
                } else if score >= 80 {
                    return "B"
                } else if score >= 70 {
                    return "C"
                } else if score >= 60 {
                    return "D"
                }
                return "F"
            }
        - id: v5
          title: Voting Eligibility
          description: Write <code>func canVote(age int) string</code> that returns "can vote" if age >= 18, else "too young".
          hints:
            - Simple comparison with 18
          solution: |-
            func canVote(age int) string {
                if age >= 18 {
                    return "can vote"
                }
                return "too young"
            }
        - id: v6
          title: Discount Eligibility
          description: >-
            Write <code>func getDiscount(age int) string</code> that returns "senior discount" (>=65), "student
            discount" (<=25), or "no discount".
          hints:
            - Check senior first, then student, then default
          solution: |-
            func getDiscount(age int) string {
                if age >= 65 {
                    return "senior discount"
                } else if age <= 25 {
                    return "student discount"
                }
                return "no discount"
            }
        - id: v7
          title: Positive or Negative
          description: Write <code>func posNegZero(n int) string</code> that returns "positive", "negative", or "zero".
          hints:
            - Check if n > 0, n < 0, or else it's zero
          solution: |-
            func posNegZero(n int) string {
                if n > 0 {
                    return "positive"
                } else if n < 0 {
                    return "negative"
                }
                return "zero"
            }
        - id: v8
          title: Speed Limit
          description: >-
            Write <code>func speedCheck(speed int) string</code> that returns "safe" (<=60), "warning" (61-80), or
            "ticket" (>80).
          hints:
            - Use ranges for different categories
          solution: |-
            func speedCheck(speed int) string {
                if speed <= 60 {
                    return "safe"
                } else if speed <= 80 {
                    return "warning"
                }
                return "ticket"
            }
        - id: v9
          title: Age Category
          description: >-
            Write <code>func ageCategory(age int) string</code> that returns "child" if age < 13, "teen" if age < 20,
            else "adult".
          hints:
            - Use multiple if/else if statements
            - Check conditions from smallest to largest
          solution: |-
            func ageCategory(age int) string {
                if age < 13 {
                    return "child"
                } else if age < 20 {
                    return "teen"
                }
                return "adult"
            }
        - id: v10
          title: BMI Category
          description: >-
            Write <code>func bmiCategory(bmi float64) string</code> that returns "underweight" if bmi < 18.5, "normal"
            if bmi < 25, else "overweight".
          hints:
            - Use <code>else if</code> for the middle condition
          solution: |-
            func bmiCategory(bmi float64) string {
                if bmi < 18.5 {
                    return "underweight"
                } else if bmi < 25 {
                    return "normal"
                }
                return "overweight"
            }
        - id: v11
          title: Season from Month
          description: >-
            Write <code>func season(month int) string</code> that returns "winter" for 12-2, "spring" for 3-5, "summer"
            for 6-8, "fall" for 9-11.
          hints:
            - Use multiple if/else if conditions
            - Check ranges like <code>month >= 3 && month <= 5</code>
          solution: |-
            func season(month int) string {
                if month == 12 || month <= 2 {
                    return "winter"
                } else if month <= 5 {
                    return "spring"
                } else if month <= 8 {
                    return "summer"
                }
                return "fall"
            }
        - id: v12
          title: Weekend or Weekday
          description: >-
            Write <code>func dayType(day string) string</code> that returns "weekend" if day is "Saturday" or "Sunday",
            else "weekday".
          hints:
            - Use <code>||</code> (OR) operator
            - "Check: <code>if day == \"Saturday\" || day == \"Sunday\"</code>"
          solution: |-
            func dayType(day string) string {
                if day == "Saturday" || day == "Sunday" {
                    return "weekend"
                }
                return "weekday"
            }
        - id: v13
          title: Password Strength
          description: >-
            Write <code>func passwordStrength(length int) string</code> that returns "weak" if length < 8, "medium" if
            length < 12, else "strong".
          hints:
            - Simple if/else if chain based on length thresholds
          solution: |-
            func passwordStrength(length int) string {
                if length < 8 {
                    return "weak"
                } else if length < 12 {
                    return "medium"
                }
                return "strong"
            }
    - id: warmup_3
      concept: Slices & Range
      variants:
        - id: v1
          title: Iterate Numbers
          description: Create a slice with three numbers, then print each using <code>for range</code>.
          hints:
            - "Create: <code>nums := []int{7, 42, 99}</code>"
            - "Loop: <code>for _, num := range nums</code>"
          solution: |-
            nums := []int{7, 42, 99}
            for _, num := range nums {
                fmt.Println(num)
            }
        - id: v2
          title: Iterate with Index
          description: "Create a slice of colors, then print each with its index: \"0: red\", \"1: blue\", etc."
          hints:
            - "Loop with index: <code>for i, color := range colors</code>"
            - "Use <code>fmt.Printf(\"%d: %s\\n\", i, color)</code>"
          solution: |-
            colors := []string{"red", "blue", "green"}
            for i, color := range colors {
                fmt.Printf("%d: %s\n", i, color)
            }
        - id: v3
          title: Iterate Strings
          description: Create a slice of your favorite foods, print each on its own line.
          hints:
            - "Create: <code>foods := []string{\"pizza\", \"sushi\", \"tacos\"}</code>"
          solution: |-
            foods := []string{"pizza", "sushi", "tacos"}
            for _, food := range foods {
                fmt.Println(food)
            }
        - id: v4
          title: Sum Slice
          description: Create a slice of numbers, then calculate and print their sum.
          hints:
            - Create a sum variable before the loop
            - "Add each number: <code>sum += num</code>"
          solution: |-
            nums := []int{10, 20, 30}
            sum := 0
            for _, num := range nums {
                sum += num
            }
            fmt.Println(sum)  // 60
        - id: v5
          title: Count Items
          description: Create a slice of fruits and print how many items are in it.
          hints:
            - Use <code>len(fruits)</code> to get the count
          solution: |-
            fruits := []string{"apple", "banana", "orange", "grape"}
            fmt.Println(len(fruits))  // 4
        - id: v6
          title: Names List
          description: "Create a slice of names and print each with a greeting: \"Hello, Alice!\""
          hints:
            - Use <code>fmt.Printf("Hello, %s!\n", name)</code>
          solution: |-
            names := []string{"Alice", "Bob", "Charlie"}
            for _, name := range names {
                fmt.Printf("Hello, %s!\n", name)
            }
        - id: v7
          title: Test Scores
          description: "Create a slice of test scores and print each one with its position: \"Test 1: 85\""
          hints:
            - Use the index in the range loop
            - Add 1 to the index for human-readable numbering
          solution: |-
            scores := []int{85, 92, 78, 95}
            for i, score := range scores {
                fmt.Printf("Test %d: %d\n", i+1, score)
            }
        - id: v8
          title: Reverse Print
          description: Create a slice of 3 animals and print them in reverse order using a regular for loop.
          hints:
            - Start from <code>len(animals)-1</code>
            - "Count down: <code>i--</code>"
          solution: |-
            animals := []string{"cat", "dog", "bird"}
            for i := len(animals) - 1; i >= 0; i-- {
                fmt.Println(animals[i])
            }
        - id: v9
          title: Find Maximum
          description: Write <code>func findMax(nums []int) int</code> that returns the largest number in the slice.
          hints:
            - Start with <code>max := nums[0]</code>
            - Use range to compare each number
          solution: |-
            func findMax(nums []int) int {
                max := nums[0]
                for _, n := range nums {
                    if n > max {
                        max = n
                    }
                }
                return max
            }
        - id: v10
          title: Find Minimum
          description: Write <code>func findMin(nums []int) int</code> that returns the smallest number in the slice.
          hints:
            - Start with <code>min := nums[0]</code>
            - "Compare each number: <code>if n < min</code>"
          solution: |-
            func findMin(nums []int) int {
                min := nums[0]
                for _, n := range nums {
                    if n < min {
                        min = n
                    }
                }
                return min
            }
        - id: v11
          title: Calculate Average
          description: Write <code>func average(nums []float64) float64</code> that returns the average of all numbers.
          hints:
            - Sum all numbers first
            - "Divide by length: <code>sum / float64(len(nums))</code>"
          solution: |-
            func average(nums []float64) float64 {
                sum := 0.0
                for _, n := range nums {
                    sum += n
                }
                return sum / float64(len(nums))
            }
        - id: v12
          title: Contains Check
          description: >-
            Write <code>func contains(items []string, target string) bool</code> that returns true if target is in
            items.
          hints:
            - Use range to check each item
            - Return true immediately when found
          solution: |-
            func contains(items []string, target string) bool {
                for _, item := range items {
                    if item == target {
                        return true
                    }
                }
                return false
            }
        - id: v13
          title: First N Elements
          description: >-
            Write <code>func firstN(items []string, n int) []string</code> that returns the first n elements of the
            slice.
          hints:
            - "Use slice syntax: <code>items[:n]</code>"
          solution: |-
            func firstN(items []string, n int) []string {
                return items[:n]
            }
    - id: warmup_4
      concept: Maps
      variants:
        - id: v1
          title: Ages Map
          description: Create a map of names to ages, then print each person's name and age.
          hints:
            - "Map syntax: <code>map[string]int{\"alice\": 30}</code>"
            - "Loop: <code>for name, age := range ages</code>"
          solution: |-
            ages := map[string]int{
                "alice": 30,
                "bob":   25,
            }
            for name, age := range ages {
                fmt.Printf("%s is %d\n", name, age)
            }
        - id: v2
          title: Prices Map
          description: Create a map of items to prices (float64), then print each item and price.
          hints:
            - "Map syntax: <code>map[string]float64{\"apple\": 1.50}</code>"
          solution: |-
            prices := map[string]float64{
                "apple":  1.50,
                "banana": 0.75,
            }
            for item, price := range prices {
                fmt.Printf("%s: $%.2f\n", item, price)
            }
        - id: v3
          title: Capitals Map
          description: Create a map of countries to their capitals, then print each pair.
          hints:
            - "Map syntax: <code>map[string]string{\"France\": \"Paris\"}</code>"
          solution: |-
            capitals := map[string]string{
                "France": "Paris",
                "Japan":  "Tokyo",
            }
            for country, capital := range capitals {
                fmt.Printf("%s: %s\n", country, capital)
            }
        - id: v4
          title: Inventory Count
          description: Create a map of product names to quantities in stock, then print each item and count.
          hints:
            - "Map syntax: <code>map[string]int{\"shirt\": 15}</code>"
          solution: |-
            inventory := map[string]int{
                "shirt": 15,
                "pants": 8,
                "hat":   20,
            }
            for item, count := range inventory {
                fmt.Printf("%s: %d in stock\n", item, count)
            }
        - id: v5
          title: Student Grades
          description: Create a map of student names to their letter grades, then print each student and grade.
          hints:
            - "Map syntax: <code>map[string]string{\"Alice\": \"A\"}</code>"
          solution: |-
            grades := map[string]string{
                "Alice": "A",
                "Bob":   "B",
                "Carol": "A",
            }
            for student, grade := range grades {
                fmt.Printf("%s: %s\n", student, grade)
            }
        - id: v6
          title: Phone Book
          description: Create a map of names to phone numbers, then print each entry.
          hints:
            - "Phone numbers can be strings: <code>\"555-1234\"</code>"
          solution: |-
            phonebook := map[string]string{
                "Alice": "555-1234",
                "Bob":   "555-5678",
            }
            for name, phone := range phonebook {
                fmt.Printf("%s: %s\n", name, phone)
            }
        - id: v7
          title: Menu Prices
          description: Create a map of menu items to their prices (use integers for cents), then print the menu.
          hints:
            - "Store cents as int: 250 for $2.50"
            - Divide by 100.0 when printing
          solution: |-
            menu := map[string]int{
                "burger": 850,
                "fries":  350,
                "soda":   200,
            }
            for item, cents := range menu {
                fmt.Printf("%s: $%.2f\n", item, float64(cents)/100.0)
            }
        - id: v8
          title: Room Numbers
          description: Create a map of employee names to their office room numbers, then print the directory.
          hints:
            - "Map syntax: <code>map[string]int{\"Alice\": 101}</code>"
          solution: |-
            offices := map[string]int{
                "Alice": 101,
                "Bob":   102,
                "Carol": 105,
            }
            for name, room := range offices {
                fmt.Printf("%s - Room %d\n", name, room)
            }
        - id: v9
          title: Most Common Value
          description: >-
            Write <code>func mostCommon(counts map[string]int) string</code> that returns the key with the highest
            value.
          hints:
            - Track max value and corresponding key
            - Loop through map with range
          solution: |-
            func mostCommon(counts map[string]int) string {
                maxKey := ""
                maxVal := 0
                for k, v := range counts {
                    if v > maxVal {
                        maxVal = v
                        maxKey = k
                    }
                }
                return maxKey
            }
        - id: v10
          title: Merge Maps
          description: >-
            Write <code>func mergeMaps(m1, m2 map[string]int) map[string]int</code> that combines both maps (m2
            overwrites m1 on conflicts).
          hints:
            - Create new result map
            - Copy all from m1, then all from m2
          solution: |-
            func mergeMaps(m1, m2 map[string]int) map[string]int {
                result := make(map[string]int)
                for k, v := range m1 {
                    result[k] = v
                }
                for k, v := range m2 {
                    result[k] = v
                }
                return result
            }
        - id: v11
          title: Filter by Value
          description: >-
            Write <code>func filterByValue(m map[string]int, threshold int) map[string]int</code> that returns only
            entries where value >= threshold.
          hints:
            - Create new map for results
            - Only add entries that meet the condition
          solution: |-
            func filterByValue(m map[string]int, threshold int) map[string]int {
                result := make(map[string]int)
                for k, v := range m {
                    if v >= threshold {
                        result[k] = v
                    }
                }
                return result
            }
        - id: v12
          title: Key Exists Multiple
          description: >-
            Write <code>func hasAllKeys(m map[string]int, keys []string) bool</code> that returns true if all keys exist
            in the map.
          hints:
            - Loop through keys slice
            - "Use comma-ok idiom: <code>_, ok := m[key]</code>"
          solution: |-
            func hasAllKeys(m map[string]int, keys []string) bool {
                for _, key := range keys {
                    if _, ok := m[key]; !ok {
                        return false
                    }
                }
                return true
            }
        - id: v13
          title: Invert Map
          description: Write <code>func invertMap(m map[string]string) map[string]string</code> that swaps keys and values.
          hints:
            - Create new map where values become keys
            - "Loop: <code>result[v] = k</code>"
          solution: |-
            func invertMap(m map[string]string) map[string]string {
                result := make(map[string]string)
                for k, v := range m {
                    result[v] = k
                }
                return result
            }
    - id: warmup_5
      concept: Variables & Assignment
      variants:
        - id: v1
          title: Declare and Print
          description: >-
            Declare a variable <code>name</code> with value "Go", and an integer <code>year</code> with value 2009.
            Print both.
          hints:
            - "Use short declaration: <code>name := \"Go\"</code>"
            - Use <code>fmt.Println(name, year)</code>
          solution: |-
            name := "Go"
            year := 2009
            fmt.Println(name, year)
        - id: v2
          title: Swap Two Variables
          description: Create two variables <code>a := 10</code> and <code>b := 20</code>. Swap their values, then print them.
          hints:
            - "Go allows simultaneous assignment: <code>a, b = b, a</code>"
          solution: |-
            a := 10
            b := 20
            a, b = b, a
            fmt.Println(a, b)  // 20 10
        - id: v3
          title: Type Inference
          description: >-
            Create variables for your age (int), height (float64), and name (string) using short declaration. Print
            their values and types.
          hints:
            - "Go infers types: <code>age := 25</code> is int"
            - Use <code>fmt.Printf("%T", age)</code> to print type
          solution: |-
            age := 25
            height := 5.9
            name := "Alice"
            fmt.Printf("age: %d (%T)\n", age, age)
            fmt.Printf("height: %.1f (%T)\n", height, height)
            fmt.Printf("name: %s (%T)\n", name, name)
        - id: v4
          title: Calculate Area
          description: Create variables for width (5.0) and height (3.0), calculate the area, and print it.
          hints:
            - Area is width * height
            - Use <code>:=</code> for short declaration
          solution: |-
            width := 5.0
            height := 3.0
            area := width * height
            fmt.Println(area)  // 15
        - id: v5
          title: String Concatenation
          description: Create variables for first name and last name, then create and print a full name.
          hints:
            - Concatenate with <code>+</code>
            - Don't forget the space between names
          solution: |-
            firstName := "John"
            lastName := "Doe"
            fullName := firstName + " " + lastName
            fmt.Println(fullName)  // John Doe
        - id: v6
          title: Boolean Logic
          description: Create two boolean variables, then print their AND and OR results.
          hints:
            - "AND: <code>a && b</code>"
            - "OR: <code>a || b</code>"
          solution: |-
            a := true
            b := false
            fmt.Println(a && b)  // false
            fmt.Println(a || b)  // true
        - id: v7
          title: Temperature Conversion
          description: Create a celsius variable (25), convert it to Fahrenheit (F = C * 9/5 + 32), and print both.
          hints:
            - "Formula: <code>fahrenheit := celsius * 9 / 5 + 32</code>"
            - Use float64 for decimal precision
          solution: |-
            celsius := 25.0
            fahrenheit := celsius * 9 / 5 + 32
            fmt.Printf("%.1fC = %.1fF\n", celsius, fahrenheit)  // 25.0C = 77.0F
        - id: v8
          title: Shopping Total
          description: >-
            Create variables for three item prices, calculate the total, then apply a 10% discount and print the final
            price.
          hints:
            - "Total: <code>price1 + price2 + price3</code>"
            - "Discount: <code>total * 0.9</code>"
          solution: |-
            item1 := 10.0
            item2 := 25.5
            item3 := 8.75
            total := item1 + item2 + item3
            final := total * 0.9
            fmt.Printf("Total: $%.2f, After discount: $%.2f\n", total, final)
        - id: v9
          title: Pythagorean Theorem
          description: >-
            Write a program that calculates the hypotenuse c given sides a=3 and b=4 using c = sqrt(aÂ² + bÂ²). Print the
            result.
          hints:
            - Use <code>math.Sqrt()</code> function
            - "Formula: <code>c := math.Sqrt(a*a + b*b)</code>"
          solution: |-
            import "math"

            a := 3.0
            b := 4.0
            c := math.Sqrt(a*a + b*b)
            fmt.Println(c)  // 5
        - id: v10
          title: Compound Interest
          description: >-
            Write a program that calculates compound interest. Given principal=1000, rate=0.05, time=2, calculate amount
            = principal * (1 + rate)^time. Print result.
          hints:
            - Use <code>math.Pow()</code> for exponentiation
            - "Formula: <code>amount := principal * math.Pow(1+rate, time)</code>"
          solution: |-
            import "math"

            principal := 1000.0
            rate := 0.05
            time := 2.0
            amount := principal * math.Pow(1+rate, time)
            fmt.Println(amount)  // 1102.5
        - id: v11
          title: Temperature Conversion
          description: Write a program that converts 100Â°F to Celsius using the formula C = (F - 32) * 5/9. Print the result.
          hints:
            - Use parentheses for correct order of operations
            - "Formula: <code>celsius := (fahrenheit - 32) * 5 / 9</code>"
          solution: |-
            fahrenheit := 100.0
            celsius := (fahrenheit - 32) * 5 / 9
            fmt.Println(celsius)  // 37.777...
        - id: v12
          title: Circle Circumference
          description: Write a program that calculates the circumference of a circle with radius 7 using C = 2Ï€r. Print the result.
          hints:
            - Use <code>math.Pi</code> constant
            - "Formula: <code>circumference := 2 * math.Pi * radius</code>"
          solution: |-
            import "math"

            radius := 7.0
            circumference := 2 * math.Pi * radius
            fmt.Println(circumference)  // 43.98...
        - id: v13
          title: Distance Formula
          description: >-
            Write a program that calculates distance between points (1,2) and (4,6) using d = sqrt((x2-x1)Â² + (y2-y1)Â²).
            Print result.
          hints:
            - "Calculate differences first: <code>dx := x2 - x1</code>"
            - Use <code>math.Sqrt(dx*dx + dy*dy)</code>
          solution: |-
            import "math"

            x1, y1 := 1.0, 2.0
            x2, y2 := 4.0, 6.0
            dx := x2 - x1
            dy := y2 - y1
            dist := math.Sqrt(dx*dx + dy*dy)
            fmt.Println(dist)  // 5
    - id: warmup_6
      concept: Multiple Returns
      variants:
        - id: v1
          title: Divide with Remainder
          description: Write <code>func divMod(a, b int) (int, int)</code> that returns both quotient and remainder.
          hints:
            - "Return two values: <code>return a / b, a % b</code>"
            - "Call with: <code>q, r := divMod(10, 3)</code>"
          solution: |-
            func divMod(a, b int) (int, int) {
                return a / b, a % b
            }

            // Usage:
            q, r := divMod(10, 3)
            fmt.Println(q, r)  // 3 1
        - id: v2
          title: Min and Max
          description: Write <code>func minMax(a, b int) (int, int)</code> that returns the smaller value first, then the larger.
          hints:
            - Use if to compare, then return in order
          solution: |-
            func minMax(a, b int) (int, int) {
                if a < b {
                    return a, b
                }
                return b, a
            }

            // Usage:
            small, big := minMax(5, 3)
            fmt.Println(small, big)  // 3 5
        - id: v3
          title: First and Last
          description: >-
            Write <code>func firstLast(s string) (string, string)</code> that returns the first and last character of a
            string.
          hints:
            - "First char: <code>string(s[0])</code>"
            - "Last char: <code>string(s[len(s)-1])</code>"
          solution: |-
            func firstLast(s string) (string, string) {
                return string(s[0]), string(s[len(s)-1])
            }

            // Usage:
            f, l := firstLast("hello")
            fmt.Println(f, l)  // h o
        - id: v4
          title: Split Name
          description: >-
            Write <code>func splitName(fullName string) (string, string)</code> that splits "John Doe" into first and
            last name (assume one space).
          hints:
            - Find the space with a simple loop or assume fixed position
            - For warmup, you can hardcode the split at index 4 for "John Doe"
          solution: |-
            func splitName(fullName string) (string, string) {
                // Simple version: find space
                for i, ch := range fullName {
                    if ch == ' ' {
                        return fullName[:i], fullName[i+1:]
                    }
                }
                return fullName, ""
            }

            // Usage:
            first, last := splitName("John Doe")
            fmt.Println(first, last)  // John Doe
        - id: v5
          title: Circle Properties
          description: >-
            Write <code>func circleProps(radius float64) (float64, float64)</code> that returns circumference and area
            (use 3.14 for pi).
          hints:
            - "Circumference: <code>2 * pi * radius</code>"
            - "Area: <code>pi * radius * radius</code>"
          solution: |-
            func circleProps(radius float64) (float64, float64) {
                pi := 3.14
                circumference := 2 * pi * radius
                area := pi * radius * radius
                return circumference, area
            }

            // Usage:
            c, a := circleProps(5.0)
            fmt.Printf("Circumference: %.2f, Area: %.2f\n", c, a)
        - id: v6
          title: Bounds Check
          description: >-
            Write <code>func inRange(n, min, max int) (bool, string)</code> that returns true/"in range" if n is between
            min and max, else false/"out of range".
          hints:
            - Check if <code>n >= min && n <= max</code>
            - Return both the boolean and a message
          solution: |-
            func inRange(n, min, max int) (bool, string) {
                if n >= min && n <= max {
                    return true, "in range"
                }
                return false, "out of range"
            }

            // Usage:
            ok, msg := inRange(15, 10, 20)
            fmt.Println(ok, msg)  // true in range
        - id: v7
          title: Quotient and Remainder
          description: Write <code>func divide(dividend, divisor int) (int, int)</code> that returns quotient and remainder.
          hints:
            - "Quotient: <code>dividend / divisor</code>"
            - "Remainder: <code>dividend % divisor</code>"
          solution: |-
            func divide(dividend, divisor int) (int, int) {
                quotient := dividend / divisor
                remainder := dividend % divisor
                return quotient, remainder
            }

            // Usage:
            q, r := divide(17, 5)
            fmt.Println(q, r)  // 3 2
        - id: v8
          title: String Info
          description: >-
            Write <code>func stringInfo(s string) (int, string)</code> that returns the length and the first character
            as a string.
          hints:
            - "Length: <code>len(s)</code>"
            - "First char: <code>string(s[0])</code>"
          solution: |-
            func stringInfo(s string) (int, string) {
                length := len(s)
                firstChar := string(s[0])
                return length, firstChar
            }

            // Usage:
            len, first := stringInfo("hello")
            fmt.Println(len, first)  // 5 h
        - id: v9
          title: Parse Int with Error
          description: >-
            Write <code>func parsePositive(s string) (int, error)</code> that converts string to int. Return error if
            conversion fails or number is negative.
          hints:
            - Use <code>strconv.Atoi(s)</code> to convert
            - Check if result < 0 and return custom error
          solution: |-
            import (
                "errors"
                "strconv"
            )

            func parsePositive(s string) (int, error) {
                n, err := strconv.Atoi(s)
                if err != nil {
                    return 0, err
                }
                if n < 0 {
                    return 0, errors.New("negative number")
                }
                return n, nil
            }
        - id: v10
          title: Validate Range
          description: >-
            Write <code>func validateRange(n, min, max int) (int, bool)</code> that returns (n, true) if n is in
            [min,max], else (0, false).
          hints:
            - "Check condition: <code>n >= min && n <= max</code>"
            - Return the value with a boolean flag
          solution: |-
            func validateRange(n, min, max int) (int, bool) {
                if n >= min && n <= max {
                    return n, true
                }
                return 0, false
            }
        - id: v11
          title: String Split at Position
          description: >-
            Write <code>func splitAt(s string, pos int) (string, string, bool)</code> that splits string at position.
            Return false if pos is out of bounds.
          hints:
            - Check if <code>pos >= 0 && pos <= len(s)</code>
            - "Use slice notation: <code>s[:pos]</code> and <code>s[pos:]</code>"
          solution: |-
            func splitAt(s string, pos int) (string, string, bool) {
                if pos < 0 || pos > len(s) {
                    return "", "", false
                }
                return s[:pos], s[pos:], true
            }
        - id: v12
          title: Find First Occurrence
          description: >-
            Write <code>func findFirst(items []string, target string) (int, bool)</code> that returns (index, true) if
            found, else (-1, false).
          hints:
            - Use range to get both index and value
            - Return immediately when target is found
          solution: |-
            func findFirst(items []string, target string) (int, bool) {
                for i, item := range items {
                    if item == target {
                        return i, true
                    }
                }
                return -1, false
            }
        - id: v13
          title: Min and Max
          description: >-
            Write <code>func minMax(nums []int) (int, int)</code> that returns both the minimum and maximum values in
            one call.
          hints:
            - Initialize both to first element
            - Update both in one loop using range
          solution: |-
            func minMax(nums []int) (int, int) {
                min, max := nums[0], nums[0]
                for _, n := range nums {
                    if n < min {
                        min = n
                    }
                    if n > max {
                        max = n
                    }
                }
                return min, max
            }
  challenges:
    - id: challenge_1
      block: 1
      difficulty: 1
      concept: Variable Declaration
      docLinks:
        - url: https://go.dev/tour/basics/9
          title: "Go Tour: Short variable declarations"
          note: := syntax
        - url: https://go.dev/ref/spec#Short_variable_declarations
          title: "Go Spec: Short variable declarations"
          note: specification details
      patternPrimer:
        bruteForce: Use explicit var declarations with types for every variable.
        bestApproach: Use := for concise declaration inside functions; use var when zero values or package-level scope needed.
        typical: Variable declaration is O(1) â€” focus on choosing the right declaration style.
      variants:
        - id: v1
          title: Deployment Counter
          description: >-
            A deployment pipeline tracks how many services have been updated during a rolling release. Write
            <code>func deployCount() int</code> that declares the count as 7 using := and returns it.
          functionSignature: func deployCount() int
          testCases:
            - input: ""
              output: "7"
          hints:
            - title: ðŸ¤” Think about it
              content: >-
                The := operator declares a new variable and infers its type from the value on the right side.
                What value represents the number of deployed services?
            - title: ðŸ’¡ Hint
              content: >-
                Use count := 7 to declare and initialize the variable. The compiler infers count is an int
                from the literal 7. Then return it.
            - title: ðŸ”§ Pattern
              content: |-
                <pre>1. Declare count with := and value 7
                2. Return count</pre>
          solution: |-
            func deployCount() int {
                count := 7
                return count
            }
          difficulty: 1
        - id: v2
          title: Server Hostname
          description: >-
            A config parser reads the hostname for a web server from a settings file. Write <code>func
            defaultHost() string</code> that declares the hostname as "localhost" using := and returns it.
          functionSignature: func defaultHost() string
          testCases:
            - input: ""
              output: "\"localhost\""
          hints:
            - title: ðŸ¤” Think about it
              content: >-
                Short declarations work with any type including strings. How do you declare a string variable
                and give it an initial value in one line?
            - title: ðŸ’¡ Hint
              content: >-
                Use host := "localhost" to declare the variable. The compiler sees the string literal and
                infers the type as string. Return the variable.
            - title: ðŸ”§ Pattern
              content: |-
                <pre>1. Declare host with := and value "localhost"
                2. Return host</pre>
          solution: |-
            func defaultHost() string {
                host := "localhost"
                return host
            }
          difficulty: 1
        - id: v3
          title: CI Pipeline Status
          description: >-
            A CI system needs to report whether the latest build passed. Write <code>func buildPassed()
            bool</code> that declares a boolean variable as true using := and returns it.
          functionSignature: func buildPassed() bool
          testCases:
            - input: ""
              output: "true"
          hints:
            - title: ðŸ¤” Think about it
              content: >-
                The := operator works with booleans just like integers and strings. What are the two possible
                boolean values in Go?
            - title: ðŸ’¡ Hint
              content: >-
                Use passed := true to declare a bool variable. The compiler infers the type from the literal
                true. Then return it.
            - title: ðŸ”§ Pattern
              content: |-
                <pre>1. Declare passed with := and value true
                2. Return passed</pre>
          solution: |-
            func buildPassed() bool {
                passed := true
                return passed
            }
          difficulty: 1
        - id: v4
          title: API Timeout Setting
          description: >-
            An HTTP client uses a default timeout for API requests. Write <code>func defaultTimeout()
            float64</code> that declares the timeout as 30.5 seconds using := and returns it.
          functionSignature: func defaultTimeout() float64
          testCases:
            - input: ""
              output: "30.5"
          hints:
            - title: ðŸ¤” Think about it
              content: >-
                Float literals in Go create float64 variables by default when used with :=. What does a
                decimal number like 30.5 represent?
            - title: ðŸ’¡ Hint
              content: >-
                Use timeout := 30.5 to declare a float64 variable. The compiler infers float64 from the
                decimal literal. Return the variable.
            - title: ðŸ”§ Pattern
              content: |-
                <pre>1. Declare timeout with := and value 30.5
                2. Return timeout</pre>
          solution: |-
            func defaultTimeout() float64 {
                timeout := 30.5
                return timeout
            }
          difficulty: 1
        - id: v5
          title: Load Balancer Total
          description: >-
            A load balancer distributes requests across two servers. Write <code>func totalRequests(primary,
            backup int) int</code> that declares both counts using := into new variables and returns their
            sum.
          functionSignature: func totalRequests(primary, backup int) int
          testCases:
            - input: 150, 85
              output: "235"
            - input: 0, 200
              output: "200"
          hints:
            - title: ðŸ¤” Think about it
              content: >-
                You can use := to declare new variables from function parameters. How do you capture two
                values and combine them?
            - title: ðŸ’¡ Hint
              content: >-
                Declare p := primary and b := backup, then return p + b. Alternatively you can skip the extra
                declarations and return primary + backup directly, but practice using := here.
            - title: ðŸ”§ Pattern
              content: |-
                <pre>1. Declare p := primary
                2. Declare b := backup
                3. Return p + b</pre>
          solution: |-
            func totalRequests(primary, backup int) int {
                p := primary
                b := backup
                return p + b
            }
          difficulty: 2
        - id: v6
          title: Package Registry Default
          description: >-
            A package manager initializes a new registry entry with zero values. Write <code>func
            emptyPackage() (string, int)</code> that uses <code>var name string</code> and <code>var version
            int</code> (no assignment) and returns both. They should return "" and 0 respectively.
          functionSignature: func emptyPackage() (string, int)
          testCases:
            - input: ""
              output: "\"\", 0"
          hints:
            - title: ðŸ¤” Think about it
              content: >-
                In Go, every type has a zero value. Declaring with var but no assignment gives you the zero
                value. What are the zero values for string and int?
            - title: ðŸ’¡ Hint
              content: >-
                Use var name string and var version int without any assignment. Go initializes them to "" and
                0 automatically. Return both values.
            - title: ðŸ”§ Pattern
              content: |-
                <pre>1. var name string (zero value: "")
                2. var version int (zero value: 0)
                3. Return name, version</pre>
          solution: |-
            func emptyPackage() (string, int) {
                var name string
                var version int
                return name, version
            }
          difficulty: 2
        - id: v7
          title: Server Config Tuple
          description: >-
            A server startup routine initializes its configuration. Write <code>func serverConfig() (string,
            int, bool)</code> that uses a single := line to declare host, port, and debug simultaneously as
            "0.0.0.0", 8080, and false. Return all three.
          functionSignature: func serverConfig() (string, int, bool)
          testCases:
            - input: ""
              output: "\"0.0.0.0\", 8080, false"
          hints:
            - title: ðŸ¤” Think about it
              content: >-
                Go allows declaring multiple variables in one := statement. You list the names on the left and
                their values on the right, separated by commas.
            - title: ðŸ’¡ Hint
              content: >-
                Use host, port, debug := "0.0.0.0", 8080, false on one line. Each variable gets the type
                inferred from its corresponding value. Return all three.
            - title: ðŸ”§ Pattern
              content: |-
                <pre>1. host, port, debug := "0.0.0.0", 8080, false
                2. Return host, port, debug</pre>
          solution: |-
            func serverConfig() (string, int, bool) {
                host, port, debug := "0.0.0.0", 8080, false
                return host, port, debug
            }
          difficulty: 2
        - id: v8
          title: Task Runner Priority Swap
          description: >-
            A task runner needs to swap the priority of two tasks. Write <code>func swapPriority(a, b int)
            (int, int)</code> that uses Go's simultaneous assignment to swap and return b, a.
          functionSignature: func swapPriority(a, b int) (int, int)
          testCases:
            - input: 1, 5
              output: 5, 1
            - input: 10, 3
              output: 3, 10
          hints:
            - title: ðŸ¤” Think about it
              content: >-
                Go supports multiple return values and evaluates the right side of an assignment fully before
                storing. Can you return two values in a different order than received?
            - title: ðŸ’¡ Hint
              content: >-
                Simply return b, a. Go evaluates both values on the right before assigning, so no temporary
                variable is needed.
            - title: ðŸ”§ Pattern
              content: |-
                <pre>1. Accept two int parameters
                2. Return them in reverse order: b, a</pre>
          solution: |-
            func swapPriority(a, b int) (int, int) {
                return b, a
            }
          difficulty: 2
        - id: v9
          title: Retry Counter Update
          description: >-
            A file downloader retries on failure, incrementing a counter each time. Write <code>func
            retryCount() int</code> that declares attempts := 0, then reassigns it to 3 using = (not :=), and
            returns it.
          functionSignature: func retryCount() int
          testCases:
            - input: ""
              output: "3"
          hints:
            - title: ðŸ¤” Think about it
              content: >-
                There is a difference between := (declare and assign) and = (assign only). You use := the
                first time and = for subsequent updates. What happens if you use := twice on the same
                variable?
            - title: ðŸ’¡ Hint
              content: >-
                Use := for the first declaration: attempts := 0. Then reassign with =: attempts = 3. Using :=
                again on the same variable in the same scope causes an error.
            - title: ðŸ”§ Pattern
              content: |-
                <pre>1. Declare with :=  (first use)
                2. Reassign with =  (already exists)
                3. Return the variable</pre>
          solution: |-
            func retryCount() int {
                attempts := 0
                attempts = 3
                return attempts
            }
          difficulty: 2
        - id: v10
          title: Build Artifact Size
          description: >-
            A build system calculates the total artifact size from a base binary, assets, and metadata
            overhead. Write <code>func artifactSize(binary, assets, overhead int) int</code> that declares
            total using := with the expression binary + assets + overhead, then declares a padding variable as
            total/10, and returns total + padding.
          functionSignature: func artifactSize(binary, assets, overhead int) int
          testCases:
            - input: 1000, 500, 200
              output: "1870"
            - input: 2048, 1024, 100
              output: "3489"
          hints:
            - title: ðŸ¤” Think about it
              content: >-
                You can use expressions on the right side of :=. You can also use a previously declared
                variable in a later := declaration. Integer division truncates in Go.
            - title: ðŸ’¡ Hint
              content: >-
                Declare total := binary + assets + overhead, then padding := total / 10 (integer division
                truncates). Return total + padding. For 1700, padding = 170, so result = 1870.
            - title: ðŸ”§ Pattern
              content: |-
                <pre>1. total := binary + assets + overhead
                2. padding := total / 10
                3. Return total + padding</pre>
          solution: |-
            func artifactSize(binary, assets, overhead int) int {
                total := binary + assets + overhead
                padding := total / 10
                return total + padding
            }
          difficulty: 3
        - id: v11
          title: GitHub Issue Breakdown
          description: >-
            A GitHub CLI tool breaks down total seconds spent on an issue into hours, minutes, and seconds.
            Write <code>func timeBreakdown(totalSec int) (int, int, int)</code> that uses := to declare hours,
            minutes, and seconds, then returns all three.
          functionSignature: func timeBreakdown(totalSec int) (int, int, int)
          testCases:
            - input: "3661"
              output: 1, 1, 1
            - input: "7384"
              output: 2, 3, 4
          hints:
            - title: ðŸ¤” Think about it
              content: >-
                To break down total seconds, use integer division and modulo. There are 3600 seconds in an
                hour and 60 seconds in a minute.
            - title: ðŸ’¡ Hint
              content: >-
                Declare hours := totalSec / 3600, then minutes := (totalSec % 3600) / 60, and seconds :=
                totalSec % 60. Each uses := to declare a new variable from an expression.
            - title: ðŸ”§ Pattern
              content: |-
                <pre>1. hours := totalSec / 3600
                2. minutes := (totalSec % 3600) / 60
                3. seconds := totalSec % 60
                4. Return hours, minutes, seconds</pre>
          solution: |-
            func timeBreakdown(totalSec int) (int, int, int) {
                hours := totalSec / 3600
                minutes := (totalSec % 3600) / 60
                seconds := totalSec % 60
                return hours, minutes, seconds
            }
          difficulty: 3
        - id: v12
          title: Network Bandwidth Estimate
          description: >-
            A parallel downloader estimates the bandwidth needed to transfer files. Write <code>func
            estimateBandwidth(fileSizeMB int, seconds float64) float64</code> that declares speedMBps using :=
            by converting fileSizeMB to float64 and dividing by seconds, then returns speedMBps.
          functionSignature: func estimateBandwidth(fileSizeMB int, seconds float64) float64
          testCases:
            - input: 100, 8.0
              output: "12.5"
            - input: 50, 4.0
              output: "12.5"
          hints:
            - title: ðŸ¤” Think about it
              content: >-
                You cannot divide an int by a float64 directly in Go. You need to convert the int to float64
                first. The := operator infers the type from the result of the expression.
            - title: ðŸ’¡ Hint
              content: >-
                Declare speedMBps := float64(fileSizeMB) / seconds. The conversion float64(fileSizeMB) allows
                the division with seconds. The result type is float64.
            - title: ðŸ”§ Pattern
              content: |-
                <pre>1. Convert fileSizeMB to float64
                2. Declare speedMBps := float64(fileSizeMB) / seconds
                3. Return speedMBps</pre>
          solution: |-
            func estimateBandwidth(fileSizeMB int, seconds float64) float64 {
                speedMBps := float64(fileSizeMB) / seconds
                return speedMBps
            }
          difficulty: 3
        - id: v13
          title: CLI Tool Initialization
          description: >-
            A CLI tool initializes its runtime state with a mix of zero-value and explicit declarations. Write
            <code>func initCLI() (string, int, bool, float64)</code> that uses <code>var</code> for the first
            two (string for appName, int for exitCode -- they will be zero values "" and 0) and := for the
            last two (verbose := true, version := 1.2). Return all four.
          functionSignature: func initCLI() (string, int, bool, float64)
          testCases:
            - input: ""
              output: "\"\", 0, true, 1.2"
          hints:
            - title: ðŸ¤” Think about it
              content: >-
                Sometimes you want a zero value (use var without assignment) and sometimes a specific initial
                value (use :=). Mixing both styles in one function is idiomatic Go.
            - title: ðŸ’¡ Hint
              content: >-
                Use var appName string and var exitCode int for zero values. Then verbose := true and version
                := 1.2 for explicit values. Return all four.
            - title: ðŸ”§ Pattern
              content: |-
                <pre>1. var appName string (zero value "")
                2. var exitCode int (zero value 0)
                3. verbose := true
                4. version := 1.2
                5. Return appName, exitCode, verbose, version</pre>
          solution: |-
            func initCLI() (string, int, bool, float64) {
                var appName string
                var exitCode int
                verbose := true
                version := 1.2
                return appName, exitCode, verbose, version
            }
          difficulty: 3
    - id: challenge_2
      block: 1
      difficulty: 1
      concept: Type Conversion
      docLinks:
        - url: https://go.dev/tour/basics/13
          title: "Go Tour: Type conversions"
          note: explicit conversion required
        - url: https://pkg.go.dev/strconv
          title: "strconv package"
          note: string/number conversions
      patternPrimer:
        bruteForce: Use separate variables for each type and convert explicitly at every step.
        bestApproach: Convert types at the point of use with Go's T(value) syntax; use strconv for string-number conversions.
        typical: Type conversions are O(1) â€” the key is knowing which conversion function to use.
      variants:
        - id: v1
          title: File Size to Megabytes
          description: >-
            A file browser displays sizes in bytes (int) but needs to show megabytes as a decimal. Write
            <code>func bytesToMB(bytes int) float64</code> that converts bytes to megabytes by dividing by
            1048576.0 (1024*1024) using float64 conversion.
          functionSignature: func bytesToMB(bytes int) float64
          testCases:
            - input: "5242880"
              output: "5"
            - input: "1572864"
              output: "1.5"
          hints:
            - title: ðŸ¤” Think about it
              content: >-
                Go requires explicit type conversions. If you divide an int by an int, you get integer
                division which truncates the result. How do you get a precise decimal answer?
            - title: ðŸ’¡ Hint
              content: >-
                Convert the bytes value to float64 first, then divide by 1048576.0: float64(bytes) /
                1048576.0. This ensures floating-point division.
            - title: ðŸ”§ Pattern
              content: |-
                <pre>1. Convert bytes to float64
                2. Divide by 1048576.0
                3. Return the result</pre>
          solution: |-
            func bytesToMB(bytes int) float64 {
                return float64(bytes) / 1048576.0
            }
          difficulty: 1
        - id: v2
          title: Response Time Truncation
          description: >-
            An API monitoring dashboard receives latency as float64 milliseconds but stores it as whole
            milliseconds for the histogram. Write <code>func truncateLatency(ms float64) int</code> that
            converts the float64 to int, truncating the decimal portion.
          functionSignature: func truncateLatency(ms float64) int
          testCases:
            - input: "42.7"
              output: "42"
            - input: "99.99"
              output: "99"
          hints:
            - title: ðŸ¤” Think about it
              content: >-
                Converting float64 to int in Go truncates toward zero -- it does not round. What will
                int(42.7) give you?
            - title: ðŸ’¡ Hint
              content: >-
                Use int(ms) to truncate the decimal part. Remember: 42.7 becomes 42 and 99.99 becomes 99 --
                always toward zero.
            - title: ðŸ”§ Pattern
              content: |-
                <pre>1. Use int(ms) to truncate
                2. Return the integer value</pre>
          solution: |-
            func truncateLatency(ms float64) int {
                return int(ms)
            }
          difficulty: 1
        - id: v3
          title: Config Port to String
          description: >-
            A config file writer needs to serialize a port number as a string for a YAML output. Write
            <code>func portToString(port int) string</code> that converts the int port to its string
            representation using strconv.Itoa.
          functionSignature: func portToString(port int) string
          testCases:
            - input: "8080"
              output: "\"8080\""
            - input: "443"
              output: "\"443\""
          hints:
            - title: ðŸ¤” Think about it
              content: >-
                string(8080) does NOT give you "8080" -- it gives you the Unicode character at code point
                8080. You need a different function for numeric-to-string conversion.
            - title: ðŸ’¡ Hint
              content: >-
                Use strconv.Itoa(port) from the strconv package. Itoa stands for "Integer to ASCII" and
                converts an int to its decimal string representation.
            - title: ðŸ”§ Pattern
              content: |-
                <pre>1. Import "strconv"
                2. Use strconv.Itoa(port)
                3. Return the string</pre>
          solution: |-
            func portToString(port int) string {
                return strconv.Itoa(port)
            }
          difficulty: 1
        - id: v4
          title: Unicode Status Indicator
          description: >-
            A terminal dashboard uses Unicode runes to display status indicators. Write <code>func
            statusIcon(r rune) string</code> that converts a rune to its string representation using string().
          functionSignature: func statusIcon(r rune) string
          testCases:
            - input: "'\\u2714'"
              output: "\"\\u2714\""
            - input: "'X'"
              output: "\"X\""
          hints:
            - title: ðŸ¤” Think about it
              content: >-
                A rune in Go represents a Unicode code point (int32). The string() conversion on a rune
                produces the UTF-8 encoded string for that character.
            - title: ðŸ’¡ Hint
              content: >-
                Use string(r) to convert the rune to its string representation. This works for any valid
                Unicode code point.
            - title: ðŸ”§ Pattern
              content: |-
                <pre>1. Use string(r) to convert rune to string
                2. Return the result</pre>
          solution: |-
            func statusIcon(r rune) string {
                return string(r)
            }
          difficulty: 1
        - id: v5
          title: Precise Build Duration
          description: >-
            A build system divides total work units between parallel workers. Integer division loses
            precision, so it needs a float result. Write <code>func avgWorkPerWorker(totalWork, workers int)
            float64</code> that returns the precise average by converting both to float64 before dividing.
          functionSignature: func avgWorkPerWorker(totalWork, workers int) float64
          testCases:
            - input: 7, 2
              output: "3.5"
            - input: 10, 3
              output: "3.3333333333333335"
          hints:
            - title: ðŸ¤” Think about it
              content: >-
                Integer division in Go truncates: 7/2 gives 3, not 3.5. You need to convert to floating-point
                before dividing to preserve the decimal.
            - title: ðŸ’¡ Hint
              content: >-
                Convert both operands before dividing: float64(totalWork) / float64(workers). This ensures
                floating-point division gives you the precise result.
            - title: ðŸ”§ Pattern
              content: |-
                <pre>1. Convert totalWork to float64
                2. Convert workers to float64
                3. Divide and return the result</pre>
          solution: |-
            func avgWorkPerWorker(totalWork, workers int) float64 {
                return float64(totalWork) / float64(workers)
            }
          difficulty: 2
        - id: v6
          title: Parse Environment Port
          description: >-
            A server reads its port from an environment variable string. Write <code>func parsePort(s string)
            (int, error)</code> that uses strconv.Atoi to parse the string as an int. Return both the value
            and any error.
          functionSignature: func parsePort(s string) (int, error)
          testCases:
            - input: "\"3000\""
              output: 3000, nil
            - input: "\"not_a_port\""
              output: 0, error
          hints:
            - title: ðŸ¤” Think about it
              content: >-
                Parsing a string to a number can fail if the string is not a valid number. Go communicates
                this through its error return pattern.
            - title: ðŸ’¡ Hint
              content: >-
                Use strconv.Atoi(s) which returns (int, error). If the string cannot be parsed, it returns 0
                and a non-nil error. Return both values directly.
            - title: ðŸ”§ Pattern
              content: |-
                <pre>1. Call strconv.Atoi(s)
                2. Return both the int and the error</pre>
          solution: |-
            func parsePort(s string) (int, error) {
                return strconv.Atoi(s)
            }
          difficulty: 2
        - id: v7
          title: Weighted Server Score
          description: >-
            A load balancer computes a server score by combining an integer base rating with a float64 weight.
            Write <code>func serverScore(rating int, weight float64) float64</code> that converts the rating
            to float64 and multiplies it by weight.
          functionSignature: func serverScore(rating int, weight float64) float64
          testCases:
            - input: 8, 1.5
              output: "12"
            - input: 5, 2.2
              output: "11"
          hints:
            - title: ðŸ¤” Think about it
              content: >-
                Go does not allow arithmetic between different numeric types directly. You must convert one
                operand to match the other before multiplying.
            - title: ðŸ’¡ Hint
              content: >-
                Convert the int to float64 first: float64(rating) * weight. Both operands must be the same
                type for the * operator.
            - title: ðŸ”§ Pattern
              content: |-
                <pre>1. Convert rating to float64
                2. Multiply by weight
                3. Return the result</pre>
          solution: |-
            func serverScore(rating int, weight float64) float64 {
                return float64(rating) * weight
            }
          difficulty: 2
        - id: v8
          title: HTTP Status Category
          description: >-
            A logging system categorizes HTTP responses by their status code byte. Write <code>func
            statusToCode(b byte) int</code> that converts a byte status code to an int.
          functionSignature: func statusToCode(b byte) int
          testCases:
            - input: byte(200)
              output: "200"
            - input: byte(127)
              output: "127"
          hints:
            - title: ðŸ¤” Think about it
              content: >-
                A byte in Go is an alias for uint8 (0-255). Converting to int widens the value, so no data is
                lost in the conversion.
            - title: ðŸ’¡ Hint
              content: >-
                Use int(b) to convert from byte to int. Since byte is a smaller integer type, this conversion
                is always safe and lossless.
            - title: ðŸ”§ Pattern
              content: |-
                <pre>1. Use int(b) to widen the byte
                2. Return the int result</pre>
          solution: |-
            func statusToCode(b byte) int {
                return int(b)
            }
          difficulty: 2
        - id: v9
          title: Average Response Time
          description: >-
            A monitoring tool collects request durations as integers (milliseconds) and computes the average
            latency. Write <code>func avgLatency(times []int) float64</code> that sums the int slice and
            returns a precise float64 average.
          functionSignature: func avgLatency(times []int) float64
          testCases:
            - input: "[]int{120, 200, 95, 185}"
              output: "150"
            - input: "[]int{10, 20, 30}"
              output: "20"
          hints:
            - title: ðŸ¤” Think about it
              content: >-
                If you sum ints and divide by an int, you get integer division which truncates. How do you get
                a precise float result from integer data?
            - title: ðŸ’¡ Hint
              content: >-
                Sum the slice as an int, then convert both the sum and length to float64 before dividing:
                float64(sum) / float64(len(times)).
            - title: ðŸ”§ Pattern
              content: |-
                <pre>1. Sum all elements as int
                2. Convert sum to float64
                3. Convert len(times) to float64
                4. Divide and return</pre>
          solution: |-
            func avgLatency(times []int) float64 {
                sum := 0
                for _, t := range times {
                    sum += t
                }
                return float64(sum) / float64(len(times))
            }
          difficulty: 2
        - id: v10
          title: Safe Config Parse
          description: >-
            A config loader reads a string value from a YAML file and needs to convert it to an int, falling
            back to a default if parsing fails. Write <code>func safeConfigInt(raw string, fallback int)
            int</code> that parses raw with strconv.Atoi and returns fallback on error.
          functionSignature: func safeConfigInt(raw string, fallback int) int
          testCases:
            - input: "\"256\", 0"
              output: "256"
            - input: "\"auto\", 64"
              output: "64"
          hints:
            - title: ðŸ¤” Think about it
              content: >-
                strconv.Atoi returns both a value and an error. When parsing fails the error is non-nil. How
                do you check for this and fall back to a default value?
            - title: ðŸ’¡ Hint
              content: >-
                Use n, err := strconv.Atoi(raw). If err != nil, return fallback. Otherwise return n. This is
                the standard Go error handling pattern.
            - title: ðŸ”§ Pattern
              content: |-
                <pre>1. n, err := strconv.Atoi(raw)
                2. if err != nil { return fallback }
                3. return n</pre>
          solution: |-
            func safeConfigInt(raw string, fallback int) int {
                n, err := strconv.Atoi(raw)
                if err != nil {
                    return fallback
                }
                return n
            }
          difficulty: 3
        - id: v11
          title: Download Progress Percentage
          description: >-
            A file downloader needs to display progress as a percentage. Write <code>func
            downloadProgress(bytesDownloaded, totalBytes int) float64</code> that calculates what percentage
            of the file has been downloaded. Convert to float64 for precision.
          functionSignature: func downloadProgress(bytesDownloaded, totalBytes int) float64
          testCases:
            - input: 750, 1000
              output: "75"
            - input: 1, 3
              output: "33.33333333333333"
          hints:
            - title: ðŸ¤” Think about it
              content: >-
                Integer division would give 0 for most partial downloads (e.g., 750/1000 = 0 in integer math).
                You need floating-point division then multiply by 100.
            - title: ðŸ’¡ Hint
              content: >-
                Convert both values to float64 before dividing, then multiply by 100: float64(bytesDownloaded)
                / float64(totalBytes) * 100.0.
            - title: ðŸ”§ Pattern
              content: |-
                <pre>1. Convert bytesDownloaded to float64
                2. Convert totalBytes to float64
                3. Divide and multiply by 100
                4. Return the percentage</pre>
          solution: |-
            func downloadProgress(bytesDownloaded, totalBytes int) float64 {
                return float64(bytesDownloaded) / float64(totalBytes) * 100.0
            }
          difficulty: 3
        - id: v12
          title: Round Metric Value
          description: >-
            A metrics dashboard needs to round float64 gauge values to the nearest integer for a sparkline
            chart. Write <code>func roundMetric(val float64) int</code> that rounds a positive float64 to the
            nearest int using the int(val + 0.5) trick.
          functionSignature: func roundMetric(val float64) int
          testCases:
            - input: "3.7"
              output: "4"
            - input: "3.2"
              output: "3"
            - input: "5.5"
              output: "6"
          hints:
            - title: ðŸ¤” Think about it
              content: >-
                int() truncates toward zero, so int(3.7) is 3 not 4. How can you add a bias before truncating
                to get rounding behavior instead?
            - title: ðŸ’¡ Hint
              content: >-
                Add 0.5 before converting: int(val + 0.5). For 3.7: int(4.2) = 4. For 3.2: int(3.7) = 3. This
                works correctly for positive numbers.
            - title: ðŸ”§ Pattern
              content: |-
                <pre>1. Add 0.5 to the float
                2. Convert to int (truncates)
                3. Return the rounded value</pre>
          solution: |-
            func roundMetric(val float64) int {
                return int(val + 0.5)
            }
          difficulty: 3
        - id: v13
          title: Parse and Sum Dimensions
          description: >-
            A CLI image resizer receives width and height as string arguments and needs to compute the total
            pixel count. Write <code>func parseAndMultiply(widthStr, heightStr string) (int, error)</code>
            that parses both strings to ints with strconv.Atoi and returns their product. If either parse
            fails, return 0 and the error.
          functionSignature: func parseAndMultiply(widthStr, heightStr string) (int, error)
          testCases:
            - input: "\"1920\", \"1080\""
              output: 2073600, nil
            - input: "\"800\", \"oops\""
              output: 0, error
          hints:
            - title: ðŸ¤” Think about it
              content: >-
                You need to parse two strings and either could fail. Go's error handling pattern requires
                checking each error immediately after the operation that can fail.
            - title: ðŸ’¡ Hint
              content: >-
                Parse each string separately with strconv.Atoi. Check the error after each parse -- if either
                fails, return 0 and the error immediately. Otherwise return their product and nil.
            - title: ðŸ”§ Pattern
              content: |-
                <pre>1. w, err := strconv.Atoi(widthStr)
                2. if err != nil { return 0, err }
                3. h, err := strconv.Atoi(heightStr)
                4. if err != nil { return 0, err }
                5. return w * h, nil</pre>
          solution: |-
            func parseAndMultiply(widthStr, heightStr string) (int, error) {
                w, err := strconv.Atoi(widthStr)
                if err != nil {
                    return 0, err
                }
                h, err := strconv.Atoi(heightStr)
                if err != nil {
                    return 0, err
                }
                return w * h, nil
            }
          difficulty: 3
    - id: challenge_3
      block: 1
      difficulty: 1
      concept: String Formatting
      docLinks:
        - url: https://pkg.go.dev/fmt
          title: "fmt package"
          note: format verbs reference
        - url: https://go.dev/doc/effective_go#printing
          title: "Effective Go: Printing"
          note: formatting best practices
      patternPrimer:
        bruteForce: Concatenate strings manually with + and strconv conversions.
        bestApproach: Use fmt.Sprintf with format verbs for clean, readable string construction.
        typical: String formatting is O(n) in output length â€” Sprintf handles type formatting automatically.
      variants:
        - id: v1
          title: Format Deployment Status
          description: >-
            A CI/CD dashboard shows deployment progress. Write <code>func formatDeploy(env string, step int)
            string</code> that returns "Deploying to {env}: step {step}" using fmt.Sprintf.
          functionSignature: func formatDeploy(env string, step int) string
          testCases:
            - input: "\"production\", 3"
              output: "\"Deploying to production: step 3\""
            - input: "\"staging\", 1"
              output: "\"Deploying to staging: step 1\""
          hints:
            - title: ðŸ¤” Think about it
              content: >-
                fmt.Sprintf lets you insert values into a template string. Use %s for strings and %d for
                integers. What template produces the required output?
            - title: ðŸ’¡ Hint
              content: >-
                Use fmt.Sprintf("Deploying to %s: step %d", env, step). The %s verb inserts the environment
                name and %d inserts the step number.
            - title: ðŸ”§ Pattern
              content: |-
                <pre>1. Use fmt.Sprintf with a format template
                2. %s for the env string argument
                3. %d for the step integer argument
                4. Return the result</pre>
          solution: |-
            func formatDeploy(env string, step int) string {
                return fmt.Sprintf("Deploying to %s: step %d", env, step)
            }
          difficulty: 1
        - id: v2
          title: Format Error Message
          description: >-
            A logging library needs to format error messages with codes. Write <code>func formatError(code
            int, msg string) string</code> that returns "Error [{code}]: {msg}" using fmt.Sprintf.
          functionSignature: func formatError(code int, msg string) string
          testCases:
            - input: 404, "not found"
              output: "\"Error [404]: not found\""
            - input: 500, "internal server error"
              output: "\"Error [500]: internal server error\""
          hints:
            - title: ðŸ¤” Think about it
              content: >-
                You need to combine an integer and a string into a formatted message. Square brackets are
                literal characters in the format string, not special syntax.
            - title: ðŸ’¡ Hint
              content: >-
                Use fmt.Sprintf("Error [%d]: %s", code, msg). Literal brackets appear directly in the format
                string and are not treated as format verbs.
            - title: ðŸ”§ Pattern
              content: |-
                <pre>1. Use %d for the integer error code
                2. Use %s for the string message
                3. Include literal brackets in the template
                4. Return the formatted string</pre>
          solution: |-
            func formatError(code int, msg string) string {
                return fmt.Sprintf("Error [%d]: %s", code, msg)
            }
          difficulty: 1
        - id: v3
          title: Format Version Tag
          description: >-
            A release tool generates version strings. Write <code>func versionTag(major, minor int)
            string</code> that returns "v{major}.{minor}" using fmt.Sprintf.
          functionSignature: func versionTag(major, minor int) string
          testCases:
            - input: 1, 4
              output: "\"v1.4\""
            - input: 2, 0
              output: "\"v2.0\""
          hints:
            - title: ðŸ¤” Think about it
              content: >-
                The output needs a literal "v" prefix and a dot separator between two integers. How do you
                include literal characters alongside format verbs?
            - title: ðŸ’¡ Hint
              content: >-
                Use fmt.Sprintf("v%d.%d", major, minor). The "v" and "." are literal characters in the format
                string; only % followed by a verb letter triggers substitution.
            - title: ðŸ”§ Pattern
              content: |-
                <pre>1. Start format string with literal "v"
                2. Use %d for major version
                3. Add literal "." separator
                4. Use %d for minor version</pre>
          solution: |-
            func versionTag(major, minor int) string {
                return fmt.Sprintf("v%d.%d", major, minor)
            }
          difficulty: 1
        - id: v4
          title: Format User Greeting
          description: >-
            A CLI application greets the user on login. Write <code>func welcomeMsg(username string,
            loginCount int) string</code> that returns "Welcome, {username}! Login #{loginCount}".
          functionSignature: func welcomeMsg(username string, loginCount int) string
          testCases:
            - input: "\"admin\", 42"
              output: "\"Welcome, admin! Login #42\""
            - input: "\"alice\", 1"
              output: "\"Welcome, alice! Login #1\""
          hints:
            - title: ðŸ¤” Think about it
              content: >-
                You need to place a string and an integer into a greeting template. The # character is a
                literal and does not need escaping in Go format strings.
            - title: ðŸ’¡ Hint
              content: >-
                Use fmt.Sprintf("Welcome, %s! Login #%d", username, loginCount). The # is just a literal
                character in the format string.
            - title: ðŸ”§ Pattern
              content: |-
                <pre>1. Use %s for the username
                2. Use %d for the login count
                3. Include literal punctuation in the template
                4. Return the formatted result</pre>
          solution: |-
            func welcomeMsg(username string, loginCount int) string {
                return fmt.Sprintf("Welcome, %s! Login #%d", username, loginCount)
            }
          difficulty: 1
        - id: v5
          title: Format IP Address
          description: >-
            A network utility formats IPv4 addresses from octets. Write <code>func formatIP(a, b, c, d int)
            string</code> that returns "{a}.{b}.{c}.{d}" using fmt.Sprintf.
          functionSignature: func formatIP(a, b, c, d int) string
          testCases:
            - input: 192, 168, 1, 100
              output: "\"192.168.1.100\""
            - input: 10, 0, 0, 1
              output: "\"10.0.0.1\""
          hints:
            - title: ðŸ¤” Think about it
              content: >-
                An IPv4 address has four numeric octets separated by dots. You need four %d verbs with dots
                between them. How do you pass four arguments to Sprintf?
            - title: ðŸ’¡ Hint
              content: >-
                Use fmt.Sprintf("%d.%d.%d.%d", a, b, c, d). Each %d substitutes one octet, and the dots are
                literal separators in the format string.
            - title: ðŸ”§ Pattern
              content: |-
                <pre>1. Use four %d verbs for the four octets
                2. Separate with literal "." characters
                3. Pass all four parameters in order
                4. Return the formatted string</pre>
          solution: |-
            func formatIP(a, b, c, d int) string {
                return fmt.Sprintf("%d.%d.%d.%d", a, b, c, d)
            }
          difficulty: 2
        - id: v6
          title: Format Hex Color
          description: >-
            A theme engine converts RGB values to hex color strings. Write <code>func hexColor(r, g, b int)
            string</code> that returns a hex color like "#FF8800" with uppercase, zero-padded two-digit hex
            values.
          functionSignature: func hexColor(r, g, b int) string
          testCases:
            - input: 255, 136, 0
              output: "\"#FF8800\""
            - input: 0, 0, 0
              output: "\"#000000\""
            - input: 1, 2, 3
              output: "\"#010203\""
          hints:
            - title: ðŸ¤” Think about it
              content: >-
                Hexadecimal format uses base-16 digits (0-9, A-F). The %X verb formats an integer as uppercase
                hex. How do you ensure each component is exactly two digits?
            - title: ðŸ’¡ Hint
              content: >-
                Use fmt.Sprintf("#%02X%02X%02X", r, g, b). The %02X verb formats as uppercase hex padded to at
                least 2 digits with leading zeros.
            - title: ðŸ”§ Pattern
              content: |-
                <pre>1. Use %02X for zero-padded uppercase hex
                2. Apply to each of r, g, b
                3. Prefix with literal "#"
                4. Return the formatted color string</pre>
          solution: |-
            func hexColor(r, g, b int) string {
                return fmt.Sprintf("#%02X%02X%02X", r, g, b)
            }
          difficulty: 2
        - id: v7
          title: Format Progress Bar
          description: >-
            A task runner displays a text progress bar. Write <code>func progressBar(current, total int)
            string</code> that returns "[  3/100]" format with the current value right-aligned in a
            3-character field.
          functionSignature: func progressBar(current, total int) string
          testCases:
            - input: 3, 100
              output: "\"[  3/100]\""
            - input: 42, 100
              output: "\" 42/100]\""
            - input: 100, 100
              output: "\"[100/100]\""
          hints:
            - title: ðŸ¤” Think about it
              content: >-
                Right-aligning a number means padding with spaces on the left. The %Nd format verb (where N is
                the width) right-aligns an integer in a field of N characters.
            - title: ðŸ’¡ Hint
              content: >-
                Use fmt.Sprintf("[%3d/%d]", current, total). The %3d right-aligns the current value in a
                3-character field, padding with spaces.
            - title: ðŸ”§ Pattern
              content: |-
                <pre>1. Use %3d for right-aligned integer (3 wide)
                2. Use %d for the total (no padding)
                3. Wrap in literal brackets with "/" separator
                4. Return the formatted string</pre>
          solution: |-
            func progressBar(current, total int) string {
                return fmt.Sprintf("[%3d/%d]", current, total)
            }
          difficulty: 2
        - id: v8
          title: Format Log Timestamp
          description: >-
            A structured logger formats timestamps for log entries. Write <code>func logTimestamp(year, month,
            day, hour, min int) string</code> that returns "YYYY-MM-DD HH:MM" with zero-padded month, day,
            hour, and minute.
          functionSignature: func logTimestamp(year, month, day, hour, min int) string
          testCases:
            - input: 2024, 3, 5, 9, 7
              output: "\"2024-03-05 09:07\""
            - input: 2025, 12, 25, 14, 30
              output: "\"2025-12-25 14:30\""
          hints:
            - title: ðŸ¤” Think about it
              content: >-
                Timestamps require consistent widths for readability. Single-digit months and days need
                leading zeros. Which format verb produces zero-padded integers?
            - title: ðŸ’¡ Hint
              content: >-
                Use fmt.Sprintf("%d-%02d-%02d %02d:%02d", year, month, day, hour, min). The %02d pads each
                component to two digits. The year uses plain %d since it is already four digits.
            - title: ðŸ”§ Pattern
              content: |-
                <pre>1. Use %d for the 4-digit year
                2. Use %02d for month, day, hour, minute
                3. Separate date parts with "-", time parts with ":"
                4. Space between date and time portions</pre>
          solution: |-
            func logTimestamp(year, month, day, hour, min int) string {
                return fmt.Sprintf("%d-%02d-%02d %02d:%02d", year, month, day, hour, min)
            }
          difficulty: 2
        - id: v9
          title: Format Key-Value Pair
          description: >-
            A config dumper displays settings as aligned key-value pairs. Write <code>func formatKV(key, value
            string) string</code> that returns the key left-aligned in a 20-character field, followed by " = "
            and the value.
          functionSignature: func formatKV(key, value string) string
          testCases:
            - input: "\"host\", \"localhost\""
              output: "\"host                 = localhost\""
            - input: "\"max_connections\", \"100\""
              output: "\"max_connections       = 100\""
          hints:
            - title: ðŸ¤” Think about it
              content: >-
                Left-alignment pads on the right with spaces. The %-Ns format verb left-aligns a string in a
                field of N characters. How does this differ from right-alignment?
            - title: ðŸ’¡ Hint
              content: >-
                Use fmt.Sprintf("%-20s = %s", key, value). The minus flag in %-20s left-aligns the key,
                padding with spaces on the right to fill 20 characters.
            - title: ðŸ”§ Pattern
              content: |-
                <pre>1. Use %-20s for left-aligned key (20 wide)
                2. Add literal " = " separator
                3. Use %s for the value
                4. Return the formatted string</pre>
          solution: |-
            func formatKV(key, value string) string {
                return fmt.Sprintf("%-20s = %s", key, value)
            }
          difficulty: 2
        - id: v10
          title: Format Memory Report
          description: >-
            A system monitor displays memory usage. Write <code>func memReport(used, total int) string</code>
            that returns "Memory: X.X/Y.X GB (ZZ.Z%)" where used and total are in megabytes, converted to GB
            by dividing by 1024. Show one decimal place for GB values and one decimal for the percentage.
          functionSignature: func memReport(used, total int) string
          testCases:
            - input: 7168, 16384
              output: "\"Memory: 7.0/16.0 GB (43.8%)\""
            - input: 4096, 8192
              output: "\"Memory: 4.0/8.0 GB (50.0%)\""
          hints:
            - title: ðŸ¤” Think about it
              content: >-
                You need to convert integers to floats for division, then format multiple float values with
                different contextual meanings. How do you compute a percentage from two values?
            - title: ðŸ’¡ Hint
              content: >-
                Convert to float64 for division. Compute GB as float64(mb)/1024.0 and percentage as
                float64(used)/float64(total)*100. Use %.1f for one decimal place and %% for a literal percent.
            - title: ðŸ”§ Pattern
              content: |-
                <pre>1. usedGB := float64(used) / 1024.0
                2. totalGB := float64(total) / 1024.0
                3. pct := float64(used) / float64(total) * 100
                4. Format with "%.1f/%.1f GB (%.1f%%)"</pre>
          solution: |-
            func memReport(used, total int) string {
                usedGB := float64(used) / 1024.0
                totalGB := float64(total) / 1024.0
                pct := float64(used) / float64(total) * 100
                return fmt.Sprintf("Memory: %.1f/%.1f GB (%.1f%%)", usedGB, totalGB, pct)
            }
          difficulty: 3
        - id: v11
          title: Format Table Header
          description: >-
            A CLI tool prints a table header with column names and a separator line. Write <code>func
            tableHeader(col1 string, w1 int, col2 string, w2 int) string</code> that returns two lines: the
            column names each left-aligned in their respective widths, and a separator of dashes matching the
            total width plus 2 for the gap. Use "  " (two spaces) between columns.
          functionSignature: func tableHeader(col1 string, w1 int, col2 string, w2 int) string
          testCases:
            - input: "\"Name\", 10, \"Score\", 8"
              output: "\"Name        Score   \\n--------------------\""
          hints:
            - title: ðŸ¤” Think about it
              content: >-
                You need dynamic-width formatting and string repetition. The fmt.Sprintf("%-*s", width, str)
                syntax uses * to take the width from an argument. How do you create a line of dashes?
            - title: ðŸ’¡ Hint
              content: >-
                Use fmt.Sprintf("%-*s  %-*s", w1, col1, w2, col2) for the header row. Use strings.Repeat("-",
                w1+w2+2) for the separator line. Join with "\n".
            - title: ðŸ”§ Pattern
              content: |-
                <pre>1. Format header: fmt.Sprintf("%-*s  %-*s", w1, col1, w2, col2)
                2. Build separator: strings.Repeat("-", w1+w2+2)
                3. Combine with "\n" between them
                4. Return the two-line string</pre>
          solution: |-
            func tableHeader(col1 string, w1 int, col2 string, w2 int) string {
                header := fmt.Sprintf("%-*s  %-*s", w1, col1, w2, col2)
                sep := strings.Repeat("-", w1+w2+2)
                return header + "\n" + sep
            }
          difficulty: 3
        - id: v12
          title: Format File Size with Unit
          description: >-
            A file manager shows sizes in the largest appropriate unit. Write <code>func formatSize(bytes int)
            string</code> that returns: "X B" for less than 1024, "X.XX KB" for less than 1048576, "X.XX MB"
            for less than 1073741824, or "X.XX GB" otherwise. Always show exactly 2 decimal places for KB, MB,
            and GB.
          functionSignature: func formatSize(bytes int) string
          testCases:
            - input: "750"
              output: "\"750 B\""
            - input: "2560"
              output: "\"2.50 KB\""
            - input: "5242880"
              output: "\"5.00 MB\""
            - input: "2147483648"
              output: "\"2.00 GB\""
          hints:
            - title: ðŸ¤” Think about it
              content: >-
                Each unit threshold is 1024 times the previous one. You need to check from smallest to largest
                and divide by the appropriate power of 1024. How do you convert int to float64 for division?
            - title: ðŸ’¡ Hint
              content: >-
                Use cascading if/else: check < 1024 first (bytes), then < 1048576 (KB), then < 1073741824
                (MB), else GB. Divide by float64 of the threshold and format with %.2f.
            - title: ðŸ”§ Pattern
              content: |-
                <pre>1. if bytes < 1024: return "%d B"
                2. else if bytes < 1048576: return "%.2f KB" (divide by 1024)
                3. else if bytes < 1073741824: return "%.2f MB" (divide by 1048576)
                4. else: return "%.2f GB" (divide by 1073741824)</pre>
          solution: |-
            func formatSize(bytes int) string {
                if bytes < 1024 {
                    return fmt.Sprintf("%d B", bytes)
                }
                if bytes < 1048576 {
                    return fmt.Sprintf("%.2f KB", float64(bytes)/1024.0)
                }
                if bytes < 1073741824 {
                    return fmt.Sprintf("%.2f MB", float64(bytes)/1048576.0)
                }
                return fmt.Sprintf("%.2f GB", float64(bytes)/1073741824.0)
            }
          difficulty: 3
        - id: v13
          title: Format Elapsed Time Smart
          description: >-
            A task timer displays elapsed time in the most natural unit. Write <code>func formatElapsed(ms
            int) string</code> that returns: "Xms" if under 1000, "X.XXs" if under 60000, "Xm Ys" if under
            3600000, or "Xh Ym Zs" otherwise. Seconds should show 2 decimal places. Minutes and seconds in the
            longer formats are integers.
          functionSignature: func formatElapsed(ms int) string
          testCases:
            - input: "450"
              output: "\"450ms\""
            - input: "2500"
              output: "\"2.50s\""
            - input: "125000"
              output: "\"2m 5s\""
            - input: "7384000"
              output: "\"2h 3m 4s\""
          hints:
            - title: ðŸ¤” Think about it
              content: >-
                Each threshold introduces a new unit. For the seconds range you need float division. For
                minutes and hours you need integer division and modulo to extract each component.
            - title: ðŸ’¡ Hint
              content: >-
                Check thresholds in order: < 1000 for ms, < 60000 for seconds (float64(ms)/1000.0), < 3600000
                for minutes (ms/1000/60 for m, ms/1000%60 for s). For hours, divide total seconds by 3600.
            - title: ðŸ”§ Pattern
              content: >-
                <pre>1. if ms < 1000: return "%dms"
          
                2. if ms < 60000: return "%.2fs" (float64(ms)/1000.0)
          
                3. if ms < 3600000: totalSec := ms/1000, m := totalSec/60, s := totalSec%60
          
                4. else: totalSec := ms/1000, h := totalSec/3600, m := (totalSec%3600)/60, s :=
                totalSec%60</pre>
          solution: |-
            func formatElapsed(ms int) string {
                if ms < 1000 {
                    return fmt.Sprintf("%dms", ms)
                }
                if ms < 60000 {
                    return fmt.Sprintf("%.2fs", float64(ms)/1000.0)
                }
                totalSec := ms / 1000
                if ms < 3600000 {
                    m := totalSec / 60
                    s := totalSec % 60
                    return fmt.Sprintf("%dm %ds", m, s)
                }
                h := totalSec / 3600
                m := (totalSec % 3600) / 60
                s := totalSec % 60
                return fmt.Sprintf("%dh %dm %ds", h, m, s)
            }
          difficulty: 3
    - id: challenge_4
      block: 1
      difficulty: 1
      concept: Function Basics
      docLinks:
        - url: https://go.dev/tour/basics/4
          title: "Go Tour: Functions"
          note: function syntax
        - url: https://go.dev/ref/spec#Function_declarations
          title: "Go Spec: Function declarations"
          note: full specification
      patternPrimer:
        bruteForce: Write separate functions for every operation, even trivial ones.
        bestApproach: Design functions with clear input/output contracts; use same-type parameter shorthand for cleaner signatures.
        typical: Focus on correct signatures, parameter types, and return types.
      variants:
        - id: v1
          title: Double a Number
          description: >-
            A scaling utility needs to double resource allocations. Write <code>func double(n int) int</code>
            that returns n multiplied by 2.
          functionSignature: func double(n int) int
          testCases:
            - input: "5"
              output: "10"
            - input: "0"
              output: "0"
            - input: "-3"
              output: "-6"
          hints:
            - title: ðŸ¤” Think about it
              content: >-
                A function takes input and returns output. The multiplication operator * doubles a value. What
                is the simplest expression to return?
            - title: ðŸ’¡ Hint
              content: >-
                Return n * 2. The function signature already specifies int parameter and int return type, so
                the body just needs the computation.
            - title: ðŸ”§ Pattern
              content: |-
                <pre>1. Define function with (n int) parameter
                2. Return n * 2</pre>
          solution: |-
            func double(n int) int {
                return n * 2
            }
          difficulty: 1
        - id: v2
          title: Negate a Value
          description: >-
            A financial calculator needs to flip the sign of a transaction amount. Write <code>func negate(n
            int) int</code> that returns the negation of n.
          functionSignature: func negate(n int) int
          testCases:
            - input: "5"
              output: "-5"
            - input: "-3"
              output: "3"
            - input: "0"
              output: "0"
          hints:
            - title: ðŸ¤” Think about it
              content: >-
                Negation flips the sign of a number. Positive becomes negative and vice versa. What unary
                operator achieves this in Go?
            - title: ðŸ’¡ Hint
              content: Return -n. The unary minus operator negates the value. Negating 0 still gives 0.
            - title: ðŸ”§ Pattern
              content: |-
                <pre>1. Define function with (n int) parameter
                2. Return -n</pre>
          solution: |-
            func negate(n int) int {
                return -n
            }
          difficulty: 1
        - id: v3
          title: Concatenate Strings
          description: >-
            A URL builder joins a base path and an endpoint. Write <code>func joinPath(base, endpoint string)
            string</code> that returns base + "/" + endpoint.
          functionSignature: func joinPath(base, endpoint string) string
          testCases:
            - input: "\"api\", \"users\""
              output: "\"api/users\""
            - input: "\"v2\", \"health\""
              output: "\"v2/health\""
          hints:
            - title: ðŸ¤” Think about it
              content: >-
                String concatenation in Go uses the + operator. You need to combine three parts: the base, a
                slash, and the endpoint.
            - title: ðŸ’¡ Hint
              content: >-
                Return base + "/" + endpoint. Go's + operator concatenates strings when used between string
                operands. The slash is a string literal.
            - title: ðŸ”§ Pattern
              content: |-
                <pre>1. Use same-type shorthand: (base, endpoint string)
                2. Concatenate with + and a "/" separator
                3. Return the combined string</pre>
          solution: |-
            func joinPath(base, endpoint string) string {
                return base + "/" + endpoint
            }
          difficulty: 1
        - id: v4
          title: Is Even
          description: >-
            A load balancer distributes requests based on even/odd IDs. Write <code>func isEven(n int)
            bool</code> that returns true if n is divisible by 2.
          functionSignature: func isEven(n int) bool
          testCases:
            - input: "4"
              output: "true"
            - input: "7"
              output: "false"
            - input: "0"
              output: "true"
          hints:
            - title: ðŸ¤” Think about it
              content: >-
                The modulo operator % gives the remainder of division. A number divisible by 2 has zero
                remainder. Can you return a boolean expression directly?
            - title: ðŸ’¡ Hint
              content: >-
                Return n%2 == 0. The comparison itself is a bool value, so no if/else is needed. The modulo
                checks divisibility.
            - title: ðŸ”§ Pattern
              content: |-
                <pre>1. Use n % 2 to get the remainder
                2. Compare with == 0
                3. Return the boolean result directly</pre>
          solution: |-
            func isEven(n int) bool {
                return n%2 == 0
            }
          difficulty: 1
        - id: v5
          title: Clamp Rate
          description: >-
            A rate limiter needs to cap request counts. Write <code>func clampRate(count, maxRate int)
            int</code> that returns count if it is less than or equal to maxRate, or maxRate otherwise.
          functionSignature: func clampRate(count, maxRate int) int
          testCases:
            - input: 50, 100
              output: "50"
            - input: 150, 100
              output: "100"
            - input: 100, 100
              output: "100"
          hints:
            - title: ðŸ¤” Think about it
              content: >-
                Clamping to a maximum means allowing the value through if it fits, or returning the cap if it
                exceeds. Which comparison operator checks if a value exceeds a limit?
            - title: ðŸ’¡ Hint
              content: >-
                Use if count > maxRate to check if the value exceeds the cap. Return maxRate in that case,
                otherwise return count unchanged.
            - title: ðŸ”§ Pattern
              content: |-
                <pre>1. if count > maxRate { return maxRate }
                2. return count</pre>
          solution: |-
            func clampRate(count, maxRate int) int {
                if count > maxRate {
                    return maxRate
                }
                return count
            }
          difficulty: 2
        - id: v6
          title: Absolute Value
          description: >-
            A distance calculator needs the magnitude of a difference. Write <code>func abs(n int) int</code>
            that returns the absolute value of n.
          functionSignature: func abs(n int) int
          testCases:
            - input: "5"
              output: "5"
            - input: "-7"
              output: "7"
            - input: "0"
              output: "0"
          hints:
            - title: ðŸ¤” Think about it
              content: >-
                Absolute value removes the sign. Positive numbers stay the same, negative numbers become
                positive. How do you negate a negative number to make it positive?
            - title: ðŸ’¡ Hint
              content: >-
                If n < 0, return -n to flip the sign. Otherwise return n unchanged. The unary minus makes a
                negative number positive.
            - title: ðŸ”§ Pattern
              content: |-
                <pre>1. if n < 0 { return -n }
                2. return n</pre>
          solution: |-
            func abs(n int) int {
                if n < 0 {
                    return -n
                }
                return n
            }
          difficulty: 2
        - id: v7
          title: Validate Port
          description: >-
            A config validator checks port ranges. Write <code>func isValidPort(port int) bool</code> that
            returns true for ports in the range 1 to 65535 (inclusive).
          functionSignature: func isValidPort(port int) bool
          testCases:
            - input: "8080"
              output: "true"
            - input: "0"
              output: "false"
            - input: "65535"
              output: "true"
            - input: "70000"
              output: "false"
          hints:
            - title: ðŸ¤” Think about it
              content: >-
                You need to check that a number falls within a range. This requires two conditions combined
                with a logical AND. Can you express both checks in a single return statement?
            - title: ðŸ’¡ Hint
              content: >-
                Return port >= 1 && port <= 65535. The && operator requires both conditions to be true. The
                entire expression evaluates to a bool.
            - title: ðŸ”§ Pattern
              content: |-
                <pre>1. Check lower bound: port >= 1
                2. Check upper bound: port <= 65535
                3. Combine with && and return directly</pre>
          solution: |-
            func isValidPort(port int) bool {
                return port >= 1 && port <= 65535
            }
          difficulty: 2
        - id: v8
          title: Celsius to Fahrenheit
          description: >-
            A weather dashboard converts temperatures for international users. Write <code>func celsiusToF(c
            float64) float64</code> that converts Celsius to Fahrenheit using the formula F = C * 9/5 + 32.
          functionSignature: func celsiusToF(c float64) float64
          testCases:
            - input: "0.0"
              output: "32"
            - input: "100.0"
              output: "212"
            - input: "-40.0"
              output: "-40"
          hints:
            - title: ðŸ¤” Think about it
              content: >-
                The conversion formula has both multiplication and addition. Order of operations applies
                naturally in Go. What does 9.0/5.0 evaluate to?
            - title: ðŸ’¡ Hint
              content: >-
                Return c*9.0/5.0 + 32.0. Use float64 literals (9.0, 5.0, 32.0) to ensure floating-point
                division rather than integer division.
            - title: ðŸ”§ Pattern
              content: |-
                <pre>1. Multiply c by 9.0/5.0
                2. Add 32.0
                3. Return the result</pre>
          solution: |-
            func celsiusToF(c float64) float64 {
                return c*9.0/5.0 + 32.0
            }
          difficulty: 2
        - id: v9
          title: Safe Divide
          description: >-
            A calculator needs division that handles zero gracefully. Write <code>func safeDivide(a, b int)
            int</code> that returns a / b, or 0 if b is zero.
          functionSignature: func safeDivide(a, b int) int
          testCases:
            - input: 10, 3
              output: "3"
            - input: 10, 0
              output: "0"
            - input: 0, 5
              output: "0"
          hints:
            - title: ðŸ¤” Think about it
              content: >-
                Division by zero causes a runtime panic in Go. You need to check the divisor before performing
                the operation. What condition must you guard against?
            - title: ðŸ’¡ Hint
              content: >-
                Check if b == 0 first and return 0 in that case. Otherwise return a / b. Integer division in
                Go truncates toward zero.
            - title: ðŸ”§ Pattern
              content: |-
                <pre>1. if b == 0 { return 0 }
                2. return a / b</pre>
          solution: |-
            func safeDivide(a, b int) int {
                if b == 0 {
                    return 0
                }
                return a / b
            }
          difficulty: 2
        - id: v10
          title: Discount Tier
          description: >-
            An e-commerce system applies tiered discounts based on the order total. Write <code>func
            discountTier(total float64) float64</code> that returns the discount multiplier: 0.0 for totals
            under 50, 0.05 for 50-99.99, 0.10 for 100-199.99, or 0.15 for 200 and above.
          functionSignature: func discountTier(total float64) float64
          testCases:
            - input: "30.0"
              output: "0"
            - input: "75.0"
              output: "0.05"
            - input: "150.0"
              output: "0.1"
            - input: "250.0"
              output: "0.15"
          hints:
            - title: ðŸ¤” Think about it
              content: >-
                Tiered thresholds must be checked in the right order. If you check from the highest threshold
                down, you can use simple if/else without overlap. Alternatively, check ascending and use
                else-if.
            - title: ðŸ’¡ Hint
              content: >-
                Check thresholds descending: if total >= 200 return 0.15, else if total >= 100 return 0.10,
                else if total >= 50 return 0.05, else return 0.0. Each branch catches the tier.
            - title: ðŸ”§ Pattern
              content: |-
                <pre>1. if total >= 200 { return 0.15 }
                2. if total >= 100 { return 0.10 }
                3. if total >= 50 { return 0.05 }
                4. return 0.0</pre>
          solution: |-
            func discountTier(total float64) float64 {
                if total >= 200 {
                    return 0.15
                }
                if total >= 100 {
                    return 0.10
                }
                if total >= 50 {
                    return 0.05
                }
                return 0.0
            }
          difficulty: 3
        - id: v11
          title: Password Strength
          description: >-
            A registration form evaluates password strength by length. Write <code>func
            passwordStrength(password string) string</code> that returns "weak" if length is under 8, "medium"
            if length is 8-11, "strong" if length is 12-15, or "very strong" if 16 or more.
          functionSignature: func passwordStrength(password string) string
          testCases:
            - input: "\"abc\""
              output: "\"weak\""
            - input: "\"password\""
              output: "\"medium\""
            - input: "\"securePass12\""
              output: "\"strong\""
            - input: "\"myVeryLongPassword!\""
              output: "\"very strong\""
          hints:
            - title: ðŸ¤” Think about it
              content: >-
                You need to measure the string length and classify it into tiers. Use len(password) to get the
                byte length. Which order of threshold checks avoids overlapping conditions?
            - title: ðŸ’¡ Hint
              content: >-
                Check from the highest threshold down: len >= 16 is "very strong", len >= 12 is "strong", len
                >= 8 is "medium", else "weak". This avoids needing range checks.
            - title: ðŸ”§ Pattern
              content: |-
                <pre>1. n := len(password)
                2. if n >= 16 { return "very strong" }
                3. if n >= 12 { return "strong" }
                4. if n >= 8 { return "medium" }
                5. return "weak"</pre>
          solution: |-
            func passwordStrength(password string) string {
                n := len(password)
                if n >= 16 {
                    return "very strong"
                }
                if n >= 12 {
                    return "strong"
                }
                if n >= 8 {
                    return "medium"
                }
                return "weak"
            }
          difficulty: 3
        - id: v12
          title: Shipping Cost
          description: >-
            An order system calculates shipping based on weight and distance. Write <code>func
            shippingCost(weightKg float64, distanceKm int) float64</code> that returns the shipping cost. Base
            rate is 5.0. Add 0.50 per kg over 2.0 kg. Add 0.01 per km over 100 km. If weight is 2.0 kg or less
            and distance is 100 km or less, just return the base rate.
          functionSignature: func shippingCost(weightKg float64, distanceKm int) float64
          testCases:
            - input: 1.5, 50
              output: "5"
            - input: 5.0, 50
              output: "6.5"
            - input: 1.0, 250
              output: "6.5"
            - input: 4.0, 200
              output: "7"
          hints:
            - title: ðŸ¤” Think about it
              content: >-
                Start with the base rate and add surcharges conditionally. The weight surcharge only applies
                to kg above 2.0, and the distance surcharge only applies to km above 100.
            - title: ðŸ’¡ Hint
              content: >-
                Start with cost := 5.0. If weightKg > 2.0, add (weightKg - 2.0) * 0.50. If distanceKm > 100,
                add float64(distanceKm - 100) * 0.01. Return cost.
            - title: ðŸ”§ Pattern
              content: |-
                <pre>1. cost := 5.0
                2. if weightKg > 2.0 { cost += (weightKg - 2.0) * 0.50 }
                3. if distanceKm > 100 { cost += float64(distanceKm - 100) * 0.01 }
                4. return cost</pre>
          solution: |-
            func shippingCost(weightKg float64, distanceKm int) float64 {
                cost := 5.0
                if weightKg > 2.0 {
                    cost += (weightKg - 2.0) * 0.50
                }
                if distanceKm > 100 {
                    cost += float64(distanceKm-100) * 0.01
                }
                return cost
            }
          difficulty: 3
        - id: v13
          title: Grade Calculator
          description: >-
            A grading system computes a weighted final score and assigns a letter grade. Write <code>func
            finalGrade(exam, homework, participation float64) string</code> that computes the final score as
            exam*0.5 + homework*0.3 + participation*0.2. Return "A" for 90+, "B" for 80+, "C" for 70+, "D" for
            60+, or "F" otherwise.
          functionSignature: func finalGrade(exam, homework, participation float64) string
          testCases:
            - input: 95.0, 90.0, 85.0
              output: "\"A\""
            - input: 70.0, 80.0, 90.0
              output: "\"B\""
            - input: 60.0, 65.0, 70.0
              output: "\"C\""
            - input: 50.0, 55.0, 60.0
              output: "\"D\""
            - input: 30.0, 40.0, 50.0
              output: "\"F\""
          hints:
            - title: ðŸ¤” Think about it
              content: >-
                First compute the weighted sum, then classify it into letter grades. The weights must add up
                to 1.0. Check thresholds from highest to lowest to assign the correct grade.
            - title: ðŸ’¡ Hint
              content: >-
                Compute score := exam*0.5 + homework*0.3 + participation*0.2. Then check score >= 90 for "A",
                score >= 80 for "B", etc. Check descending so each else-if catches the right range.
            - title: ðŸ”§ Pattern
              content: |-
                <pre>1. score := exam*0.5 + homework*0.3 + participation*0.2
                2. if score >= 90 { return "A" }
                3. if score >= 80 { return "B" }
                4. if score >= 70 { return "C" }
                5. if score >= 60 { return "D" }
                6. return "F"</pre>
          solution: |-
            func finalGrade(exam, homework, participation float64) string {
                score := exam*0.5 + homework*0.3 + participation*0.2
                if score >= 90 {
                    return "A"
                }
                if score >= 80 {
                    return "B"
                }
                if score >= 70 {
                    return "C"
                }
                if score >= 60 {
                    return "D"
                }
                return "F"
            }
          difficulty: 3
    - id: challenge_5
      block: 1
      difficulty: 1
      concept: "Multiple Returns"
      docLinks:
        - url: https://go.dev/tour/basics/6
          title: "Go Tour: Multiple results"
          note: returning multiple values
        - url: https://go.dev/doc/effective_go#multiple-returns
          title: "Effective Go: Multiple return values"
          note: idiomatic usage
      patternPrimer:
        bruteForce: Use structs or global variables to return multiple pieces of data.
        bestApproach: Use Go's native multiple return values for clean, expressive function signatures.
        typical: Multiple returns add no overhead â€” they are a core Go idiom.
      variants:
        - id: v1
          title: Split Repository Path
          description: >-
            A GitHub CLI parses repository identifiers. Write <code>func splitRepo(path string) (string,
            string)</code> that splits an "owner/repo" string on "/" and returns the owner and repo name.
            Assume exactly one slash.
          functionSignature: func splitRepo(path string) (string, string)
          testCases:
            - input: "\"octocat/hello-world\""
              output: "\"octocat\", \"hello-world\""
            - input: "\"golang/go\""
              output: "\"golang\", \"go\""
          hints:
            - title: ðŸ¤” Think about it
              content: >-
                You need to find where the slash is and extract the text before and after it. Go has built-in
                string splitting functions that can help.
            - title: ðŸ’¡ Hint
              content: >-
                Use strings.Cut(path, "/") which returns the part before the separator, the part after, and a
                boolean. You can ignore the boolean since we assume one slash exists.
            - title: ðŸ”§ Pattern
              content: |-
                <pre>1. Use strings.Cut(path, "/") to split at the slash
                2. Capture the owner (before) and repo (after)
                3. Return owner, repo</pre>
          solution: |-
            func splitRepo(path string) (string, string) {
                owner, repo, _ := strings.Cut(path, "/")
                return owner, repo
            }
          difficulty: 1
        - id: v2
          title: Double and Half
          description: >-
            A calculator utility needs paired transformations. Write <code>func doubleAndHalf(n int) (int,
            int)</code> that returns twice the value and half the value (integer division) of n.
          functionSignature: func doubleAndHalf(n int) (int, int)
          testCases:
            - input: "10"
              output: 20, 5
            - input: "7"
              output: 14, 3
          hints:
            - title: ðŸ¤” Think about it
              content: >-
                You need to compute two values from one input. Multiplying by 2 gives double. What operator
                gives you integer division?
            - title: ðŸ’¡ Hint
              content: >-
                Double is n * 2. Half is n / 2 (integer division truncates in Go). Return both values with a
                single return statement.
            - title: ðŸ”§ Pattern
              content: |-
                <pre>1. Compute double: n * 2
                2. Compute half: n / 2
                3. Return double, half</pre>
          solution: |-
            func doubleAndHalf(n int) (int, int) {
                return n * 2, n / 2
            }
          difficulty: 1
        - id: v3
          title: Rectangle Dimensions
          description: >-
            A layout engine calculates rectangle properties. Write <code>func rectInfo(width, height int)
            (int, int)</code> that returns the area and perimeter of a rectangle.
          functionSignature: func rectInfo(width, height int) (int, int)
          testCases:
            - input: 5, 3
              output: 15, 16
            - input: 4, 4
              output: 16, 16
          hints:
            - title: ðŸ¤” Think about it
              content: >-
                Area of a rectangle is width times height. Perimeter is the total distance around all four
                sides. How do you compute each?
            - title: ðŸ’¡ Hint
              content: >-
                Area = width * height. Perimeter = 2 * (width + height). Return both in a single return
                statement.
            - title: ðŸ”§ Pattern
              content: |-
                <pre>1. Compute area: width * height
                2. Compute perimeter: 2 * (width + height)
                3. Return area, perimeter</pre>
          solution: |-
            func rectInfo(width, height int) (int, int) {
                return width * height, 2 * (width + height)
            }
          difficulty: 1
        - id: v4
          title: Swap Values
          description: >-
            A sorting algorithm needs a swap helper. Write <code>func swap(a, b int) (int, int)</code> that
            returns the two values in reversed order.
          functionSignature: func swap(a, b int) (int, int)
          testCases:
            - input: 1, 2
              output: 2, 1
            - input: 42, 99
              output: 99, 42
          hints:
            - title: ðŸ¤” Think about it
              content: >-
                Unlike many languages, Go lets you return multiple values directly. You do not need a
                temporary variable to swap.
            - title: ðŸ’¡ Hint
              content: Simply return b first and a second. Go's multiple return makes swapping trivial.
            - title: ðŸ”§ Pattern
              content: |-
                <pre>1. Return b, a
                2. That's it â€” Go handles the rest</pre>
          solution: |-
            func swap(a, b int) (int, int) {
                return b, a
            }
          difficulty: 1
        - id: v5
          title: Split Host and Port
          description: >-
            A network library parses server addresses. Write <code>func splitHostPort(addr string) (string,
            string)</code> that splits a "host:port" string and returns the host and port as separate strings.
            Assume exactly one colon.
          functionSignature: func splitHostPort(addr string) (string, string)
          testCases:
            - input: "\"localhost:8080\""
              output: "\"localhost\", \"8080\""
            - input: "\"192.168.1.1:443\""
              output: "\"192.168.1.1\", \"443\""
          hints:
            - title: ðŸ¤” Think about it
              content: >-
                This is a string splitting problem. You need to find the colon and extract what comes before
                and after it. Go has a function that does exactly this.
            - title: ðŸ’¡ Hint
              content: >-
                Use strings.Cut(addr, ":") which splits at the first colon and returns the part before, the
                part after, and a boolean. Return the two string parts.
            - title: ðŸ”§ Pattern
              content: |-
                <pre>1. Use strings.Cut(addr, ":") to split at the colon
                2. Capture host (before) and port (after)
                3. Return host, port</pre>
          solution: |-
            func splitHostPort(addr string) (string, string) {
                host, port, _ := strings.Cut(addr, ":")
                return host, port
            }
          difficulty: 2
        - id: v6
          title: Initials Extractor
          description: >-
            A contact app displays user initials for avatars. Write <code>func initials(first, last string)
            (byte, byte)</code> that returns the first byte of each name as the initials.
          functionSignature: func initials(first, last string) (byte, byte)
          testCases:
            - input: "\"John\", \"Doe\""
              output: "'J', 'D'"
            - input: "\"Alice\", \"Smith\""
              output: "'A', 'S'"
          hints:
            - title: ðŸ¤” Think about it
              content: >-
                You only need the first character of each string. In Go, indexing a string gives you a byte.
                How do you access the first byte?
            - title: ðŸ’¡ Hint
              content: The first byte of a string is accessed with s[0]. Get first[0] and last[0] and return both.
            - title: ðŸ”§ Pattern
              content: |-
                <pre>1. Get first initial: first[0]
                2. Get last initial: last[0]
                3. Return both bytes</pre>
          solution: |-
            func initials(first, last string) (byte, byte) {
                return first[0], last[0]
            }
          difficulty: 2
        - id: v7
          title: Seconds to Minutes
          description: >-
            A media player converts durations for display. Write <code>func toMinSec(totalSeconds int) (int,
            int)</code> that converts a total number of seconds into whole minutes and remaining seconds.
          functionSignature: func toMinSec(totalSeconds int) (int, int)
          testCases:
            - input: "125"
              output: 2, 5
            - input: "60"
              output: 1, 0
            - input: "45"
              output: 0, 45
          hints:
            - title: ðŸ¤” Think about it
              content: >-
                There are 60 seconds in a minute. Integer division gives you the whole minutes, and the modulo
                operator gives you the leftover seconds.
            - title: ðŸ’¡ Hint
              content: >-
                Minutes = totalSeconds / 60. Remaining seconds = totalSeconds % 60. Return both values
                together.
            - title: ðŸ”§ Pattern
              content: |-
                <pre>1. Compute minutes: totalSeconds / 60
                2. Compute remaining seconds: totalSeconds % 60
                3. Return minutes, seconds</pre>
          solution: |-
            func toMinSec(totalSeconds int) (int, int) {
                return totalSeconds / 60, totalSeconds % 60
            }
          difficulty: 2
        - id: v8
          title: String Metrics
          description: >-
            A text analysis tool gathers string statistics. Write <code>func stringMetrics(s string) (int,
            int)</code> that returns the length of the string and the number of spaces it contains.
          functionSignature: func stringMetrics(s string) (int, int)
          testCases:
            - input: "\"hello world\""
              output: 11, 1
            - input: "\"go is great\""
              output: 11, 2
            - input: "\"nospaces\""
              output: 8, 0
          hints:
            - title: ðŸ¤” Think about it
              content: >-
                One value is built into Go (length), but counting spaces requires scanning the string. How can
                you count occurrences of a character?
            - title: ðŸ’¡ Hint
              content: >-
                Use len(s) for the total length. Use strings.Count(s, " ") to count spaces. Return both
                values.
            - title: ðŸ”§ Pattern
              content: |-
                <pre>1. Get length: len(s)
                2. Count spaces: strings.Count(s, " ")
                3. Return length, spaceCount</pre>
          solution: |-
            func stringMetrics(s string) (int, int) {
                return len(s), strings.Count(s, " ")
            }
          difficulty: 2
        - id: v9
          title: Clamp with Report
          description: >-
            A game engine clamps values to a range and reports whether clamping occurred. Write <code>func
            clamp(value, lo, hi int) (int, bool)</code> that returns the clamped value and true if it was
            changed, false if it was already in range.
          functionSignature: func clamp(value, lo, hi int) (int, bool)
          testCases:
            - input: 5, 1, 10
              output: 5, false
            - input: "-3, 0, 100"
              output: 0, true
            - input: 200, 0, 100
              output: 100, true
          hints:
            - title: ðŸ¤” Think about it
              content: >-
                Clamping means forcing a value into a range. If it is below the minimum, use the minimum. If
                above the maximum, use the maximum. The boolean tells the caller whether the value was
                modified.
            - title: ðŸ’¡ Hint
              content: >-
                Check if value < lo (return lo, true) and if value > hi (return hi, true). Otherwise the value
                is already in range â€” return it with false.
            - title: ðŸ”§ Pattern
              content: |-
                <pre>1. If value < lo: return lo, true
                2. If value > hi: return hi, true
                3. Return value, false</pre>
          solution: |-
            func clamp(value, lo, hi int) (int, bool) {
                if value < lo {
                    return lo, true
                }
                if value > hi {
                    return hi, true
                }
                return value, false
            }
          difficulty: 2
        - id: v10
          title: Build Step Stats
          description: >-
            A CI pipeline reports timing for its build steps. Write <code>func stepStats(durations []int)
            (int, int, int)</code> that returns the count, minimum, and maximum duration from the slice.
          functionSignature: func stepStats(durations []int) (int, int, int)
          testCases:
            - input: "[]int{120, 45, 300, 90}"
              output: 4, 45, 300
            - input: "[]int{10, 20}"
              output: 2, 10, 20
          hints:
            - title: ðŸ¤” Think about it
              content: >-
                Count is straightforward with len(). For min and max, you need to scan the slice and track the
                smallest and largest values. What should you initialize them to?
            - title: ðŸ’¡ Hint
              content: >-
                Initialize min and max to durations[0]. Loop through the rest, updating min when you find a
                smaller value and max when you find a larger one. Return all three.
            - title: ðŸ”§ Pattern
              content: |-
                <pre>1. count := len(durations)
                2. min, max := durations[0], durations[0]
                3. For each d in durations:
                   - If d < min: min = d
                   - If d > max: max = d
                4. Return count, min, max</pre>
          solution: |-
            func stepStats(durations []int) (int, int, int) {
                min, max := durations[0], durations[0]
                for _, d := range durations[1:] {
                    if d < min {
                        min = d
                    }
                    if d > max {
                        max = d
                    }
                }
                return len(durations), min, max
            }
          difficulty: 3
        - id: v11
          title: Parse Key-Value
          description: >-
            A configuration parser reads "key=value" strings. Write <code>func parseKeyValue(s string)
            (string, string, bool)</code> that splits the string at "=" and returns the key, value, and true.
            If there is no "=", return empty strings and false.
          functionSignature: func parseKeyValue(s string) (string, string, bool)
          testCases:
            - input: "\"host=localhost\""
              output: "\"host\", \"localhost\", true"
            - input: "\"noequals\""
              output: "\"\", \"\", false"
            - input: "\"port=8080\""
              output: "\"port\", \"8080\", true"
          hints:
            - title: ðŸ¤” Think about it
              content: >-
                You need to split at "=" and also report whether the split succeeded. Go's strings.Cut
                function returns a boolean that tells you exactly this.
            - title: ðŸ’¡ Hint
              content: >-
                Use strings.Cut(s, "=") which returns (before, after, found). If !found, return empty strings
                and false. Otherwise return the key, value, and true.
            - title: ðŸ”§ Pattern
              content: |-
                <pre>1. key, value, ok := strings.Cut(s, "=")
                2. If !ok: return "", "", false
                3. Return key, value, true</pre>
          solution: |-
            func parseKeyValue(s string) (string, string, bool) {
                key, value, ok := strings.Cut(s, "=")
                if !ok {
                    return "", "", false
                }
                return key, value, true
            }
          difficulty: 3
        - id: v12
          title: Word Count Extremes
          description: >-
            A text analysis tool compares word lengths. Write <code>func wordExtremes(words []string) (string,
            string, int)</code> that returns the longest word, the shortest word, and the difference in their
            lengths.
          functionSignature: func wordExtremes(words []string) (string, string, int)
          testCases:
            - input: "[]string{\"go\", \"python\", \"c\", \"rust\"}"
              output: "\"python\", \"c\", 5"
            - input: "[]string{\"cat\", \"elephant\", \"dog\"}"
              output: "\"elephant\", \"cat\", 5"
          hints:
            - title: ðŸ¤” Think about it
              content: >-
                You need to track two words as you loop: the longest so far and the shortest so far.
                Initialize both to the first word, then compare lengths.
            - title: ðŸ’¡ Hint
              content: >-
                Loop through words. If len(word) > len(longest), update longest. If len(word) < len(shortest),
                update shortest. The difference is len(longest) - len(shortest).
            - title: ðŸ”§ Pattern
              content: |-
                <pre>1. longest, shortest := words[0], words[0]
                2. For each word in words:
                   - If len(word) > len(longest): longest = word
                   - If len(word) < len(shortest): shortest = word
                3. diff := len(longest) - len(shortest)
                4. Return longest, shortest, diff</pre>
          solution: |-
            func wordExtremes(words []string) (string, string, int) {
                longest, shortest := words[0], words[0]
                for _, word := range words[1:] {
                    if len(word) > len(longest) {
                        longest = word
                    }
                    if len(word) < len(shortest) {
                        shortest = word
                    }
                }
                return longest, shortest, len(longest) - len(shortest)
            }
          difficulty: 3
        - id: v13
          title: Parse Version String
          description: >-
            A package manager parses semantic version strings. Write <code>func parseVersion(ver string)
            (string, string, string, bool)</code> that splits a "major.minor.patch" string into its three
            parts. Return empty strings and false if the format is invalid (does not have exactly two dots).
          functionSignature: func parseVersion(ver string) (string, string, string, bool)
          testCases:
            - input: "\"1.20.3\""
              output: "\"1\", \"20\", \"3\", true"
            - input: "\"2.0.0\""
              output: "\"2\", \"0\", \"0\", true"
            - input: "\"invalid\""
              output: "\"\", \"\", \"\", false"
          hints:
            - title: ðŸ¤” Think about it
              content: >-
                A valid version has exactly three parts separated by two dots. You need to split the string
                and verify you get exactly three pieces. How can you split a string by a delimiter in Go?
            - title: ðŸ’¡ Hint
              content: >-
                Use strings.Split(ver, ".") to get all parts. Check that len(parts) == 3. If not, return empty
                strings and false. Otherwise return the three parts and true.
            - title: ðŸ”§ Pattern
              content: |-
                <pre>1. parts := strings.Split(ver, ".")
                2. If len(parts) != 3: return "", "", "", false
                3. Return parts[0], parts[1], parts[2], true</pre>
          solution: |-
            func parseVersion(ver string) (string, string, string, bool) {
                parts := strings.Split(ver, ".")
                if len(parts) != 3 {
                    return "", "", "", false
                }
                return parts[0], parts[1], parts[2], true
            }
          difficulty: 3
    - id: challenge_6
      block: 1
      difficulty: 2
      concept: "Error Handling"
      docLinks:
        - url: https://go.dev/blog/error-handling-and-go
          title: "Go Blog: Error handling and Go"
          note: idiomatic error patterns
        - url: https://go.dev/tour/methods/19
          title: "Go Tour: Errors"
          note: error interface
      patternPrimer:
        bruteForce: Use panics or ignore errors entirely.
        bestApproach: Return errors as values; check err != nil immediately after each call that can fail.
        typical: Error handling adds minimal overhead â€” the pattern is if err != nil { return ..., err }.
      variants:
        - id: v1
          title: Validate Username
          description: >-
            A user registration system validates usernames. Write <code>func validateUsername(name string)
            error</code> that returns an error if the name is empty or longer than 20 characters, and nil
            otherwise.
          functionSignature: func validateUsername(name string) error
          testCases:
            - input: "\"gopher\""
              output: nil
            - input: "\"\""
              output: error
            - input: "\"thisusernameiswaytoolongtobevalid\""
              output: error
          hints:
            - title: ðŸ¤” Think about it
              content: >-
                There are two conditions that make a username invalid: being empty and being too long. Check
                each one and return an appropriate error.
            - title: ðŸ’¡ Hint
              content: >-
                Check if name == "" first, then check if len(name) > 20. Use errors.New() to create
                descriptive error messages for each case. Return nil if valid.
            - title: ðŸ”§ Pattern
              content: |-
                <pre>1. If name == "": return errors.New("username required")
                2. If len(name) > 20: return errors.New("username too long")
                3. Return nil</pre>
          solution: |-
            func validateUsername(name string) error {
                if name == "" {
                    return errors.New("username required")
                }
                if len(name) > 20 {
                    return errors.New("username too long")
                }
                return nil
            }
          difficulty: 1
        - id: v2
          title: Safe Array Access
          description: >-
            A data pipeline accesses elements by index safely. Write <code>func safeAccess(items []string,
            index int) (string, error)</code> that returns the element at the given index, or an error if the
            index is out of bounds.
          functionSignature: func safeAccess(items []string, index int) (string, error)
          testCases:
            - input: "[]string{\"a\", \"b\", \"c\"}, 1"
              output: "\"b\", nil"
            - input: "[]string{\"a\", \"b\", \"c\"}, 5"
              output: "\"\", error"
            - input: "[]string{\"a\", \"b\", \"c\"}, -1"
              output: "\"\", error"
          hints:
            - title: ðŸ¤” Think about it
              content: >-
                Accessing a slice out of bounds causes a panic in Go. You need to check the bounds yourself
                before indexing. What range of indices is valid?
            - title: ðŸ’¡ Hint
              content: >-
                Valid indices are 0 to len(items)-1. Check if index < 0 or index >= len(items). If out of
                bounds, return an empty string and an error. Otherwise return the element.
            - title: ðŸ”§ Pattern
              content: |-
                <pre>1. If index < 0 or index >= len(items):
                   - return "", fmt.Errorf("index %d out of bounds", index)
                2. Return items[index], nil</pre>
          solution: |-
            func safeAccess(items []string, index int) (string, error) {
                if index < 0 || index >= len(items) {
                    return "", fmt.Errorf("index %d out of bounds", index)
                }
                return items[index], nil
            }
          difficulty: 1
        - id: v3
          title: Validate Percentage
          description: >-
            A dashboard widget displays percentages. Write <code>func validatePercent(value int) (int,
            error)</code> that returns the value if it is between 0 and 100 inclusive, or an error otherwise.
          functionSignature: func validatePercent(value int) (int, error)
          testCases:
            - input: "50"
              output: 50, nil
            - input: "-1"
              output: 0, error
            - input: "101"
              output: 0, error
          hints:
            - title: ðŸ¤” Think about it
              content: >-
                A valid percentage is any integer from 0 to 100. Values outside this range should produce an
                error. What two conditions define "out of range"?
            - title: ðŸ’¡ Hint
              content: >-
                Check if value < 0 or value > 100. If either is true, return 0 and an error created with
                fmt.Errorf. Otherwise return value and nil.
            - title: ðŸ”§ Pattern
              content: |-
                <pre>1. If value < 0 or value > 100:
                   - return 0, fmt.Errorf("invalid percentage: %d", value)
                2. Return value, nil</pre>
          solution: |-
            func validatePercent(value int) (int, error) {
                if value < 0 || value > 100 {
                    return 0, fmt.Errorf("invalid percentage: %d", value)
                }
                return value, nil
            }
          difficulty: 1
        - id: v4
          title: Non-Zero Divisor
          description: >-
            A math utility guards against division by zero. Write <code>func safeDivide(a, b int) (int,
            error)</code> that returns a / b or an error if b is zero.
          functionSignature: func safeDivide(a, b int) (int, error)
          testCases:
            - input: 10, 2
              output: 5, nil
            - input: 10, 0
              output: 0, error
          hints:
            - title: ðŸ¤” Think about it
              content: >-
                Dividing by zero causes a runtime panic in Go. You need to prevent this by checking b before
                performing the division.
            - title: ðŸ’¡ Hint
              content: >-
                Check if b == 0 first. If so, return 0 and errors.New("division by zero"). Otherwise return a
                / b and nil.
            - title: ðŸ”§ Pattern
              content: |-
                <pre>1. If b == 0: return 0, errors.New("division by zero")
                2. Return a / b, nil</pre>
          solution: |-
            func safeDivide(a, b int) (int, error) {
                if b == 0 {
                    return 0, errors.New("division by zero")
                }
                return a / b, nil
            }
          difficulty: 1
        - id: v5
          title: Parse Port Number
          description: >-
            A config loader reads port numbers from strings. Write <code>func parsePort(s string) (int,
            error)</code> that converts s to an int and returns an error if the string is not a valid number
            or if the port is outside the range 1-65535.
          functionSignature: func parsePort(s string) (int, error)
          testCases:
            - input: "\"8080\""
              output: 8080, nil
            - input: "\"0\""
              output: 0, error
            - input: "\"99999\""
              output: 0, error
            - input: "\"abc\""
              output: 0, error
          hints:
            - title: ðŸ¤” Think about it
              content: >-
                There are two things that can go wrong: the string might not be a number at all, or the number
                might be outside the valid port range. Check both, in order.
            - title: ðŸ’¡ Hint
              content: >-
                Use strconv.Atoi(s) to parse. If err != nil, return it. Then check if the port is < 1 or >
                65535 and return an error for that case.
            - title: ðŸ”§ Pattern
              content: |-
                <pre>1. port, err := strconv.Atoi(s)
                2. If err != nil: return 0, fmt.Errorf("invalid port: %w", err)
                3. If port < 1 or port > 65535: return 0, errors.New("port out of range")
                4. Return port, nil</pre>
          solution: |-
            func parsePort(s string) (int, error) {
                port, err := strconv.Atoi(s)
                if err != nil {
                    return 0, fmt.Errorf("invalid port: %w", err)
                }
                if port < 1 || port > 65535 {
                    return 0, errors.New("port out of range")
                }
                return port, nil
            }
          difficulty: 2
        - id: v6
          title: Validate Password
          description: >-
            A signup form validates passwords. Write <code>func validatePassword(pw string) error</code> that
            returns an error if the password is shorter than 8 characters or longer than 64 characters, and
            nil otherwise.
          functionSignature: func validatePassword(pw string) error
          testCases:
            - input: "\"securePass123\""
              output: nil
            - input: "\"short\""
              output: error
            - input: "\"\""
              output: error
          hints:
            - title: ðŸ¤” Think about it
              content: >-
                Password validation has a minimum and maximum length. Check both boundary conditions and
                return a helpful error message for each.
            - title: ðŸ’¡ Hint
              content: >-
                Check if len(pw) < 8 first, then if len(pw) > 64. Return a different error message for each
                case. If both pass, return nil.
            - title: ðŸ”§ Pattern
              content: |-
                <pre>1. If len(pw) < 8: return errors.New("password too short")
                2. If len(pw) > 64: return errors.New("password too long")
                3. Return nil</pre>
          solution: |-
            func validatePassword(pw string) error {
                if len(pw) < 8 {
                    return errors.New("password too short")
                }
                if len(pw) > 64 {
                    return errors.New("password too long")
                }
                return nil
            }
          difficulty: 2
        - id: v7
          title: Parse Temperature
          description: >-
            A weather API parses temperature strings. Write <code>func parseTemp(s string) (float64,
            error)</code> that converts a string to a float64 and returns an error if the string is invalid or
            the temperature is below absolute zero (-273.15).
          functionSignature: func parseTemp(s string) (float64, error)
          testCases:
            - input: "\"22.5\""
              output: 22.5, nil
            - input: "\"-300\""
              output: 0, error
            - input: "\"hot\""
              output: 0, error
          hints:
            - title: ðŸ¤” Think about it
              content: >-
                Two validations are needed: first the string must parse as a number, then the value must be
                physically plausible. Check them in sequence.
            - title: ðŸ’¡ Hint
              content: >-
                Use strconv.ParseFloat(s, 64) to parse the string. If err != nil, return it. Then check if the
                temperature is below -273.15 and return an error for that.
            - title: ðŸ”§ Pattern
              content: |-
                <pre>1. temp, err := strconv.ParseFloat(s, 64)
                2. If err != nil: return 0, err
                3. If temp < -273.15: return 0, errors.New("below absolute zero")
                4. Return temp, nil</pre>
          solution: |-
            func parseTemp(s string) (float64, error) {
                temp, err := strconv.ParseFloat(s, 64)
                if err != nil {
                    return 0, err
                }
                if temp < -273.15 {
                    return 0, errors.New("below absolute zero")
                }
                return temp, nil
            }
          difficulty: 2
        - id: v8
          title: Lookup with Error
          description: >-
            A registry service looks up services by name. Write <code>func lookupService(registry
            map[string]int, name string) (int, error)</code> that returns the port for a service name, or an
            error if the service is not found.
          functionSignature: func lookupService(registry map[string]int, name string) (int, error)
          testCases:
            - input: "map[string]int{\"web\": 80, \"ssh\": 22}, \"web\""
              output: 80, nil
            - input: "map[string]int{\"web\": 80, \"ssh\": 22}, \"ftp\""
              output: 0, error
          hints:
            - title: ðŸ¤” Think about it
              content: >-
                Go maps return a second boolean value that tells you whether the key existed. You can use this
                comma-ok pattern to detect missing services.
            - title: ðŸ’¡ Hint
              content: >-
                Use port, ok := registry[name]. If !ok, return 0 and an error with fmt.Errorf. Otherwise
                return port and nil.
            - title: ðŸ”§ Pattern
              content: |-
                <pre>1. port, ok := registry[name]
                2. If !ok: return 0, fmt.Errorf("service %q not found", name)
                3. Return port, nil</pre>
          solution: |-
            func lookupService(registry map[string]int, name string) (int, error) {
                port, ok := registry[name]
                if !ok {
                    return 0, fmt.Errorf("service %q not found", name)
                }
                return port, nil
            }
          difficulty: 2
        - id: v9
          title: Validate Step Definition
          description: >-
            A task runner validates step definitions before execution. Write <code>func validateStep(name
            string, timeout int) error</code> that checks the name is non-empty and the timeout is positive.
            Return the first error found.
          functionSignature: func validateStep(name string, timeout int) error
          testCases:
            - input: "\"build\", 30"
              output: nil
            - input: "\"\", 30"
              output: error
            - input: "\"build\", -1"
              output: error
            - input: "\"build\", 0"
              output: error
          hints:
            - title: ðŸ¤” Think about it
              content: >-
                There are two fields to validate: name and timeout. Use the guard clause pattern to check each
                one and return early on the first failure.
            - title: ðŸ’¡ Hint
              content: >-
                Check if name == "" first, return error. Then check if timeout <= 0, return error. If both
                pass, return nil.
            - title: ðŸ”§ Pattern
              content: |-
                <pre>1. If name == "": return errors.New("step name required")
                2. If timeout <= 0: return errors.New("timeout must be positive")
                3. Return nil</pre>
          solution: |-
            func validateStep(name string, timeout int) error {
                if name == "" {
                    return errors.New("step name required")
                }
                if timeout <= 0 {
                    return errors.New("timeout must be positive")
                }
                return nil
            }
          difficulty: 2
        - id: v10
          title: Validate Coordinate
          description: >-
            A mapping API validates geographic coordinates. Write <code>func validateCoord(lat, lon float64)
            error</code> that returns an error if latitude is outside [-90, 90] or longitude is outside [-180,
            180]. Return the first error found.
          functionSignature: func validateCoord(lat, lon float64) error
          testCases:
            - input: 40.7128, -74.0060
              output: nil
            - input: 91.0, 0.0
              output: error
            - input: 0.0, 200.0
              output: error
          hints:
            - title: ðŸ¤” Think about it
              content: >-
                Latitude ranges from -90 to 90 and longitude from -180 to 180. You need to check both values
                and return a specific error message for whichever fails first.
            - title: ðŸ’¡ Hint
              content: >-
                Check latitude first: if lat < -90 or lat > 90, return an error. Then check longitude: if lon
                < -180 or lon > 180, return an error. Use fmt.Errorf for descriptive messages.
            - title: ðŸ”§ Pattern
              content: |-
                <pre>1. If lat < -90 or lat > 90:
                   - return fmt.Errorf("latitude %f out of range", lat)
                2. If lon < -180 or lon > 180:
                   - return fmt.Errorf("longitude %f out of range", lon)
                3. Return nil</pre>
          solution: |-
            func validateCoord(lat, lon float64) error {
                if lat < -90 || lat > 90 {
                    return fmt.Errorf("latitude %f out of range", lat)
                }
                if lon < -180 || lon > 180 {
                    return fmt.Errorf("longitude %f out of range", lon)
                }
                return nil
            }
          difficulty: 3
        - id: v11
          title: Parse Duration String
          description: >-
            A scheduler parses duration strings like "30s" or "5m". Write <code>func parseDuration(s string)
            (int, string, error)</code> that extracts the numeric value and unit suffix. Return an error if
            the string is too short, the number part is invalid, or the unit is not "s", "m", or "h".
          functionSignature: func parseDuration(s string) (int, string, error)
          testCases:
            - input: "\"30s\""
              output: 30, "s", nil
            - input: "\"5m\""
              output: 5, "m", nil
            - input: "\"abc\""
              output: 0, "", error
            - input: "\"10x\""
              output: 0, "", error
          hints:
            - title: ðŸ¤” Think about it
              content: >-
                The last character is the unit and everything before it is the number. You need to separate
                them, parse the number, and verify the unit is valid.
            - title: ðŸ’¡ Hint
              content: >-
                Check len(s) >= 2. Extract the unit as the last character with string(s[len(s)-1]). Parse the
                number from s[:len(s)-1] with strconv.Atoi. Check that the unit is "s", "m", or "h".
            - title: ðŸ”§ Pattern
              content: |-
                <pre>1. If len(s) < 2: return 0, "", errors.New("too short")
                2. unit := string(s[len(s)-1])
                3. n, err := strconv.Atoi(s[:len(s)-1])
                4. If err != nil: return 0, "", err
                5. If unit is not "s", "m", or "h": return error
                6. Return n, unit, nil</pre>
          solution: |-
            func parseDuration(s string) (int, string, error) {
                if len(s) < 2 {
                    return 0, "", errors.New("duration too short")
                }
                unit := string(s[len(s)-1])
                n, err := strconv.Atoi(s[:len(s)-1])
                if err != nil {
                    return 0, "", fmt.Errorf("invalid number: %w", err)
                }
                if unit != "s" && unit != "m" && unit != "h" {
                    return 0, "", fmt.Errorf("invalid unit: %s", unit)
                }
                return n, unit, nil
            }
          difficulty: 3
        - id: v12
          title: Parse Assignment
          description: >-
            A scripting interpreter parses assignment statements like "x = 42". Write <code>func
            parseAssignment(line string) (string, int, error)</code> that extracts the variable name and
            integer value. Return an error if there is no " = " separator or the value is not a valid integer.
          functionSignature: func parseAssignment(line string) (string, int, error)
          testCases:
            - input: "\"x = 42\""
              output: "\"x\", 42, nil"
            - input: "\"count = 100\""
              output: "\"count\", 100, nil"
            - input: "\"invalid\""
              output: "\"\", 0, error"
            - input: "\"x = abc\""
              output: "\"\", 0, error"
          hints:
            - title: ðŸ¤” Think about it
              content: >-
                You need to split the line at " = " to get the variable name and value string. Then parse the
                value as an integer. Each step can fail.
            - title: ðŸ’¡ Hint
              content: >-
                Use strings.Cut(line, " = ") to split. If the separator is not found, return an error. Then
                use strconv.Atoi on the value part. Check errors at each step.
            - title: ðŸ”§ Pattern
              content: |-
                <pre>1. name, valStr, ok := strings.Cut(line, " = ")
                2. If !ok: return "", 0, errors.New("missing = separator")
                3. val, err := strconv.Atoi(valStr)
                4. If err != nil: return "", 0, err
                5. Return name, val, nil</pre>
          solution: |-
            func parseAssignment(line string) (string, int, error) {
                name, valStr, ok := strings.Cut(line, " = ")
                if !ok {
                    return "", 0, errors.New("missing = separator")
                }
                val, err := strconv.Atoi(valStr)
                if err != nil {
                    return "", 0, fmt.Errorf("invalid value: %w", err)
                }
                return name, val, nil
            }
          difficulty: 3
        - id: v13
          title: Validate HTTP Header
          description: >-
            An HTTP framework validates request headers. Write <code>func validateHeader(name, value string)
            error</code> that checks: name must be non-empty, name must not contain spaces, value must not be
            longer than 8192 characters. Return the first error found.
          functionSignature: func validateHeader(name, value string) error
          testCases:
            - input: "\"Content-Type\", \"text/html\""
              output: nil
            - input: "\"\", \"text/html\""
              output: error
            - input: "\"Bad Header\", \"value\""
              output: error
          hints:
            - title: ðŸ¤” Think about it
              content: >-
                There are three validation rules to check in sequence. Use the guard clause pattern: check one
                condition, return early if it fails, then check the next.
            - title: ðŸ’¡ Hint
              content: >-
                Check name == "" first. Then use strings.Contains(name, " ") to reject spaces in the header
                name. Finally check len(value) > 8192. Return nil if all pass.
            - title: ðŸ”§ Pattern
              content: |-
                <pre>1. If name == "": return errors.New("header name required")
                2. If strings.Contains(name, " "):
                   - return errors.New("header name must not contain spaces")
                3. If len(value) > 8192:
                   - return errors.New("header value too long")
                4. Return nil</pre>
          solution: |-
            func validateHeader(name, value string) error {
                if name == "" {
                    return errors.New("header name required")
                }
                if strings.Contains(name, " ") {
                    return errors.New("header name must not contain spaces")
                }
                if len(value) > 8192 {
                    return errors.New("header value too long")
                }
                return nil
            }
          difficulty: 3
    - id: challenge_7
      block: 1
      difficulty: 1
      concept: "Building Slices"
      docLinks:
        - url: https://go.dev/blog/slices-intro
          title: "Go Blog: Go Slices intro"
          note: slice fundamentals
        - url: https://go.dev/tour/moretypes/7
          title: "Go Tour: Slices"
          note: slice basics
      patternPrimer:
        bruteForce: Pre-allocate a large array and track the size manually.
        bestApproach: Use append() to build slices dynamically; use make() when size is known ahead of time.
        typical: append() is amortized O(1) per element â€” slices grow automatically.
      variants:
        - id: v1
          title: Build Number List
          description: >-
            A monitoring dashboard needs a list of sensor IDs. Write <code>func sensorIDs(n int) []int</code>
            that returns a slice containing the numbers 1 through n.
          functionSignature: func sensorIDs(n int) []int
          testCases:
            - input: "5"
              output: "[]int{1, 2, 3, 4, 5}"
            - input: "3"
              output: "[]int{1, 2, 3}"
          hints:
            - title: ðŸ¤” Think about it
              content: >-
                You need to build up a slice one element at a time. Start with an empty slice and add numbers
                in a loop.
            - title: ðŸ’¡ Hint
              content: Create an empty slice with []int{}. Use a for loop from 1 to n and append each number.
            - title: ðŸ”§ Pattern
              content: |-
                <pre>1. result := []int{}
                2. For i := 1 to n:
                   - result = append(result, i)
                3. Return result</pre>
          solution: |-
            func sensorIDs(n int) []int {
                result := []int{}
                for i := 1; i <= n; i++ {
                    result = append(result, i)
                }
                return result
            }
          difficulty: 1
        - id: v2
          title: Zero Buffer
          description: >-
            A network protocol needs a zero-filled buffer of a given size. Write <code>func zeroBuffer(n int)
            []int</code> that returns a slice of n zeros using make().
          functionSignature: func zeroBuffer(n int) []int
          testCases:
            - input: "4"
              output: "[]int{0, 0, 0, 0}"
            - input: "2"
              output: "[]int{0, 0}"
          hints:
            - title: ðŸ¤” Think about it
              content: >-
                Go has a built-in function that creates a slice of a given length with zero values. What is it
                called?
            - title: ðŸ’¡ Hint
              content: >-
                Use make([]int, n) to create a slice of length n. All int elements are automatically
                initialized to 0.
            - title: ðŸ”§ Pattern
              content: <pre>1. Return make([]int, n)</pre>
          solution: |-
            func zeroBuffer(n int) []int {
                return make([]int, n)
            }
          difficulty: 1
        - id: v3
          title: Repeat Tag
          description: >-
            A template engine repeats a placeholder tag a set number of times. Write <code>func repeatTag(tag
            string, n int) []string</code> that returns a slice with tag repeated n times.
          functionSignature: func repeatTag(tag string, n int) []string
          testCases:
            - input: "\"<br>\", 3"
              output: "[]string{\"<br>\", \"<br>\", \"<br>\"}"
            - input: "\"--\", 2"
              output: "[]string{\"--\", \"--\"}"
          hints:
            - title: ðŸ¤” Think about it
              content: >-
                You need a loop that runs n times, appending the same value each iteration. What does the
                starting slice look like?
            - title: ðŸ’¡ Hint
              content: Start with an empty string slice. Loop n times and append tag each time.
            - title: ðŸ”§ Pattern
              content: |-
                <pre>1. result := []string{}
                2. For i := 0 to n:
                   - result = append(result, tag)
                3. Return result</pre>
          solution: |-
            func repeatTag(tag string, n int) []string {
                result := []string{}
                for i := 0; i < n; i++ {
                    result = append(result, tag)
                }
                return result
            }
          difficulty: 1
        - id: v4
          title: Even Numbers
          description: >-
            A pagination system generates even page numbers. Write <code>func evens(n int) []int</code> that
            returns a slice containing [2, 4, 6, ..., 2n].
          functionSignature: func evens(n int) []int
          testCases:
            - input: "4"
              output: "[]int{2, 4, 6, 8}"
            - input: "3"
              output: "[]int{2, 4, 6}"
          hints:
            - title: ðŸ¤” Think about it
              content: >-
                Each element is twice its position starting from 1. How do you generate the sequence 2, 4, 6,
                ...?
            - title: ðŸ’¡ Hint
              content: Loop from 1 to n. For each i, append i * 2 to the result slice.
            - title: ðŸ”§ Pattern
              content: |-
                <pre>1. result := []int{}
                2. For i := 1 to n:
                   - result = append(result, i*2)
                3. Return result</pre>
          solution: |-
            func evens(n int) []int {
                result := []int{}
                for i := 1; i <= n; i++ {
                    result = append(result, i*2)
                }
                return result
            }
          difficulty: 1
        - id: v5
          title: Filter Negative
          description: >-
            A financial system isolates losses from a transaction log. Write <code>func filterNegative(nums
            []int) []int</code> that returns a new slice containing only the negative numbers.
          functionSignature: func filterNegative(nums []int) []int
          testCases:
            - input: "[]int{5, -3, 0, -7, 2}"
              output: "[]int{-3, -7}"
            - input: "[]int{-1, -2, 3}"
              output: "[]int{-1, -2}"
          hints:
            - title: ðŸ¤” Think about it
              content: >-
                You need to selectively include elements based on a condition. Start with an empty result and
                only add elements that are less than zero.
            - title: ðŸ’¡ Hint
              content: Loop through the input. For each number, check if n < 0. If so, append it to the result slice.
            - title: ðŸ”§ Pattern
              content: |-
                <pre>1. result := []int{}
                2. For each n in nums:
                   - If n < 0: result = append(result, n)
                3. Return result</pre>
          solution: |-
            func filterNegative(nums []int) []int {
                result := []int{}
                for _, n := range nums {
                    if n < 0 {
                        result = append(result, n)
                    }
                }
                return result
            }
          difficulty: 2
        - id: v6
          title: Build Args
          description: >-
            A CLI tool builds its argument list dynamically. Write <code>func buildArgs(cmd string, flags
            []string) []string</code> that creates a slice starting with cmd and appends all flags.
          functionSignature: func buildArgs(cmd string, flags []string) []string
          testCases:
            - input: "\"git\", []string{\"-v\", \"--all\"}"
              output: "[]string{\"git\", \"-v\", \"--all\"}"
            - input: "\"go\", []string{\"build\", \"-o\", \"app\"}"
              output: "[]string{\"go\", \"build\", \"-o\", \"app\"}"
          hints:
            - title: ðŸ¤” Think about it
              content: >-
                You need a slice that starts with one element and then has all elements from another slice
                appended. How do you combine a single value with a slice?
            - title: ðŸ’¡ Hint
              content: >-
                Create a slice with cmd as the first element: []string{cmd}. Then use append with the ...
                operator to spread the flags slice into it.
            - title: ðŸ”§ Pattern
              content: |-
                <pre>1. result := []string{cmd}
                2. result = append(result, flags...)
                3. Return result</pre>
          solution: |-
            func buildArgs(cmd string, flags []string) []string {
                result := []string{cmd}
                result = append(result, flags...)
                return result
            }
          difficulty: 2
        - id: v7
          title: Collect Errors
          description: >-
            A log collector gathers error lines from output. Write <code>func collectErrors(lines []string,
            prefix string) []string</code> that returns a new slice containing only lines that start with the
            given prefix.
          functionSignature: func collectErrors(lines []string, prefix string) []string
          testCases:
            - input: "[]string{\"ERROR: disk full\", \"INFO: ok\", \"ERROR: timeout\"}, \"ERROR\""
              output: "[]string{\"ERROR: disk full\", \"ERROR: timeout\"}"
            - input: "[]string{\"WARN: slow\", \"INFO: done\"}, \"ERROR\""
              output: "[]string{}"
          hints:
            - title: ðŸ¤” Think about it
              content: >-
                You need to check whether each string begins with a certain prefix. The strings package has a
                function for this.
            - title: ðŸ’¡ Hint
              content: >-
                Import "strings" and use strings.HasPrefix(line, prefix) to test each line. Append matching
                lines to the result.
            - title: ðŸ”§ Pattern
              content: |-
                <pre>1. result := []string{}
                2. For each line in lines:
                   - If strings.HasPrefix(line, prefix):
                     - result = append(result, line)
                3. Return result</pre>
          solution: |-
            func collectErrors(lines []string, prefix string) []string {
                result := []string{}
                for _, line := range lines {
                    if strings.HasPrefix(line, prefix) {
                        result = append(result, line)
                    }
                }
                return result
            }
          difficulty: 2
        - id: v8
          title: Powers of Two
          description: >-
            A memory allocator needs a table of power-of-two sizes. Write <code>func powersOfTwo(n int)
            []int</code> that returns a slice containing [1, 2, 4, 8, ...] with n elements.
          functionSignature: func powersOfTwo(n int) []int
          testCases:
            - input: "4"
              output: "[]int{1, 2, 4, 8}"
            - input: "6"
              output: "[]int{1, 2, 4, 8, 16, 32}"
          hints:
            - title: ðŸ¤” Think about it
              content: >-
                Each element is double the previous one. You can track the current value and double it each
                iteration, or compute it directly.
            - title: ðŸ’¡ Hint
              content: >-
                Start with val := 1. In each of n iterations, append val then set val *= 2. Alternatively,
                append 1 << i for i from 0 to n-1.
            - title: ðŸ”§ Pattern
              content: |-
                <pre>1. result := []int{}
                2. val := 1
                3. For i := 0 to n:
                   - result = append(result, val)
                   - val *= 2
                4. Return result</pre>
          solution: |-
            func powersOfTwo(n int) []int {
                result := []int{}
                val := 1
                for i := 0; i < n; i++ {
                    result = append(result, val)
                    val *= 2
                }
                return result
            }
          difficulty: 2
        - id: v9
          title: Countdown Sequence
          description: >-
            A deployment system builds a countdown sequence. Write <code>func countdown(start int)
            []int</code> that returns a slice counting down from start to 1.
          functionSignature: func countdown(start int) []int
          testCases:
            - input: "5"
              output: "[]int{5, 4, 3, 2, 1}"
            - input: "3"
              output: "[]int{3, 2, 1}"
          hints:
            - title: ðŸ¤” Think about it
              content: >-
                You need a decreasing sequence. Use a for loop that starts high and counts down, appending
                each value.
            - title: ðŸ’¡ Hint
              content: Loop from start down to 1 using for i := start; i >= 1; i-- and append each i to the result.
            - title: ðŸ”§ Pattern
              content: |-
                <pre>1. result := []int{}
                2. For i := start down to 1:
                   - result = append(result, i)
                3. Return result</pre>
          solution: |-
            func countdown(start int) []int {
                result := []int{}
                for i := start; i >= 1; i-- {
                    result = append(result, i)
                }
                return result
            }
          difficulty: 2
        - id: v10
          title: Merge Sorted
          description: >-
            A search engine merges two sorted result lists. Write <code>func mergeSorted(a, b []int)
            []int</code> that merges two already-sorted ascending slices into one sorted slice.
          functionSignature: func mergeSorted(a, b []int) []int
          testCases:
            - input: "[]int{1, 3, 5}, []int{2, 4, 6}"
              output: "[]int{1, 2, 3, 4, 5, 6}"
            - input: "[]int{1, 4}, []int{2, 3, 5}"
              output: "[]int{1, 2, 3, 4, 5}"
          hints:
            - title: ðŸ¤” Think about it
              content: >-
                Both slices are already sorted. Use two pointers, one for each slice, and always pick the
                smaller element next. When one slice is exhausted, append the rest of the other.
            - title: ðŸ’¡ Hint
              content: >-
                Maintain indices i and j. While both are in bounds, compare a[i] and b[j] and append the
                smaller. After the loop, append any remaining elements from both slices using the ...
                operator.
            - title: ðŸ”§ Pattern
              content: |-
                <pre>1. result := []int{}, i := 0, j := 0
                2. While i < len(a) AND j < len(b):
                   - If a[i] <= b[j]: append a[i], i++
                   - Else: append b[j], j++
                3. Append a[i:]... and b[j:]...
                4. Return result</pre>
          solution: |-
            func mergeSorted(a, b []int) []int {
                result := []int{}
                i, j := 0, 0
                for i < len(a) && j < len(b) {
                    if a[i] <= b[j] {
                        result = append(result, a[i])
                        i++
                    } else {
                        result = append(result, b[j])
                        j++
                    }
                }
                result = append(result, a[i:]...)
                result = append(result, b[j:]...)
                return result
            }
          difficulty: 3
        - id: v11
          title: Deduplicate Sorted
          description: >-
            A database index removes duplicate keys from a sorted list. Write <code>func dedup(sorted []int)
            []int</code> that returns a new slice with consecutive duplicates removed from an already-sorted
            input.
          functionSignature: func dedup(sorted []int) []int
          testCases:
            - input: "[]int{1, 1, 2, 3, 3, 3, 4}"
              output: "[]int{1, 2, 3, 4}"
            - input: "[]int{5, 5, 5}"
              output: "[]int{5}"
          hints:
            - title: ðŸ¤” Think about it
              content: >-
                Because the input is sorted, duplicates are always adjacent. You only need to compare each
                element with the previous one. If they differ, include the current element.
            - title: ðŸ’¡ Hint
              content: >-
                Always include the first element. Then loop from index 1 onward, appending only when sorted[i]
                != sorted[i-1].
            - title: ðŸ”§ Pattern
              content: |-
                <pre>1. If len(sorted) == 0: return []int{}
                2. result := []int{sorted[0]}
                3. For i := 1 to len(sorted):
                   - If sorted[i] != sorted[i-1]:
                     - result = append(result, sorted[i])
                4. Return result</pre>
          solution: |-
            func dedup(sorted []int) []int {
                if len(sorted) == 0 {
                    return []int{}
                }
                result := []int{sorted[0]}
                for i := 1; i < len(sorted); i++ {
                    if sorted[i] != sorted[i-1] {
                        result = append(result, sorted[i])
                    }
                }
                return result
            }
          difficulty: 3
        - id: v12
          title: Zip Pairs
          description: >-
            A config loader pairs keys with values. Write <code>func zip(keys []string, vals []string)
            []string</code> that returns a slice of "key=val" pairs. If the slices have different lengths,
            stop at the shorter one.
          functionSignature: func zip(keys []string, vals []string) []string
          testCases:
            - input: "[]string{\"host\", \"port\"}, []string{\"localhost\", \"8080\"}"
              output: "[]string{\"host=localhost\", \"port=8080\"}"
            - input: "[]string{\"a\", \"b\", \"c\"}, []string{\"1\", \"2\"}"
              output: "[]string{\"a=1\", \"b=2\"}"
          hints:
            - title: ðŸ¤” Think about it
              content: >-
                You need to iterate through both slices simultaneously and combine corresponding elements.
                First determine which slice is shorter so you don't go out of bounds.
            - title: ðŸ’¡ Hint
              content: >-
                Find the minimum of len(keys) and len(vals). Loop up to that count, and for each index format
                keys[i] + "=" + vals[i].
            - title: ðŸ”§ Pattern
              content: |-
                <pre>1. n := min(len(keys), len(vals))
                2. result := []string{}
                3. For i := 0 to n:
                   - result = append(result, keys[i]+"="+vals[i])
                4. Return result</pre>
          solution: |-
            func zip(keys []string, vals []string) []string {
                n := len(keys)
                if len(vals) < n {
                    n = len(vals)
                }
                result := []string{}
                for i := 0; i < n; i++ {
                    result = append(result, keys[i]+"="+vals[i])
                }
                return result
            }
          difficulty: 3
        - id: v13
          title: Group Consecutive
          description: >-
            A log analyzer groups consecutive identical status codes. Write <code>func groupConsecutive(nums
            []int) [][]int</code> that splits a slice into groups of consecutive equal values. For example,
            [1,1,2,2,2,3] becomes [[1,1],[2,2,2],[3]].
          functionSignature: func groupConsecutive(nums []int) [][]int
          testCases:
            - input: "[]int{1, 1, 2, 2, 2, 3}"
              output: "[][]int{{1, 1}, {2, 2, 2}, {3}}"
            - input: "[]int{5, 5, 5}"
              output: "[][]int{{5, 5, 5}}"
          hints:
            - title: ðŸ¤” Think about it
              content: >-
                Walk through the slice and start a new group whenever the current element differs from the
                previous one. Keep building the current group otherwise.
            - title: ðŸ’¡ Hint
              content: >-
                Start with a current group containing the first element. For each subsequent element, if it
                equals the last element of the current group, append to it. Otherwise, save the current group
                to the result and start a new one.
            - title: ðŸ”§ Pattern
              content: |-
                <pre>1. If len(nums) == 0: return [][]int{}
                2. current := []int{nums[0]}
                3. result := [][]int{}
                4. For i := 1 to len(nums):
                   - If nums[i] == nums[i-1]: append to current
                   - Else: append current to result, start new current
                5. Append final current to result
                6. Return result</pre>
          solution: |-
            func groupConsecutive(nums []int) [][]int {
                if len(nums) == 0 {
                    return [][]int{}
                }
                result := [][]int{}
                current := []int{nums[0]}
                for i := 1; i < len(nums); i++ {
                    if nums[i] == nums[i-1] {
                        current = append(current, nums[i])
                    } else {
                        result = append(result, current)
                        current = []int{nums[i]}
                    }
                }
                result = append(result, current)
                return result
            }
          difficulty: 3
    - id: challenge_8
      block: 1
      difficulty: 2
      concept: "Slice Operations"
      docLinks:
        - url: https://go.dev/blog/slices-intro
          title: "Go Blog: Go Slices usage"
          note: slicing syntax
        - url: https://go.dev/ref/spec#Slice_expressions
          title: "Go Spec: Slice expressions"
          note: s[low:high]
      patternPrimer:
        bruteForce: Manually copy elements one by one into new slices.
        bestApproach: Use Go's slice expressions s[a:b] for clean sub-slice extraction; use copy() for safe duplication.
        typical: Slice expressions are O(1) (shared backing array); copy is O(n).
      variants:
        - id: v1
          title: First N Elements
          description: >-
            A dashboard shows the top results from a search. Write <code>func firstN(nums []int, n int)
            []int</code> that returns the first n elements of the slice.
          functionSignature: func firstN(nums []int, n int) []int
          testCases:
            - input: "[]int{1, 2, 3, 4, 5}, 3"
              output: "[]int{1, 2, 3}"
            - input: "[]int{10, 20, 30}, 2"
              output: "[]int{10, 20}"
          hints:
            - title: ðŸ¤” Think about it
              content: >-
                Go's slice syntax lets you take a portion of a slice by specifying a range. How do you express
                "from the beginning up to n elements"?
            - title: ðŸ’¡ Hint
              content: >-
                Use the slice expression nums[:n] which takes elements from index 0 up to (but not including)
                index n.
            - title: ðŸ”§ Pattern
              content: <pre>1. Return nums[:n]</pre>
          solution: |-
            func firstN(nums []int, n int) []int {
                return nums[:n]
            }
          difficulty: 1
        - id: v2
          title: Last N Elements
          description: >-
            A build system needs the most recent log entries. Write <code>func lastN(nums []int, n int)
            []int</code> that returns the last n elements of the slice.
          functionSignature: func lastN(nums []int, n int) []int
          testCases:
            - input: "[]int{1, 2, 3, 4, 5}, 2"
              output: "[]int{4, 5}"
            - input: "[]int{10, 20, 30}, 1"
              output: "[]int{30}"
          hints:
            - title: ðŸ¤” Think about it
              content: >-
                To get the last n elements, you need to figure out the starting index. If the slice has 5
                elements and you want the last 2, where do you start?
            - title: ðŸ’¡ Hint
              content: The starting index is len(nums) - n. Use nums[len(nums)-n:] to get from that point to the end.
            - title: ðŸ”§ Pattern
              content: <pre>1. Return nums[len(nums)-n:]</pre>
          solution: |-
            func lastN(nums []int, n int) []int {
                return nums[len(nums)-n:]
            }
          difficulty: 1
        - id: v3
          title: Slice Length
          description: >-
            A queue monitor reports how many items remain. Write <code>func countItems(items []string)
            int</code> that returns the number of elements in the slice.
          functionSignature: func countItems(items []string) int
          testCases:
            - input: "[]string{\"a\", \"b\", \"c\"}"
              output: "3"
            - input: "[]string{}"
              output: "0"
          hints:
            - title: ðŸ¤” Think about it
              content: Go has a built-in function that returns the number of elements in a slice. What is it?
            - title: ðŸ’¡ Hint
              content: Use the built-in len() function to get the length of the slice.
            - title: ðŸ”§ Pattern
              content: <pre>1. Return len(items)</pre>
          solution: |-
            func countItems(items []string) int {
                return len(items)
            }
          difficulty: 1
        - id: v4
          title: Drop Prefix
          description: >-
            A file parser skips header lines. Write <code>func dropFirst(nums []int) []int</code> that returns
            the slice without the first element.
          functionSignature: func dropFirst(nums []int) []int
          testCases:
            - input: "[]int{1, 2, 3}"
              output: "[]int{2, 3}"
            - input: "[]int{10, 20}"
              output: "[]int{20}"
          hints:
            - title: ðŸ¤” Think about it
              content: >-
                Removing the first element means keeping everything from index 1 onward. What slice expression
                does this?
            - title: ðŸ’¡ Hint
              content: Use nums[1:] to get everything starting from index 1.
            - title: ðŸ”§ Pattern
              content: <pre>1. Return nums[1:]</pre>
          solution: |-
            func dropFirst(nums []int) []int {
                return nums[1:]
            }
          difficulty: 1
        - id: v5
          title: Middle Element
          description: >-
            A statistics module extracts the median from a sorted odd-length dataset. Write <code>func
            middle(nums []int) int</code> that returns the middle element of a slice with an odd number of
            elements.
          functionSignature: func middle(nums []int) int
          testCases:
            - input: "[]int{1, 2, 3, 4, 5}"
              output: "3"
            - input: "[]int{10, 20, 30}"
              output: "20"
          hints:
            - title: ðŸ¤” Think about it
              content: >-
                For a slice of length 5, the middle element is at index 2. For length 3, it is at index 1.
                What is the formula?
            - title: ðŸ’¡ Hint
              content: >-
                The middle index is len(nums) / 2. Integer division automatically rounds down, which gives the
                correct middle for odd-length slices.
            - title: ðŸ”§ Pattern
              content: <pre>1. Return nums[len(nums)/2]</pre>
          solution: |-
            func middle(nums []int) int {
                return nums[len(nums)/2]
            }
          difficulty: 2
        - id: v6
          title: Reverse Copy
          description: >-
            A stack debugger displays items bottom-to-top. Write <code>func reverseCopy(nums []int)
            []int</code> that returns a new reversed slice without modifying the original.
          functionSignature: func reverseCopy(nums []int) []int
          testCases:
            - input: "[]int{1, 2, 3, 4}"
              output: "[]int{4, 3, 2, 1}"
            - input: "[]int{5, 10}"
              output: "[]int{10, 5}"
          hints:
            - title: ðŸ¤” Think about it
              content: >-
                You need to create a new slice where the first element of the original becomes the last, and
                vice versa. How do you map from the original index to the reversed index?
            - title: ðŸ’¡ Hint
              content: >-
                Create a new slice with make(). For each element at index i, place it at position
                len(nums)-1-i in the result.
            - title: ðŸ”§ Pattern
              content: |-
                <pre>1. result := make([]int, len(nums))
                2. For i, v := range nums:
                   - result[len(nums)-1-i] = v
                3. Return result</pre>
          solution: |-
            func reverseCopy(nums []int) []int {
                result := make([]int, len(nums))
                for i, v := range nums {
                    result[len(nums)-1-i] = v
                }
                return result
            }
          difficulty: 2
        - id: v7
          title: Rotate Left
          description: >-
            A task queue rotates priority. Write <code>func rotateLeft(nums []int, k int) []int</code> that
            rotates the slice left by k positions.
          functionSignature: func rotateLeft(nums []int, k int) []int
          testCases:
            - input: "[]int{1, 2, 3, 4, 5}, 2"
              output: "[]int{3, 4, 5, 1, 2}"
            - input: "[]int{10, 20, 30}, 1"
              output: "[]int{20, 30, 10}"
          hints:
            - title: ðŸ¤” Think about it
              content: >-
                Rotating left by k means the first k elements move to the end. Can you split the slice into
                two parts and recombine?
            - title: ðŸ’¡ Hint
              content: >-
                Split at position k: take nums[k:] and nums[:k]. Combine them with append. Use k % len(nums)
                to handle k larger than the slice length.
            - title: ðŸ”§ Pattern
              content: |-
                <pre>1. k = k % len(nums)
                2. Return append(nums[k:], nums[:k]...)</pre>
          solution: |-
            func rotateLeft(nums []int, k int) []int {
                k = k % len(nums)
                return append(nums[k:], nums[:k]...)
            }
          difficulty: 2
        - id: v8
          title: Split At Index
          description: >-
            A load balancer divides work between two workers. Write <code>func splitAt(nums []int, index int)
            ([]int, []int)</code> that splits the slice into two parts at the given index.
          functionSignature: func splitAt(nums []int, index int) ([]int, []int)
          testCases:
            - input: "[]int{1, 2, 3, 4, 5}, 3"
              output: "[]int{1, 2, 3}, []int{4, 5}"
            - input: "[]int{10, 20, 30}, 1"
              output: "[]int{10}, []int{20, 30}"
          hints:
            - title: ðŸ¤” Think about it
              content: >-
                Splitting at an index means everything before that index goes into the first part, and
                everything from that index onward goes into the second part.
            - title: ðŸ’¡ Hint
              content: Use nums[:index] for the first part and nums[index:] for the second. Return both.
            - title: ðŸ”§ Pattern
              content: <pre>1. Return nums[:index], nums[index:]</pre>
          solution: |-
            func splitAt(nums []int, index int) ([]int, []int) {
                return nums[:index], nums[index:]
            }
          difficulty: 2
        - id: v9
          title: Contains Value
          description: >-
            A permission checker tests whether a user has a required role. Write <code>func contains(items
            []string, target string) bool</code> that checks if the target value exists in the slice.
          functionSignature: func contains(items []string, target string) bool
          testCases:
            - input: "[]string{\"admin\", \"editor\", \"viewer\"}, \"editor\""
              output: "true"
            - input: "[]string{\"admin\", \"editor\"}, \"owner\""
              output: "false"
          hints:
            - title: ðŸ¤” Think about it
              content: >-
                You need to scan through the slice looking for a match. What do you return if you find it?
                What if you reach the end without finding it?
            - title: ðŸ’¡ Hint
              content: >-
                Loop through and compare each element to target. Return true immediately when found. After the
                loop, return false.
            - title: ðŸ”§ Pattern
              content: |-
                <pre>1. For each item in items:
                   - If item == target: return true
                2. Return false</pre>
          solution: |-
            func contains(items []string, target string) bool {
                for _, item := range items {
                    if item == target {
                        return true
                    }
                }
                return false
            }
          difficulty: 2
        - id: v10
          title: Remove At Index
          description: >-
            A playlist editor lets users delete a track by position. Write <code>func removeAt(nums []int,
            index int) []int</code> that returns a new slice with the element at the given index removed.
          functionSignature: func removeAt(nums []int, index int) []int
          testCases:
            - input: "[]int{1, 2, 3, 4}, 2"
              output: "[]int{1, 2, 4}"
            - input: "[]int{10, 20, 30}, 0"
              output: "[]int{20, 30}"
          hints:
            - title: ðŸ¤” Think about it
              content: >-
                You need to combine the part before the index with the part after the index, skipping the
                element at that position. Be careful not to modify the original slice.
            - title: ðŸ’¡ Hint
              content: >-
                Create a new slice. Append everything before the index, then append everything after the
                index. Use the ... spread operator with append.
            - title: ðŸ”§ Pattern
              content: |-
                <pre>1. result := make([]int, 0, len(nums)-1)
                2. result = append(result, nums[:index]...)
                3. result = append(result, nums[index+1:]...)
                4. Return result</pre>
          solution: |-
            func removeAt(nums []int, index int) []int {
                result := make([]int, 0, len(nums)-1)
                result = append(result, nums[:index]...)
                result = append(result, nums[index+1:]...)
                return result
            }
          difficulty: 3
        - id: v11
          title: Insert At Index
          description: >-
            A sorted list needs a new entry placed at the correct position. Write <code>func insertAt(nums
            []int, index, value int) []int</code> that returns a new slice with the value inserted at the
            given index.
          functionSignature: func insertAt(nums []int, index, value int) []int
          testCases:
            - input: "[]int{1, 2, 4, 5}, 2, 3"
              output: "[]int{1, 2, 3, 4, 5}"
            - input: "[]int{10, 30}, 1, 20"
              output: "[]int{10, 20, 30}"
          hints:
            - title: ðŸ¤” Think about it
              content: >-
                Inserting means you take everything before the index, add the new value, then add everything
                from the index onward. The result is one element longer.
            - title: ðŸ’¡ Hint
              content: >-
                Build a new slice: append nums[:index], then the value, then nums[index:]. Use the ... spread
                operator for the slice parts.
            - title: ðŸ”§ Pattern
              content: |-
                <pre>1. result := make([]int, 0, len(nums)+1)
                2. result = append(result, nums[:index]...)
                3. result = append(result, value)
                4. result = append(result, nums[index:]...)
                5. Return result</pre>
          solution: |-
            func insertAt(nums []int, index, value int) []int {
                result := make([]int, 0, len(nums)+1)
                result = append(result, nums[:index]...)
                result = append(result, value)
                result = append(result, nums[index:]...)
                return result
            }
          difficulty: 3
        - id: v12
          title: Chunk Slice
          description: >-
            A batch processor splits work into fixed-size chunks. Write <code>func chunk(nums []int, size int)
            [][]int</code> that splits the slice into chunks of the given size. The last chunk may be smaller.
          functionSignature: func chunk(nums []int, size int) [][]int
          testCases:
            - input: "[]int{1, 2, 3, 4, 5}, 2"
              output: "[][]int{{1, 2}, {3, 4}, {5}}"
            - input: "[]int{1, 2, 3, 4}, 2"
              output: "[][]int{{1, 2}, {3, 4}}"
          hints:
            - title: ðŸ¤” Think about it
              content: >-
                You need to walk through the slice in steps of the given size, taking a sub-slice each time.
                What happens when the remaining elements are fewer than the chunk size?
            - title: ðŸ’¡ Hint
              content: >-
                Use a for loop that increments by size. For each step, calculate the end index as i + size,
                but cap it at len(nums) to avoid going out of bounds.
            - title: ðŸ”§ Pattern
              content: |-
                <pre>1. result := [][]int{}
                2. For i := 0; i < len(nums); i += size:
                   - end := i + size
                   - If end > len(nums): end = len(nums)
                   - result = append(result, nums[i:end])
                3. Return result</pre>
          solution: |-
            func chunk(nums []int, size int) [][]int {
                result := [][]int{}
                for i := 0; i < len(nums); i += size {
                    end := i + size
                    if end > len(nums) {
                        end = len(nums)
                    }
                    result = append(result, nums[i:end])
                }
                return result
            }
          difficulty: 3
        - id: v13
          title: Sliding Window Max
          description: >-
            A performance monitor tracks peak values over a sliding window. Write <code>func windowMax(nums
            []int, size int) []int</code> that returns the maximum value in each sliding window of the given
            size.
          functionSignature: func windowMax(nums []int, size int) []int
          testCases:
            - input: "[]int{1, 3, 2, 5, 4}, 3"
              output: "[]int{3, 5, 5}"
            - input: "[]int{4, 1, 3, 2}, 2"
              output: "[]int{4, 3, 3}"
          hints:
            - title: ðŸ¤” Think about it
              content: >-
                A sliding window of size k over a slice produces len(nums) - k + 1 windows. For each window,
                you need to find the maximum element. Think about how to scan a sub-slice for the max.
            - title: ðŸ’¡ Hint
              content: >-
                For each starting position i from 0 to len(nums)-size, scan the sub-slice nums[i:i+size] to
                find the maximum. Use a nested loop or initialize max to nums[i] and compare each element.
            - title: ðŸ”§ Pattern
              content: |-
                <pre>1. result := []int{}
                2. For i := 0; i <= len(nums)-size; i++:
                   - max := nums[i]
                   - For j := i+1; j < i+size; j++:
                     - If nums[j] > max: max = nums[j]
                   - result = append(result, max)
                3. Return result</pre>
          solution: |-
            func windowMax(nums []int, size int) []int {
                result := []int{}
                for i := 0; i <= len(nums)-size; i++ {
                    max := nums[i]
                    for j := i + 1; j < i+size; j++ {
                        if nums[j] > max {
                            max = nums[j]
                        }
                    }
                    result = append(result, max)
                }
                return result
            }
          difficulty: 3
    - id: challenge_9
      block: 1
      difficulty: 1
      concept: "For Loops"
      docLinks:
        - url: https://go.dev/tour/flowcontrol/1
          title: "Go Tour: For"
          note: the only loop in Go
        - url: https://go.dev/ref/spec#For_statements
          title: "Go Spec: For statements"
          note: three forms
      patternPrimer:
        bruteForce: Write separate loops for each variant of iteration.
        bestApproach: "Go has one loop keyword \u2014 for \u2014 with three forms: C-style, while-style, and infinite + break."
        typical: Most loops are O(n) \u2014 choose the right form for clarity.
      variants:
        - id: v1
          title: Sum a Range
          description: >-
            A budget calculator needs to total up monthly expenses. Write <code>func sumRange(start, end int)
            int</code> that returns the sum of all integers from start to end (inclusive) using a for loop.
          functionSignature: func sumRange(start, end int) int
          testCases:
            - input: 1, 5
              output: "15"
            - input: 3, 7
              output: "25"
          hints:
            - title: ðŸ¤” Think about it
              content: >-
                You need to add every integer from start up to end. What kind of loop counts from one value to
                another?
            - title: ðŸ’¡ Hint
              content: >-
                Use a C-style for loop: for i := start; i <= end; i++. Keep a running total and add each i to
                it.
            - title: ðŸ”§ Pattern
              content: |-
                <pre>1. total := 0
                2. for i := start; i <= end; i++:
                   - total += i
                3. return total</pre>
          solution: |-
            func sumRange(start, end int) int {
                total := 0
                for i := start; i <= end; i++ {
                    total += i
                }
                return total
            }
          difficulty: 1
        - id: v2
          title: Repeat String
          description: >-
            A template engine needs to repeat placeholder text. Write <code>func repeatStr(s string, n int)
            string</code> that returns the string s repeated n times using a for loop.
          functionSignature: func repeatStr(s string, n int) string
          testCases:
            - input: "\"ab\", 3"
              output: "\"ababab\""
            - input: "\"x\", 5"
              output: "\"xxxxx\""
            - input: "\"hi\", 0"
              output: "\"\""
          hints:
            - title: ðŸ¤” Think about it
              content: >-
                You need to concatenate a string to itself n times. What is the simplest loop that runs
                exactly n iterations?
            - title: ðŸ’¡ Hint
              content: Start with result := "". Use for i := 0; i < n; i++ and append s to result each iteration.
            - title: ðŸ”§ Pattern
              content: |-
                <pre>1. result := ""
                2. for i := 0; i < n; i++:
                   - result += s
                3. return result</pre>
          solution: |-
            func repeatStr(s string, n int) string {
                result := ""
                for i := 0; i < n; i++ {
                    result += s
                }
                return result
            }
          difficulty: 1
        - id: v3
          title: Generate Step IDs
          description: >-
            A build system generates step identifiers. Write <code>func stepIDs(prefix string, count int)
            []string</code> that returns a slice like ["prefix-1", "prefix-2", ...] up to count, using a for
            loop.
          functionSignature: func stepIDs(prefix string, count int) []string
          testCases:
            - input: "\"build\", 3"
              output: "[]string{\"build-1\", \"build-2\", \"build-3\"}"
            - input: "\"step\", 1"
              output: "[]string{\"step-1\"}"
          hints:
            - title: ðŸ¤” Think about it
              content: >-
                You need to create count strings, each combining a prefix with a number. How do you format an
                integer into a string in Go?
            - title: ðŸ’¡ Hint
              content: >-
                Use fmt.Sprintf("%s-%d", prefix, i) inside a for loop from 1 to count. Append each result to a
                slice.
            - title: ðŸ”§ Pattern
              content: |-
                <pre>1. result := []string{}
                2. for i := 1; i <= count; i++:
                   - append fmt.Sprintf("%s-%d", prefix, i) to result
                3. return result</pre>
          solution: |-
            func stepIDs(prefix string, count int) []string {
                result := []string{}
                for i := 1; i <= count; i++ {
                    result = append(result, fmt.Sprintf("%s-%d", prefix, i))
                }
                return result
            }
          difficulty: 1
        - id: v4
          title: Triangular Number
          description: >-
            A bowling alley app calculates how many pins are in a triangle of n rows. Write <code>func
            triangular(n int) int</code> that returns 1 + 2 + 3 + ... + n using a for loop.
          functionSignature: func triangular(n int) int
          testCases:
            - input: "4"
              output: "10"
            - input: "1"
              output: "1"
            - input: "0"
              output: "0"
          hints:
            - title: ðŸ¤” Think about it
              content: >-
                The triangular number for n is the sum of all integers from 1 to n. What accumulator pattern
                adds each number in a loop?
            - title: ðŸ’¡ Hint
              content: Initialize sum := 0. Loop for i := 1; i <= n; i++ and add i to sum each time.
            - title: ðŸ”§ Pattern
              content: |-
                <pre>1. sum := 0
                2. for i := 1; i <= n; i++:
                   - sum += i
                3. return sum</pre>
          solution: |-
            func triangular(n int) int {
                sum := 0
                for i := 1; i <= n; i++ {
                    sum += i
                }
                return sum
            }
          difficulty: 1
        - id: v5
          title: Count Evens in Range
          description: >-
            A scheduling tool counts available even-numbered time slots. Write <code>func countEvens(low, high
            int) int</code> that counts how many even numbers exist between low and high (inclusive) using a
            for loop.
          functionSignature: func countEvens(low, high int) int
          testCases:
            - input: 1, 10
              output: "5"
            - input: 2, 2
              output: "1"
            - input: 1, 1
              output: "0"
          hints:
            - title: ðŸ¤” Think about it
              content: >-
                Loop through every number in the range and check a condition. What operator tells you if a
                number is even?
            - title: ðŸ’¡ Hint
              content: >-
                Use for i := low; i <= high; i++. Inside the loop, check if i % 2 == 0 and increment a counter
                when it is.
            - title: ðŸ”§ Pattern
              content: |-
                <pre>1. count := 0
                2. for i := low; i <= high; i++:
                   - if i % 2 == 0: count++
                3. return count</pre>
          solution: |-
            func countEvens(low, high int) int {
                count := 0
                for i := low; i <= high; i++ {
                    if i%2 == 0 {
                        count++
                    }
                }
                return count
            }
          difficulty: 2
        - id: v6
          title: Exponential Backoff
          description: >-
            A deployment script retries failed requests with exponential backoff. Write <code>func
            retryDelay(attempt int) int</code> that computes 2 raised to the power of attempt using a for loop
            (not math.Pow). Return the result in milliseconds.
          functionSignature: func retryDelay(attempt int) int
          testCases:
            - input: "0"
              output: "1"
            - input: "3"
              output: "8"
            - input: "10"
              output: "1024"
          hints:
            - title: ðŸ¤” Think about it
              content: >-
                Exponentiation is repeated multiplication. You start with 1 and multiply by 2 a certain number
                of times. How many times should the loop run?
            - title: ðŸ’¡ Hint
              content: Start result := 1. Loop for i := 0; i < attempt; i++ and multiply result by 2 each time.
            - title: ðŸ”§ Pattern
              content: |-
                <pre>1. result := 1
                2. for i := 0; i < attempt; i++:
                   - result *= 2
                3. return result</pre>
          solution: |-
            func retryDelay(attempt int) int {
                result := 1
                for i := 0; i < attempt; i++ {
                    result *= 2
                }
                return result
            }
          difficulty: 2
        - id: v7
          title: Sum of Multiples
          description: >-
            A billing system totals charges that are multiples of a base fee. Write <code>func sumMultiples(n,
            divisor int) int</code> that returns the sum of all multiples of divisor between 1 and n
            (inclusive) using a for loop.
          functionSignature: func sumMultiples(n, divisor int) int
          testCases:
            - input: 10, 3
              output: "18"
            - input: 15, 5
              output: "45"
            - input: 7, 10
              output: "0"
          hints:
            - title: ðŸ¤” Think about it
              content: >-
                Loop from 1 to n and test each number for divisibility. What operator checks if a number
                divides evenly?
            - title: ðŸ’¡ Hint
              content: Use for i := 1; i <= n; i++. Check if i % divisor == 0 and add i to a running sum when it is.
            - title: ðŸ”§ Pattern
              content: |-
                <pre>1. sum := 0
                2. for i := 1; i <= n; i++:
                   - if i % divisor == 0: sum += i
                3. return sum</pre>
          solution: |-
            func sumMultiples(n, divisor int) int {
                sum := 0
                for i := 1; i <= n; i++ {
                    if i%divisor == 0 {
                        sum += i
                    }
                }
                return sum
            }
          difficulty: 2
        - id: v8
          title: FizzBuzz Count
          description: >-
            A code review tool scores FizzBuzz outputs. Write <code>func fizzBuzzCount(n int) int</code> that
            counts how many numbers from 1 to n are divisible by 3 or 5 (or both) using a for loop.
          functionSignature: func fizzBuzzCount(n int) int
          testCases:
            - input: "15"
              output: "7"
            - input: "5"
              output: "2"
            - input: "2"
              output: "0"
          hints:
            - title: ðŸ¤” Think about it
              content: >-
                Loop from 1 to n and check two divisibility conditions. How do you combine conditions with a
                logical OR in Go?
            - title: ðŸ’¡ Hint
              content: Use for i := 1; i <= n; i++. Check if i%3 == 0 || i%5 == 0. If true, increment a counter.
            - title: ðŸ”§ Pattern
              content: |-
                <pre>1. count := 0
                2. for i := 1; i <= n; i++:
                   - if i%3 == 0 || i%5 == 0: count++
                3. return count</pre>
          solution: |-
            func fizzBuzzCount(n int) int {
                count := 0
                for i := 1; i <= n; i++ {
                    if i%3 == 0 || i%5 == 0 {
                        count++
                    }
                }
                return count
            }
          difficulty: 2
        - id: v9
          title: Digit Product
          description: >-
            A serial number validator multiplies digits together. Write <code>func digitProduct(n int)
            int</code> that returns the product of all digits of n using a while-style for loop. If n is 0,
            return 0.
          functionSignature: func digitProduct(n int) int
          testCases:
            - input: "234"
              output: "24"
            - input: "105"
              output: "0"
            - input: "0"
              output: "0"
          hints:
            - title: ðŸ¤” Think about it
              content: >-
                Extract each digit with n % 10 and remove it with n / 10. What should the initial accumulator
                value be for multiplication?
            - title: ðŸ’¡ Hint
              content: >-
                Handle n == 0 first. Then start with product := 1 and use for n > 0. Each iteration, multiply
                product by n%10, then n /= 10.
            - title: ðŸ”§ Pattern
              content: |-
                <pre>1. if n == 0: return 0
                2. product := 1
                3. for n > 0:
                   - product *= n % 10
                   - n /= 10
                4. return product</pre>
          solution: |-
            func digitProduct(n int) int {
                if n == 0 {
                    return 0
                }
                product := 1
                for n > 0 {
                    product *= n % 10
                    n /= 10
                }
                return product
            }
          difficulty: 2
        - id: v10
          title: Reverse Integer
          description: >-
            A data pipeline needs to reverse numeric IDs for deduplication hashing. Write <code>func
            reverseInt(n int) int</code> that reverses the digits of a non-negative integer using a for loop.
            For example, 1234 becomes 4321.
          functionSignature: func reverseInt(n int) int
          testCases:
            - input: "1234"
              output: "4321"
            - input: "100"
              output: "1"
            - input: "0"
              output: "0"
          hints:
            - title: ðŸ¤” Think about it
              content: >-
                To reverse digits, you extract the last digit and build a new number from left to right. Each
                time you add a digit, you need to shift the existing result. What arithmetic operation shifts
                a decimal number left by one place?
            - title: ðŸ’¡ Hint
              content: >-
                Use for n > 0. Each iteration: reversed = reversed*10 + n%10, then n /= 10. This peels digits
                off the right and appends them to the new number.
            - title: ðŸ”§ Pattern
              content: |-
                <pre>1. reversed := 0
                2. for n > 0:
                   - reversed = reversed*10 + n%10
                   - n /= 10
                3. return reversed</pre>
          solution: |-
            func reverseInt(n int) int {
                reversed := 0
                for n > 0 {
                    reversed = reversed*10 + n%10
                    n /= 10
                }
                return reversed
            }
          difficulty: 3
        - id: v11
          title: Build Fibonacci Slice
          description: >-
            A simulation engine generates Fibonacci sequences for modeling growth patterns. Write <code>func
            fibonacci(n int) []int</code> that returns the first n Fibonacci numbers starting with 0, 1, 1, 2,
            3, ... using a for loop.
          functionSignature: func fibonacci(n int) []int
          testCases:
            - input: "6"
              output: "[]int{0, 1, 1, 2, 3, 5}"
            - input: "1"
              output: "[]int{0}"
            - input: "2"
              output: "[]int{0, 1}"
          hints:
            - title: ðŸ¤” Think about it
              content: >-
                Each Fibonacci number is the sum of the two preceding ones. You need to handle the first two
                values as special cases, then loop to generate the rest. How do you track two previous values
                simultaneously?
            - title: ðŸ’¡ Hint
              content: >-
                Start a slice with 0 and 1. Then for i := 2; i < n; i++, compute the next value as result[i-1]
                + result[i-2] and append it.
            - title: ðŸ”§ Pattern
              content: |-
                <pre>1. if n <= 0: return []int{}
                2. if n == 1: return []int{0}
                3. result := []int{0, 1}
                4. for i := 2; i < n; i++:
                   - next := result[i-1] + result[i-2]
                   - append next to result
                5. return result</pre>
          solution: |-
            func fibonacci(n int) []int {
                if n <= 0 {
                    return []int{}
                }
                if n == 1 {
                    return []int{0}
                }
                result := []int{0, 1}
                for i := 2; i < n; i++ {
                    result = append(result, result[i-1]+result[i-2])
                }
                return result
            }
          difficulty: 3
        - id: v12
          title: Converging Sum
          description: >-
            A numerical methods library approximates values by summing series. Write <code>func harmonicSum(n
            int) float64</code> that returns the sum of the first n terms of the harmonic series: 1/1 + 1/2 +
            1/3 + ... + 1/n.
          functionSignature: func harmonicSum(n int) float64
          testCases:
            - input: "1"
              output: "1.0"
            - input: "4"
              output: "2.083333333333333"
          hints:
            - title: ðŸ¤” Think about it
              content: >-
                You need to sum fractions where the denominator increases by 1 each step. Integer division
                would truncate the results. How do you ensure floating-point division in Go?
            - title: ðŸ’¡ Hint
              content: >-
                Use for i := 1; i <= n; i++ and add 1.0/float64(i) to a float64 accumulator. Casting the
                integer to float64 ensures proper division.
            - title: ðŸ”§ Pattern
              content: |-
                <pre>1. sum := 0.0
                2. for i := 1; i <= n; i++:
                   - sum += 1.0 / float64(i)
                3. return sum</pre>
          solution: |-
            func harmonicSum(n int) float64 {
                sum := 0.0
                for i := 1; i <= n; i++ {
                    sum += 1.0 / float64(i)
                }
                return sum
            }
          difficulty: 3
        - id: v13
          title: Two-Pointer Palindrome Check
          description: >-
            A content moderation tool checks if usernames are palindromes. Write <code>func isPalindrome(s
            string) bool</code> that uses a two-pointer for loop to check if a string reads the same forwards
            and backwards. Compare bytes only (ASCII input guaranteed).
          functionSignature: func isPalindrome(s string) bool
          testCases:
            - input: "\"racecar\""
              output: "true"
            - input: "\"hello\""
              output: "false"
            - input: "\"a\""
              output: "true"
          hints:
            - title: ðŸ¤” Think about it
              content: >-
                A palindrome reads the same from both ends. If you place one pointer at the start and one at
                the end, how do they move toward each other? When can you stop early to say it is not a
                palindrome?
            - title: ðŸ’¡ Hint
              content: >-
                Use for left, right := 0, len(s)-1; left < right; left, right = left+1, right-1. If s[left] !=
                s[right] at any point, return false.
            - title: ðŸ”§ Pattern
              content: |-
                <pre>1. left := 0, right := len(s) - 1
                2. for left < right:
                   - if s[left] != s[right]: return false
                   - left++, right--
                3. return true</pre>
          solution: |-
            func isPalindrome(s string) bool {
                for left, right := 0, len(s)-1; left < right; left, right = left+1, right-1 {
                    if s[left] != s[right] {
                        return false
                    }
                }
                return true
            }
          difficulty: 3
    - id: challenge_10
      block: 1
      difficulty: 1
      concept: "Range Loops"
      docLinks:
        - url: https://go.dev/tour/moretypes/16
          title: "Go Tour: Range"
          note: iterating slices and maps
        - url: https://go.dev/doc/effective_go#for
          title: "Effective Go: For"
          note: range patterns
      patternPrimer:
        bruteForce: Use C-style for with manual index tracking.
        bestApproach: "Use for i, v := range to iterate slices idiomatically; use _ to discard unused index or value."
        typical: Range is the idiomatic way to iterate in Go \u2014 same O(n) complexity, cleaner syntax.
      variants:
        - id: v1
          title: Sum All Elements
          description: >-
            A payroll system totals employee hours. Write <code>func sumAll(nums []int) int</code> that
            returns the sum of all elements in the slice using a range loop.
          functionSignature: func sumAll(nums []int) int
          testCases:
            - input: "[]int{10, 20, 30}"
              output: "60"
            - input: "[]int{5}"
              output: "5"
            - input: "[]int{}"
              output: "0"
          hints:
            - title: ðŸ¤” Think about it
              content: >-
                You want the value of each element but not the index. How do you discard the index variable in
                a range loop?
            - title: ðŸ’¡ Hint
              content: >-
                Use for _, n := range nums. The underscore discards the index. Accumulate a running sum and
                return it after the loop.
            - title: ðŸ”§ Pattern
              content: |-
                <pre>1. sum := 0
                2. for _, n := range nums:
                   - sum += n
                3. return sum</pre>
          solution: |-
            func sumAll(nums []int) int {
                sum := 0
                for _, n := range nums {
                    sum += n
                }
                return sum
            }
          difficulty: 1
        - id: v2
          title: Contains String
          description: >-
            A CLI autocomplete engine checks if a command exists in the known commands list. Write <code>func
            contains(items []string, target string) bool</code> that returns true if target is found in the
            slice using a range loop.
          functionSignature: func contains(items []string, target string) bool
          testCases:
            - input: "[]string{\"build\", \"test\", \"run\"}, \"test\""
              output: "true"
            - input: "[]string{\"build\", \"test\", \"run\"}, \"deploy\""
              output: "false"
          hints:
            - title: ðŸ¤” Think about it
              content: >-
                As soon as you find the target, you know the answer. Can you exit the loop early instead of
                checking every element?
            - title: ðŸ’¡ Hint
              content: >-
                Use for _, item := range items. If item == target, return true immediately. After the loop,
                return false.
            - title: ðŸ”§ Pattern
              content: |-
                <pre>1. for _, item := range items:
                   - if item == target: return true
                2. return false</pre>
          solution: |-
            func contains(items []string, target string) bool {
                for _, item := range items {
                    if item == target {
                        return true
                    }
                }
                return false
            }
          difficulty: 1
        - id: v3
          title: Find Minimum
          description: >-
            A monitoring dashboard displays the lowest latency reading. Write <code>func findMin(nums []int)
            int</code> that returns the smallest element in the slice using a range loop. The slice is
            guaranteed non-empty.
          functionSignature: func findMin(nums []int) int
          testCases:
            - input: "[]int{8, 3, 12, 1, 6}"
              output: "1"
            - input: "[]int{42}"
              output: "42"
          hints:
            - title: ðŸ¤” Think about it
              content: >-
                Track the smallest value seen so far. What should you initialize it to so that it works for
                any input?
            - title: ðŸ’¡ Hint
              content: >-
                Set min to nums[0]. Then for _, n := range nums, update min whenever n is smaller than the
                current min.
            - title: ðŸ”§ Pattern
              content: |-
                <pre>1. min := nums[0]
                2. for _, n := range nums:
                   - if n < min: min = n
                3. return min</pre>
          solution: |-
            func findMin(nums []int) int {
                min := nums[0]
                for _, n := range nums {
                    if n < min {
                        min = n
                    }
                }
                return min
            }
          difficulty: 1
        - id: v4
          title: Count Matches
          description: >-
            A log analyzer counts entries of a given severity level. Write <code>func countLevel(entries
            []string, level string) int</code> that uses range to count how many entries match the given level
            string.
          functionSignature: func countLevel(entries []string, level string) int
          testCases:
            - input: "[]string{\"ERROR\", \"INFO\", \"ERROR\", \"WARN\"}, \"ERROR\""
              output: "2"
            - input: "[]string{\"INFO\", \"INFO\"}, \"ERROR\""
              output: "0"
          hints:
            - title: ðŸ¤” Think about it
              content: Iterate through each entry and compare it to the level. What do you do when they match?
            - title: ðŸ’¡ Hint
              content: Start count := 0. Use for _, entry := range entries. If entry == level, increment count.
            - title: ðŸ”§ Pattern
              content: |-
                <pre>1. count := 0
                2. for _, entry := range entries:
                   - if entry == level: count++
                3. return count</pre>
          solution: |-
            func countLevel(entries []string, level string) int {
                count := 0
                for _, entry := range entries {
                    if entry == level {
                        count++
                    }
                }
                return count
            }
          difficulty: 1
        - id: v5
          title: Filter Above Threshold
          description: >-
            A performance monitor filters out metrics below a threshold. Write <code>func filterAbove(nums
            []int, threshold int) []int</code> that returns a new slice containing only elements greater than
            threshold, using range.
          functionSignature: func filterAbove(nums []int, threshold int) []int
          testCases:
            - input: "[]int{5, 12, 3, 18, 7}, 6"
              output: "[]int{12, 18, 7}"
            - input: "[]int{1, 2, 3}, 10"
              output: "[]int{}"
          hints:
            - title: ðŸ¤” Think about it
              content: >-
                You need to build a new slice with only certain elements. How do you conditionally add items
                to a slice in Go?
            - title: ðŸ’¡ Hint
              content: >-
                Start with result := []int{}. Use for _, n := range nums. If n > threshold, append n to
                result.
            - title: ðŸ”§ Pattern
              content: |-
                <pre>1. result := []int{}
                2. for _, n := range nums:
                   - if n > threshold: append n to result
                3. return result</pre>
          solution: |-
            func filterAbove(nums []int, threshold int) []int {
                result := []int{}
                for _, n := range nums {
                    if n > threshold {
                        result = append(result, n)
                    }
                }
                return result
            }
          difficulty: 2
        - id: v6
          title: Index of First Match
          description: >-
            A search engine returns the position of the first result matching a query. Write <code>func
            firstIndex(words []string, target string) int</code> that returns the index of the first
            occurrence of target in the slice, or -1 if not found.
          functionSignature: func firstIndex(words []string, target string) int
          testCases:
            - input: "[]string{\"go\", \"rust\", \"python\", \"go\"}, \"go\""
              output: "0"
            - input: "[]string{\"go\", \"rust\"}, \"java\""
              output: "-1"
          hints:
            - title: ðŸ¤” Think about it
              content: >-
                You need both the index and the value from range. How does range give you both in a single
                loop variable assignment?
            - title: ðŸ’¡ Hint
              content: >-
                Use for i, w := range words. When w == target, return i immediately. If the loop finishes
                without finding it, return -1.
            - title: ðŸ”§ Pattern
              content: |-
                <pre>1. for i, w := range words:
                   - if w == target: return i
                2. return -1</pre>
          solution: |-
            func firstIndex(words []string, target string) int {
                for i, w := range words {
                    if w == target {
                        return i
                    }
                }
                return -1
            }
          difficulty: 2
        - id: v7
          title: Double Values
          description: >-
            A data transformation pipeline doubles each metric value. Write <code>func doubleAll(nums []int)
            []int</code> that returns a new slice with every element multiplied by 2, using range with index.
          functionSignature: func doubleAll(nums []int) []int
          testCases:
            - input: "[]int{3, 7, 1}"
              output: "[]int{6, 14, 2}"
            - input: "[]int{0, -5}"
              output: "[]int{0, -10}"
          hints:
            - title: ðŸ¤” Think about it
              content: >-
                You need a result slice of the same length as the input. How can you pre-allocate a slice of a
                known size in Go?
            - title: ðŸ’¡ Hint
              content: >-
                Use make([]int, len(nums)) to create the result. Then for i, n := range nums, set result[i] =
                n * 2.
            - title: ðŸ”§ Pattern
              content: |-
                <pre>1. result := make([]int, len(nums))
                2. for i, n := range nums:
                   - result[i] = n * 2
                3. return result</pre>
          solution: |-
            func doubleAll(nums []int) []int {
                result := make([]int, len(nums))
                for i, n := range nums {
                    result[i] = n * 2
                }
                return result
            }
          difficulty: 2
        - id: v8
          title: Count Vowels in String
          description: >-
            A text analysis library counts vowels in user input. Write <code>func countVowels(s string)
            int</code> that uses range over a string to count how many characters are vowels (a, e, i, o, u,
            case-insensitive).
          functionSignature: func countVowels(s string) int
          testCases:
            - input: "\"Hello World\""
              output: "3"
            - input: "\"rhythm\""
              output: "0"
            - input: "\"AEIOU\""
              output: "5"
          hints:
            - title: ðŸ¤” Think about it
              content: >-
                When you range over a string in Go, you get runes (Unicode code points). How can you check if
                a rune is one of several target characters?
            - title: ðŸ’¡ Hint
              content: >-
                Use for _, c := range s. Convert each rune to lowercase with unicode.ToLower or use
                strings.ContainsRune on a vowel string "aeiouAEIOU". Increment a counter for each match.
            - title: ðŸ”§ Pattern
              content: |-
                <pre>1. count := 0
                2. vowels := "aeiouAEIOU"
                3. for _, c := range s:
                   - if strings.ContainsRune(vowels, c): count++
                4. return count</pre>
          solution: |-
            func countVowels(s string) int {
                count := 0
                vowels := "aeiouAEIOU"
                for _, c := range s {
                    if strings.ContainsRune(vowels, c) {
                        count++
                    }
                }
                return count
            }
          difficulty: 2
        - id: v9
          title: Map to Uppercase
          description: >-
            A config normalizer converts all setting names to uppercase. Write <code>func toUpper(words
            []string) []string</code> that returns a new slice with each string converted to uppercase using
            range.
          functionSignature: func toUpper(words []string) []string
          testCases:
            - input: "[]string{\"go\", \"Rust\", \"PYTHON\"}"
              output: "[]string{\"GO\", \"RUST\", \"PYTHON\"}"
            - input: "[]string{}"
              output: "[]string{}"
          hints:
            - title: ðŸ¤” Think about it
              content: >-
                You need to transform each string and collect the results. What standard library function
                converts a string to uppercase in Go?
            - title: ðŸ’¡ Hint
              content: >-
                Use strings.ToUpper(w) inside a range loop. Pre-allocate with make([]string, len(words)) and
                assign result[i] = strings.ToUpper(w).
            - title: ðŸ”§ Pattern
              content: |-
                <pre>1. result := make([]string, len(words))
                2. for i, w := range words:
                   - result[i] = strings.ToUpper(w)
                3. return result</pre>
          solution: |-
            func toUpper(words []string) []string {
                result := make([]string, len(words))
                for i, w := range words {
                    result[i] = strings.ToUpper(w)
                }
                return result
            }
          difficulty: 2
        - id: v10
          title: Longest Filename
          description: >-
            A file browser displays the longest filename for column width calculation. Write <code>func
            longestName(names []string) string</code> that returns the longest string in the slice using
            range. If tied, return the first one found.
          functionSignature: func longestName(names []string) string
          testCases:
            - input: "[]string{\"main.go\", \"README.md\", \"go.mod\"}"
              output: "\"README.md\""
            - input: "[]string{\"a\", \"bb\", \"cc\"}"
              output: "\"bb\""
          hints:
            - title: ðŸ¤” Think about it
              content: >-
                This is like finding the max value, but you compare string lengths instead of numbers. What
                should you initialize the best candidate to?
            - title: ðŸ’¡ Hint
              content: >-
                Initialize best := names[0]. Range over the slice. If len(name) > len(best), update best.
                Using strict > ensures the first longest wins ties.
            - title: ðŸ”§ Pattern
              content: |-
                <pre>1. best := names[0]
                2. for _, name := range names:
                   - if len(name) > len(best): best = name
                3. return best</pre>
          solution: |-
            func longestName(names []string) string {
                best := names[0]
                for _, name := range names {
                    if len(name) > len(best) {
                        best = name
                    }
                }
                return best
            }
          difficulty: 3
        - id: v11
          title: Partition Evens and Odds
          description: >-
            A data pipeline separates records into two streams. Write <code>func partition(nums []int) ([]int,
            []int)</code> that returns two slices: the first containing all even numbers and the second
            containing all odd numbers, both in their original order, using range.
          functionSignature: func partition(nums []int) ([]int, []int)
          testCases:
            - input: "[]int{1, 2, 3, 4, 5, 6}"
              output: "[]int{2, 4, 6}, []int{1, 3, 5}"
            - input: "[]int{7}"
              output: "[]int{}, []int{7}"
          hints:
            - title: ðŸ¤” Think about it
              content: >-
                You need two separate result slices. As you iterate, you decide which slice each element
                belongs to. What condition determines even vs odd?
            - title: ðŸ’¡ Hint
              content: >-
                Create evens := []int{} and odds := []int{}. Use for _, n := range nums. If n%2 == 0, append
                to evens; otherwise append to odds. Return both.
            - title: ðŸ”§ Pattern
              content: |-
                <pre>1. evens := []int{}, odds := []int{}
                2. for _, n := range nums:
                   - if n%2 == 0: append to evens
                   - else: append to odds
                3. return evens, odds</pre>
          solution: |-
            func partition(nums []int) ([]int, []int) {
                evens := []int{}
                odds := []int{}
                for _, n := range nums {
                    if n%2 == 0 {
                        evens = append(evens, n)
                    } else {
                        odds = append(odds, n)
                    }
                }
                return evens, odds
            }
          difficulty: 3
        - id: v12
          title: Running Average
          description: >-
            A sensor dashboard shows the running average of readings over time. Write <code>func
            runningAvg(nums []int) []float64</code> that returns a slice where each element is the average of
            all elements up to and including that index.
          functionSignature: func runningAvg(nums []int) []float64
          testCases:
            - input: "[]int{4, 2, 6}"
              output: "[]float64{4.0, 3.0, 4.0}"
            - input: "[]int{10}"
              output: "[]float64{10.0}"
          hints:
            - title: ðŸ¤” Think about it
              content: >-
                At each position, you need the sum of all values seen so far divided by the number of values.
                You need both the index and a running sum. How does range give you the index?
            - title: ðŸ’¡ Hint
              content: >-
                Keep a running sum. Use for i, n := range nums. Add n to sum, then compute float64(sum) /
                float64(i+1) for the average at position i.
            - title: ðŸ”§ Pattern
              content: |-
                <pre>1. result := make([]float64, len(nums))
                2. sum := 0
                3. for i, n := range nums:
                   - sum += n
                   - result[i] = float64(sum) / float64(i+1)
                4. return result</pre>
          solution: |-
            func runningAvg(nums []int) []float64 {
                result := make([]float64, len(nums))
                sum := 0
                for i, n := range nums {
                    sum += n
                    result[i] = float64(sum) / float64(i+1)
                }
                return result
            }
          difficulty: 3
        - id: v13
          title: Flatten Nested Slices
          description: >-
            A data aggregator merges results from multiple sources. Write <code>func flatten(nested [][]int)
            []int</code> that flattens a slice of slices into a single slice using nested range loops,
            preserving order.
          functionSignature: func flatten(nested [][]int) []int
          testCases:
            - input: "[][]int{{1, 2}, {3}, {4, 5, 6}}"
              output: "[]int{1, 2, 3, 4, 5, 6}"
            - input: "[][]int{{}, {7}, {}}"
              output: "[]int{7}"
          hints:
            - title: ðŸ¤” Think about it
              content: >-
                You have a slice of slices. You need to iterate the outer slice, and for each inner slice,
                iterate its elements. This requires nested range loops. How do you append all inner elements
                to a single result?
            - title: ðŸ’¡ Hint
              content: >-
                Use for _, inner := range nested as the outer loop. Inside, use for _, n := range inner and
                append each n to a result slice.
            - title: ðŸ”§ Pattern
              content: |-
                <pre>1. result := []int{}
                2. for _, inner := range nested:
                   - for _, n := range inner:
                     - append n to result
                3. return result</pre>
          solution: |-
            func flatten(nested [][]int) []int {
                result := []int{}
                for _, inner := range nested {
                    for _, n := range inner {
                        result = append(result, n)
                    }
                }
                return result
            }
          difficulty: 3
    - id: challenge_11
      block: 1
      difficulty: 2
      concept: "Map Basics"
      docLinks:
        - url: https://go.dev/blog/maps
          title: "Go Blog: Go maps in action"
          note: comprehensive map guide
        - url: https://go.dev/tour/moretypes/19
          title: "Go Tour: Maps"
          note: map basics
      patternPrimer:
        bruteForce: Use parallel slices for keys and values and search linearly.
        bestApproach: Use maps for O(1) key lookups; build maps from data with make() or literals.
        typical: Map operations (get/set/delete) are O(1) average case.
      variants:
        - id: v1
          title: Step Durations
          description: >-
            A task runner stores how long each build step takes. Write <code>func stepDurations()
            map[string]int</code> that returns a map literal with "compile":120, "test":45, and "deploy":30.
          functionSignature: func stepDurations() map[string]int
          testCases:
            - input: ""
              output: "map[string]int{\"compile\": 120, \"test\": 45, \"deploy\": 30}"
          hints:
            - title: ðŸ¤” Think about it
              content: >-
                Go lets you create a map with initial values using a map literal. What is the syntax for a
                map[string]int literal with key-value pairs?
            - title: ðŸ’¡ Hint
              content: >-
                Return a map literal directly: map[string]int{"compile": 120, "test": 45, "deploy": 30}. Each
                entry is key: value separated by commas.
            - title: ðŸ”§ Pattern
              content: |-
                <pre>1. Return a map literal with three entries
                2. Keys are strings, values are ints</pre>
          solution: |-
            func stepDurations() map[string]int {
                return map[string]int{
                    "compile": 120,
                    "test":    45,
                    "deploy":  30,
                }
            }
          difficulty: 1
        - id: v2
          title: HTTP Status Codes
          description: >-
            A web framework needs a lookup table for common HTTP status descriptions. Write <code>func
            httpStatuses() map[int]string</code> that returns a map with 200:"OK", 404:"Not Found", and
            500:"Internal Server Error".
          functionSignature: func httpStatuses() map[int]string
          testCases:
            - input: ""
              output: "map[int]string{200: \"OK\", 404: \"Not Found\", 500: \"Internal Server Error\"}"
          hints:
            - title: ðŸ¤” Think about it
              content: >-
                Map keys and values can be different types. Here keys are ints and values are strings. How do
                you declare a map[int]string literal?
            - title: ðŸ’¡ Hint
              content: >-
                Return map[int]string{200: "OK", 404: "Not Found", 500: "Internal Server Error"}. Integer keys
                don't need quotes.
            - title: ðŸ”§ Pattern
              content: |-
                <pre>1. Create a map[int]string literal
                2. Add three status code entries
                3. Return the map</pre>
          solution: |-
            func httpStatuses() map[int]string {
                return map[int]string{
                    200: "OK",
                    404: "Not Found",
                    500: "Internal Server Error",
                }
            }
          difficulty: 1
        - id: v3
          title: Config Store
          description: >-
            A microservice reads a flat config. Write <code>func defaultConfig() map[string]string</code> that
            returns a map with "host":"localhost", "port":"8080", and "mode":"debug".
          functionSignature: func defaultConfig() map[string]string
          testCases:
            - input: ""
              output: "map[string]string{\"host\": \"localhost\", \"port\": \"8080\", \"mode\": \"debug\"}"
          hints:
            - title: ðŸ¤” Think about it
              content: >-
                A config store is naturally a map[string]string where keys are setting names and values are
                setting values. How do you create one with initial data?
            - title: ðŸ’¡ Hint
              content: >-
                Use a map literal: map[string]string{"host": "localhost", "port": "8080", "mode": "debug"}.
                All keys and values are strings.
            - title: ðŸ”§ Pattern
              content: |-
                <pre>1. Return a map[string]string literal
                2. Include all three config entries</pre>
          solution: |-
            func defaultConfig() map[string]string {
                return map[string]string{
                    "host": "localhost",
                    "port": "8080",
                    "mode": "debug",
                }
            }
          difficulty: 1
        - id: v4
          title: Read and Add Entry
          description: >-
            A feature-flag registry needs to be extended. Write <code>func addFlag(flags map[string]bool, name
            string) map[string]bool</code> that sets flags[name] to true and returns the modified map.
          functionSignature: func addFlag(flags map[string]bool, name string) map[string]bool
          testCases:
            - input: "map[string]bool{\"dark_mode\": true}, \"beta_ui\""
              output: "map[string]bool{\"dark_mode\": true, \"beta_ui\": true}"
            - input: map[string]bool{}, "logging"
              output: "map[string]bool{\"logging\": true}"
          hints:
            - title: ðŸ¤” Think about it
              content: >-
                Adding a new entry to a map is as simple as assigning to a new key. What happens when you
                assign to a key that doesn't exist yet?
            - title: ðŸ’¡ Hint
              content: >-
                Use flags[name] = true to add the entry. Maps are reference types, so modifying the map
                parameter also modifies the original. Return the map.
            - title: ðŸ”§ Pattern
              content: |-
                <pre>1. flags[name] = true
                2. Return flags</pre>
          solution: |-
            func addFlag(flags map[string]bool, name string) map[string]bool {
                flags[name] = true
                return flags
            }
          difficulty: 1
        - id: v5
          title: Count Log Levels
          description: >-
            A log analyzer counts severity levels. Write <code>func countLevels(entries []string)
            map[string]int</code> that counts occurrences of each unique string in the slice. For example,
            ["INFO","ERROR","INFO"] returns {"INFO":2,"ERROR":1}.
          functionSignature: func countLevels(entries []string) map[string]int
          testCases:
            - input: "[]string{\"INFO\", \"ERROR\", \"INFO\", \"WARN\", \"ERROR\"}"
              output: "map[string]int{\"INFO\": 2, \"ERROR\": 2, \"WARN\": 1}"
            - input: "[]string{\"DEBUG\"}"
              output: "map[string]int{\"DEBUG\": 1}"
          hints:
            - title: ðŸ¤” Think about it
              content: >-
                You need to iterate over the slice and keep a running tally for each unique string. What map
                type lets you count by string key?
            - title: ðŸ’¡ Hint
              content: >-
                Create counts := make(map[string]int). For each entry, do counts[entry]++. Missing keys
                default to zero, so the first increment sets the count to 1.
            - title: ðŸ”§ Pattern
              content: |-
                <pre>1. counts := make(map[string]int)
                2. for _, e := range entries: counts[e]++
                3. return counts</pre>
          solution: |-
            func countLevels(entries []string) map[string]int {
                counts := make(map[string]int)
                for _, e := range entries {
                    counts[e]++
                }
                return counts
            }
          difficulty: 2
        - id: v6
          title: Build Index
          description: >-
            A search engine indexes words by position. Write <code>func buildIndex(words []string)
            map[string]int</code> that maps each word to the index of its first occurrence. For example,
            ["go","rust","go"] returns {"go":0,"rust":1}.
          functionSignature: func buildIndex(words []string) map[string]int
          testCases:
            - input: "[]string{\"go\", \"rust\", \"go\", \"python\"}"
              output: "map[string]int{\"go\": 0, \"rust\": 1, \"python\": 3}"
            - input: "[]string{\"a\", \"b\", \"a\", \"b\"}"
              output: "map[string]int{\"a\": 0, \"b\": 1}"
          hints:
            - title: ðŸ¤” Think about it
              content: >-
                You only want the first occurrence of each word. How do you skip a word if it has already been
                recorded in the map?
            - title: ðŸ’¡ Hint
              content: >-
                Range over words with index. Before adding, check if the key already exists. If not, set
                index[word] = i. You can use the comma-ok idiom or simply check if the key is already present.
            - title: ðŸ”§ Pattern
              content: |-
                <pre>1. idx := make(map[string]int)
                2. for i, w := range words:
                   - if _, exists := idx[w]; !exists: idx[w] = i
                3. return idx</pre>
          solution: |-
            func buildIndex(words []string) map[string]int {
                idx := make(map[string]int)
                for i, w := range words {
                    if _, exists := idx[w]; !exists {
                        idx[w] = i
                    }
                }
                return idx
            }
          difficulty: 2
        - id: v7
          title: Zip to Map
          description: >-
            A CSV parser pairs header names with row values. Write <code>func zipToMap(keys []string, values
            []int) map[string]int</code> that builds a map from two parallel slices. Assume both slices have
            the same length.
          functionSignature: func zipToMap(keys []string, values []int) map[string]int
          testCases:
            - input: "[]string{\"cpu\", \"mem\", \"disk\"}, []int{80, 64, 120}"
              output: "map[string]int{\"cpu\": 80, \"mem\": 64, \"disk\": 120}"
            - input: "[]string{\"a\"}, []int{1}"
              output: "map[string]int{\"a\": 1}"
          hints:
            - title: ðŸ¤” Think about it
              content: >-
                Two slices of the same length where index i in one corresponds to index i in the other. How do
                you iterate them together?
            - title: ðŸ’¡ Hint
              content: >-
                Use for i := range keys and set m[keys[i]] = values[i] to pair up corresponding elements from
                both slices.
            - title: ðŸ”§ Pattern
              content: |-
                <pre>1. m := make(map[string]int)
                2. for i := range keys:
                   - m[keys[i]] = values[i]
                3. return m</pre>
          solution: |-
            func zipToMap(keys []string, values []int) map[string]int {
                m := make(map[string]int)
                for i := range keys {
                    m[keys[i]] = values[i]
                }
                return m
            }
          difficulty: 2
        - id: v8
          title: Unique Usernames
          description: >-
            An auth system deduplicates a list of login usernames. Write <code>func uniqueNames(names
            []string) []string</code> that returns a slice of unique names preserving the order of first
            appearance.
          functionSignature: func uniqueNames(names []string) []string
          testCases:
            - input: "[]string{\"alice\", \"bob\", \"alice\", \"carol\", \"bob\"}"
              output: "[]string{\"alice\", \"bob\", \"carol\"}"
            - input: "[]string{\"x\", \"x\", \"x\"}"
              output: "[]string{\"x\"}"
          hints:
            - title: ðŸ¤” Think about it
              content: >-
                A map can serve as a set to track which names you have already seen. How do you preserve order
                while deduplicating?
            - title: ðŸ’¡ Hint
              content: >-
                Use a map[string]bool as a "seen" set. For each name, if it is not in seen, append it to the
                result and mark it as seen.
            - title: ðŸ”§ Pattern
              content: |-
                <pre>1. seen := make(map[string]bool)
                2. result := []string{}
                3. for _, name := range names:
                   - if !seen[name]: seen[name] = true, append to result
                4. return result</pre>
          solution: |-
            func uniqueNames(names []string) []string {
                seen := make(map[string]bool)
                result := []string{}
                for _, name := range names {
                    if !seen[name] {
                        seen[name] = true
                        result = append(result, name)
                    }
                }
                return result
            }
          difficulty: 2
        - id: v9
          title: Sum by Category
          description: >-
            An expense tracker sums amounts by category. Write <code>func sumByCategory(categories []string,
            amounts []int) map[string]int</code> that returns a map of category to total amount. Both slices
            have the same length.
          functionSignature: func sumByCategory(categories []string, amounts []int) map[string]int
          testCases:
            - input: "[]string{\"food\", \"transport\", \"food\", \"food\"}, []int{20, 35, 15, 10}"
              output: "map[string]int{\"food\": 45, \"transport\": 35}"
            - input: "[]string{\"rent\"}, []int{1200}"
              output: "map[string]int{\"rent\": 1200}"
          hints:
            - title: ðŸ¤” Think about it
              content: >-
                You need to accumulate amounts for the same category. What happens when you use += on a map
                entry that does not exist yet?
            - title: ðŸ’¡ Hint
              content: >-
                Create a map[string]int. Loop by index and do totals[categories[i]] += amounts[i]. Missing
                keys default to 0, so the first += correctly sets the initial total.
            - title: ðŸ”§ Pattern
              content: |-
                <pre>1. totals := make(map[string]int)
                2. for i := range categories:
                   - totals[categories[i]] += amounts[i]
                3. return totals</pre>
          solution: |-
            func sumByCategory(categories []string, amounts []int) map[string]int {
                totals := make(map[string]int)
                for i := range categories {
                    totals[categories[i]] += amounts[i]
                }
                return totals
            }
          difficulty: 2
        - id: v10
          title: Invert Registry
          description: >-
            A service registry maps service names to port numbers. Write <code>func invertRegistry(reg
            map[string]int) map[int][]string</code> that inverts the map so each port maps to a slice of
            services on that port.
          functionSignature: func invertRegistry(reg map[string]int) map[int][]string
          testCases:
            - input: "map[string]int{\"api\": 8080, \"web\": 8080, \"db\": 5432}"
              output: "map[int][]string{8080: {\"api\", \"web\"}, 5432: {\"db\"}}"
          hints:
            - title: ðŸ¤” Think about it
              content: >-
                Multiple services can share the same port. A simple key-value inversion would lose data. How
                do you group multiple original keys under a single inverted key?
            - title: ðŸ’¡ Hint
              content: >-
                Use a map[int][]string for the result. For each service-port pair, append the service name to
                the slice at result[port]. Appending to a nil slice works in Go.
            - title: ðŸ”§ Pattern
              content: |-
                <pre>1. result := make(map[int][]string)
                2. for name, port := range reg:
                   - result[port] = append(result[port], name)
                3. return result</pre>
          solution: |-
            func invertRegistry(reg map[string]int) map[int][]string {
                result := make(map[int][]string)
                for name, port := range reg {
                    result[port] = append(result[port], name)
                }
                return result
            }
          difficulty: 3
        - id: v11
          title: Delete Stale Entries
          description: >-
            A cache evicts entries older than a threshold. Write <code>func deleteStale(cache map[string]int,
            maxAge int) map[string]int</code> that removes entries whose value (representing age in seconds)
            exceeds maxAge and returns the modified map.
          functionSignature: func deleteStale(cache map[string]int, maxAge int) map[string]int
          testCases:
            - input: "map[string]int{\"a\": 10, \"b\": 300, \"c\": 50}, 60"
              output: "map[string]int{\"a\": 10, \"c\": 50}"
            - input: "map[string]int{\"x\": 100}, 200"
              output: "map[string]int{\"x\": 100}"
          hints:
            - title: ðŸ¤” Think about it
              content: >-
                Go allows you to delete entries from a map while iterating over it. The built-in delete()
                function removes a key. When should you call it?
            - title: ðŸ’¡ Hint
              content: >-
                Range over the map. For each entry where the value exceeds maxAge, call delete(cache, key). It
                is safe to delete map entries during a range loop in Go.
            - title: ðŸ”§ Pattern
              content: |-
                <pre>1. for k, v := range cache:
                   - if v > maxAge: delete(cache, k)
                2. return cache</pre>
          solution: |-
            func deleteStale(cache map[string]int, maxAge int) map[string]int {
                for k, v := range cache {
                    if v > maxAge {
                        delete(cache, k)
                    }
                }
                return cache
            }
          difficulty: 3
        - id: v12
          title: Merge with Sum
          description: >-
            A metrics pipeline merges counters from two sources. Write <code>func mergeWithSum(a, b
            map[string]int) map[string]int</code> that returns a new map where overlapping keys have their
            values summed.
          functionSignature: func mergeWithSum(a, b map[string]int) map[string]int
          testCases:
            - input: "map[string]int{\"hits\": 10, \"errors\": 2}, map[string]int{\"hits\": 5, \"timeouts\": 1}"
              output: "map[string]int{\"hits\": 15, \"errors\": 2, \"timeouts\": 1}"
            - input: "map[string]int{\"x\": 1}, map[string]int{\"y\": 2}"
              output: "map[string]int{\"x\": 1, \"y\": 2}"
          hints:
            - title: ðŸ¤” Think about it
              content: >-
                Unlike a simple merge where b overwrites a, here you want to add the values when a key appears
                in both maps. How do you combine values for shared keys?
            - title: ðŸ’¡ Hint
              content: >-
                Create a result map. Copy all of a into it. Then range over b and use result[k] += v. Since
                missing keys default to 0, keys only in b are added correctly too.
            - title: ðŸ”§ Pattern
              content: |-
                <pre>1. result := make(map[string]int)
                2. for k, v := range a: result[k] = v
                3. for k, v := range b: result[k] += v
                4. return result</pre>
          solution: |-
            func mergeWithSum(a, b map[string]int) map[string]int {
                result := make(map[string]int)
                for k, v := range a {
                    result[k] = v
                }
                for k, v := range b {
                    result[k] += v
                }
                return result
            }
          difficulty: 3
        - id: v13
          title: Build Adjacency List
          description: >-
            A graph builder creates an adjacency list from a list of edges. Write <code>func
            buildAdjacency(edges [][2]string) map[string][]string</code> that converts a slice of [from, to]
            pairs into a map where each key maps to its list of neighbors. Edges are directed.
          functionSignature: func buildAdjacency(edges [][2]string) map[string][]string
          testCases:
            - input: "[][2]string{{\"a\", \"b\"}, {\"a\", \"c\"}, {\"b\", \"c\"}}"
              output: "map[string][]string{\"a\": {\"b\", \"c\"}, \"b\": {\"c\"}}"
            - input: "[][2]string{{\"x\", \"y\"}}"
              output: "map[string][]string{\"x\": {\"y\"}}"
          hints:
            - title: ðŸ¤” Think about it
              content: >-
                Each edge adds a neighbor to the from node's list. Multiple edges from the same node should
                all be collected. What map value type supports collecting multiple items?
            - title: ðŸ’¡ Hint
              content: >-
                Use a map[string][]string. For each edge, append the to node to adj[from]. Appending to a nil
                slice in Go creates a new slice automatically.
            - title: ðŸ”§ Pattern
              content: |-
                <pre>1. adj := make(map[string][]string)
                2. for _, edge := range edges:
                   - from, to := edge[0], edge[1]
                   - adj[from] = append(adj[from], to)
                3. return adj</pre>
          solution: |-
            func buildAdjacency(edges [][2]string) map[string][]string {
                adj := make(map[string][]string)
                for _, edge := range edges {
                    from, to := edge[0], edge[1]
                    adj[from] = append(adj[from], to)
                }
                return adj
            }
          difficulty: 3
    - id: challenge_12
      block: 1
      difficulty: 2
      concept: "Comma-Ok Pattern"
      docLinks:
        - url: https://go.dev/doc/effective_go#maps
          title: "Effective Go: Maps"
          note: comma-ok idiom
        - url: https://go.dev/ref/spec#Index_expressions
          title: "Go Spec: Index expressions"
          note: two-value form
      patternPrimer:
        bruteForce: Check if zero value means the key is missing (unreliable for int/string maps).
        bestApproach: "Always use value, ok := m[key] to distinguish missing keys from zero values."
        typical: "Comma-ok lookup is O(1) â€” same as regular map access, but safe."
      variants:
        - id: v1
          title: Preference Lookup
          description: >-
            A CLI reads user preferences with defaults. Write <code>func getPreference(prefs
            map[string]string, key string, fallback string) string</code> that returns the preference value if
            the key exists, or fallback if not found.
          functionSignature: func getPreference(prefs map[string]string, key string, fallback string) string
          testCases:
            - input: "map[string]string{\"theme\": \"dark\"}, \"theme\", \"light\""
              output: "\"dark\""
            - input: "map[string]string{\"theme\": \"dark\"}, \"lang\", \"en\""
              output: "\"en\""
          hints:
            - title: ðŸ¤” Think about it
              content: >-
                You need to check if the key exists in the map before returning its value. What Go idiom lets
                you check existence and get the value at the same time?
            - title: ðŸ’¡ Hint
              content: >-
                Use the comma-ok pattern: if v, ok := prefs[key]; ok { return v }. If the key is not found,
                fall through to return the fallback.
            - title: ðŸ”§ Pattern
              content: |-
                <pre>1. v, ok := prefs[key]
                2. If ok -> return v
                3. Otherwise -> return fallback</pre>
          solution: |-
            func getPreference(prefs map[string]string, key string, fallback string) string {
                if v, ok := prefs[key]; ok {
                    return v
                }
                return fallback
            }
          difficulty: 1
        - id: v2
          title: Resolve Version
          description: >-
            A package manager resolves dependency versions. Write <code>func resolveVersion(registry
            map[string]string, pkg string) (string, bool)</code> that looks up a package version. Return the
            version and true if found, or "" and false otherwise.
          functionSignature: func resolveVersion(registry map[string]string, pkg string) (string, bool)
          testCases:
            - input: "map[string]string{\"gin\": \"1.9.0\", \"echo\": \"4.11.0\"}, \"gin\""
              output: "\"1.9.0\", true"
            - input: "map[string]string{\"gin\": \"1.9.0\"}, \"fiber\""
              output: "\"\", false"
          hints:
            - title: ðŸ¤” Think about it
              content: >-
                The function must indicate whether the package was found. Returning just the value would make
                it impossible to distinguish "not found" from a key with an empty version string.
            - title: ðŸ’¡ Hint
              content: >-
                Use the comma-ok pattern: v, ok := registry[pkg]. Return both values directly. The ok boolean
                tells the caller whether the package exists.
            - title: ðŸ”§ Pattern
              content: |-
                <pre>1. v, ok := registry[pkg]
                2. return v, ok</pre>
          solution: |-
            func resolveVersion(registry map[string]string, pkg string) (string, bool) {
                v, ok := registry[pkg]
                return v, ok
            }
          difficulty: 1
        - id: v3
          title: Environment Variable
          description: >-
            A config loader reads environment overrides. Write <code>func envOrDefault(env map[string]string,
            key string, defaultVal string) string</code> that returns the environment value for key if it
            exists, otherwise defaultVal.
          functionSignature: func envOrDefault(env map[string]string, key string, defaultVal string) string
          testCases:
            - input: "map[string]string{\"PORT\": \"9090\"}, \"PORT\", \"8080\""
              output: "\"9090\""
            - input: "map[string]string{\"PORT\": \"9090\"}, \"HOST\", \"localhost\""
              output: "\"localhost\""
            - input: "map[string]string{\"DEBUG\": \"\"}, \"DEBUG\", \"false\""
              output: "\"\""
          hints:
            - title: ðŸ¤” Think about it
              content: >-
                An empty string is a valid environment value (e.g. DEBUG=""). You cannot simply check if the
                result is "" to decide it is missing. What pattern distinguishes missing from empty?
            - title: ðŸ’¡ Hint
              content: >-
                Use if v, ok := env[key]; ok { return v }. The comma-ok pattern correctly handles the case
                where the value is an empty string but the key exists.
            - title: ðŸ”§ Pattern
              content: |-
                <pre>1. v, ok := env[key]
                2. If ok -> return v
                3. Otherwise -> return defaultVal</pre>
          solution: |-
            func envOrDefault(env map[string]string, key string, defaultVal string) string {
                if v, ok := env[key]; ok {
                    return v
                }
                return defaultVal
            }
          difficulty: 1
        - id: v4
          title: Is Registered
          description: >-
            A user registry checks membership. Write <code>func isRegistered(users map[string]int, username
            string) bool</code> that returns true if the username exists in the map, false otherwise.
          functionSignature: func isRegistered(users map[string]int, username string) bool
          testCases:
            - input: "map[string]int{\"alice\": 1001, \"bob\": 1002}, \"alice\""
              output: "true"
            - input: "map[string]int{\"alice\": 1001, \"bob\": 1002}, \"carol\""
              output: "false"
          hints:
            - title: ðŸ¤” Think about it
              content: >-
                You only care whether the key is present, not its value. Is there a way to discard the value
                from a map lookup?
            - title: ðŸ’¡ Hint
              content: "Use the blank identifier to discard the value: _, ok := users[username]. Return ok directly."
            - title: ðŸ”§ Pattern
              content: |-
                <pre>1. _, ok := users[username]
                2. return ok</pre>
          solution: |-
            func isRegistered(users map[string]int, username string) bool {
                _, ok := users[username]
                return ok
            }
          difficulty: 1
        - id: v5
          title: Get with Transform
          description: >-
            A pricing engine applies discounts. Write <code>func discountedPrice(prices map[string]int, item
            string, discountPercent int) int</code> that returns the price reduced by discountPercent if the
            item exists, or -1 if not found.
          functionSignature: func discountedPrice(prices map[string]int, item string, discountPercent int) int
          testCases:
            - input: "map[string]int{\"shirt\": 100, \"hat\": 40}, \"shirt\", 20"
              output: "80"
            - input: "map[string]int{\"shirt\": 100}, \"pants\", 10"
              output: "-1"
          hints:
            - title: ðŸ¤” Think about it
              content: >-
                First you need to confirm the item exists. If it does, compute the discounted price. If not,
                return a sentinel value. How does comma-ok help here?
            - title: ðŸ’¡ Hint
              content: >-
                Use if price, ok := prices[item]; ok to check existence. Compute the discount as price * (100
                - discountPercent) / 100 and return it. Otherwise return -1.
            - title: ðŸ”§ Pattern
              content: |-
                <pre>1. price, ok := prices[item]
                2. If ok -> return price * (100 - discountPercent) / 100
                3. Otherwise -> return -1</pre>
          solution: |-
            func discountedPrice(prices map[string]int, item string, discountPercent int) int {
                if price, ok := prices[item]; ok {
                    return price * (100 - discountPercent) / 100
                }
                return -1
            }
          difficulty: 2
        - id: v6
          title: Priority Fallback
          description: >-
            A notification router tries multiple channels. Write <code>func pickChannel(prefs
            map[string]string, keys []string, fallback string) string</code> that iterates through keys in
            order and returns the value for the first key found in prefs. If none are found, return fallback.
          functionSignature: func pickChannel(prefs map[string]string, keys []string, fallback string) string
          testCases:
            - input: "map[string]string{\"sms\": \"555-1234\"}, []string{\"email\", \"sms\", \"push\"}, \"none\""
              output: "\"555-1234\""
            - input: "map[string]string{\"push\": \"token123\"}, []string{\"email\", \"sms\"}, \"none\""
              output: "\"none\""
          hints:
            - title: ðŸ¤” Think about it
              content: >-
                You want to try multiple keys in priority order and stop at the first one that exists. How do
                you exit early from a loop in Go?
            - title: ðŸ’¡ Hint
              content: >-
                Loop through keys. For each key, use comma-ok to check the map. If ok is true, return the
                value immediately. If the loop finishes without finding anything, return fallback.
            - title: ðŸ”§ Pattern
              content: |-
                <pre>1. for _, k := range keys:
                   - v, ok := prefs[k]
                   - if ok -> return v
                2. return fallback</pre>
          solution: |-
            func pickChannel(prefs map[string]string, keys []string, fallback string) string {
                for _, k := range keys {
                    if v, ok := prefs[k]; ok {
                        return v
                    }
                }
                return fallback
            }
          difficulty: 2
        - id: v7
          title: Safe Sum
          description: >-
            A budget tool sums specific line items. Write <code>func safeSum(budget map[string]int, items
            []string) int</code> that sums the values for the given items, skipping any item not found in the
            budget map.
          functionSignature: func safeSum(budget map[string]int, items []string) int
          testCases:
            - input: "map[string]int{\"rent\": 1200, \"food\": 400}, []string{\"rent\", \"travel\", \"food\"}"
              output: "1600"
            - input: "map[string]int{\"rent\": 1200}, []string{\"gym\", \"coffee\"}"
              output: "0"
          hints:
            - title: ðŸ¤” Think about it
              content: >-
                You need to add values for keys that exist and skip keys that do not. How does comma-ok help
                you decide whether to include each item?
            - title: ðŸ’¡ Hint
              content: >-
                Initialize total := 0. For each item, use if v, ok := budget[item]; ok to check existence. If
                found, add v to total. Return total.
            - title: ðŸ”§ Pattern
              content: |-
                <pre>1. total := 0
                2. for _, item := range items:
                   - v, ok := budget[item]
                   - if ok -> total += v
                3. return total</pre>
          solution: |-
            func safeSum(budget map[string]int, items []string) int {
                total := 0
                for _, item := range items {
                    if v, ok := budget[item]; ok {
                        total += v
                    }
                }
                return total
            }
          difficulty: 2
        - id: v8
          title: Replace Placeholders
          description: >-
            A template engine replaces placeholders with values. Write <code>func replacePlaceholders(tokens
            []string, vars map[string]string) []string</code> that returns a new slice where each token is
            replaced by its value from vars if the key exists, or kept as-is otherwise.
          functionSignature: func replacePlaceholders(tokens []string, vars map[string]string) []string
          testCases:
            - input: "[]string{\"name\", \"likes\", \"lang\"}, map[string]string{\"name\": \"Alice\", \"lang\": \"Go\"}"
              output: "[]string{\"Alice\", \"likes\", \"Go\"}"
            - input: "[]string{\"x\", \"y\"}, map[string]string{}"
              output: "[]string{\"x\", \"y\"}"
          hints:
            - title: ðŸ¤” Think about it
              content: >-
                For each token, you need to check if a replacement exists. If it does, use it. If not, keep
                the original. What pattern handles this conditional swap?
            - title: ðŸ’¡ Hint
              content: >-
                Create a result slice. For each token, use comma-ok on vars. If ok, use the replacement value.
                Otherwise use the original token.
            - title: ðŸ”§ Pattern
              content: |-
                <pre>1. result := make([]string, len(tokens))
                2. for i, t := range tokens:
                   - v, ok := vars[t]
                   - if ok -> result[i] = v
                   - else -> result[i] = t
                3. return result</pre>
          solution: |-
            func replacePlaceholders(tokens []string, vars map[string]string) []string {
                result := make([]string, len(tokens))
                for i, t := range tokens {
                    if v, ok := vars[t]; ok {
                        result[i] = v
                    } else {
                        result[i] = t
                    }
                }
                return result
            }
          difficulty: 2
        - id: v9
          title: Update if Exists
          description: >-
            A scoring system adjusts scores only for known players. Write <code>func adjustScore(scores
            map[string]int, player string, delta int) (int, bool)</code> that adds delta to the player's score
            if they exist. Return the new score and true, or 0 and false if the player is not found.
          functionSignature: func adjustScore(scores map[string]int, player string, delta int) (int, bool)
          testCases:
            - input: "map[string]int{\"alice\": 50, \"bob\": 30}, \"alice\", 10"
              output: 60, true
            - input: "map[string]int{\"alice\": 50}, \"carol\", 10"
              output: 0, false
          hints:
            - title: ðŸ¤” Think about it
              content: >-
                You should only modify the map if the player already has a score. How do you conditionally
                update a map entry and report whether it happened?
            - title: ðŸ’¡ Hint
              content: >-
                Use comma-ok to check if the player exists. If ok, update scores[player] += delta and return
                the new value with true. Otherwise return 0, false.
            - title: ðŸ”§ Pattern
              content: |-
                <pre>1. v, ok := scores[player]
                2. if ok -> scores[player] = v + delta; return v + delta, true
                3. return 0, false</pre>
          solution: |-
            func adjustScore(scores map[string]int, player string, delta int) (int, bool) {
                if v, ok := scores[player]; ok {
                    scores[player] = v + delta
                    return v + delta, true
                }
                return 0, false
            }
          difficulty: 2
        - id: v10
          title: Chained Lookup
          description: >-
            A DNS resolver follows CNAME chains. Write <code>func resolveChain(aliases map[string]string,
            start string) string</code> that follows the chain of lookups until a key is not found, then
            returns the last resolved value. If the start key itself is not found, return start.
          functionSignature: func resolveChain(aliases map[string]string, start string) string
          testCases:
            - input: "map[string]string{\"a\": \"b\", \"b\": \"c\", \"c\": \"final\"}, \"a\""
              output: "\"final\""
            - input: "map[string]string{\"a\": \"b\"}, \"a\""
              output: "\"b\""
            - input: "map[string]string{\"a\": \"b\"}, \"z\""
              output: "\"z\""
          hints:
            - title: ðŸ¤” Think about it
              content: >-
                You need to keep looking up the result in the map until it no longer appears as a key. This is
                a loop that uses comma-ok to decide when to stop.
            - title: ðŸ’¡ Hint
              content: >-
                Set current := start. In a loop, use v, ok := aliases[current]. If ok, set current = v and
                continue. If not ok, break and return current.
            - title: ðŸ”§ Pattern
              content: |-
                <pre>1. current := start
                2. Loop:
                   - v, ok := aliases[current]
                   - if ok -> current = v
                   - else -> break
                3. return current</pre>
          solution: |-
            func resolveChain(aliases map[string]string, start string) string {
                current := start
                for {
                    v, ok := aliases[current]
                    if !ok {
                        break
                    }
                    current = v
                }
                return current
            }
          difficulty: 3
        - id: v11
          title: Nested Safe Lookup
          description: >-
            A configuration system uses nested maps. Write <code>func nestedLookup(config
            map[string]map[string]string, section string, key string, fallback string) string</code> that
            returns config[section][key] if both the section and key exist, otherwise returns fallback.
          functionSignature: >-
            func nestedLookup(config map[string]map[string]string, section string, key string, fallback
            string) string
          testCases:
            - input: "map[string]map[string]string{\"db\": {\"host\": \"localhost\"}}, \"db\", \"host\", \"unknown\""
              output: "\"localhost\""
            - input: "map[string]map[string]string{\"db\": {\"host\": \"localhost\"}}, \"cache\", \"host\", \"unknown\""
              output: "\"unknown\""
            - input: "map[string]map[string]string{\"db\": {\"host\": \"localhost\"}}, \"db\", \"port\", \"5432\""
              output: "\"5432\""
          hints:
            - title: ðŸ¤” Think about it
              content: >-
                With nested maps you need two comma-ok checks: first for the outer key, then for the inner
                key. If either fails, return the fallback.
            - title: ðŸ’¡ Hint
              content: >-
                First check if inner, ok := config[section]; ok. If the section exists, check if v, ok :=
                inner[key]; ok. If both succeed, return v. Otherwise return fallback.
            - title: ðŸ”§ Pattern
              content: |-
                <pre>1. inner, ok := config[section]
                2. if !ok -> return fallback
                3. v, ok := inner[key]
                4. if ok -> return v
                5. return fallback</pre>
          solution: >-
            func nestedLookup(config map[string]map[string]string, section string, key string, fallback
            string) string {
                if inner, ok := config[section]; ok {
                    if v, ok := inner[key]; ok {
                        return v
                    }
                }
                return fallback
            }
          difficulty: 3
        - id: v12
          title: Collect Translated
          description: >-
            A localization system translates a list of UI labels. Write <code>func translateLabels(labels
            []string, dict map[string]string) ([]string, []string)</code> that returns two slices: translated
            labels (using dict value if found, original if not) and a slice of labels that were missing from
            the dictionary.
          functionSignature: func translateLabels(labels []string, dict map[string]string) ([]string, []string)
          testCases:
            - input: "[]string{\"save\", \"cancel\", \"ok\"}, map[string]string{\"save\": \"guardar\", \"ok\": \"aceptar\"}"
              output: "[]string{\"guardar\", \"cancel\", \"aceptar\"}, []string{\"cancel\"}"
            - input: "[]string{\"hello\"}, map[string]string{\"hello\": \"hola\"}"
              output: "[]string{\"hola\"}, []string{}"
          hints:
            - title: ðŸ¤” Think about it
              content: >-
                You need to process each label and track two things: the translated output and which labels
                had no translation. The comma-ok pattern tells you both in one check.
            - title: ðŸ’¡ Hint
              content: >-
                Create two result slices. For each label, use v, ok := dict[label]. If ok, append v to
                translated. If not ok, append the original label to translated AND append it to the missing
                list.
            - title: ðŸ”§ Pattern
              content: |-
                <pre>1. translated := []string{}, missing := []string{}
                2. for _, label := range labels:
                   - v, ok := dict[label]
                   - if ok -> append v to translated
                   - else -> append label to translated and missing
                3. return translated, missing</pre>
          solution: |-
            func translateLabels(labels []string, dict map[string]string) ([]string, []string) {
                translated := []string{}
                missing := []string{}
                for _, label := range labels {
                    if v, ok := dict[label]; ok {
                        translated = append(translated, v)
                    } else {
                        translated = append(translated, label)
                        missing = append(missing, label)
                    }
                }
                return translated, missing
            }
          difficulty: 3
        - id: v13
          title: Multi-Map Lookup
          description: >-
            A configuration system checks multiple override layers. Write <code>func multiLookup(layers
            []map[string]string, key string) (string, bool)</code> that searches through layers in order and
            returns the value from the first layer where the key exists. If no layer contains the key, return
            "" and false.
          functionSignature: func multiLookup(layers []map[string]string, key string) (string, bool)
          testCases:
            - input: "[]map[string]string{{\"a\": \"1\"}, {\"a\": \"2\", \"b\": \"3\"}}, \"b\""
              output: "\"3\", true"
            - input: "[]map[string]string{{\"a\": \"1\"}, {\"a\": \"2\"}}, \"a\""
              output: "\"1\", true"
            - input: "[]map[string]string{{\"a\": \"1\"}}, \"z\""
              output: "\"\", false"
          hints:
            - title: ðŸ¤” Think about it
              content: >-
                You need to search through an ordered list of maps and stop at the first one that contains the
                key. This is like a chain of overrides where earlier layers have higher priority.
            - title: ðŸ’¡ Hint
              content: >-
                Loop through the layers slice. For each layer, use v, ok := layer[key]. If ok, return v and
                true immediately. After the loop, return "" and false.
            - title: ðŸ”§ Pattern
              content: |-
                <pre>1. for _, layer := range layers:
                   - v, ok := layer[key]
                   - if ok -> return v, true
                2. return "", false</pre>
          solution: |-
            func multiLookup(layers []map[string]string, key string) (string, bool) {
                for _, layer := range layers {
                    if v, ok := layer[key]; ok {
                        return v, true
                    }
                }
                return "", false
            }
          difficulty: 3
    - id: challenge_13
      block: 1
      difficulty: 2
      concept: "Strings & Runes"
      docLinks:
        - url: https://go.dev/blog/strings
          title: "Go Blog: Strings, bytes, runes and characters"
          note: string internals
        - url: https://go.dev/ref/spec#String_types
          title: "Go Spec: String types"
          note: string specification
      patternPrimer:
        bruteForce: Treat strings as byte arrays and hope for ASCII.
        bestApproach: "Use []rune(s) for Unicode-safe character operations; range over string iterates runes automatically."
        typical: "len(s) returns bytes; len([]rune(s)) returns character count. Know the difference."
      variants:
        - id: v1
          title: Normalize Command
          description: >-
            A CLI tool normalizes command names to lowercase before dispatch. Write <code>func
            normalizeCmd(cmd string) string</code> that returns the lowercased version of the command string
            using <code>strings.ToLower</code>.
          functionSignature: func normalizeCmd(cmd string) string
          testCases:
            - input: "\"BUILD\""
              output: "\"build\""
            - input: "\"Deploy\""
              output: "\"deploy\""
            - input: "\"status\""
              output: "\"status\""
          hints:
            - title: ðŸ¤” Think about it
              content: >-
                Go's strings package provides functions for common string transformations. Which function
                converts an entire string to lowercase?
            - title: ðŸ’¡ Hint
              content: >-
                Use <code>strings.ToLower(cmd)</code> which returns a new string with all Unicode letters
                mapped to their lowercase equivalents.
            - title: ðŸ”§ Pattern
              content: <pre>1. Return strings.ToLower(cmd)</pre>
          solution: |-
            func normalizeCmd(cmd string) string {
                return strings.ToLower(cmd)
            }
          difficulty: 1
        - id: v2
          title: Has File Extension
          description: >-
            A file manager checks whether a filename has a given extension. Write <code>func
            hasExtension(filename, ext string) bool</code> that returns true if the filename ends with the
            given extension (e.g., ".go"). Use <code>strings.HasSuffix</code>.
          functionSignature: func hasExtension(filename, ext string) bool
          testCases:
            - input: "\"main.go\", \".go\""
              output: "true"
            - input: "\"readme.md\", \".go\""
              output: "false"
            - input: "\"archive.tar.gz\", \".gz\""
              output: "true"
          hints:
            - title: ðŸ¤” Think about it
              content: >-
                You need to check whether a string ends with a particular suffix. Go's strings package has a
                dedicated function for this check.
            - title: ðŸ’¡ Hint
              content: >-
                Use <code>strings.HasSuffix(filename, ext)</code> which returns true if the filename string
                ends with the ext string.
            - title: ðŸ”§ Pattern
              content: <pre>1. Return strings.HasSuffix(filename, ext)</pre>
          solution: |-
            func hasExtension(filename, ext string) bool {
                return strings.HasSuffix(filename, ext)
            }
          difficulty: 1
        - id: v3
          title: Contains Substring
          description: >-
            A search tool checks if a log line contains a keyword. Write <code>func containsKeyword(line,
            keyword string) bool</code> that returns true if the keyword appears anywhere in the line,
            case-insensitively.
          functionSignature: func containsKeyword(line, keyword string) bool
          testCases:
            - input: "\"ERROR: disk full\", \"error\""
              output: "true"
            - input: "\"INFO: started\", \"error\""
              output: "false"
            - input: "\"Warning: low memory\", \"warning\""
              output: "true"
          hints:
            - title: ðŸ¤” Think about it
              content: >-
                For a case-insensitive search, you need to normalize both strings to the same case before
                checking. Which strings package function checks for containment?
            - title: ðŸ’¡ Hint
              content: >-
                Convert both strings to lowercase with <code>strings.ToLower</code>, then use
                <code>strings.Contains</code> to check if the keyword is present.
            - title: ðŸ”§ Pattern
              content: |-
                <pre>1. Convert line to lowercase
                2. Convert keyword to lowercase
                3. Return strings.Contains(lowerLine, lowerKeyword)</pre>
          solution: |-
            func containsKeyword(line, keyword string) bool {
                return strings.Contains(strings.ToLower(line), strings.ToLower(keyword))
            }
          difficulty: 1
        - id: v4
          title: Shout Message
          description: >-
            A notification system converts messages to uppercase for urgent alerts. Write <code>func shout(msg
            string) string</code> that returns the message in all uppercase using
            <code>strings.ToUpper</code>, with an exclamation mark appended.
          functionSignature: func shout(msg string) string
          testCases:
            - input: "\"server down\""
              output: "\"SERVER DOWN!\""
            - input: "\"help\""
              output: "\"HELP!\""
            - input: "\"Alert\""
              output: "\"ALERT!\""
          hints:
            - title: ðŸ¤” Think about it
              content: >-
                You need to transform the string to uppercase and add a character at the end. Go strings can
                be concatenated with the + operator.
            - title: ðŸ’¡ Hint
              content: >-
                Use <code>strings.ToUpper(msg)</code> to convert to uppercase, then concatenate "!" using the
                + operator.
            - title: ðŸ”§ Pattern
              content: |-
                <pre>1. upper := strings.ToUpper(msg)
                2. Return upper + "!"</pre>
          solution: |-
            func shout(msg string) string {
                return strings.ToUpper(msg) + "!"
            }
          difficulty: 1
        - id: v5
          title: Mask Email
          description: >-
            A log formatter masks sensitive email addresses. Write <code>func maskEmail(email string)
            string</code> that replaces everything before the '@' with "***". If the string contains no '@',
            return it unchanged.
          functionSignature: func maskEmail(email string) string
          testCases:
            - input: "\"alice@example.com\""
              output: "\"***@example.com\""
            - input: "\"bob.smith@corp.io\""
              output: "\"***@corp.io\""
            - input: "\"no-at-sign\""
              output: "\"no-at-sign\""
          hints:
            - title: ðŸ¤” Think about it
              content: >-
                You need to find the position of '@' in the string, then replace everything before it. What
                function finds the index of a character in a string?
            - title: ðŸ’¡ Hint
              content: >-
                Use <code>strings.Index(email, "@")</code> to find the '@' position. If it returns -1, there's
                no '@'. Otherwise, concatenate "***" with the substring from '@' onward using slice syntax
                <code>email[idx:]</code>.
            - title: ðŸ”§ Pattern
              content: |-
                <pre>1. idx := strings.Index(email, "@")
                2. If idx == -1 -> return email unchanged
                3. Return "***" + email[idx:]</pre>
          solution: |-
            func maskEmail(email string) string {
                idx := strings.Index(email, "@")
                if idx == -1 {
                    return email
                }
                return "***" + email[idx:]
            }
          difficulty: 2
        - id: v6
          title: Extract Domain
          description: >-
            A URL parser extracts the domain from a URL string. Write <code>func extractDomain(url string)
            string</code> that removes the "https://" or "http://" prefix and strips everything after the
            first '/' in the remaining string. Use <code>strings.TrimPrefix</code> and
            <code>strings.Split</code>.
          functionSignature: func extractDomain(url string) string
          testCases:
            - input: "\"https://example.com/path\""
              output: "\"example.com\""
            - input: "\"http://go.dev/doc\""
              output: "\"go.dev\""
            - input: "\"https://localhost\""
              output: "\"localhost\""
          hints:
            - title: ðŸ¤” Think about it
              content: >-
                You need to remove a prefix and then isolate the domain before the first '/'. Go's strings
                package has functions for both prefix removal and splitting.
            - title: ðŸ’¡ Hint
              content: >-
                First strip "https://" with <code>strings.TrimPrefix</code>, then try "http://". After that,
                split on "/" and take the first part to get just the domain.
            - title: ðŸ”§ Pattern
              content: |-
                <pre>1. Strip "https://" prefix
                2. Strip "http://" prefix
                3. Split on "/"
                4. Return first element</pre>
          solution: |-
            func extractDomain(url string) string {
                s := strings.TrimPrefix(url, "https://")
                s = strings.TrimPrefix(s, "http://")
                parts := strings.Split(s, "/")
                return parts[0]
            }
          difficulty: 2
        - id: v7
          title: Sanitize Tag
          description: >-
            A tagging system sanitizes user input by trimming whitespace and converting to lowercase. Write
            <code>func sanitizeTag(tag string) string</code> that trims leading/trailing spaces with
            <code>strings.TrimSpace</code>, replaces internal spaces with hyphens using
            <code>strings.ReplaceAll</code>, and lowercases the result.
          functionSignature: func sanitizeTag(tag string) string
          testCases:
            - input: "\"  Hello World  \""
              output: "\"hello-world\""
            - input: "\"Go Lang\""
              output: "\"go-lang\""
            - input: "\"already-clean\""
              output: "\"already-clean\""
          hints:
            - title: ðŸ¤” Think about it
              content: >-
                You need to chain three string transformations: trim whitespace, replace spaces, and convert
                case. The order matters â€” trim first so edge spaces don't create leading/trailing hyphens.
            - title: ðŸ’¡ Hint
              content: >-
                Use <code>strings.TrimSpace</code> first, then <code>strings.ReplaceAll(s, " ", "-")</code> to
                swap spaces for hyphens, then <code>strings.ToLower</code> to lowercase.
            - title: ðŸ”§ Pattern
              content: |-
                <pre>1. Trim whitespace with strings.TrimSpace
                2. Replace spaces with hyphens
                3. Convert to lowercase
                4. Return result</pre>
          solution: |-
            func sanitizeTag(tag string) string {
                s := strings.TrimSpace(tag)
                s = strings.ReplaceAll(s, " ", "-")
                return strings.ToLower(s)
            }
          difficulty: 2
        - id: v8
          title: CSV Line Joiner
          description: >-
            A data exporter builds CSV lines from field slices. Write <code>func toCSVLine(fields []string)
            string</code> that joins the fields with commas using <code>strings.Join</code> and trims any
            whitespace from each field first.
          functionSignature: func toCSVLine(fields []string) string
          testCases:
            - input: "[]string{\"name\", \" age \", \"city\"}"
              output: "\"name,age,city\""
            - input: "[]string{\" go \", \" rust \"}"
              output: "\"go,rust\""
            - input: "[]string{\"solo\"}"
              output: "\"solo\""
          hints:
            - title: ðŸ¤” Think about it
              content: >-
                You need to first clean each field by removing whitespace, then combine them with commas. This
                requires iterating over the slice and modifying each element before joining.
            - title: ðŸ’¡ Hint
              content: >-
                Loop through the fields slice and apply <code>strings.TrimSpace</code> to each element. Then
                use <code>strings.Join(fields, ",")</code> to combine them with commas.
            - title: ðŸ”§ Pattern
              content: |-
                <pre>1. For each field, trim whitespace
                2. Join all fields with ","
                3. Return the joined string</pre>
          solution: |-
            func toCSVLine(fields []string) string {
                for i, f := range fields {
                    fields[i] = strings.TrimSpace(f)
                }
                return strings.Join(fields, ",")
            }
          difficulty: 2
        - id: v9
          title: Initials Extractor
          description: >-
            A user profile system generates initials from a full name. Write <code>func initials(name string)
            string</code> that splits the name on spaces, takes the first rune of each word, uppercases it,
            and joins them with dots. For example, "john doe" becomes "J.D".
          functionSignature: func initials(name string) string
          testCases:
            - input: "\"john doe\""
              output: "\"J.D\""
            - input: "\"Alice Bob Charlie\""
              output: "\"A.B.C\""
            - input: "\"go\""
              output: "\"G\""
          hints:
            - title: ðŸ¤” Think about it
              content: >-
                You need to split into words, extract the first character of each, uppercase it, and join with
                dots. This combines splitting, rune conversion, and string building.
            - title: ðŸ’¡ Hint
              content: >-
                Use <code>strings.Fields</code> to split. For each word, get the first rune with
                <code>[]rune(word)[0]</code>, uppercase it with <code>unicode.ToUpper</code>, and convert to
                string. Collect into a slice and join with ".".
            - title: ðŸ”§ Pattern
              content: |-
                <pre>1. words := strings.Fields(name)
                2. For each word:
                   - Get first rune
                   - Uppercase it
                   - Append string(rune) to parts slice
                3. Return strings.Join(parts, ".")</pre>
          solution: |-
            func initials(name string) string {
                words := strings.Fields(name)
                parts := []string{}
                for _, w := range words {
                    r := []rune(w)[0]
                    parts = append(parts, string(unicode.ToUpper(r)))
                }
                return strings.Join(parts, ".")
            }
          difficulty: 2
        - id: v10
          title: Rune-Safe Substring
          description: >-
            A text editor needs to extract a substring by rune positions. Write <code>func runeSubstring(s
            string, start, end int) string</code> that returns the substring from rune index start (inclusive)
            to end (exclusive). Handle multi-byte characters correctly. If start or end are out of bounds,
            clamp them to valid range.
          functionSignature: func runeSubstring(s string, start, end int) string
          testCases:
            - input: "\"Hello, ä¸–ç•Œ\", 7, 9"
              output: "\"ä¸–ç•Œ\""
            - input: "\"abcdef\", 1, 4"
              output: "\"bcd\""
            - input: "\"go\", 0, 100"
              output: "\"go\""
          hints:
            - title: ðŸ¤” Think about it
              content: >-
                Byte-based slicing (s[start:end]) would break multi-byte characters. You need to work with
                runes to correctly index by character position. Also consider edge cases for out-of-bounds
                indices.
            - title: ðŸ’¡ Hint
              content: >-
                Convert to <code>[]rune(s)</code>. Clamp start to [0, len(runes)] and end to [start,
                len(runes)]. Then slice the rune array and convert back to string.
            - title: ðŸ”§ Pattern
              content: |-
                <pre>1. runes := []rune(s)
                2. Clamp start: max(0, min(start, len(runes)))
                3. Clamp end: max(start, min(end, len(runes)))
                4. Return string(runes[start:end])</pre>
          solution: |-
            func runeSubstring(s string, start, end int) string {
                runes := []rune(s)
                n := len(runes)
                if start < 0 {
                    start = 0
                }
                if start > n {
                    start = n
                }
                if end < start {
                    end = start
                }
                if end > n {
                    end = n
                }
                return string(runes[start:end])
            }
          difficulty: 3
        - id: v11
          title: Count Unicode Categories
          description: >-
            A text analyzer categorizes characters. Write <code>func countCategories(s string) (int, int,
            int)</code> that returns three counts: letters, digits, and other characters (including spaces and
            punctuation). Use <code>unicode.IsLetter</code> and <code>unicode.IsDigit</code> for correct
            Unicode handling.
          functionSignature: func countCategories(s string) (int, int, int)
          testCases:
            - input: "\"Hello 123!\""
              output: 5, 3, 2
              note: 5 letters, 3 digits, space + exclamation = 2 other
            - input: "\"abc\""
              output: 3, 0, 0
            - input: "\"Ã©lÃ¨ve 42\""
              output: 5, 2, 1
              note: accented letters count as letters
          hints:
            - title: ðŸ¤” Think about it
              content: >-
                You need to classify each character into one of three categories. The unicode package provides
                functions that correctly classify Unicode characters beyond just ASCII.
            - title: ðŸ’¡ Hint
              content: >-
                Range over the string to get runes. For each rune, check <code>unicode.IsLetter(r)</code>
                first, then <code>unicode.IsDigit(r)</code>. If neither, it's in the "other" category.
                Increment the appropriate counter.
            - title: ðŸ”§ Pattern
              content: |-
                <pre>1. letters, digits, other := 0, 0, 0
                2. For each rune r in s:
                   - If unicode.IsLetter(r) -> letters++
                   - Else if unicode.IsDigit(r) -> digits++
                   - Else -> other++
                3. Return letters, digits, other</pre>
          solution: |-
            func countCategories(s string) (int, int, int) {
                letters, digits, other := 0, 0, 0
                for _, r := range s {
                    if unicode.IsLetter(r) {
                        letters++
                    } else if unicode.IsDigit(r) {
                        digits++
                    } else {
                        other++
                    }
                }
                return letters, digits, other
            }
          difficulty: 3
        - id: v12
          title: Word Wrap
          description: >-
            A terminal formatter wraps long text to a given width. Write <code>func wordWrap(s string, width
            int) []string</code> that splits the string into lines where each line is at most width runes
            long. Break only at spaces; if a single word is longer than width, place it on its own line.
          functionSignature: func wordWrap(s string, width int) []string
          testCases:
            - input: "\"the quick brown fox\", 10"
              output: "[]string{\"the quick\", \"brown fox\"}"
            - input: "\"hello world\", 5"
              output: "[]string{\"hello\", \"world\"}"
            - input: "\"superlongword ok\", 6"
              output: "[]string{\"superlongword\", \"ok\"}"
          hints:
            - title: ðŸ¤” Think about it
              content: >-
                You need to split into words and then greedily fit as many words as possible on each line
                without exceeding the width. Track the current line length in runes, not bytes.
            - title: ðŸ’¡ Hint
              content: >-
                Use <code>strings.Fields</code> to get words. Build lines by appending words while the rune
                length stays within width. When adding a word would exceed the limit, start a new line.
            - title: ðŸ”§ Pattern
              content: |-
                <pre>1. Split into words
                2. currentLine := first word
                3. For each remaining word:
                   - If len(currentLine) + 1 + len(word) <= width:
                     - Append word to currentLine with space
                   - Else:
                     - Save currentLine to results
                     - Start new currentLine with word
                4. Save final currentLine
                5. Return results</pre>
          solution: |-
            func wordWrap(s string, width int) []string {
                words := strings.Fields(s)
                if len(words) == 0 {
                    return []string{}
                }
                lines := []string{}
                current := words[0]
                for _, w := range words[1:] {
                    if len([]rune(current))+1+len([]rune(w)) <= width {
                        current += " " + w
                    } else {
                        lines = append(lines, current)
                        current = w
                    }
                }
                lines = append(lines, current)
                return lines
            }
          difficulty: 3
        - id: v13
          title: Normalize Whitespace
          description: >-
            A text processor normalizes irregular whitespace. Write <code>func normalizeWhitespace(s string)
            string</code> that collapses all consecutive whitespace characters (spaces, tabs, newlines) into
            single spaces, trims leading and trailing whitespace, and preserves non-ASCII runes correctly.
          functionSignature: func normalizeWhitespace(s string) string
          testCases:
            - input: "\"  hello   world  \""
              output: "\"hello world\""
            - input: "\"line1\\n\\tline2\""
              output: "\"line1 line2\""
            - input: "\"Ã©lÃ¨ve\\t  du\\n monde\""
              output: "\"Ã©lÃ¨ve du monde\""
          hints:
            - title: ðŸ¤” Think about it
              content: >-
                Go's <code>strings.Fields</code> splits on any whitespace and removes empty entries. If you
                then rejoin the result with single spaces, you get collapsed whitespace. But can you do it
                manually with rune iteration?
            - title: ðŸ’¡ Hint
              content: >-
                The simplest approach: <code>strings.Fields(s)</code> handles all whitespace types and removes
                empties, then <code>strings.Join</code> with a single space produces the normalized result.
            - title: ðŸ”§ Pattern
              content: |-
                <pre>1. words := strings.Fields(s)
                2. Return strings.Join(words, " ")</pre>
          solution: |-
            func normalizeWhitespace(s string) string {
                return strings.Join(strings.Fields(s), " ")
            }
          difficulty: 3
    - id: challenge_14
      block: 1
      difficulty: 3
      concept: "Go Fundamentals Combined"
      docLinks:
        - url: https://go.dev/doc/effective_go
          title: "Effective Go"
          note: comprehensive Go guide
        - url: https://go.dev/tour/welcome/1
          title: "A Tour of Go"
          note: complete Go tutorial
      patternPrimer:
        bruteForce: Solve each sub-problem independently without leveraging Go idioms.
        bestApproach: Combine slices, maps, loops, functions, and error handling into cohesive solutions using idiomatic Go.
        typical: Multi-step problems test your ability to choose the right tool from your Go toolkit.
      variants:
        - id: v1
          title: Rollout Summary
          description: >-
            A deployment tool summarizes rollout status. Write <code>func rolloutSummary(statuses []string)
            map[string]int</code> that takes a slice of service statuses (each is "running", "pending", or
            "failed") and returns a map counting how many services have each status.
          functionSignature: func rolloutSummary(statuses []string) map[string]int
          testCases:
            - input: "[]string{\"running\", \"failed\", \"running\", \"pending\", \"running\"}"
              output: "map[string]int{\"running\": 3, \"failed\": 1, \"pending\": 1}"
            - input: "[]string{\"pending\", \"pending\"}"
              output: "map[string]int{\"pending\": 2}"
            - input: "[]string{}"
              output: map[string]int{}
          hints:
            - title: ðŸ¤” Think about it
              content: >-
                You need to count occurrences of each status string. A map is ideal for counting because Go's
                zero value for int is 0, so you can increment missing keys directly.
            - title: ðŸ’¡ Hint
              content: >-
                Create a map with <code>make(map[string]int)</code>. Range over the statuses slice and
                increment each status count with <code>counts[status]++</code>.
            - title: ðŸ”§ Pattern
              content: |-
                <pre>1. counts := make(map[string]int)
                2. For each status in statuses:
                   - counts[status]++
                3. Return counts</pre>
          solution: |-
            func rolloutSummary(statuses []string) map[string]int {
                counts := make(map[string]int)
                for _, s := range statuses {
                    counts[s]++
                }
                return counts
            }
          difficulty: 1
        - id: v2
          title: Filter and Transform
          description: >-
            A data pipeline filters numbers and formats them. Write <code>func filterAndLabel(nums []int,
            threshold int) []string</code> that keeps only numbers greater than the threshold and returns them
            as formatted strings "value: N".
          functionSignature: func filterAndLabel(nums []int, threshold int) []string
          testCases:
            - input: "[]int{10, 5, 20, 3, 15}, 8"
              output: "[]string{\"value: 10\", \"value: 20\", \"value: 15\"}"
            - input: "[]int{1, 2, 3}, 10"
              output: "[]string{}"
            - input: "[]int{100}, 0"
              output: "[]string{\"value: 100\"}"
          hints:
            - title: ðŸ¤” Think about it
              content: >-
                This combines filtering (conditional logic) with formatting (string conversion). You need to
                check each number against the threshold and format the keepers.
            - title: ðŸ’¡ Hint
              content: >-
                Range over nums. For each number that exceeds the threshold, use <code>fmt.Sprintf("value:
                %d", n)</code> to format it and append to a result slice.
            - title: ðŸ”§ Pattern
              content: |-
                <pre>1. result := []string{}
                2. For each num in nums:
                   - If num > threshold:
                     - Append fmt.Sprintf("value: %d", num)
                3. Return result</pre>
          solution: |-
            func filterAndLabel(nums []int, threshold int) []string {
                result := []string{}
                for _, n := range nums {
                    if n > threshold {
                        result = append(result, fmt.Sprintf("value: %d", n))
                    }
                }
                return result
            }
          difficulty: 1
        - id: v3
          title: Max and Index
          description: >-
            A monitoring system finds the peak reading from sensor data. Write <code>func
            maxWithIndex(readings []int) (int, int)</code> that returns the maximum value and the index where
            it occurs. If the slice is empty, return 0 and -1.
          functionSignature: func maxWithIndex(readings []int) (int, int)
          testCases:
            - input: "[]int{3, 7, 2, 9, 4}"
              output: 9, 3
            - input: "[]int{5}"
              output: 5, 0
            - input: "[]int{}"
              output: 0, -1
          hints:
            - title: ðŸ¤” Think about it
              content: >-
                This combines multiple returns (Go functions can return more than one value) with loop logic
                to track both the maximum value and its position. How do you handle the empty slice edge case?
            - title: ðŸ’¡ Hint
              content: >-
                Check for empty first. Initialize max to readings[0] and maxIdx to 0. Loop through the rest,
                updating both whenever you find a larger value. Return both using Go's multiple return syntax.
            - title: ðŸ”§ Pattern
              content: |-
                <pre>1. If empty -> return 0, -1
                2. maxVal := readings[0], maxIdx := 0
                3. For i, v := range readings:
                   - If v > maxVal: update maxVal and maxIdx
                4. Return maxVal, maxIdx</pre>
          solution: |-
            func maxWithIndex(readings []int) (int, int) {
                if len(readings) == 0 {
                    return 0, -1
                }
                maxVal := readings[0]
                maxIdx := 0
                for i, v := range readings {
                    if v > maxVal {
                        maxVal = v
                        maxIdx = i
                    }
                }
                return maxVal, maxIdx
            }
          difficulty: 1
        - id: v4
          title: Environment Lookup
          description: >-
            A config loader resolves environment variables with defaults. Write <code>func envOrDefault(env
            map[string]string, key, fallback string) string</code> that returns the value from the env map if
            the key exists (using comma-ok), or the fallback string otherwise.
          functionSignature: func envOrDefault(env map[string]string, key, fallback string) string
          testCases:
            - input: "map[string]string{\"PORT\": \"8080\", \"HOST\": \"localhost\"}, \"PORT\", \"3000\""
              output: "\"8080\""
            - input: "map[string]string{\"PORT\": \"8080\"}, \"HOST\", \"0.0.0.0\""
              output: "\"0.0.0.0\""
            - input: map[string]string{}, "DB", "sqlite"
              output: "\"sqlite\""
          hints:
            - title: ðŸ¤” Think about it
              content: >-
                Go maps return the zero value for missing keys. To distinguish between a missing key and a key
                with an empty value, you need the comma-ok pattern. How does comma-ok work with map lookups?
            - title: ðŸ’¡ Hint
              content: >-
                Use <code>val, ok := env[key]</code>. If ok is true, the key exists â€” return val. Otherwise,
                return the fallback string.
            - title: ðŸ”§ Pattern
              content: |-
                <pre>1. val, ok := env[key]
                2. If ok -> return val
                3. Return fallback</pre>
          solution: |-
            func envOrDefault(env map[string]string, key, fallback string) string {
                if val, ok := env[key]; ok {
                    return val
                }
                return fallback
            }
          difficulty: 1
        - id: v5
          title: Parse Key-Value Pairs
          description: >-
            A config parser reads "key=value" strings into a map. Write <code>func parseKV(pairs []string)
            (map[string]string, error)</code> that splits each string on the first "=" sign. Return an error
            if any string does not contain "=".
          functionSignature: func parseKV(pairs []string) (map[string]string, error)
          testCases:
            - input: "[]string{\"host=localhost\", \"port=8080\"}"
              output: "map[string]string{\"host\": \"localhost\", \"port\": \"8080\"}, nil"
            - input: "[]string{\"key=val=ue\"}"
              output: "map[string]string{\"key\": \"val=ue\"}, nil"
              note: splits on first = only
            - input: "[]string{\"invalid\"}"
              output: nil, error
              note: no = sign
          hints:
            - title: ðŸ¤” Think about it
              content: >-
                This combines string splitting, map building, and error handling. You need to split on the
                first "=" only â€” <code>strings.SplitN</code> lets you limit the number of splits. How do you
                detect the error case?
            - title: ðŸ’¡ Hint
              content: >-
                Use <code>strings.SplitN(pair, "=", 2)</code> to split into at most 2 parts. If the result has
                only 1 part, there was no "=" â€” return an error with <code>fmt.Errorf</code>. Otherwise, store
                parts[0] as key and parts[1] as value in the map.
            - title: ðŸ”§ Pattern
              content: |-
                <pre>1. result := make(map[string]string)
                2. For each pair:
                   - parts := strings.SplitN(pair, "=", 2)
                   - If len(parts) < 2 -> return nil, error
                   - result[parts[0]] = parts[1]
                3. Return result, nil</pre>
          solution: |-
            func parseKV(pairs []string) (map[string]string, error) {
                result := make(map[string]string)
                for _, p := range pairs {
                    parts := strings.SplitN(p, "=", 2)
                    if len(parts) < 2 {
                        return nil, fmt.Errorf("invalid pair: %s", p)
                    }
                    result[parts[0]] = parts[1]
                }
                return result, nil
            }
          difficulty: 2
        - id: v6
          title: Bucket Scores
          description: >-
            A grading system buckets student scores into letter grades. Write <code>func bucketScores(scores
            map[string]int) map[string][]string</code> that takes a map of student names to scores and returns
            a map of grade letters ("A", "B", "C", "D", "F") to slices of student names. Grades: A >= 90, B >=
            80, C >= 70, D >= 60, F < 60.
          functionSignature: func bucketScores(scores map[string]int) map[string][]string
          testCases:
            - input: "map[string]int{\"alice\": 95, \"bob\": 72, \"carol\": 88}"
              output: "map[string][]string{\"A\": {\"alice\"}, \"B\": {\"carol\"}, \"C\": {\"bob\"}}"
            - input: "map[string]int{\"dan\": 45}"
              output: "map[string][]string{\"F\": {\"dan\"}}"
          hints:
            - title: ðŸ¤” Think about it
              content: >-
                This combines map iteration, conditional logic (to determine the grade), and building a map of
                slices. You need to iterate over the input map, classify each score, and append the name to
                the right bucket.
            - title: ðŸ’¡ Hint
              content: >-
                Create a result map. For each student, determine the grade using if/else chains. Append the
                student name to the appropriate slice in the result map. Go's append works even on nil slices.
            - title: ðŸ”§ Pattern
              content: |-
                <pre>1. result := make(map[string][]string)
                2. For each name, score in scores:
                   - Determine grade letter (A/B/C/D/F)
                   - result[grade] = append(result[grade], name)
                3. Return result</pre>
          solution: |-
            func bucketScores(scores map[string]int) map[string][]string {
                result := make(map[string][]string)
                for name, score := range scores {
                    var grade string
                    if score >= 90 {
                        grade = "A"
                    } else if score >= 80 {
                        grade = "B"
                    } else if score >= 70 {
                        grade = "C"
                    } else if score >= 60 {
                        grade = "D"
                    } else {
                        grade = "F"
                    }
                    result[grade] = append(result[grade], name)
                }
                return result
            }
          difficulty: 2
        - id: v7
          title: Merge Configs
          description: >-
            A config merger combines two config maps, where the second overrides the first. Write <code>func
            mergeConfigs(base, override map[string]string) map[string]string</code> that returns a new map
            containing all keys from both maps, with override values taking precedence.
          functionSignature: func mergeConfigs(base, override map[string]string) map[string]string
          testCases:
            - input: >-
                map[string]string{"port": "3000", "host": "localhost"}, map[string]string{"port": "8080",
                "debug": "true"}
              output: "map[string]string{\"port\": \"8080\", \"host\": \"localhost\", \"debug\": \"true\"}"
            - input: "map[string]string{\"a\": \"1\"}, map[string]string{}"
              output: "map[string]string{\"a\": \"1\"}"
          hints:
            - title: ðŸ¤” Think about it
              content: >-
                You need to iterate over two maps and build a new one. The order matters: if you copy base
                first and then override, the override values will naturally replace base values for shared
                keys.
            - title: ðŸ’¡ Hint
              content: >-
                Create a new map with make. Range over the base map first, copying all key-value pairs. Then
                range over the override map, which will overwrite any duplicate keys from base.
            - title: ðŸ”§ Pattern
              content: |-
                <pre>1. result := make(map[string]string)
                2. For each k, v in base:
                   - result[k] = v
                3. For each k, v in override:
                   - result[k] = v
                4. Return result</pre>
          solution: |-
            func mergeConfigs(base, override map[string]string) map[string]string {
                result := make(map[string]string)
                for k, v := range base {
                    result[k] = v
                }
                for k, v := range override {
                    result[k] = v
                }
                return result
            }
          difficulty: 2
        - id: v8
          title: Inventory Report
          description: >-
            A warehouse builds an inventory report. Write <code>func inventoryReport(items map[string]int,
            lowThreshold int) (int, []string)</code> that returns the total count of all items and a slice of
            item names whose quantity is at or below the low threshold, sorted alphabetically.
          functionSignature: func inventoryReport(items map[string]int, lowThreshold int) (int, []string)
          testCases:
            - input: "map[string]int{\"bolts\": 200, \"nails\": 5, \"screws\": 3}, 10"
              output: 208, []string{"nails", "screws"}
            - input: "map[string]int{\"pens\": 50}, 10"
              output: 50, []string{}
          hints:
            - title: ðŸ¤” Think about it
              content: >-
                This combines map iteration with accumulation, conditional filtering, and sorting. You need to
                track a running total while also collecting items that meet the low stock condition.
            - title: ðŸ’¡ Hint
              content: >-
                Range over the map. Add each quantity to a total. If the quantity is <= lowThreshold, append
                the name to a low-stock slice. Use <code>sort.Strings</code> to sort the result
                alphabetically.
            - title: ðŸ”§ Pattern
              content: |-
                <pre>1. total := 0, lowStock := []string{}
                2. For each name, qty in items:
                   - total += qty
                   - If qty <= lowThreshold: append name
                3. sort.Strings(lowStock)
                4. Return total, lowStock</pre>
          solution: |-
            func inventoryReport(items map[string]int, lowThreshold int) (int, []string) {
                total := 0
                lowStock := []string{}
                for name, qty := range items {
                    total += qty
                    if qty <= lowThreshold {
                        lowStock = append(lowStock, name)
                    }
                }
                sort.Strings(lowStock)
                return total, lowStock
            }
          difficulty: 2
        - id: v9
          title: Safe Division
          description: >-
            A calculator performs batch divisions with error handling. Write <code>func safeDivide(pairs
            [][2]int) ([]float64, error)</code> that takes a slice of [2]int pairs (numerator, denominator)
            and returns a slice of results. If any denominator is zero, return nil and an error indicating
            which index failed.
          functionSignature: func safeDivide(pairs [][2]int) ([]float64, error)
          testCases:
            - input: "[][2]int{{10, 2}, {9, 3}}"
              output: "[]float64{5.0, 3.0}, nil"
            - input: "[][2]int{{10, 2}, {5, 0}}"
              output: nil, error
              note: division by zero at index 1
            - input: "[][2]int{}"
              output: "[]float64{}, nil"
          hints:
            - title: ðŸ¤” Think about it
              content: >-
                This combines error handling with type conversion and slice building. You need to check for
                division by zero and return an error early if found. How do you convert int division to
                float64?
            - title: ðŸ’¡ Hint
              content: >-
                Loop through pairs with index. Check if the denominator (pair[1]) is 0 â€” if so, return nil and
                an error using <code>fmt.Errorf</code>. Otherwise, compute <code>float64(pair[0]) /
                float64(pair[1])</code> and append.
            - title: ðŸ”§ Pattern
              content: |-
                <pre>1. results := []float64{}
                2. For i, pair := range pairs:
                   - If pair[1] == 0 -> return nil, error at index i
                   - Append float64(pair[0]) / float64(pair[1])
                3. Return results, nil</pre>
          solution: |-
            func safeDivide(pairs [][2]int) ([]float64, error) {
                results := []float64{}
                for i, p := range pairs {
                    if p[1] == 0 {
                        return nil, fmt.Errorf("division by zero at index %d", i)
                    }
                    results = append(results, float64(p[0])/float64(p[1]))
                }
                return results, nil
            }
          difficulty: 2
        - id: v10
          title: Config Validator
          description: >-
            A deployment system validates configuration. Write <code>func validateConfig(config
            map[string]string, required []string) error</code> that checks if all required keys exist in the
            config map. If any are missing, return an error listing all missing keys. If all are present,
            return nil.
          functionSignature: func validateConfig(config map[string]string, required []string) error
          testCases:
            - input: "map[string]string{\"host\": \"localhost\", \"port\": \"8080\"}, []string{\"host\", \"port\"}"
              output: nil
            - input: "map[string]string{\"host\": \"localhost\"}, []string{\"host\", \"port\", \"db\"}"
              output: error
              note: "missing keys: port, db"
            - input: map[string]string{}, []string{}
              output: nil
          hints:
            - title: ðŸ¤” Think about it
              content: >-
                This combines comma-ok map lookups with error handling and string formatting. You need to
                collect all missing keys first, then decide whether to return an error or nil.
            - title: ðŸ’¡ Hint
              content: >-
                Loop through required keys. Use comma-ok to check each key in the config map. Collect missing
                keys into a slice. If the slice is non-empty, return an error with <code>fmt.Errorf("missing
                keys: %s", strings.Join(missing, ", "))</code>.
            - title: ðŸ”§ Pattern
              content: |-
                <pre>1. missing := []string{}
                2. For each key in required:
                   - _, ok := config[key]
                   - If !ok -> append key to missing
                3. If len(missing) > 0 -> return error
                4. Return nil</pre>
          solution: |-
            func validateConfig(config map[string]string, required []string) error {
                missing := []string{}
                for _, key := range required {
                    if _, ok := config[key]; !ok {
                        missing = append(missing, key)
                    }
                }
                if len(missing) > 0 {
                    return fmt.Errorf("missing keys: %s", strings.Join(missing, ", "))
                }
                return nil
            }
          difficulty: 3
        - id: v11
          title: CLI Table Formatter
          description: >-
            A CLI tool formats key-value pairs as an aligned table. Write <code>func formatTable(entries
            []string) (string, error)</code> that takes "key=value" strings, splits them, finds the longest
            key for alignment, and returns a formatted table where keys are right-padded. Return an error if
            any entry lacks "=".
          functionSignature: func formatTable(entries []string) (string, error)
          testCases:
            - input: "[]string{\"name=Alice\", \"age=30\", \"city=NYC\"}"
              output: "\"name = Alice\\nage  = 30\\ncity = NYC\", nil"
            - input: "[]string{\"x=1\"}"
              output: "\"x = 1\", nil"
            - input: "[]string{\"bad\"}"
              output: "\"\", error"
          hints:
            - title: ðŸ¤” Think about it
              content: >-
                This combines string splitting, error handling, finding a maximum length, and formatted
                output. You need two passes: one to parse and find the longest key, one to format the output.
            - title: ðŸ’¡ Hint
              content: >-
                First pass: split each entry on "=" (using SplitN), validate, and collect key-value pairs
                while tracking the maximum key length. Second pass: format each line using
                <code>fmt.Sprintf("%-*s = %s", maxLen, key, value)</code> for alignment.
            - title: ðŸ”§ Pattern
              content: |-
                <pre>1. Parse all entries into key-value pairs
                   - Error if any lacks "="
                2. Find max key length
                3. Format each pair: left-pad key to max length
                4. Join lines with newline
                5. Return result, nil</pre>
          solution: |-
            func formatTable(entries []string) (string, error) {
                type kv struct{ key, val string }
                pairs := []kv{}
                maxLen := 0
                for _, e := range entries {
                    parts := strings.SplitN(e, "=", 2)
                    if len(parts) < 2 {
                        return "", fmt.Errorf("invalid entry: %s", e)
                    }
                    pairs = append(pairs, kv{parts[0], parts[1]})
                    if len(parts[0]) > maxLen {
                        maxLen = len(parts[0])
                    }
                }
                lines := []string{}
                for _, p := range pairs {
                    lines = append(lines, fmt.Sprintf("%-*s = %s", maxLen, p.key, p.val))
                }
                return strings.Join(lines, "\n"), nil
            }
          difficulty: 3
        - id: v12
          title: Histogram Builder
          description: >-
            A data visualization tool builds a text histogram. Write <code>func histogram(data map[string]int)
            string</code> that returns a multi-line string where each line has a label, a colon, and a bar of
            '#' characters equal to the count. Labels should be sorted alphabetically, and each label should
            be right-padded to the length of the longest label.
          functionSignature: func histogram(data map[string]int) string
          testCases:
            - input: "map[string]int{\"go\": 3, \"rust\": 5, \"c\": 1}"
              output: "\"c    : #\\ngo   : ###\\nrust : #####\""
            - input: "map[string]int{\"x\": 2}"
              output: "\"x : ##\""
          hints:
            - title: ðŸ¤” Think about it
              content: >-
                This combines map iteration, sorting, finding maximum label length for alignment, and building
                repeated characters. You need to sort the keys, align the labels, and build each bar.
            - title: ðŸ’¡ Hint
              content: >-
                Collect keys and sort them. Find the longest key for padding. For each key, use
                <code>strings.Repeat("#", count)</code> to build the bar and <code>fmt.Sprintf("%-*s", maxLen,
                key)</code> for aligned labels.
            - title: ðŸ”§ Pattern
              content: |-
                <pre>1. Collect and sort keys alphabetically
                2. Find max key length
                3. For each key (sorted):
                   - Format: padded_label + " : " + "#" repeated count times
                4. Join lines with newline
                5. Return result</pre>
          solution: |-
            func histogram(data map[string]int) string {
                keys := []string{}
                for k := range data {
                    keys = append(keys, k)
                }
                sort.Strings(keys)
                maxLen := 0
                for _, k := range keys {
                    if len(k) > maxLen {
                        maxLen = len(k)
                    }
                }
                lines := []string{}
                for _, k := range keys {
                    bar := strings.Repeat("#", data[k])
                    lines = append(lines, fmt.Sprintf("%-*s : %s", maxLen, k, bar))
                }
                return strings.Join(lines, "\n")
            }
          difficulty: 3
        - id: v13
          title: Pipeline Processor
          description: >-
            A data pipeline processes records through multiple stages. Write <code>func pipeline(records
            []string, prefix string, maxLen int) ([]string, int)</code> that: (1) filters out empty strings,
            (2) trims whitespace from each record, (3) prepends the prefix, (4) truncates to maxLen runes if
            needed, and returns the processed records and the count of records that were truncated.
          functionSignature: func pipeline(records []string, prefix string, maxLen int) ([]string, int)
          testCases:
            - input: "[]string{\"  hello  \", \"\", \"world\"}, \">\", 8"
              output: "[]string{\">hello\", \">world\"}, 0"
            - input: "[]string{\"longrecord\", \"ab\"}, \"prefix-\", 10"
              output: "[]string{\"prefix-lon\", \"prefix-ab\"}, 1"
              note: prefix-longrecord is 17 runes, truncated to 10
            - input: "[]string{\"\", \"\"}, \"x\", 5"
              output: "[]string{}, 0"
          hints:
            - title: ðŸ¤” Think about it
              content: >-
                This combines filtering, string trimming, concatenation, rune-aware truncation, and counting.
                Process each record through all stages in sequence, tracking how many needed truncation.
            - title: ðŸ’¡ Hint
              content: >-
                Loop through records. Skip empty strings. Trim whitespace with <code>strings.TrimSpace</code>.
                Prepend the prefix. Check the rune length â€” if it exceeds maxLen, slice the rune array and
                increment the truncation counter. Append the processed record to results.
            - title: ðŸ”§ Pattern
              content: |-
                <pre>1. result := []string{}, truncated := 0
                2. For each record:
                   - Skip if empty
                   - Trim whitespace
                   - Prepend prefix
                   - If rune length > maxLen:
                     - Truncate to maxLen runes
                     - truncated++
                   - Append to result
                3. Return result, truncated</pre>
          solution: |-
            func pipeline(records []string, prefix string, maxLen int) ([]string, int) {
                result := []string{}
                truncated := 0
                for _, r := range records {
                    if r == "" {
                        continue
                    }
                    r = strings.TrimSpace(r)
                    r = prefix + r
                    runes := []rune(r)
                    if len(runes) > maxLen {
                        r = string(runes[:maxLen])
                        truncated++
                    }
                    result = append(result, r)
                }
                return result, truncated
            }
          difficulty: 3