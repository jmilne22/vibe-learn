conceptLinks:
  Variable Declaration: "#lesson-variables"
  Type Conversion: "#lesson-variables"
  String Formatting: "#lesson-functions"
  Function Basics: "#lesson-functions"
  Multiple Returns: "#lesson-functions"
  Error Handling: "#lesson-functions"
  Building Slices: "#lesson-slices"
  Slice Operations: "#lesson-slices"
  For Loops: "#lesson-loops"
  Range Loops: "#lesson-loops"
  Map Basics: "#lesson-maps"
  Comma-Ok Pattern: "#lesson-comma-ok"
  Strings & Runes: "#lesson-variables"
  Go Fundamentals Combined: "#lesson-variables"
  If/Else: "#lesson-if"
  Slices & Range: "#lesson-slices"
  Maps: "#lesson-maps"
  make() Function: "#lesson-slices"
  Range with Index: "#lesson-loops"
variants:
  warmups:
    - id: warmup_1
      concept: For Loops
      quickRef: |
        <code>for i := 0; i &lt; n; i++ { }</code><br>
                <code>for condition { }</code> &nbsp; <code>for { }</code> (infinite)
      variants:
        - id: v1
          title: Print 1 to 10
          description: Write a program that prints the numbers 1 to 10, one per line.
          hints:
            - Use <code>for i := 1; i <= 10; i++</code>
          solution: |-
            for i := 1; i <= 10; i++ {
                fmt.Println(i)
            }
        - id: v2
          title: Countdown from 5
          description: Write a program that counts down from 5 to 1, then prints "Go!"
          hints:
            - Use <code>for i := 5; i >= 1; i--</code>
            - Print "Go!" after the loop
          solution: |-
            for i := 5; i >= 1; i-- {
                fmt.Println(i)
            }
            fmt.Println("Go!")
        - id: v3
          title: Print Even Numbers
          description: Write a program that prints even numbers from 2 to 10.
          hints:
            - Use <code>for i := 2; i <= 10; i += 2</code>
          solution: |-
            for i := 2; i <= 10; i += 2 {
                fmt.Println(i)
            }
        - id: v4
          title: Count by Twos
          description: Write a program that prints odd numbers from 1 to 9.
          hints:
            - Use <code>for i := 1; i <= 9; i += 2</code>
          solution: |-
            for i := 1; i <= 9; i += 2 {
                fmt.Println(i)
            }
        - id: v5
          title: Reindeer Roll Call
          description: >-
            Write a program that prints each reindeer with its position number. Use a slice of names
            ["Dasher", "Dancer", "Prancer", "Vixen", "Comet"] and print "1. Dasher", "2. Dancer", etc.
          hints:
            - "Create a slice: <code>reindeer := []string{\"Dasher\", \"Dancer\", ...}</code>"
            - "Use index+1 for position: <code>fmt.Printf(\"%d. %s\\n\", i+1, name)</code>"
          solution: |-
            reindeer := []string{"Dasher", "Dancer", "Prancer", "Vixen", "Comet"}
            for i, name := range reindeer {
                fmt.Printf("%d. %s\n", i+1, name)
            }
        - id: v6
          title: Gift Label Printer
          description: >-
            Write a program that prints gift labels for a set of 5 gifts. Print "Gift 1 of 5",
            "Gift 2 of 5", etc. up to "Gift 5 of 5".
          hints:
            - Use <code>for i := 1; i <= 5; i++</code>
            - "Use fmt.Printf: <code>fmt.Printf(\"Gift %d of 5\\n\", i)</code>"
          solution: |-
            for i := 1; i <= 5; i++ {
                fmt.Printf("Gift %d of 5\n", i)
            }
        - id: v7
          title: Star Rating
          description: >-
            Write a program that prints star ratings for scores 1 through 5. For each score, print
            that many stars on a line (e.g., "***" for 3, "*****" for 5).
          hints:
            - "Outer loop for each rating: <code>for i := 1; i <= 5; i++</code>"
            - "Inner loop prints stars: <code>for j := 0; j < i; j++ { fmt.Print(\"*\") }</code>"
          solution: |-
            for i := 1; i <= 5; i++ {
                for j := 0; j < i; j++ {
                    fmt.Print("*")
                }
                fmt.Println()
            }
        - id: v8
          title: Count Down by Threes
          description: Write a program that counts down from 15 to 0 by threes (15, 12, 9, 6, 3, 0).
          hints:
            - Start at 15, use <code>i -= 3</code>
          solution: |-
            for i := 15; i >= 0; i -= 3 {
                fmt.Println(i)
            }
        - id: v9
          title: Password Dots
          description: >-
            Write a program that takes a password string "secret" and prints a masked version as dots
            matching its length. Use a for loop to build the dot string one character at a time.
          hints:
            - "Get length: <code>password := \"secret\"</code> has length 6"
            - "Build dots in a loop: <code>mask += \".\"</code>"
          solution: |-
            password := "secret"
            mask := ""
            for i := 0; i < len(password); i++ {
                mask += "."
            }
            fmt.Println(mask)  // ......
        - id: v10
          title: Repeat Greeting
          description: >-
            Write a program that prints Santa's laugh by repeating "Ho! " n times. Set n to 3 and
            print "Ho! Ho! Ho! " using a for loop.
          hints:
            - "Build the string: <code>laugh += \"Ho! \"</code>"
            - Loop n times to repeat
          solution: |-
            n := 3
            laugh := ""
            for i := 0; i < n; i++ {
                laugh += "Ho! "
            }
            fmt.Println(laugh)  // Ho! Ho! Ho!
        - id: v11
          title: Buzzer Countdown
          description: >-
            Write a program that counts down from 10 to 1. On multiples of 3, print "BUZZ!" instead of the number.
          hints:
            - "Use <code>for i := 10; i >= 1; i--</code>"
            - "Check multiples: <code>if i % 3 == 0</code>"
          solution: |-
            for i := 10; i >= 1; i-- {
                if i%3 == 0 {
                    fmt.Println("BUZZ!")
                } else {
                    fmt.Println(i)
                }
            }
        - id: v12
          title: Print Star Pattern
          description: Write a program that prints a triangle pattern of stars (1 star, then 2 stars, then 3 stars).
          hints:
            - Outer loop controls rows
            - "Inner loop prints stars: <code>for j := 0; j < i; j++</code>"
          solution: |-
            for i := 1; i <= 3; i++ {
                for j := 0; j < i; j++ {
                    fmt.Print("*")
                }
                fmt.Println()
            }
        - id: v13
          title: Progress Bar
          description: >-
            Write a program that prints a progress bar filling up from 0% to 100% in steps of 20%.
            Print lines like "[==        ] 20%" where each = represents 20% progress (max 5 chars in a 10-char bar).
          hints:
            - "Outer loop: <code>for step := 0; step <= 5; step++</code>"
            - "Build the filled part with = and empty part with spaces"
          solution: |-
            for step := 0; step <= 5; step++ {
                bar := ""
                for j := 0; j < 5; j++ {
                    if j < step {
                        bar += "="
                    } else {
                        bar += " "
                    }
                }
                fmt.Printf("[%s] %d%%\n", bar, step*20)
            }
    - id: warmup_2
      concept: If/Else
      quickRef: |
        <code>if x &gt; 0 { } else if x == 0 { } else { }</code><br>
                <code>if v, ok := m[k]; ok { }</code> (init statement)
      variants:
        - id: v1
          title: Odd or Even
          description: Write <code>func oddOrEven(n int) string</code> that returns "even" if n is divisible by 2, else "odd".
          hints:
            - "Use modulo: <code>if n % 2 == 0</code> means even"
          solution: |-
            func oddOrEven(n int) string {
                if n % 2 == 0 {
                    return "even"
                }
                return "odd"
            }
        - id: v2
          title: Pass or Fail
          description: Write <code>func passOrFail(score int) string</code> that returns "pass" if score >= 60, else "fail".
          hints:
            - "Simple if/else: <code>if score >= 60 { return \"pass\" }</code>"
          solution: |-
            func passOrFail(score int) string {
                if score >= 60 {
                    return "pass"
                }
                return "fail"
            }
        - id: v3
          title: Temperature Feel
          description: >-
            Write <code>func tempFeel(celsius int) string</code> that returns "freezing" (< 0), "cold" (0-15), "warm"
            (16-25), or "hot" (> 25).
          hints:
            - Chain if/else if based on temperature thresholds
          solution: |-
            func tempFeel(celsius int) string {
                if celsius < 0 {
                    return "freezing"
                } else if celsius <= 15 {
                    return "cold"
                } else if celsius <= 25 {
                    return "warm"
                }
                return "hot"
            }
        - id: v4
          title: Grade Letter
          description: >-
            Write <code>func gradeLetter(score int) string</code> that returns "A" (>=90), "B" (>=80), "C" (>=70), "D"
            (>=60), or "F" (<60).
          hints:
            - Use chained if/else if statements
            - Check highest grade first
          solution: |-
            func gradeLetter(score int) string {
                if score >= 90 {
                    return "A"
                } else if score >= 80 {
                    return "B"
                } else if score >= 70 {
                    return "C"
                } else if score >= 60 {
                    return "D"
                }
                return "F"
            }
        - id: v5
          title: Voting Eligibility
          description: Write <code>func canVote(age int) string</code> that returns "can vote" if age >= 18, else "too young".
          hints:
            - Simple comparison with 18
          solution: |-
            func canVote(age int) string {
                if age >= 18 {
                    return "can vote"
                }
                return "too young"
            }
        - id: v6
          title: Discount Eligibility
          description: >-
            Write <code>func getDiscount(age int) string</code> that returns "senior discount" (>=65), "student
            discount" (<=25), or "no discount".
          hints:
            - Check senior first, then student, then default
          solution: |-
            func getDiscount(age int) string {
                if age >= 65 {
                    return "senior discount"
                } else if age <= 25 {
                    return "student discount"
                }
                return "no discount"
            }
        - id: v7
          title: Shipping Speed
          description: >-
            Write <code>func shippingSpeed(days int) string</code> that returns "express" if days <= 2,
            "standard" if days <= 5, or "economy" for anything longer.
          hints:
            - Chain if/else if based on day thresholds
          solution: |-
            func shippingSpeed(days int) string {
                if days <= 2 {
                    return "express"
                } else if days <= 5 {
                    return "standard"
                }
                return "economy"
            }
        - id: v8
          title: Speed Limit
          description: >-
            Write <code>func speedCheck(speed int) string</code> that returns "safe" (<=60), "warning" (61-80), or
            "ticket" (>80).
          hints:
            - Use ranges for different categories
          solution: |-
            func speedCheck(speed int) string {
                if speed <= 60 {
                    return "safe"
                } else if speed <= 80 {
                    return "warning"
                }
                return "ticket"
            }
        - id: v9
          title: Age Category
          description: >-
            Write <code>func ageCategory(age int) string</code> that returns "child" if age < 13, "teen" if age < 20,
            else "adult".
          hints:
            - Use multiple if/else if statements
            - Check conditions from smallest to largest
          solution: |-
            func ageCategory(age int) string {
                if age < 13 {
                    return "child"
                } else if age < 20 {
                    return "teen"
                }
                return "adult"
            }
        - id: v10
          title: File Size Category
          description: >-
            Write <code>func fileSizeCategory(bytes int) string</code> that returns "small" if bytes < 1024,
            "medium" if bytes < 1048576 (1 MB), or "large" otherwise.
          hints:
            - Use <code>else if</code> for the middle condition
          solution: |-
            func fileSizeCategory(bytes int) string {
                if bytes < 1024 {
                    return "small"
                } else if bytes < 1048576 {
                    return "medium"
                }
                return "large"
            }
        - id: v11
          title: Season from Month
          description: >-
            Write <code>func season(month int) string</code> that returns "winter" for 12-2, "spring" for 3-5, "summer"
            for 6-8, "fall" for 9-11.
          hints:
            - Use multiple if/else if conditions
            - Check ranges like <code>month >= 3 && month <= 5</code>
          solution: |-
            func season(month int) string {
                if month == 12 || month <= 2 {
                    return "winter"
                } else if month <= 5 {
                    return "spring"
                } else if month <= 8 {
                    return "summer"
                }
                return "fall"
            }
        - id: v12
          title: Weekend or Weekday
          description: >-
            Write <code>func dayType(day string) string</code> that returns "weekend" if day is "Saturday" or "Sunday",
            else "weekday".
          hints:
            - Use <code>||</code> (OR) operator
            - "Check: <code>if day == \"Saturday\" || day == \"Sunday\"</code>"
          solution: |-
            func dayType(day string) string {
                if day == "Saturday" || day == "Sunday" {
                    return "weekend"
                }
                return "weekday"
            }
        - id: v13
          title: Password Strength
          description: >-
            Write <code>func passwordStrength(length int) string</code> that returns "weak" if length < 8, "medium" if
            length < 12, else "strong".
          hints:
            - Simple if/else if chain based on length thresholds
          solution: |-
            func passwordStrength(length int) string {
                if length < 8 {
                    return "weak"
                } else if length < 12 {
                    return "medium"
                }
                return "strong"
            }
    - id: warmup_3
      concept: Slices & Range
      quickRef: |
        <code>s := []int{1, 2, 3}</code> &nbsp; <code>s = append(s, v)</code><br>
                <code>for i, v := range s { }</code> &nbsp; <code>s[lo:hi]</code>
      variants:
        - id: v1
          title: Iterate Numbers
          description: Create a slice with three numbers, then print each using <code>for range</code>.
          hints:
            - "Create: <code>nums := []int{7, 42, 99}</code>"
            - "Loop: <code>for _, num := range nums</code>"
          solution: |-
            nums := []int{7, 42, 99}
            for _, num := range nums {
                fmt.Println(num)
            }
        - id: v2
          title: Iterate with Index
          description: "Create a slice of colors, then print each with its index: \"0: red\", \"1: blue\", etc."
          hints:
            - "Loop with index: <code>for i, color := range colors</code>"
            - "Use <code>fmt.Printf(\"%d: %s\\n\", i, color)</code>"
          solution: |-
            colors := []string{"red", "blue", "green"}
            for i, color := range colors {
                fmt.Printf("%d: %s\n", i, color)
            }
        - id: v3
          title: Iterate Strings
          description: Create a slice of your favorite foods, print each on its own line.
          hints:
            - "Create: <code>foods := []string{\"pizza\", \"sushi\", \"tacos\"}</code>"
          solution: |-
            foods := []string{"pizza", "sushi", "tacos"}
            for _, food := range foods {
                fmt.Println(food)
            }
        - id: v4
          title: Longest Name
          description: >-
            Create a slice of names ["Al", "Bob", "Christina", "Dan"]. Find and print the longest name.
          hints:
            - Start with <code>longest := names[0]</code>
            - "Compare lengths: <code>if len(name) > len(longest)</code>"
          solution: |-
            names := []string{"Al", "Bob", "Christina", "Dan"}
            longest := names[0]
            for _, name := range names {
                if len(name) > len(longest) {
                    longest = name
                }
            }
            fmt.Println(longest)  // Christina
        - id: v5
          title: Count Items
          description: Create a slice of fruits and print how many items are in it.
          hints:
            - Use <code>len(fruits)</code> to get the count
          solution: |-
            fruits := []string{"apple", "banana", "orange", "grape"}
            fmt.Println(len(fruits))  // 4
        - id: v6
          title: Names List
          description: "Create a slice of names and print each with a greeting: \"Hello, Alice!\""
          hints:
            - Use <code>fmt.Printf("Hello, %s!\n", name)</code>
          solution: |-
            names := []string{"Alice", "Bob", "Charlie"}
            for _, name := range names {
                fmt.Printf("Hello, %s!\n", name)
            }
        - id: v7
          title: Test Scores
          description: "Create a slice of test scores and print each one with its position: \"Test 1: 85\""
          hints:
            - Use the index in the range loop
            - Add 1 to the index for human-readable numbering
          solution: |-
            scores := []int{85, 92, 78, 95}
            for i, score := range scores {
                fmt.Printf("Test %d: %d\n", i+1, score)
            }
        - id: v8
          title: Reverse Print
          description: Create a slice of 3 animals and print them in reverse order using a regular for loop.
          hints:
            - Start from <code>len(animals)-1</code>
            - "Count down: <code>i--</code>"
          solution: |-
            animals := []string{"cat", "dog", "bird"}
            for i := len(animals) - 1; i >= 0; i-- {
                fmt.Println(animals[i])
            }
        - id: v9
          title: Find Oldest
          description: >-
            Create two slices: names ["Alice", "Bob", "Charlie"] and ages [25, 42, 31]. Find and print
            the name of the oldest person.
          hints:
            - Track the index of the maximum age
            - "Use that index to get the name: <code>names[maxIdx]</code>"
          solution: |-
            names := []string{"Alice", "Bob", "Charlie"}
            ages := []int{25, 42, 31}
            maxIdx := 0
            for i, age := range ages {
                if age > ages[maxIdx] {
                    maxIdx = i
                }
            }
            fmt.Println(names[maxIdx])  // Bob
        - id: v10
          title: Shortest Word
          description: >-
            Create a slice of words ["programming", "is", "fun", "in", "Go"]. Find and print the shortest word.
          hints:
            - Start with <code>shortest := words[0]</code>
            - "Compare lengths: <code>if len(word) < len(shortest)</code>"
          solution: |-
            words := []string{"programming", "is", "fun", "in", "Go"}
            shortest := words[0]
            for _, word := range words {
                if len(word) < len(shortest) {
                    shortest = word
                }
            }
            fmt.Println(shortest)  // is
        - id: v11
          title: Calculate Average
          description: Write <code>func average(nums []float64) float64</code> that returns the average of all numbers.
          hints:
            - Sum all numbers first
            - "Divide by length: <code>sum / float64(len(nums))</code>"
          solution: |-
            func average(nums []float64) float64 {
                sum := 0.0
                for _, n := range nums {
                    sum += n
                }
                return sum / float64(len(nums))
            }
        - id: v12
          title: Contains Check
          description: >-
            Write <code>func contains(items []string, target string) bool</code> that returns true if target is in
            items.
          hints:
            - Use range to check each item
            - Return true immediately when found
          solution: |-
            func contains(items []string, target string) bool {
                for _, item := range items {
                    if item == target {
                        return true
                    }
                }
                return false
            }
        - id: v13
          title: First N Elements
          description: >-
            Write <code>func firstN(items []string, n int) []string</code> that returns the first n elements of the
            slice.
          hints:
            - "Use slice syntax: <code>items[:n]</code>"
          solution: |-
            func firstN(items []string, n int) []string {
                return items[:n]
            }
    - id: warmup_4
      concept: Maps
      quickRef: |
        <code>m := map[string]int{}</code> &nbsp; <code>m[k] = v</code><br>
                <code>v, ok := m[k]</code> &nbsp; <code>delete(m, k)</code>
      variants:
        - id: v1
          title: Ages Map
          description: Create a map of names to ages, then print each person's name and age.
          hints:
            - "Map syntax: <code>map[string]int{\"alice\": 30}</code>"
            - "Loop: <code>for name, age := range ages</code>"
          solution: |-
            ages := map[string]int{
                "alice": 30,
                "bob":   25,
            }
            for name, age := range ages {
                fmt.Printf("%s is %d\n", name, age)
            }
        - id: v2
          title: Prices Map
          description: Create a map of items to prices (float64), then print each item and price.
          hints:
            - "Map syntax: <code>map[string]float64{\"apple\": 1.50}</code>"
          solution: |-
            prices := map[string]float64{
                "apple":  1.50,
                "banana": 0.75,
            }
            for item, price := range prices {
                fmt.Printf("%s: $%.2f\n", item, price)
            }
        - id: v3
          title: Capitals Map
          description: Create a map of countries to their capitals, then print each pair.
          hints:
            - "Map syntax: <code>map[string]string{\"France\": \"Paris\"}</code>"
          solution: |-
            capitals := map[string]string{
                "France": "Paris",
                "Japan":  "Tokyo",
            }
            for country, capital := range capitals {
                fmt.Printf("%s: %s\n", country, capital)
            }
        - id: v4
          title: Inventory Count
          description: Create a map of product names to quantities in stock, then print each item and count.
          hints:
            - "Map syntax: <code>map[string]int{\"shirt\": 15}</code>"
          solution: |-
            inventory := map[string]int{
                "shirt": 15,
                "pants": 8,
                "hat":   20,
            }
            for item, count := range inventory {
                fmt.Printf("%s: %d in stock\n", item, count)
            }
        - id: v5
          title: Student Grades
          description: Create a map of student names to their letter grades, then print each student and grade.
          hints:
            - "Map syntax: <code>map[string]string{\"Alice\": \"A\"}</code>"
          solution: |-
            grades := map[string]string{
                "Alice": "A",
                "Bob":   "B",
                "Carol": "A",
            }
            for student, grade := range grades {
                fmt.Printf("%s: %s\n", student, grade)
            }
        - id: v6
          title: Phone Book
          description: Create a map of names to phone numbers, then print each entry.
          hints:
            - "Phone numbers can be strings: <code>\"555-1234\"</code>"
          solution: |-
            phonebook := map[string]string{
                "Alice": "555-1234",
                "Bob":   "555-5678",
            }
            for name, phone := range phonebook {
                fmt.Printf("%s: %s\n", name, phone)
            }
        - id: v7
          title: Menu Prices
          description: Create a map of menu items to their prices (use integers for cents), then print the menu.
          hints:
            - "Store cents as int: 250 for $2.50"
            - Divide by 100.0 when printing
          solution: |-
            menu := map[string]int{
                "burger": 850,
                "fries":  350,
                "soda":   200,
            }
            for item, cents := range menu {
                fmt.Printf("%s: $%.2f\n", item, float64(cents)/100.0)
            }
        - id: v8
          title: Room Numbers
          description: Create a map of employee names to their office room numbers, then print the directory.
          hints:
            - "Map syntax: <code>map[string]int{\"Alice\": 101}</code>"
          solution: |-
            offices := map[string]int{
                "Alice": 101,
                "Bob":   102,
                "Carol": 105,
            }
            for name, room := range offices {
                fmt.Printf("%s - Room %d\n", name, room)
            }
        - id: v9
          title: Most Common Value
          description: >-
            Write <code>func mostCommon(counts map[string]int) string</code> that returns the key with the highest
            value.
          hints:
            - Track max value and corresponding key
            - Loop through map with range
          solution: |-
            func mostCommon(counts map[string]int) string {
                maxKey := ""
                maxVal := 0
                for k, v := range counts {
                    if v > maxVal {
                        maxVal = v
                        maxKey = k
                    }
                }
                return maxKey
            }
        - id: v10
          title: Merge Maps
          description: >-
            Write <code>func mergeMaps(m1, m2 map[string]int) map[string]int</code> that combines both maps (m2
            overwrites m1 on conflicts).
          hints:
            - Create new result map
            - Copy all from m1, then all from m2
          solution: |-
            func mergeMaps(m1, m2 map[string]int) map[string]int {
                result := make(map[string]int)
                for k, v := range m1 {
                    result[k] = v
                }
                for k, v := range m2 {
                    result[k] = v
                }
                return result
            }
        - id: v11
          title: Filter by Value
          description: >-
            Write <code>func filterByValue(m map[string]int, threshold int) map[string]int</code> that returns only
            entries where value >= threshold.
          hints:
            - Create new map for results
            - Only add entries that meet the condition
          solution: |-
            func filterByValue(m map[string]int, threshold int) map[string]int {
                result := make(map[string]int)
                for k, v := range m {
                    if v >= threshold {
                        result[k] = v
                    }
                }
                return result
            }
        - id: v12
          title: Key Exists Multiple
          description: >-
            Write <code>func hasAllKeys(m map[string]int, keys []string) bool</code> that returns true if all keys exist
            in the map.
          hints:
            - Loop through keys slice
            - "Use comma-ok idiom: <code>_, ok := m[key]</code>"
          solution: |-
            func hasAllKeys(m map[string]int, keys []string) bool {
                for _, key := range keys {
                    if _, ok := m[key]; !ok {
                        return false
                    }
                }
                return true
            }
        - id: v13
          title: Invert Map
          description: Write <code>func invertMap(m map[string]string) map[string]string</code> that swaps keys and values.
          hints:
            - Create new map where values become keys
            - "Loop: <code>result[v] = k</code>"
          solution: |-
            func invertMap(m map[string]string) map[string]string {
                result := make(map[string]string)
                for k, v := range m {
                    result[v] = k
                }
                return result
            }
    - id: warmup_5
      concept: Variables & Assignment
      quickRef: |
        <code>var x int</code> &nbsp; <code>x := 42</code> (short declaration)<br>
                <code>const c = 10</code> &nbsp; <code>var x, y = 1, 2</code>
      variants:
        - id: v1
          title: Declare and Print
          description: >-
            Declare a variable <code>name</code> with value "Go", and an integer <code>year</code> with value 2009.
            Print both.
          hints:
            - "Use short declaration: <code>name := \"Go\"</code>"
            - Use <code>fmt.Println(name, year)</code>
          solution: |-
            name := "Go"
            year := 2009
            fmt.Println(name, year)
        - id: v2
          title: Swap Two Variables
          description: Create two variables <code>a := 10</code> and <code>b := 20</code>. Swap their values, then print them.
          hints:
            - "Go allows simultaneous assignment: <code>a, b = b, a</code>"
          solution: |-
            a := 10
            b := 20
            a, b = b, a
            fmt.Println(a, b)  // 20 10
        - id: v3
          title: Type Inference
          description: >-
            Create variables for your age (int), height (float64), and name (string) using short declaration. Print
            their values and types.
          hints:
            - "Go infers types: <code>age := 25</code> is int"
            - Use <code>fmt.Printf("%T", age)</code> to print type
          solution: |-
            age := 25
            height := 5.9
            name := "Alice"
            fmt.Printf("age: %d (%T)\n", age, age)
            fmt.Printf("height: %.1f (%T)\n", height, height)
            fmt.Printf("name: %s (%T)\n", name, name)
        - id: v4
          title: Build a Greeting
          description: >-
            Declare variables for a title ("Dr."), first name ("Jane"), and last name ("Smith").
            Concatenate them into a full greeting and print "Hello, Dr. Jane Smith!".
          hints:
            - "Use string concatenation with <code>+</code>"
            - "Build the greeting: <code>greeting := \"Hello, \" + title + \" \" + first + \" \" + last + \"!\"</code>"
          solution: |-
            title := "Dr."
            first := "Jane"
            last := "Smith"
            greeting := "Hello, " + title + " " + first + " " + last + "!"
            fmt.Println(greeting)  // Hello, Dr. Jane Smith!
        - id: v5
          title: String Concatenation
          description: Create variables for first name and last name, then create and print a full name.
          hints:
            - Concatenate with <code>+</code>
            - Don't forget the space between names
          solution: |-
            firstName := "John"
            lastName := "Doe"
            fullName := firstName + " " + lastName
            fmt.Println(fullName)  // John Doe
        - id: v6
          title: Boolean Logic
          description: Create two boolean variables, then print their AND and OR results.
          hints:
            - "AND: <code>a && b</code>"
            - "OR: <code>a || b</code>"
          solution: |-
            a := true
            b := false
            fmt.Println(a && b)  // false
            fmt.Println(a || b)  // true
        - id: v7
          title: Time Zone Offset
          description: >-
            Declare a UTC hour as 14 (2 PM UTC) and an offset of -5 (Eastern Time). Compute the local
            hour and print "UTC: 14, Local: 9".
          hints:
            - "Compute: <code>local := utcHour + offset</code>"
            - Use <code>fmt.Printf</code> to print both values
          solution: |-
            utcHour := 14
            offset := -5
            local := utcHour + offset
            fmt.Printf("UTC: %d, Local: %d\n", utcHour, local)  // UTC: 14, Local: 9
        - id: v8
          title: Inventory Update
          description: >-
            Declare a stock count of 50 items. Subtract 12 sold items, then add 8 restocked items.
            Print the final inventory count.
          hints:
            - "Update stock: <code>stock -= sold</code> then <code>stock += restocked</code>"
            - Use <code>fmt.Println</code> for the final count
          solution: |-
            stock := 50
            sold := 12
            restocked := 8
            stock -= sold
            stock += restocked
            fmt.Println(stock)  // 46
        - id: v9
          title: User Profile
          description: >-
            Declare variables for a user profile: name ("Alice"), age (30), and email ("alice@example.com").
            Print a formatted profile card showing all three values.
          hints:
            - "Use different types: string, int, string"
            - "Use <code>fmt.Printf</code> for formatted output"
          solution: |-
            name := "Alice"
            age := 30
            email := "alice@example.com"
            fmt.Printf("Name: %s\nAge: %d\nEmail: %s\n", name, age, email)
        - id: v10
          title: Score Tracker
          description: >-
            Declare a base score of 100, add a bonus of 25 points, then apply a 2x multiplier.
            Print the final score.
          hints:
            - "Add bonus: <code>score += bonus</code>"
            - "Apply multiplier: <code>score *= multiplier</code>"
          solution: |-
            score := 100
            bonus := 25
            multiplier := 2
            score += bonus
            score *= multiplier
            fmt.Println(score)  // 250
        - id: v11
          title: File Size Display
          description: >-
            Declare a file size as 4096 bytes (int). Convert it to kilobytes as a float64 and print both
            values: "4096 bytes = 4.00 KB".
          hints:
            - "Convert to float64: <code>kb := float64(bytes) / 1024</code>"
            - Use <code>fmt.Printf</code> with %.2f for formatting
          solution: |-
            bytes := 4096
            kb := float64(bytes) / 1024
            fmt.Printf("%d bytes = %.2f KB\n", bytes, kb)  // 4096 bytes = 4.00 KB
        - id: v12
          title: Elapsed Time
          description: >-
            Declare a start time of 1430 (2:30 PM) and end time of 1715 (5:15 PM) as integers representing
            24-hour format (hours * 100 + minutes). Calculate and print the elapsed time in minutes.
          hints:
            - "Extract hours and minutes: <code>hours := time / 100</code>, <code>mins := time % 100</code>"
            - Convert both to total minutes, then subtract
          solution: |-
            start := 1430
            end := 1715
            startMins := (start/100)*60 + start%100
            endMins := (end/100)*60 + end%100
            elapsed := endMins - startMins
            fmt.Printf("%d minutes elapsed\n", elapsed)  // 165 minutes elapsed
        - id: v13
          title: Character Counter
          description: >-
            Declare a string variable with the value "Hello, Go!". Get its length and print both
            the string and its character count.
          hints:
            - "Get length: <code>length := len(s)</code>"
            - Use <code>fmt.Printf</code> for formatted output
          solution: |-
            s := "Hello, Go!"
            length := len(s)
            fmt.Printf("%q has %d characters\n", s, length)  // "Hello, Go!" has 10 characters
    - id: warmup_6
      concept: Multiple Returns
      quickRef: |
        <code>func f() (int, error) { return 0, nil }</code><br>
                <code>v, err := f()</code> &nbsp; Use <code>_</code> to discard a return value
      variants:
        - id: v1
          title: Parse Email
          description: >-
            Write <code>func parseEmail(email string) (string, string)</code> that splits "user@domain.com"
            into the username and domain parts. Loop to find the '@' character.
          hints:
            - "Find '@' with a loop: <code>for i, ch := range email</code>"
            - "Split using slice: <code>email[:i]</code> and <code>email[i+1:]</code>"
          solution: |-
            func parseEmail(email string) (string, string) {
                for i, ch := range email {
                    if ch == '@' {
                        return email[:i], email[i+1:]
                    }
                }
                return email, ""
            }

            // Usage:
            user, domain := parseEmail("alice@example.com")
            fmt.Println(user, domain)  // alice example.com
        - id: v2
          title: Min and Max
          description: Write <code>func minMax(a, b int) (int, int)</code> that returns the smaller value first, then the larger.
          hints:
            - Use if to compare, then return in order
          solution: |-
            func minMax(a, b int) (int, int) {
                if a < b {
                    return a, b
                }
                return b, a
            }

            // Usage:
            small, big := minMax(5, 3)
            fmt.Println(small, big)  // 3 5
        - id: v3
          title: First and Last
          description: >-
            Write <code>func firstLast(s string) (string, string)</code> that returns the first and last character of a
            string.
          hints:
            - "First char: <code>string(s[0])</code>"
            - "Last char: <code>string(s[len(s)-1])</code>"
          solution: |-
            func firstLast(s string) (string, string) {
                return string(s[0]), string(s[len(s)-1])
            }

            // Usage:
            f, l := firstLast("hello")
            fmt.Println(f, l)  // h o
        - id: v4
          title: Split Name
          description: >-
            Write <code>func splitName(fullName string) (string, string)</code> that splits "John Doe" into first and
            last name (assume one space).
          hints:
            - Find the space with a simple loop or assume fixed position
            - For warmup, you can hardcode the split at index 4 for "John Doe"
          solution: |-
            func splitName(fullName string) (string, string) {
                // Simple version: find space
                for i, ch := range fullName {
                    if ch == ' ' {
                        return fullName[:i], fullName[i+1:]
                    }
                }
                return fullName, ""
            }

            // Usage:
            first, last := splitName("John Doe")
            fmt.Println(first, last)  // John Doe
        - id: v5
          title: Full Name Parts
          description: >-
            Write <code>func nameParts(full string) (string, string)</code> that given a name like
            "Dr. Jane Smith", returns the title ("Dr.") and the rest ("Jane Smith"). Split at the first space.
          hints:
            - "Find first space in a loop"
            - "Return <code>full[:i]</code> and <code>full[i+1:]</code>"
          solution: |-
            func nameParts(full string) (string, string) {
                for i, ch := range full {
                    if ch == ' ' {
                        return full[:i], full[i+1:]
                    }
                }
                return full, ""
            }

            // Usage:
            title, rest := nameParts("Dr. Jane Smith")
            fmt.Println(title, rest)  // Dr. Jane Smith
        - id: v6
          title: Bounds Check
          description: >-
            Write <code>func inRange(n, min, max int) (bool, string)</code> that returns true/"in range" if n is between
            min and max, else false/"out of range".
          hints:
            - Check if <code>n >= min && n <= max</code>
            - Return both the boolean and a message
          solution: |-
            func inRange(n, min, max int) (bool, string) {
                if n >= min && n <= max {
                    return true, "in range"
                }
                return false, "out of range"
            }

            // Usage:
            ok, msg := inRange(15, 10, 20)
            fmt.Println(ok, msg)  // true in range
        - id: v7
          title: File Extension
          description: >-
            Write <code>func splitFilename(filename string) (string, string)</code> that splits "photo.jpg"
            into the name ("photo") and extension ("jpg"). Find the last dot character.
          hints:
            - "Search backwards for '.': loop from <code>len(filename)-1</code> down"
            - "Return <code>filename[:i]</code> and <code>filename[i+1:]</code>"
          solution: |-
            func splitFilename(filename string) (string, string) {
                for i := len(filename) - 1; i >= 0; i-- {
                    if filename[i] == '.' {
                        return filename[:i], filename[i+1:]
                    }
                }
                return filename, ""
            }

            // Usage:
            name, ext := splitFilename("photo.jpg")
            fmt.Println(name, ext)  // photo jpg
        - id: v8
          title: String Info
          description: >-
            Write <code>func stringInfo(s string) (int, string)</code> that returns the length and the first character
            as a string.
          hints:
            - "Length: <code>len(s)</code>"
            - "First char: <code>string(s[0])</code>"
          solution: |-
            func stringInfo(s string) (int, string) {
                length := len(s)
                firstChar := string(s[0])
                return length, firstChar
            }

            // Usage:
            len, first := stringInfo("hello")
            fmt.Println(len, first)  // 5 h
        - id: v9
          title: Parse Int with Error
          description: >-
            Write <code>func parsePositive(s string) (int, error)</code> that converts string to int. Return error if
            conversion fails or number is negative.
          hints:
            - Use <code>strconv.Atoi(s)</code> to convert
            - Check if result < 0 and return custom error
          solution: |-
            import (
                "errors"
                "strconv"
            )

            func parsePositive(s string) (int, error) {
                n, err := strconv.Atoi(s)
                if err != nil {
                    return 0, err
                }
                if n < 0 {
                    return 0, errors.New("negative number")
                }
                return n, nil
            }
        - id: v10
          title: Validate Range
          description: >-
            Write <code>func validateRange(n, min, max int) (int, bool)</code> that returns (n, true) if n is in
            [min,max], else (0, false).
          hints:
            - "Check condition: <code>n >= min && n <= max</code>"
            - Return the value with a boolean flag
          solution: |-
            func validateRange(n, min, max int) (int, bool) {
                if n >= min && n <= max {
                    return n, true
                }
                return 0, false
            }
        - id: v11
          title: String Split at Position
          description: >-
            Write <code>func splitAt(s string, pos int) (string, string, bool)</code> that splits string at position.
            Return false if pos is out of bounds.
          hints:
            - Check if <code>pos >= 0 && pos <= len(s)</code>
            - "Use slice notation: <code>s[:pos]</code> and <code>s[pos:]</code>"
          solution: |-
            func splitAt(s string, pos int) (string, string, bool) {
                if pos < 0 || pos > len(s) {
                    return "", "", false
                }
                return s[:pos], s[pos:], true
            }
        - id: v12
          title: Find First Occurrence
          description: >-
            Write <code>func findFirst(items []string, target string) (int, bool)</code> that returns (index, true) if
            found, else (-1, false).
          hints:
            - Use range to get both index and value
            - Return immediately when target is found
          solution: |-
            func findFirst(items []string, target string) (int, bool) {
                for i, item := range items {
                    if item == target {
                        return i, true
                    }
                }
                return -1, false
            }
        - id: v13
          title: Min and Max
          description: >-
            Write <code>func minMax(nums []int) (int, int)</code> that returns both the minimum and maximum values in
            one call.
          hints:
            - Initialize both to first element
            - Update both in one loop using range
          solution: |-
            func minMax(nums []int) (int, int) {
                min, max := nums[0], nums[0]
                for _, n := range nums {
                    if n < min {
                        min = n
                    }
                    if n > max {
                        max = n
                    }
                }
                return min, max
            }
  challenges:
    - id: challenge_1
      block: 1
      difficulty: 1
      concept: Variable Declaration
      docLinks:
        - url: https://go.dev/tour/basics/9
          title: "Go Tour: Short variable declarations"
          note: := syntax
        - url: https://go.dev/ref/spec#Short_variable_declarations
          title: "Go Spec: Short variable declarations"
          note: specification details
      patternPrimer:
        bruteForce: Use explicit var declarations with types for every variable.
        bestApproach: Use := for concise declaration inside functions; use var when zero values or package-level scope needed.
        typical: Variable declaration is O(1) â€” focus on choosing the right declaration style.
      quickRef: |
        <code>var x int = 5</code> &nbsp; <code>x := 5</code><br>
                <code>var x int</code> (zero value) &nbsp; <code>const c = 10</code>
      variants:
        - id: v1
          title: Declare and Return Integer
          description: Write <code>func declareInt() int</code> that uses := to declare x as 42 and return it.
          functionSignature: func declareInt() int
          testCases:
            - input: ""
              output: "42"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                The := operator declares a new variable and infers its type from the value on the right side. What
                value do you need to assign?
            - title: "\U0001F4A1 Hint"
              content: >-
                Use x := 42 to declare and initialize x, then return it. The compiler infers x is an int from the
                literal 42.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>1. Declare variable with :=
                2. Return the variable</pre>
          solution: |-
            func declareInt() int {
                x := 42
                return x
            }
          difficulty: 1
        - id: v2
          title: Declare and Return String
          description: >-
            Write <code>func declareString() string</code> that uses := to declare greeting as "hello" and return it.
          functionSignature: func declareString() string
          testCases:
            - input: ""
              output: "\"hello\""
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                Short declarations work with any type. How do you declare a string variable with an initial value
                using :=?
            - title: "\U0001F4A1 Hint"
              content: >-
                Use greeting := "hello" to declare and initialize a string variable. The compiler infers the type
                from the string literal.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>1. Declare string variable with :=
                2. Return the variable</pre>
          solution: |-
            func declareString() string {
                greeting := "hello"
                return greeting
            }
          difficulty: 1
        - id: v3
          title: Concat Two Strings
          description: >-
            Write <code>func concatTwo() string</code> that declares first := "Hello" and second := "World"
            using short declarations, then returns them concatenated with a space.
          functionSignature: func concatTwo() string
          testCases:
            - input: ""
              output: "\"Hello World\""
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                You can use := multiple times in the same function to declare different variables. How do you
                concatenate strings in Go?
            - title: "\U0001F4A1 Hint"
              content: >-
                Declare first := "Hello" and second := "World" on separate lines, then return first + " " + second.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>1. Declare first string variable with :=
                2. Declare second string variable with :=
                3. Return their concatenation</pre>
          solution: |-
            func concatTwo() string {
                first := "Hello"
                second := "World"
                return first + " " + second
            }
          difficulty: 1
        - id: v4
          title: Boolean Declaration
          description: Write <code>func isGoFun() bool</code> that declares and returns true using :=.
          functionSignature: func isGoFun() bool
          testCases:
            - input: ""
              output: "true"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                The := operator works with booleans too. What are the two possible boolean literal values in Go?
            - title: "\U0001F4A1 Hint"
              content: >-
                Use result := true to declare a boolean variable. The compiler infers the bool type from the
                literal true.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>1. Declare bool variable with :=
                2. Return the variable</pre>
          solution: |-
            func isGoFun() bool {
                result := true
                return result
            }
          difficulty: 1
        - id: v5
          title: Multi-Variable Declaration
          description: >-
            Write <code>func multiDeclare() (string, int, bool)</code> that uses a single := to declare name, age,
            and active simultaneously. Set name="Go", age=15, active=true. Return all three.
          functionSignature: func multiDeclare() (string, int, bool)
          testCases:
            - input: ""
              output: "\"Go\", 15, true"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                Go lets you declare multiple variables in a single := statement by listing them on the left and
                their values on the right. How would you write this?
            - title: "\U0001F4A1 Hint"
              content: >-
                Use name, age, active := "Go", 15, true to declare all three at once. Each variable gets the type
                inferred from its corresponding value.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>1. Declare multiple variables: a, b, c := val1, val2, val3
                2. Return all variables</pre>
          solution: |-
            func multiDeclare() (string, int, bool) {
                name, age, active := "Go", 15, true
                return name, age, active
            }
          difficulty: 2
        - id: v6
          title: Zero Value Int
          description: >-
            Write <code>func zeroInt() int</code> that uses <code>var x int</code> (no assignment) and returns x.
            Should return 0 (the zero value for int).
          functionSignature: func zeroInt() int
          testCases:
            - input: ""
              output: "0"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                In Go, every type has a zero value. What is the zero value for int? What happens when you declare a
                variable with var but don't assign it?
            - title: "\U0001F4A1 Hint"
              content: >-
                Use var x int without any assignment. Go automatically initializes it to 0, the zero value for
                integers.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>1. Declare with var (no initial value)
                2. Return â€” variable has its zero value</pre>
          solution: |-
            func zeroInt() int {
                var x int
                return x
            }
          difficulty: 2
        - id: v7
          title: Zero Value String
          description: >-
            Write <code>func zeroString() string</code> that uses <code>var s string</code> and returns s. Should
            return "" (the zero value for string).
          functionSignature: func zeroString() string
          testCases:
            - input: ""
              output: "\"\""
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                Every Go type has a zero value. For int it's 0, for bool it's false. What is the zero value for
                string?
            - title: "\U0001F4A1 Hint"
              content: >-
                Use var s string without assignment. Go initializes strings to "" (empty string) by default.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>1. Declare with var (no initial value)
                2. Return â€” string zero value is ""</pre>
          solution: |-
            func zeroString() string {
                var s string
                return s
            }
          difficulty: 2
        - id: v8
          title: Swap Values
          description: >-
            Write <code>func swap(a, b int) (int, int)</code> that returns b, a (swapped). Use Go's simultaneous
            assignment.
          functionSignature: func swap(a, b int) (int, int)
          testCases:
            - input: "3, 7"
              output: "7, 3"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                Go functions can return multiple values. How do you return two values in a different order than
                they were received?
            - title: "\U0001F4A1 Hint"
              content: >-
                Simply return b, a. Go evaluates the right side fully before assigning, so no temporary variable is
                needed.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>1. Accept two parameters
                2. Return them in reverse order</pre>
          solution: |-
            func swap(a, b int) (int, int) {
                return b, a
            }
          difficulty: 2
        - id: v9
          title: Reassignment
          description: >-
            Write <code>func reassign() int</code> that declares x := 5, then reassigns x = 10 (note: = not :=),
            and returns x.
          functionSignature: func reassign() int
          testCases:
            - input: ""
              output: "10"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                There's a difference between := (declare and assign) and = (assign only). When do you use each
                one?
            - title: "\U0001F4A1 Hint"
              content: >-
                Use := for the first declaration, then = for reassignment. Using := again on the same variable in
                the same scope would cause an error.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>1. Declare with :=  (first use)
                2. Reassign with =  (already exists)
                3. Return the variable</pre>
          solution: |-
            func reassign() int {
                x := 5
                x = 10
                return x
            }
          difficulty: 2
        - id: v10
          title: Build Greeting
          description: >-
            Write <code>func buildGreeting(name, role string) string</code> that declares a greeting
            using := by combining "Welcome, " + name + " (" + role + ")!" and returns it.
          functionSignature: func buildGreeting(name, role string) string
          testCases:
            - input: "\"Alice\", \"admin\""
              output: "\"Welcome, Alice (admin)!\""
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                You can use any expression on the right side of :=. String concatenation with + builds longer
                strings from parts.
            - title: "\U0001F4A1 Hint"
              content: >-
                Use greeting := "Welcome, " + name + " (" + role + ")!". The type is inferred as string from the
                expression.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>1. Declare variable with := using concatenation
                2. Return the greeting</pre>
          solution: |-
            func buildGreeting(name, role string) string {
                greeting := "Welcome, " + name + " (" + role + ")!"
                return greeting
            }
          difficulty: 3
        - id: v11
          title: Multiple Assignment Math
          description: >-
            Write <code>func splitSeconds(totalSeconds int) (int, int, int)</code> that converts total seconds to
            hours, minutes, and seconds using := and returns all three.
          functionSignature: func splitSeconds(totalSeconds int) (int, int, int)
          testCases:
            - input: "3661"
              output: "1, 1, 1"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                To break down seconds, think about integer division and the modulo operator. How many seconds are
                in an hour? In a minute?
            - title: "\U0001F4A1 Hint"
              content: >-
                Use hours := totalSeconds / 3600 for hours. For minutes, take the remainder after removing hours
                and divide by 60. Seconds are the final remainder.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>1. hours := total / 3600
                2. minutes := (total % 3600) / 60
                3. seconds := total % 60
                4. Return all three</pre>
          solution: |-
            func splitSeconds(totalSeconds int) (int, int, int) {
                hours := totalSeconds / 3600
                minutes := (totalSeconds % 3600) / 60
                seconds := totalSeconds % 60
                return hours, minutes, seconds
            }
          difficulty: 3
        - id: v12
          title: Badge Generator
          description: >-
            Write <code>func badge(name, dept string) string</code> that declares badge := name + " - " + dept
            using short declaration and returns it. For example, badge("Alice", "Engineering") returns
            "Alice - Engineering".
          functionSignature: func badge(name, dept string) string
          testCases:
            - input: "\"Alice\", \"Engineering\""
              output: "\"Alice - Engineering\""
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                You can use string concatenation on the right side of :=. The type is inferred from the string
                expression.
            - title: "\U0001F4A1 Hint"
              content: >-
                Use badge := name + " - " + dept. The compiler infers the type as string from the concatenation
                expression.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>1. Declare badge with := using concatenation
                2. Return badge</pre>
          solution: |-
            func badge(name, dept string) string {
                badge := name + " - " + dept
                return badge
            }
          difficulty: 3
        - id: v13
          title: Var vs Short Declaration
          description: >-
            Write <code>func initializeAll() (int, string, bool, float64)</code> that uses <code>var</code> for the
            first two (int, string â€” they'll be zero values 0, "") and := for the last two (bool=true,
            float64=3.14). Return all four.
          functionSignature: func initializeAll() (int, string, bool, float64)
          testCases:
            - input: ""
              output: "0, \"\", true, 3.14"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                Sometimes you want a zero value (use var), and sometimes you want a specific initial value (use
                :=). When would you choose one over the other?
            - title: "\U0001F4A1 Hint"
              content: >-
                Use var n int and var s string for zero values. Use b := true and f := 3.14 for explicit values.
                Mix both styles in the same function.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>1. var for zero-value variables
                2. := for initialized variables
                3. Return all variables</pre>
          solution: |-
            func initializeAll() (int, string, bool, float64) {
                var n int
                var s string
                b := true
                f := 3.14
                return n, s, b, f
            }
          difficulty: 3
    - id: challenge_2
      block: 1
      difficulty: 1
      concept: Type Conversion
      docLinks:
        - url: https://go.dev/tour/basics/13
          title: "Go Tour: Type conversions"
          note: explicit conversion required
        - url: https://pkg.go.dev/strconv
          title: "strconv package"
          note: string/number conversions
      patternPrimer:
        bruteForce: Use separate variables for each type and convert explicitly at every step.
        bestApproach: Convert types at the point of use with Go's T(value) syntax; use strconv for string-number conversions.
        typical: Type conversions are O(1) â€” the key is knowing which conversion function to use.
      quickRef: |
        <code>int(f)</code> &nbsp; <code>float64(i)</code> &nbsp; <code>string(b)</code><br>
                <code>strconv.Itoa(i)</code> &nbsp; <code>strconv.Atoi(s)</code>
      variants:
        - id: v1
          title: Int to Float
          description: Write <code>func intToFloat(n int) float64</code> that converts an int to float64 and returns it.
          functionSignature: func intToFloat(n int) float64
          testCases:
            - input: "42"
              output: "42"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                Go requires explicit type conversions â€” no implicit casting. How do you convert one numeric type to
                another?
            - title: "\U0001F4A1 Hint"
              content: >-
                Use the target type as a function: float64(n). This explicitly converts the int value to float64.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>1. Use T(value) syntax: float64(n)
                2. Return the converted value</pre>
          solution: |-
            func intToFloat(n int) float64 {
                return float64(n)
            }
          difficulty: 1
        - id: v2
          title: Float to Int
          description: >-
            Write <code>func floatToInt(f float64) int</code> that converts a float64 to int (truncates the decimal
            portion).
          functionSignature: func floatToInt(f float64) int
          testCases:
            - input: "3.7"
              output: "3"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                Converting float to int truncates (drops) the decimal part â€” it does not round. What will int(3.9)
                give you?
            - title: "\U0001F4A1 Hint"
              content: >-
                Use int(f) to truncate the float. Remember: 3.7 becomes 3 and 3.2 also becomes 3 â€” always toward
                zero.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>1. Use int(floatValue) to truncate
                2. Return the converted value</pre>
          solution: |-
            func floatToInt(f float64) int {
                return int(f)
            }
          difficulty: 1
        - id: v3
          title: Format Progress
          description: >-
            Write <code>func formatProgress(completed, total int) float64</code> that converts completed and total
            to float64 and returns the completion percentage (0-100).
          functionSignature: func formatProgress(completed, total int) float64
          testCases:
            - input: "3, 4"
              output: "75"
            - input: "1, 3"
              output: "33.33333333333333"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                Integer division in Go truncates: 3/4 gives 0, not 0.75. How can you get the precise result?
            - title: "\U0001F4A1 Hint"
              content: >-
                Convert both operands to float64 before dividing, then multiply by 100:
                float64(completed) / float64(total) * 100.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>1. Convert both ints to float64
                2. Divide completed by total
                3. Multiply by 100 and return</pre>
          solution: |-
            func formatProgress(completed, total int) float64 {
                return float64(completed) / float64(total) * 100
            }
          difficulty: 1
        - id: v4
          title: Rune to String
          description: Write <code>func runeToString(r rune) string</code> that converts a rune to a string using string().
          functionSignature: func runeToString(r rune) string
          testCases:
            - input: "'A'"
              output: "\"A\""
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                A rune in Go represents a Unicode code point. The string() conversion on a rune produces the
                UTF-8 string for that character.
            - title: "\U0001F4A1 Hint"
              content: >-
                Use string(r) to convert a rune to its string representation. For example, string('A') gives "A".
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>1. Use string(rune) to convert
                2. Return the string</pre>
          solution: |-
            func runeToString(r rune) string {
                return string(r)
            }
          difficulty: 1
        - id: v5
          title: Int to String
          description: >-
            Write <code>func intToString(n int) string</code> that uses strconv.Itoa to convert an int to its string
            representation.
          functionSignature: func intToString(n int) string
          testCases:
            - input: "42"
              output: "\"42\""
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                string(42) gives you "*" (the character with code point 42), not "42". You need a different
                function for numeric-to-string conversion.
            - title: "\U0001F4A1 Hint"
              content: >-
                Use strconv.Itoa(n) (Integer to ASCII) from the strconv package. It converts an int to its decimal
                string representation.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>1. Import "strconv"
                2. Use strconv.Itoa(n)
                3. Return the string</pre>
          solution: |-
            func intToString(n int) string {
                return strconv.Itoa(n)
            }
          difficulty: 2
        - id: v6
          title: String to Int
          description: >-
            Write <code>func stringToInt(s string) (int, error)</code> that uses strconv.Atoi to parse a string as
            an int. Return the value and any error.
          functionSignature: func stringToInt(s string) (int, error)
          testCases:
            - input: "\"42\""
              output: "42, nil"
            - input: "\"abc\""
              output: "0, error"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                Parsing a string to a number can fail if the string isn't a valid number. How does Go communicate
                this potential failure?
            - title: "\U0001F4A1 Hint"
              content: >-
                Use strconv.Atoi(s) which returns (int, error). If the string can't be parsed, it returns 0 and a
                non-nil error.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>1. Call strconv.Atoi(s)
                2. Return both the value and the error</pre>
          solution: |-
            func stringToInt(s string) (int, error) {
                return strconv.Atoi(s)
            }
          difficulty: 2
        - id: v7
          title: Combine ID
          description: >-
            Write <code>func combineID(prefix string, id int) string</code> that combines a string prefix with
            an integer ID. For example, combineID("user", 42) returns "user-42".
          functionSignature: func combineID(prefix string, id int) string
          testCases:
            - input: "\"user\", 42"
              output: "\"user-42\""
            - input: "\"item\", 7"
              output: "\"item-7\""
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                You need to convert an int to a string to concatenate. string(42) gives "*" not "42". What
                function converts an int to its decimal string representation?
            - title: "\U0001F4A1 Hint"
              content: >-
                Use strconv.Itoa(id) to convert the integer to a string, then concatenate with prefix + "-" +
                the converted ID.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>1. Convert int to string: strconv.Itoa(id)
                2. Concatenate: prefix + "-" + idStr
                3. Return the result</pre>
          solution: |-
            func combineID(prefix string, id int) string {
                return prefix + "-" + strconv.Itoa(id)
            }
          difficulty: 2
        - id: v8
          title: Byte to Int
          description: Write <code>func byteToInt(b byte) int</code> that converts a byte to an int.
          functionSignature: func byteToInt(b byte) int
          testCases:
            - input: "byte(65)"
              output: "65"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                A byte in Go is an alias for uint8. Converting to int widens the value â€” no data is lost.
            - title: "\U0001F4A1 Hint"
              content: >-
                Use int(b) to convert from byte to int. Since byte is a smaller integer type, this conversion is
                always safe.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>1. Use int(byteValue) to widen
                2. Return the int</pre>
          solution: |-
            func byteToInt(b byte) int {
                return int(b)
            }
          difficulty: 2
        - id: v9
          title: Score Display
          description: >-
            Write <code>func scoreDisplay(score int) string</code> that converts an int score to a float64
            and formats it as a percentage string like "85.0%". Use fmt.Sprintf with float64 conversion.
          functionSignature: func scoreDisplay(score int) string
          testCases:
            - input: "85"
              output: "\"85.0%\""
            - input: "100"
              output: "\"100.0%\""
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                You need to convert an int to float64 for formatting with a decimal point. What format verb
                shows one decimal place?
            - title: "\U0001F4A1 Hint"
              content: >-
                Convert to float64 first, then use fmt.Sprintf("%.1f%%", float64(score)). The %% prints a
                literal % sign.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>1. Convert int to float64
                2. Format with fmt.Sprintf("%.1f%%", ...)
                3. Return the string</pre>
          solution: |-
            func scoreDisplay(score int) string {
                return fmt.Sprintf("%.1f%%", float64(score))
            }
          difficulty: 2
        - id: v10
          title: Safe Parse Int
          description: >-
            Write <code>func safeParse(s string, fallback int) int</code> that parses s as int with strconv.Atoi. If
            there is an error, return the fallback value instead.
          functionSignature: func safeParse(s string, fallback int) int
          testCases:
            - input: "\"10\", 0"
              output: "10"
            - input: "\"abc\", -1"
              output: "-1"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                strconv.Atoi returns an error when the string can't be parsed. How do you check for and handle
                this error?
            - title: "\U0001F4A1 Hint"
              content: >-
                Use n, err := strconv.Atoi(s). If err != nil, return the fallback. Otherwise return n. This is a
                common Go error handling pattern.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>1. n, err := strconv.Atoi(s)
                2. if err != nil { return fallback }
                3. return n</pre>
          solution: |-
            func safeParse(s string, fallback int) int {
                n, err := strconv.Atoi(s)
                if err != nil {
                    return fallback
                }
                return n
            }
          difficulty: 3
        - id: v11
          title: File Size Format
          description: >-
            Write <code>func fileSizeFormat(bytes int) string</code> that converts bytes to a human-readable
            string. If >= 1024, show as KB with one decimal. For example, 2048 returns "2.0 KB", 500 returns
            "500 B".
          functionSignature: func fileSizeFormat(bytes int) string
          testCases:
            - input: "2048"
              output: "\"2.0 KB\""
            - input: "500"
              output: "\"500 B\""
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                You need to choose between two formats based on the size. For the KB format, you need
                floating-point division.
            - title: "\U0001F4A1 Hint"
              content: >-
                Check if bytes >= 1024. If so, convert to float64 and divide by 1024.0, then format with
                "%.1f KB". Otherwise use "%d B".
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>1. If bytes >= 1024: format as KB with float64
                2. Otherwise: format as bytes
                3. Return the formatted string</pre>
          solution: |-
            func fileSizeFormat(bytes int) string {
                if bytes >= 1024 {
                    return fmt.Sprintf("%.1f KB", float64(bytes)/1024.0)
                }
                return fmt.Sprintf("%d B", bytes)
            }
          difficulty: 3
        - id: v12
          title: Rating Stars
          description: >-
            Write <code>func ratingStars(rating float64) int</code> that converts a float64 rating (like 3.7)
            to an integer star count by rounding to the nearest integer. Use int(rating + 0.5).
          functionSignature: func ratingStars(rating float64) int
          testCases:
            - input: "3.7"
              output: "4"
            - input: "3.2"
              output: "3"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                int() truncates toward zero. How can you add a bias before truncating to achieve rounding behavior?
            - title: "\U0001F4A1 Hint"
              content: >-
                Add 0.5 before converting: int(rating + 0.5). For 3.7: int(4.2) = 4. For 3.2: int(3.7) = 3.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>1. Add 0.5 to the rating
                2. Convert to int (truncates)
                3. Return the star count</pre>
          solution: |-
            func ratingStars(rating float64) int {
                return int(rating + 0.5)
            }
          difficulty: 3
        - id: v13
          title: Parse and Sum
          description: >-
            Write <code>func parseAndSum(a, b string) (int, error)</code> that parses both strings to ints and
            returns their sum. If either parse fails, return 0 and the error.
          functionSignature: func parseAndSum(a, b string) (int, error)
          testCases:
            - input: "\"3\", \"4\""
              output: "7, nil"
            - input: "\"3\", \"abc\""
              output: "0, error"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                You need to parse two strings, and either one could fail. How do you handle multiple potential
                errors in sequence?
            - title: "\U0001F4A1 Hint"
              content: >-
                Parse each string separately with strconv.Atoi. Check the error after each parse â€” if either fails,
                return 0 and the error immediately.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>1. x, err := strconv.Atoi(a)
                2. if err != nil { return 0, err }
                3. y, err := strconv.Atoi(b)
                4. if err != nil { return 0, err }
                5. return x + y, nil</pre>
          solution: |-
            func parseAndSum(a, b string) (int, error) {
                x, err := strconv.Atoi(a)
                if err != nil {
                    return 0, err
                }
                y, err := strconv.Atoi(b)
                if err != nil {
                    return 0, err
                }
                return x + y, nil
            }
          difficulty: 3
    - id: challenge_3
      block: 1
      difficulty: 1
      concept: String Formatting
      docLinks:
        - url: https://pkg.go.dev/fmt
          title: "fmt package"
          note: format verbs reference
        - url: https://go.dev/doc/effective_go#printing
          title: "Effective Go: Printing"
          note: formatting best practices
      patternPrimer:
        bruteForce: Concatenate strings manually with + and strconv conversions.
        bestApproach: Use fmt.Sprintf with format verbs for clean, readable string construction.
        typical: String formatting is O(n) in output length â€” Sprintf handles type formatting automatically.
      quickRef: |
        <code>fmt.Sprintf("%s is %d", name, age)</code><br>
                Verbs: <code>%v</code> any &nbsp; <code>%d</code> int &nbsp; <code>%s</code> string &nbsp; <code>%f</code> float &nbsp; <code>%t</code> bool
      variants:
        - id: v1
          title: Greet by Name
          description: >-
            Write <code>func greet(name string) string</code> that returns "Hello, {name}!" using fmt.Sprintf.
          functionSignature: func greet(name string) string
          testCases:
            - input: "\"Alice\""
              output: "\"Hello, Alice!\""
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                fmt.Sprintf works like Printf but returns the string instead of printing it. What format verb do
                you use for strings?
            - title: "\U0001F4A1 Hint"
              content: >-
                Use fmt.Sprintf("Hello, %s!", name). The %s verb inserts a string value into the format template.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>1. Use fmt.Sprintf with %s for strings
                2. Return the formatted string</pre>
          solution: |-
            func greet(name string) string {
                return fmt.Sprintf("Hello, %s!", name)
            }
          difficulty: 1
        - id: v2
          title: Format Age
          description: >-
            Write <code>func formatAge(name string, age int) string</code> that returns "{name} is {age} years old"
            using Sprintf.
          functionSignature: func formatAge(name string, age int) string
          testCases:
            - input: "\"Bob\", 25"
              output: "\"Bob is 25 years old\""
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                Sprintf can take multiple arguments with different types. What format verb do you use for integers?
            - title: "\U0001F4A1 Hint"
              content: >-
                Use fmt.Sprintf("%s is %d years old", name, age). The %s verb is for strings and %d is for
                integers.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>1. Use %s for string arguments
                2. Use %d for integer arguments
                3. Return fmt.Sprintf result</pre>
          solution: |-
            func formatAge(name string, age int) string {
                return fmt.Sprintf("%s is %d years old", name, age)
            }
          difficulty: 1
        - id: v3
          title: Format Price
          description: >-
            Write <code>func formatPrice(cents int) string</code> that converts cents to a dollar string like
            "$1.50". Use cents/100 for dollars and cents%100 for remaining cents.
          functionSignature: func formatPrice(cents int) string
          testCases:
            - input: "150"
              output: "\"$1.50\""
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                You need to split cents into dollars and remaining cents. Integer division and modulo can do this.
                How do you ensure two-digit cents like "50" instead of "5"?
            - title: "\U0001F4A1 Hint"
              content: >-
                Use fmt.Sprintf("$%d.%02d", cents/100, cents%100). The %02d format pads with zeros to ensure
                two digits for cents.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>1. dollars := cents / 100
                2. remaining := cents % 100
                3. Format with %02d for zero-padded cents</pre>
          solution: |-
            func formatPrice(cents int) string {
                return fmt.Sprintf("$%d.%02d", cents/100, cents%100)
            }
          difficulty: 1
        - id: v4
          title: Repeat Word
          description: >-
            Write <code>func repeatWord(word string, n int) string</code> that returns the word repeated n times,
            separated by spaces.
          functionSignature: func repeatWord(word string, n int) string
          testCases:
            - input: "\"go\", 3"
              output: "\"go go go\""
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                You need to build a string by repeating a word with spaces between them. How do you avoid a
                trailing space?
            - title: "\U0001F4A1 Hint"
              content: >-
                Loop n times, appending the word each iteration. Add a space before each word except the first one
                (check if i > 0).
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>1. Initialize result := ""
                2. Loop n times:
                   - If not first, add " "
                   - Add word
                3. Return result</pre>
          solution: |-
            func repeatWord(word string, n int) string {
                result := ""
                for i := 0; i < n; i++ {
                    if i > 0 {
                        result += " "
                    }
                    result += word
                }
                return result
            }
          difficulty: 1
        - id: v5
          title: Format Coordinates
          description: >-
            Write <code>func formatCoord(x, y float64) string</code> that returns "(x, y)" with 2 decimal places.
          functionSignature: func formatCoord(x, y float64) string
          testCases:
            - input: "3.14159, 2.71828"
              output: "\"(3.14, 2.72)\""
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                The %.Nf format verb controls how many decimal places a float is displayed with. What value of N
                gives two decimal places?
            - title: "\U0001F4A1 Hint"
              content: >-
                Use fmt.Sprintf("(%.2f, %.2f)", x, y). The %.2f verb formats a float with exactly 2 decimal
                places, rounding as needed.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>1. Use %.2f for 2-decimal-place floats
                2. Format both x and y in the template
                3. Return the formatted string</pre>
          solution: |-
            func formatCoord(x, y float64) string {
                return fmt.Sprintf("(%.2f, %.2f)", x, y)
            }
          difficulty: 2
        - id: v6
          title: Zero-Padded Time
          description: >-
            Write <code>func formatTime(h, m, s int) string</code> that returns "HH:MM:SS" with zero-padding.
          functionSignature: func formatTime(h, m, s int) string
          testCases:
            - input: "9, 5, 3"
              output: "\"09:05:03\""
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                Single-digit numbers need a leading zero (9 becomes 09). Which format verb width specifier adds
                leading zeros?
            - title: "\U0001F4A1 Hint"
              content: >-
                Use fmt.Sprintf("%02d:%02d:%02d", h, m, s). The %02d format pads integers with zeros to a minimum
                width of 2.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>1. Use %02d for zero-padded integers
                2. Separate hours, minutes, seconds with ":"
                3. Return the formatted string</pre>
          solution: |-
            func formatTime(h, m, s int) string {
                return fmt.Sprintf("%02d:%02d:%02d", h, m, s)
            }
          difficulty: 2
        - id: v7
          title: Quote String
          description: >-
            Write <code>func quoteString(s string) string</code> that returns the string with %q formatting (adds
            Go-syntax double quotes).
          functionSignature: func quoteString(s string) string
          testCases:
            - input: "\"hello world\""
              output: "\"\\\"hello world\\\"\""
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                The %q verb produces a Go-syntax quoted string literal, including the surrounding double quotes and
                any necessary escape sequences.
            - title: "\U0001F4A1 Hint"
              content: >-
                Use fmt.Sprintf("%q", s). The %q verb adds double quotes around the string and escapes special
                characters inside it.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>1. Use %q for Go-quoted strings
                2. Return the formatted result</pre>
          solution: |-
            func quoteString(s string) string {
                return fmt.Sprintf("%q", s)
            }
          difficulty: 2
        - id: v8
          title: Format Percentage
          description: >-
            Write <code>func formatPercent(value float64) string</code> that returns the value formatted as "XX.X%"
            with one decimal place.
          functionSignature: func formatPercent(value float64) string
          testCases:
            - input: "85.678"
              output: "\"85.7%\""
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                To include a literal % character in a Sprintf format string, you need to escape it. How do you
                escape % in a format string?
            - title: "\U0001F4A1 Hint"
              content: >-
                Use fmt.Sprintf("%.1f%%", value). The %.1f gives one decimal place, and %% produces a literal
                percent sign.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>1. Use %.1f for one decimal place
                2. Use %% for a literal % character
                3. Return the formatted string</pre>
          solution: |-
            func formatPercent(value float64) string {
                return fmt.Sprintf("%.1f%%", value)
            }
          difficulty: 2
        - id: v9
          title: Format List
          description: >-
            Write <code>func formatList(items []string) string</code> that formats items as a numbered list:
            "1. item\n2. item\n..."
          functionSignature: func formatList(items []string) string
          testCases:
            - input: "[]string{\"go\", \"rust\", \"python\"}"
              output: "\"1. go\\n2. rust\\n3. python\""
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                You need to build a multi-line string with numbered items. How do you get both the index and value
                from a range loop?
            - title: "\U0001F4A1 Hint"
              content: >-
                Use a range loop with index. Add a newline before each item except the first. Use
                fmt.Sprintf("%d. %s", i+1, item) for each line.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>1. Loop with index: for i, item := range items
                2. Add "\n" before each item (except first)
                3. Format each as "%d. %s" (i+1 for 1-based)
                4. Return accumulated result</pre>
          solution: |-
            func formatList(items []string) string {
                result := ""
                for i, item := range items {
                    if i > 0 {
                        result += "\n"
                    }
                    result += fmt.Sprintf("%d. %s", i+1, item)
                }
                return result
            }
          difficulty: 2
        - id: v10
          title: Table Row
          description: >-
            Write <code>func tableRow(name string, score int, grade string) string</code> that returns a fixed-width
            formatted row: name left-aligned in 15 chars, score right-aligned in 5 chars, grade right-aligned in 3
            chars. Use %-15s, %5d, %3s.
          functionSignature: func tableRow(name string, score int, grade string) string
          testCases:
            - input: "\"Alice\", 95, \"A\""
              output: "\"Alice           95   A\""
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                Format verbs can include width specifiers. A positive width right-aligns, and a negative width
                (with -) left-aligns. How do you combine these?
            - title: "\U0001F4A1 Hint"
              content: >-
                Use fmt.Sprintf("%-15s%5d%3s", name, score, grade). The - flag left-aligns the name, while score
                and grade are right-aligned by default.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>1. %-15s for left-aligned string (15 wide)
                2. %5d for right-aligned int (5 wide)
                3. %3s for right-aligned string (3 wide)
                4. Return the formatted row</pre>
          solution: |-
            func tableRow(name string, score int, grade string) string {
                return fmt.Sprintf("%-15s%5d%3s", name, score, grade)
            }
          difficulty: 3
        - id: v11
          title: Format Bytes
          description: >-
            Write <code>func formatBytes(bytes int) string</code> that formats a byte count as human-readable:
            less than 1024 returns "X B", less than 1048576 returns "X.XX KB", otherwise returns "X.XX MB".
          functionSignature: func formatBytes(bytes int) string
          testCases:
            - input: "500"
              output: "\"500 B\""
            - input: "1536"
              output: "\"1.50 KB\""
            - input: "2621440"
              output: "\"2.50 MB\""
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                You need to choose the right unit based on the size. What thresholds separate bytes, kilobytes, and
                megabytes?
            - title: "\U0001F4A1 Hint"
              content: >-
                Use if/else to check thresholds: < 1024 for bytes, < 1048576 for KB, else MB. Divide by the
                appropriate power of 1024 and format with %.2f.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>1. if bytes < 1024: format as "%d B"
                2. else if bytes < 1048576: format as "%.2f KB"
                3. else: format as "%.2f MB"</pre>
          solution: |-
            func formatBytes(bytes int) string {
                if bytes < 1024 {
                    return fmt.Sprintf("%d B", bytes)
                }
                if bytes < 1048576 {
                    return fmt.Sprintf("%.2f KB", float64(bytes)/1024.0)
                }
                return fmt.Sprintf("%.2f MB", float64(bytes)/1048576.0)
            }
          difficulty: 3
        - id: v12
          title: Format Duration
          description: >-
            Write <code>func formatDuration(seconds int) string</code> that formats as "Xh Ym Zs", omitting the
            hours component when zero. E.g., 3661 returns "1h 1m 1s", 120 returns "2m 0s", 45 returns "45s".
          functionSignature: func formatDuration(seconds int) string
          testCases:
            - input: "3661"
              output: "\"1h 1m 1s\""
            - input: "120"
              output: "\"2m 0s\""
            - input: "45"
              output: "\"45s\""
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                Break seconds into hours, minutes, and remaining seconds using division and modulo. Then decide
                which components to include in the output.
            - title: "\U0001F4A1 Hint"
              content: >-
                Calculate h, m, s from the total. If h > 0, include all three. If only m > 0, include minutes and
                seconds. Otherwise just seconds.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>1. h := seconds / 3600
                2. m := (seconds % 3600) / 60
                3. s := seconds % 60
                4. Build string based on which components > 0</pre>
          solution: |-
            func formatDuration(seconds int) string {
                h := seconds / 3600
                m := (seconds % 3600) / 60
                s := seconds % 60
                if h > 0 {
                    return fmt.Sprintf("%dh %dm %ds", h, m, s)
                }
                if m > 0 {
                    return fmt.Sprintf("%dm %ds", m, s)
                }
                return fmt.Sprintf("%ds", s)
            }
          difficulty: 3
        - id: v13
          title: Format Plural
          description: >-
            Write <code>func formatPlural(count int, singular string) string</code> that returns "1 item" or
            "N items". If count is 1, use the singular form. Otherwise append "s".
          functionSignature: func formatPlural(count int, singular string) string
          testCases:
            - input: "1, \"cat\""
              output: "\"1 cat\""
            - input: "5, \"cat\""
              output: "\"5 cats\""
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                You need to conditionally add an "s" suffix based on the count. What is the simplest way to check
                for singular vs plural?
            - title: "\U0001F4A1 Hint"
              content: >-
                Check if count == 1. If so, use the singular form. Otherwise, append "s" to the singular word.
                Use fmt.Sprintf to combine the count and word.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>1. if count == 1: return "%d %s" (singular)
                2. else: return "%d %ss" (plural with s)</pre>
          solution: |-
            func formatPlural(count int, singular string) string {
                if count == 1 {
                    return fmt.Sprintf("%d %s", count, singular)
                }
                return fmt.Sprintf("%d %ss", count, singular)
            }
          difficulty: 3
    - id: challenge_4
      block: 1
      difficulty: 1
      concept: Function Basics
      docLinks:
        - url: https://go.dev/tour/basics/4
          title: "Go Tour: Functions"
          note: function syntax
        - url: https://go.dev/ref/spec#Function_declarations
          title: "Go Spec: Function declarations"
          note: full specification
      patternPrimer:
        bruteForce: Write separate functions for every operation, even trivial ones.
        bestApproach: Design functions with clear input/output contracts; use same-type parameter shorthand for cleaner signatures.
        typical: Focus on correct signatures, parameter types, and return types.
      quickRef: |
        <code>func name(a int, b string) int { }</code><br>
                <code>func name(a, b int) (int, error) { }</code>
      variants:
        - id: v1
          title: Greet
          description: >-
            Write <code>func greet(name string) string</code> that returns "Hello, {name}!". For example,
            greet("Alice") returns "Hello, Alice!".
          functionSignature: func greet(name string) string
          testCases:
            - input: "\"Alice\""
              output: "\"Hello, Alice!\""
            - input: "\"World\""
              output: "\"Hello, World!\""
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                A function takes input parameters and returns a result. How do you build a formatted string from a
                variable?
            - title: "\U0001F4A1 Hint"
              content: >-
                Use string concatenation: return "Hello, " + name + "!" or use fmt.Sprintf("Hello, %s!", name).
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>1. Define function with string parameter and return type
                2. Return concatenated greeting string</pre>
          solution: |-
            func greet(name string) string {
                return "Hello, " + name + "!"
            }
          difficulty: 1
        - id: v2
          title: Is Positive
          description: Write <code>func isPositive(n int) bool</code> that returns true if n is greater than 0.
          functionSignature: func isPositive(n int) bool
          testCases:
            - input: "5"
              output: "true"
            - input: "-3"
              output: "false"
            - input: "0"
              output: "false"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                A comparison expression like n > 0 already evaluates to a bool. Do you need an if statement?
            - title: "\U0001F4A1 Hint"
              content: >-
                Return the comparison directly: return n > 0. No if/else needed â€” the comparison itself is a bool
                value.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>1. Return a boolean expression directly
                2. No if/else needed for simple conditions</pre>
          solution: |-
            func isPositive(n int) bool {
                return n > 0
            }
          difficulty: 1
        - id: v3
          title: Full Name
          description: >-
            Write <code>func fullName(first, last string) string</code> that returns "{first} {last}". Note the
            same-type parameter shorthand.
          functionSignature: func fullName(first, last string) string
          testCases:
            - input: "\"John\", \"Doe\""
              output: "\"John Doe\""
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                When consecutive parameters share the same type, Go lets you write the type only once. How do you
                concatenate two strings with a space?
            - title: "\U0001F4A1 Hint"
              content: >-
                Use string concatenation: return first + " " + last. The (first, last string) shorthand means both
                parameters are strings.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>1. Use same-type shorthand: (a, b type)
                2. Concatenate with + operator
                3. Return the combined string</pre>
          solution: |-
            func fullName(first, last string) string {
                return first + " " + last
            }
          difficulty: 1
        - id: v4
          title: Max of Two
          description: Write <code>func maxOf(a, b int) int</code> that returns the larger of a and b.
          functionSignature: func maxOf(a, b int) int
          testCases:
            - input: "3, 7"
              output: "7"
            - input: "10, 5"
              output: "10"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                You need to compare two values and return the larger one. What control structure lets you choose
                between two options?
            - title: "\U0001F4A1 Hint"
              content: >-
                Use an if statement: if a > b, return a; otherwise return b. Go doesn't have a ternary operator,
                so use if/else.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>1. if a > b { return a }
                2. return b</pre>
          solution: |-
            func maxOf(a, b int) int {
                if a > b {
                    return a
                }
                return b
            }
          difficulty: 1
        - id: v5
          title: Truncate
          description: >-
            Write <code>func truncate(s string, maxLen int) string</code> that returns s if its length is <=
            maxLen, otherwise returns the first maxLen characters. For example, truncate("hello world", 5)
            returns "hello".
          functionSignature: func truncate(s string, maxLen int) string
          testCases:
            - input: "\"hello world\", 5"
              output: "\"hello\""
            - input: "\"hi\", 5"
              output: "\"hi\""
            - input: "\"exact\", 5"
              output: "\"exact\""
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                You need to check the string's length against a maximum. If it's short enough, return as-is. Otherwise,
                how do you take a substring of the first N characters?
            - title: "\U0001F4A1 Hint"
              content: >-
                Check if len(s) <= maxLen (return s). Otherwise return s[:maxLen] to take the first maxLen bytes.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>1. if len(s) <= maxLen { return s }
                2. return s[:maxLen]</pre>
          solution: |-
            func truncate(s string, maxLen int) string {
                if len(s) <= maxLen {
                    return s
                }
                return s[:maxLen]
            }
          difficulty: 2
        - id: v6
          title: Pluralize
          description: >-
            Write <code>func pluralize(count int, word string) string</code> that returns "1 item" when count
            is 1, or "N items" (with an "s") otherwise. For example, pluralize(3, "cat") returns "3 cats".
          functionSignature: func pluralize(count int, word string) string
          testCases:
            - input: "1, \"cat\""
              output: "\"1 cat\""
            - input: "3, \"cat\""
              output: "\"3 cats\""
            - input: "0, \"dog\""
              output: "\"0 dogs\""
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                You need to conditionally add an "s" suffix. When should the singular form be used?
            - title: "\U0001F4A1 Hint"
              content: >-
                Check if count == 1. If so, return without "s". Otherwise append "s" to the word. Use
                fmt.Sprintf to format the result.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>1. if count == 1: return fmt.Sprintf("%d %s", count, word)
                2. return fmt.Sprintf("%d %ss", count, word)</pre>
          solution: |-
            func pluralize(count int, word string) string {
                if count == 1 {
                    return fmt.Sprintf("%d %s", count, word)
                }
                return fmt.Sprintf("%d %ss", count, word)
            }
          difficulty: 2
        - id: v7
          title: Is Between
          description: >-
            Write <code>func isBetween(n, low, high int) bool</code> that returns true if low <= n <= high.
          functionSignature: func isBetween(n, low, high int) bool
          testCases:
            - input: "5, 1, 10"
              output: "true"
            - input: "0, 1, 10"
              output: "false"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                You need to check that n satisfies two conditions simultaneously. What logical operator combines
                two boolean conditions?
            - title: "\U0001F4A1 Hint"
              content: >-
                Return n >= low && n <= high. The && operator ensures both conditions must be true. Return the
                boolean expression directly.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>1. Check n >= low AND n <= high
                2. Return the boolean expression directly</pre>
          solution: |-
            func isBetween(n, low, high int) bool {
                return n >= low && n <= high
            }
          difficulty: 2
        - id: v8
          title: Initials
          description: >-
            Write <code>func getInitials(first, last string) string</code> that returns the first letter of each
            name as uppercase initials. For example, getInitials("john", "doe") returns "JD".
          functionSignature: func getInitials(first, last string) string
          testCases:
            - input: "\"John\", \"Doe\""
              output: "\"JD\""
            - input: "\"alice\", \"smith\""
              output: "\"AS\""
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                You need to extract the first character of each string and ensure they are uppercase. What Go
                package provides case conversion for individual characters?
            - title: "\U0001F4A1 Hint"
              content: >-
                Use strings.ToUpper(string(first[0])) to get the uppercased first letter. Concatenate both initials
                into a single string.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>1. Get first char of each name: string(first[0]), string(last[0])
                2. Uppercase each: strings.ToUpper()
                3. Concatenate and return</pre>
          solution: |-
            func getInitials(first, last string) string {
                return strings.ToUpper(string(first[0])) + strings.ToUpper(string(last[0]))
            }
          difficulty: 2
        - id: v9
          title: Initial
          description: >-
            Write <code>func initial(name string) string</code> that returns the first character of name as a
            string. Use string(name[0]).
          functionSignature: func initial(name string) string
          testCases:
            - input: "\"Alice\""
              output: "\"A\""
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                Indexing a string with [0] gives you a byte, not a string. How do you convert a byte back to a
                string?
            - title: "\U0001F4A1 Hint"
              content: >-
                Use string(name[0]) to get the first byte and convert it to a single-character string. This works
                for ASCII characters.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>1. Access first byte: name[0]
                2. Convert to string: string(name[0])
                3. Return the result</pre>
          solution: |-
            func initial(name string) string {
                return string(name[0])
            }
          difficulty: 2
        - id: v10
          title: Censor Word
          description: >-
            Write <code>func censor(word string) string</code> that replaces all characters except the first and
            last with asterisks. For example, censor("hello") returns "h***o". If the word is 2 chars or fewer,
            return it unchanged.
          functionSignature: func censor(word string) string
          testCases:
            - input: "\"hello\""
              output: "\"h***o\""
            - input: "\"Go\""
              output: "\"Go\""
            - input: "\"abc\""
              output: "\"a*c\""
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                You need to keep the first and last characters and replace everything in between. How do you build
                a string of repeated characters?
            - title: "\U0001F4A1 Hint"
              content: >-
                If len(word) <= 2, return as-is. Otherwise, build: string(word[0]) + repeated "*" for the middle +
                string(word[len-1]). Use strings.Repeat for the asterisks.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>1. if len(word) <= 2: return word
                2. middle := strings.Repeat("*", len(word)-2)
                3. return string(word[0]) + middle + string(word[len(word)-1])</pre>
          solution: |-
            func censor(word string) string {
                if len(word) <= 2 {
                    return word
                }
                middle := strings.Repeat("*", len(word)-2)
                return string(word[0]) + middle + string(word[len(word)-1])
            }
          difficulty: 3
        - id: v11
          title: Slugify
          description: >-
            Write <code>func slugify(title string) string</code> that converts a title to a URL slug by
            lowercasing and replacing spaces with hyphens. For example, "Hello World" becomes "hello-world".
          functionSignature: func slugify(title string) string
          testCases:
            - input: "\"Hello World\""
              output: "\"hello-world\""
            - input: "\"Go Is Fun\""
              output: "\"go-is-fun\""
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                You need two transformations: lowercase the string and replace spaces. The strings package has
                functions for both. What order should you apply them?
            - title: "\U0001F4A1 Hint"
              content: >-
                Use strings.ToLower() to lowercase, then strings.ReplaceAll() to swap spaces for hyphens. Chain
                the two calls.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>1. lower := strings.ToLower(title)
                2. slug := strings.ReplaceAll(lower, " ", "-")
                3. return slug</pre>
          solution: |-
            func slugify(title string) string {
                return strings.ReplaceAll(strings.ToLower(title), " ", "-")
            }
          difficulty: 3
        - id: v12
          title: Fizz Buzz Single
          description: >-
            Write <code>func fizzBuzz(n int) string</code> that returns "FizzBuzz" if divisible by 15, "Fizz" if
            divisible by 3, "Buzz" if divisible by 5, else the number as a string.
          functionSignature: func fizzBuzz(n int) string
          testCases:
            - input: "15"
              output: "\"FizzBuzz\""
            - input: "3"
              output: "\"Fizz\""
            - input: "5"
              output: "\"Buzz\""
            - input: "7"
              output: "\"7\""
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                The order of checks matters. Why should you check divisible-by-15 before checking divisible-by-3 or
                divisible-by-5?
            - title: "\U0001F4A1 Hint"
              content: >-
                Check n%15 == 0 first (both 3 and 5), then n%3 == 0, then n%5 == 0. For the default case, convert
                n to string with strconv.Itoa(n).
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>1. if n%15 == 0: return "FizzBuzz"
                2. if n%3 == 0: return "Fizz"
                3. if n%5 == 0: return "Buzz"
                4. return strconv.Itoa(n)</pre>
          solution: |-
            func fizzBuzz(n int) string {
                if n%15 == 0 {
                    return "FizzBuzz"
                }
                if n%3 == 0 {
                    return "Fizz"
                }
                if n%5 == 0 {
                    return "Buzz"
                }
                return strconv.Itoa(n)
            }
          difficulty: 3
        - id: v13
          title: Leap Year
          description: >-
            Write <code>func isLeapYear(year int) bool</code> that returns true if year is a leap year (divisible by
            4, but not by 100 unless also divisible by 400).
          functionSignature: func isLeapYear(year int) bool
          testCases:
            - input: "2000"
              output: "true"
            - input: "1900"
              output: "false"
            - input: "2024"
              output: "true"
            - input: "2023"
              output: "false"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                The leap year rule has three conditions combined with AND and OR. How do you express "divisible by 4
                AND (not divisible by 100 OR divisible by 400)"?
            - title: "\U0001F4A1 Hint"
              content: >-
                Return year%4 == 0 && (year%100 != 0 || year%400 == 0). Use parentheses to group the OR condition
                correctly.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>1. Check divisible by 4: year%4 == 0
                2. AND not divisible by 100: year%100 != 0
                3. OR divisible by 400: year%400 == 0
                4. Return the combined boolean expression</pre>
          solution: |-
            func isLeapYear(year int) bool {
                return year%4 == 0 && (year%100 != 0 || year%400 == 0)
            }
          difficulty: 3
    - id: challenge_5
      block: 1
      difficulty: 1
      concept: "Multiple Returns"
      docLinks:
        - url: https://go.dev/tour/basics/6
          title: "Go Tour: Multiple results"
          note: returning multiple values
        - url: https://go.dev/doc/effective_go#multiple-returns
          title: "Effective Go: Multiple return values"
          note: idiomatic usage
      patternPrimer:
        bruteForce: Use structs or global variables to return multiple pieces of data.
        bestApproach: Use Go's native multiple return values for clean, expressive function signatures.
        typical: Multiple returns add no overhead â€” they are a core Go idiom.
      quickRef: |
        <code>func f() (int, error) { return 0, nil }</code><br>
                <code>v, err := f()</code> &nbsp; Use <code>_</code> to discard a return value
      variants:
        - id: v1
          title: Min and Max
          description: >-
            Write <code>func minMax(a, b int) (int, int)</code> that returns the smaller value first, then the larger.
          functionSignature: func minMax(a, b int) (int, int)
          testCases:
            - input: "3, 7"
              output: "3, 7"
            - input: "10, 2"
              output: "2, 10"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                You need to return two values. Which one should come first? Think about how to compare
                two numbers and decide the order.
            - title: "\U0001F4A1 Hint"
              content: >-
                Use an if statement to check which is smaller. Return in the correct order for each case.
                Go lets you return two values separated by a comma.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>1. Compare a and b
                2. If a < b: return a, b
                3. Otherwise: return b, a</pre>
          solution: |-
            func minMax(a, b int) (int, int) {
                if a < b {
                    return a, b
                }
                return b, a
            }
          difficulty: 1
        - id: v2
          title: Name Parts
          description: >-
            Write <code>func nameParts(full string) (string, string)</code> that splits "First Last" at the space
            and returns the first name and last name. Assume exactly one space.
          functionSignature: func nameParts(full string) (string, string)
          testCases:
            - input: "\"John Doe\""
              output: "\"John\", \"Doe\""
            - input: "\"Jane Smith\""
              output: "\"Jane\", \"Smith\""
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                You need to find where the space is in the string. Once you know the position, how can you
                extract the part before and after it?
            - title: "\U0001F4A1 Hint"
              content: >-
                Use strings.Index(full, " ") to find the space position, then slice the string. Or use
                strings.Cut(full, " ") which returns both parts and a boolean.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>1. Find the space position with strings.Cut or strings.Index
                2. Extract substring before the space (first name)
                3. Extract substring after the space (last name)
                4. Return both</pre>
          solution: |-
            func nameParts(full string) (string, string) {
                first, last, _ := strings.Cut(full, " ")
                return first, last
            }
          difficulty: 1
        - id: v3
          title: Split at Char
          description: >-
            Write <code>func splitAtChar(s string, sep byte) (string, string, bool)</code> that splits a string
            at the first occurrence of sep. Return both parts and true, or ("", "", false) if sep not found.
          functionSignature: func splitAtChar(s string, sep byte) (string, string, bool)
          testCases:
            - input: "\"hello-world\", '-'"
              output: "\"hello\", \"world\", true"
            - input: "\"abc\", '-'"
              output: "\"\", \"\", false"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                You need to find the first occurrence of sep in the string and split at that point. How do you
                loop through a string's bytes?
            - title: "\U0001F4A1 Hint"
              content: >-
                Loop through s with an index. When s[i] == sep, return s[:i] and s[i+1:] and true. If the loop
                ends without finding sep, return empty strings and false.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>1. For i := 0; i < len(s); i++:
                   - If s[i] == sep: return s[:i], s[i+1:], true
                2. Return "", "", false</pre>
          solution: |-
            func splitAtChar(s string, sep byte) (string, string, bool) {
                for i := 0; i < len(s); i++ {
                    if s[i] == sep {
                        return s[:i], s[i+1:], true
                    }
                }
                return "", "", false
            }
          difficulty: 1
        - id: v4
          title: Count and Collect
          description: >-
            Write <code>func filterByLen(words []string, minLen int) ([]string, int)</code> that returns a
            slice of words with length >= minLen and the count of matching words.
          functionSignature: func filterByLen(words []string, minLen int) ([]string, int)
          testCases:
            - input: "[]string{\"go\", \"rust\", \"c\", \"python\"}, 3"
              output: "[]string{\"rust\", \"python\"}, 2"
            - input: "[]string{\"hi\", \"hello\"}, 5"
              output: "[]string{\"hello\"}, 1"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                You need to filter and count at the same time. Can you build the result slice and derive the
                count from it?
            - title: "\U0001F4A1 Hint"
              content: >-
                Loop through words, appending those with len(word) >= minLen. After the loop, return the result
                slice and len(result).
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>1. result := []string{}
                2. For each word in words:
                   - If len(word) >= minLen: append to result
                3. Return result, len(result)</pre>
          solution: |-
            func filterByLen(words []string, minLen int) ([]string, int) {
                result := []string{}
                for _, word := range words {
                    if len(word) >= minLen {
                        result = append(result, word)
                    }
                }
                return result, len(result)
            }
          difficulty: 1
        - id: v5
          title: First and Last
          description: >-
            Write <code>func firstLast(s string) (byte, byte)</code> that returns the first and last byte of a
            string.
          functionSignature: func firstLast(s string) (byte, byte)
          testCases:
            - input: "\"hello\""
              output: "'h', 'o'"
            - input: "\"Go\""
              output: "'G', 'o'"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                Strings in Go can be indexed like arrays to get individual bytes. How do you access the first
                element? How about the last?
            - title: "\U0001F4A1 Hint"
              content: >-
                The first byte is s[0]. The last byte is s[len(s)-1]. Return both values together.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>1. Get first byte: s[0]
                2. Get last byte: s[len(s)-1]
                3. Return both</pre>
          solution: |-
            func firstLast(s string) (byte, byte) {
                return s[0], s[len(s)-1]
            }
          difficulty: 2
        - id: v6
          title: Parse Key-Value
          description: >-
            Write <code>func parseKeyValue(s string) (string, string, error)</code> that splits a "key=value"
            string into key and value. Return an error if there's no '=' sign.
          functionSignature: func parseKeyValue(s string) (string, string, error)
          testCases:
            - input: "\"name=Alice\""
              output: "\"name\", \"Alice\", nil"
            - input: "\"invalid\""
              output: "\"\", \"\", error"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                You need to find the '=' character and split the string there. What should you return when
                the separator is missing?
            - title: "\U0001F4A1 Hint"
              content: >-
                Use strings.Cut(s, "=") which returns (before, after, found). If !found, return empty strings
                and an error. Otherwise return the key and value with nil error.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>1. key, value, ok := strings.Cut(s, "=")
                2. If !ok: return "", "", errors.New("no = found")
                3. Return key, value, nil</pre>
          solution: |-
            func parseKeyValue(s string) (string, string, error) {
                key, value, ok := strings.Cut(s, "=")
                if !ok {
                    return "", "", errors.New("missing = separator")
                }
                return key, value, nil
            }
          difficulty: 2
        - id: v7
          title: Head and Rest
          description: >-
            Write <code>func headAndRest(sentence string) (string, string)</code> that returns the first word
            and the remaining words from a sentence. For example, "hello world today" returns "hello" and
            "world today".
          functionSignature: func headAndRest(sentence string) (string, string)
          testCases:
            - input: "\"hello world today\""
              output: "\"hello\", \"world today\""
            - input: "\"single\""
              output: "\"single\", \"\""
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                You need to find the first space and split there. What happens if there's no space in the
                string?
            - title: "\U0001F4A1 Hint"
              content: >-
                Use strings.Cut(sentence, " "). It returns (before, after, found). If no space is found, the
                whole string is the head and rest is empty.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>1. head, rest, _ := strings.Cut(sentence, " ")
                2. Return head, rest</pre>
          solution: |-
            func headAndRest(sentence string) (string, string) {
                head, rest, _ := strings.Cut(sentence, " ")
                return head, rest
            }
          difficulty: 2
        - id: v8
          title: Head and Tail
          description: >-
            Write <code>func headTail(nums []int) (int, []int)</code> that returns the first element and the
            remaining slice.
          functionSignature: func headTail(nums []int) (int, []int)
          testCases:
            - input: "[]int{1, 2, 3, 4}"
              output: "1, []int{2, 3, 4}"
            - input: "[]int{10, 20}"
              output: "10, []int{20}"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                The head is a single element and the tail is a slice. How do you get everything except the
                first element from a slice?
            - title: "\U0001F4A1 Hint"
              content: >-
                The first element is nums[0]. The tail is nums[1:] which gives everything from index 1
                onward. Return both.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>1. Head = nums[0]
                2. Tail = nums[1:]
                3. Return head, tail</pre>
          solution: |-
            func headTail(nums []int) (int, []int) {
                return nums[0], nums[1:]
            }
          difficulty: 2
        - id: v9
          title: Bounds
          description: >-
            Write <code>func bounds(nums []int) (int, int)</code> that finds and returns the minimum and maximum
            values of a slice.
          functionSignature: func bounds(nums []int) (int, int)
          testCases:
            - input: "[]int{3, 1, 4, 1, 5}"
              output: "1, 5"
            - input: "[]int{7, 2, 9, 4}"
              output: "2, 9"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                You need to track two values as you scan through the slice. What should you initialize them
                to?
            - title: "\U0001F4A1 Hint"
              content: >-
                Initialize both min and max to the first element. Loop through the rest and update min when
                you find something smaller, max when you find something larger.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>1. min, max := nums[0], nums[0]
                2. For each element in nums:
                   - If element < min: min = element
                   - If element > max: max = element
                3. Return min, max</pre>
          solution: |-
            func bounds(nums []int) (int, int) {
                min, max := nums[0], nums[0]
                for _, n := range nums[1:] {
                    if n < min {
                        min = n
                    }
                    if n > max {
                        max = n
                    }
                }
                return min, max
            }
          difficulty: 2
        - id: v10
          title: Lookup with Found
          description: >-
            Write <code>func lookup(names []string, target string) (int, bool)</code> that finds target in names.
            Return (index, true) if found, or (-1, false) if not.
          functionSignature: func lookup(names []string, target string) (int, bool)
          testCases:
            - input: "[]string{\"a\", \"b\", \"c\"}, \"b\""
              output: "1, true"
            - input: "[]string{\"a\", \"b\", \"c\"}, \"z\""
              output: "-1, false"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                This is a linear search that returns two things: where the item is and whether it was found.
                What should you return if you finish the loop without finding it?
            - title: "\U0001F4A1 Hint"
              content: >-
                Use a for loop with range to get both index and value. Compare each value to target. If
                found, return immediately with the index and true.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>1. For i, name := range names:
                   - If name == target: return i, true
                2. After loop: return -1, false</pre>
          solution: |-
            func lookup(names []string, target string) (int, bool) {
                for i, name := range names {
                    if name == target {
                        return i, true
                    }
                }
                return -1, false
            }
          difficulty: 3
        - id: v11
          title: Parse Score
          description: >-
            Write <code>func parseScore(s string) (int, string, error)</code> that parses a string in "85/A"
            format. Return the number, the letter grade, and an error if the format is invalid.
          functionSignature: func parseScore(s string) (int, string, error)
          testCases:
            - input: "\"85/A\""
              output: "85, \"A\", nil"
            - input: "\"bad\""
              output: "0, \"\", error"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                You need to split the string at "/" and then convert the first part to a number. What
                happens if there is no "/" or the number part is not valid?
            - title: "\U0001F4A1 Hint"
              content: >-
                Use strings.Cut(s, "/") to split at the slash. It returns (before, after, found). Then use
                strconv.Atoi on the number part. Check errors at each step.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>1. Split string at "/" using strings.Cut
                2. If no "/" found: return 0, "", error
                3. Parse number part with strconv.Atoi
                4. If parse fails: return 0, "", error
                5. Return number, grade, nil</pre>
          solution: |-
            func parseScore(s string) (int, string, error) {
                numStr, grade, ok := strings.Cut(s, "/")
                if !ok {
                    return 0, "", errors.New("invalid format: missing /")
                }
                num, err := strconv.Atoi(numStr)
                if err != nil {
                    return 0, "", fmt.Errorf("invalid number: %w", err)
                }
                return num, grade, nil
            }
          difficulty: 3
        - id: v12
          title: Statistics
          description: >-
            Write <code>func stats(nums []int) (int, int, float64)</code> that returns the minimum, maximum,
            and average of the slice.
          functionSignature: func stats(nums []int) (int, int, float64)
          testCases:
            - input: "[]int{2, 4, 6, 8}"
              output: "2, 8, 5.0"
            - input: "[]int{1, 3, 5}"
              output: "1, 5, 3.0"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                You need three pieces of information from one pass through the slice. Can you track min,
                max, and sum all in the same loop?
            - title: "\U0001F4A1 Hint"
              content: >-
                Initialize min and max to nums[0] and sum to 0. In one loop, update min and max as needed,
                and add to sum. Compute the average after the loop.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>1. min, max := nums[0], nums[0]; sum := 0
                2. For each n in nums:
                   - If n < min: min = n
                   - If n > max: max = n
                   - sum += n
                3. avg := float64(sum) / float64(len(nums))
                4. Return min, max, avg</pre>
          solution: |-
            func stats(nums []int) (int, int, float64) {
                min, max := nums[0], nums[0]
                sum := 0
                for _, n := range nums {
                    if n < min {
                        min = n
                    }
                    if n > max {
                        max = n
                    }
                    sum += n
                }
                return min, max, float64(sum) / float64(len(nums))
            }
          difficulty: 3
        - id: v13
          title: Longest and Shortest
          description: >-
            Write <code>func longestShortest(words []string) (string, string)</code> that returns the longest
            and shortest strings from a slice.
          functionSignature: func longestShortest(words []string) (string, string)
          testCases:
            - input: "[]string{\"go\", \"python\", \"c\"}"
              output: "\"python\", \"c\""
            - input: "[]string{\"hello\", \"hi\", \"hey\"}"
              output: "\"hello\", \"hi\""
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                This is like finding min and max, but instead of comparing numbers, you are comparing string
                lengths. What do you initialize your tracking variables to?
            - title: "\U0001F4A1 Hint"
              content: >-
                Start with longest and shortest both set to the first word. Loop through and compare
                len(word) to update each tracker.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>1. longest, shortest := words[0], words[0]
                2. For each word in words:
                   - If len(word) > len(longest): longest = word
                   - If len(word) < len(shortest): shortest = word
                3. Return longest, shortest</pre>
          solution: |-
            func longestShortest(words []string) (string, string) {
                longest, shortest := words[0], words[0]
                for _, word := range words[1:] {
                    if len(word) > len(longest) {
                        longest = word
                    }
                    if len(word) < len(shortest) {
                        shortest = word
                    }
                }
                return longest, shortest
            }
          difficulty: 3
    - id: challenge_6
      block: 1
      difficulty: 2
      concept: "Error Handling"
      docLinks:
        - url: https://go.dev/blog/error-handling-and-go
          title: "Go Blog: Error handling and Go"
          note: idiomatic error patterns
        - url: https://go.dev/tour/methods/19
          title: "Go Tour: Errors"
          note: error interface
      patternPrimer:
        bruteForce: Use panics or ignore errors entirely.
        bestApproach: Return errors as values; check err != nil immediately after each call that can fail.
        typical: Error handling adds minimal overhead â€” the pattern is if err != nil { return ..., err }.
      quickRef: |
        <code>if err != nil { return err }</code><br>
                <code>fmt.Errorf("context: %w", err)</code> &nbsp; <code>errors.Is()</code>
      variants:
        - id: v1
          title: Validate Age
          description: >-
            Write <code>func validateAge(age int) error</code> that returns an error if age is less than 0 or
            greater than 150, and nil otherwise.
          functionSignature: func validateAge(age int) error
          testCases:
            - input: "25"
              output: "nil"
            - input: "-1"
              output: "error"
            - input: "200"
              output: "error"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                You need to check if a value falls outside an acceptable range. What are the two boundary
                conditions?
            - title: "\U0001F4A1 Hint"
              content: >-
                Use errors.New() to create an error value. Check if age < 0 or age > 150. If either is
                true, return the error. Otherwise return nil.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>1. If age < 0 or age > 150:
                   - return errors.New("invalid age")
                2. Return nil</pre>
          solution: |-
            func validateAge(age int) error {
                if age < 0 || age > 150 {
                    return errors.New("invalid age")
                }
                return nil
            }
          difficulty: 1
        - id: v2
          title: Parse Username
          description: >-
            Write <code>func parseUsername(email string) (string, error)</code> that extracts the username
            (part before @) from an email address. Return an error if there's no @ sign.
          functionSignature: func parseUsername(email string) (string, error)
          testCases:
            - input: "\"alice@example.com\""
              output: "\"alice\", nil"
            - input: "\"invalid\""
              output: "\"\", error"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                You need to find the @ symbol and extract what comes before it. What should happen if the
                email doesn't contain an @ at all?
            - title: "\U0001F4A1 Hint"
              content: >-
                Use strings.Cut(email, "@") to split at the @. If the boolean is false, return an error.
                Otherwise return the first part.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>1. user, _, ok := strings.Cut(email, "@")
                2. If !ok: return "", errors.New("invalid email")
                3. Return user, nil</pre>
          solution: |-
            func parseUsername(email string) (string, error) {
                user, _, ok := strings.Cut(email, "@")
                if !ok {
                    return "", errors.New("invalid email: missing @")
                }
                return user, nil
            }
          difficulty: 1
        - id: v3
          title: Non-Empty String
          description: >-
            Write <code>func requireNonEmpty(s string) (string, error)</code> that returns an error if s is
            empty, otherwise returns s.
          functionSignature: func requireNonEmpty(s string) (string, error)
          testCases:
            - input: "\"hello\""
              output: "\"hello\", nil"
            - input: "\"\""
              output: "\"\", error"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                How do you check if a string is empty in Go? What is the zero value for a string?
            - title: "\U0001F4A1 Hint"
              content: >-
                Compare s to "" or check len(s) == 0. If empty, return the empty string and an error.
                Otherwise return s and nil.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>1. If s == "": return "", errors.New("empty string")
                2. Return s, nil</pre>
          solution: |-
            func requireNonEmpty(s string) (string, error) {
                if s == "" {
                    return "", errors.New("empty string")
                }
                return s, nil
            }
          difficulty: 1
        - id: v4
          title: Positive Only
          description: >-
            Write <code>func positiveOnly(n int) (int, error)</code> that returns an error if n is less than or
            equal to 0.
          functionSignature: func positiveOnly(n int) (int, error)
          testCases:
            - input: "5"
              output: "5, nil"
            - input: "0"
              output: "0, error"
            - input: "-3"
              output: "0, error"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                Positive means strictly greater than zero. Both zero and negative numbers should be
                rejected.
            - title: "\U0001F4A1 Hint"
              content: >-
                Check if n <= 0. If so, return 0 and an error. Otherwise return n and nil.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>1. If n <= 0: return 0, errors.New("must be positive")
                2. Return n, nil</pre>
          solution: |-
            func positiveOnly(n int) (int, error) {
                if n <= 0 {
                    return 0, errors.New("must be positive")
                }
                return n, nil
            }
          difficulty: 1
        - id: v5
          title: Validate Range
          description: >-
            Write <code>func validateRange(n, min, max int) error</code> that returns an error with a
            descriptive message if n is outside the [min, max] range.
          functionSignature: func validateRange(n, min, max int) error
          testCases:
            - input: "5, 1, 10"
              output: "nil"
            - input: "15, 1, 10"
              output: "error"
            - input: "0, 1, 10"
              output: "error"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                A value is in range if it's greater than or equal to min AND less than or equal to max.
                When is it out of range?
            - title: "\U0001F4A1 Hint"
              content: >-
                Use fmt.Errorf to include the actual values in the error message. Check n < min or n > max.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>1. If n < min or n > max:
                   - return fmt.Errorf("value %d out of range [%d, %d]", n, min, max)
                2. Return nil</pre>
          solution: |-
            func validateRange(n, min, max int) error {
                if n < min || n > max {
                    return fmt.Errorf("value %d out of range [%d, %d]", n, min, max)
                }
                return nil
            }
          difficulty: 2
        - id: v6
          title: Safe Get
          description: >-
            Write <code>func safeGet(items []string, index int) (string, error)</code> that returns the element
            at the given index. Return an error if the index is out of bounds.
          functionSignature: func safeGet(items []string, index int) (string, error)
          testCases:
            - input: "[]string{\"a\", \"b\", \"c\"}, 1"
              output: "\"b\", nil"
            - input: "[]string{\"a\", \"b\"}, 5"
              output: "\"\", error"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                Accessing an out-of-bounds index in Go causes a runtime panic. You need to validate the index
                before accessing the slice.
            - title: "\U0001F4A1 Hint"
              content: >-
                Check if index < 0 || index >= len(items). If so, return an empty string and an error.
                Otherwise return items[index] and nil.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>1. If index < 0 || index >= len(items): return "", errors.New("out of bounds")
                2. Return items[index], nil</pre>
          solution: |-
            func safeGet(items []string, index int) (string, error) {
                if index < 0 || index >= len(items) {
                    return "", fmt.Errorf("index %d out of bounds (len=%d)", index, len(items))
                }
                return items[index], nil
            }
          difficulty: 2
        - id: v7
          title: Parse Positive Int
          description: >-
            Write <code>func parsePositive(s string) (int, error)</code> that parses a string to an int and
            verifies it is positive. Return an error for invalid input or non-positive numbers.
          functionSignature: func parsePositive(s string) (int, error)
          testCases:
            - input: "\"42\""
              output: "42, nil"
            - input: "\"-5\""
              output: "0, error"
            - input: "\"abc\""
              output: "0, error"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                There are two things that can go wrong: the string might not be a valid number, or the
                number might not be positive. You need to check both.
            - title: "\U0001F4A1 Hint"
              content: >-
                Use strconv.Atoi to parse. If err != nil, return it. Then check if the result is positive.
                This is the "check error, then continue" pattern.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>1. n, err := strconv.Atoi(s)
                2. If err != nil: return 0, err
                3. If n <= 0: return 0, errors.New("not positive")
                4. Return n, nil</pre>
          solution: |-
            func parsePositive(s string) (int, error) {
                n, err := strconv.Atoi(s)
                if err != nil {
                    return 0, err
                }
                if n <= 0 {
                    return 0, errors.New("not positive")
                }
                return n, nil
            }
          difficulty: 2
        - id: v8
          title: Lookup or Error
          description: >-
            Write <code>func lookupName(names map[string]int, key string) (int, error)</code> that looks up a
            key in the map. Return an error if the key is not found.
          functionSignature: func lookupName(names map[string]int, key string) (int, error)
          testCases:
            - input: "map[string]int{\"alice\": 30, \"bob\": 25}, \"alice\""
              output: "30, nil"
            - input: "map[string]int{\"alice\": 30, \"bob\": 25}, \"dave\""
              output: "0, error"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                Go maps return a second value that tells you if the key existed. How do you use this
                comma-ok idiom to detect missing keys?
            - title: "\U0001F4A1 Hint"
              content: >-
                Use v, ok := names[key]. If !ok, the key was not found â€” return an error. Otherwise return v
                and nil.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>1. v, ok := names[key]
                2. If !ok: return 0, fmt.Errorf("key %q not found", key)
                3. Return v, nil</pre>
          solution: |-
            func lookupName(names map[string]int, key string) (int, error) {
                v, ok := names[key]
                if !ok {
                    return 0, fmt.Errorf("key %q not found", key)
                }
                return v, nil
            }
          difficulty: 2
        - id: v9
          title: Validate Email
          description: >-
            Write <code>func validateEmail(email string) error</code> that returns an error if the email is
            empty or does not contain an "@" symbol.
          functionSignature: func validateEmail(email string) error
          testCases:
            - input: "\"user@example.com\""
              output: "nil"
            - input: "\"invalid\""
              output: "error"
            - input: "\"\""
              output: "error"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                There are two validation checks: the string must not be empty, and it must contain "@".
                Order matters â€” check the simplest condition first.
            - title: "\U0001F4A1 Hint"
              content: >-
                Check if email == "" first, then use strings.Contains(email, "@") to verify the @ symbol is
                present. Return different error messages for each case.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>1. If email == "": return errors.New("empty email")
                2. If !strings.Contains(email, "@"):
                   - return errors.New("missing @")
                3. Return nil</pre>
          solution: |-
            func validateEmail(email string) error {
                if email == "" {
                    return errors.New("empty email")
                }
                if !strings.Contains(email, "@") {
                    return errors.New("missing @")
                }
                return nil
            }
          difficulty: 2
        - id: v10
          title: Chain Validation
          description: >-
            Write <code>func validateUser(name string, age int) error</code> that validates the name is
            non-empty AND the age is between 0 and 150. Return the first error found.
          functionSignature: func validateUser(name string, age int) error
          testCases:
            - input: "\"Alice\", 25"
              output: "nil"
            - input: "\"\", 25"
              output: "error"
            - input: "\"Alice\", -1"
              output: "error"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                When you have multiple things to validate, check them one at a time and return early on the
                first failure. This is the "guard clause" pattern.
            - title: "\U0001F4A1 Hint"
              content: >-
                Check name first: if empty, return error. Then check age: if out of range, return error.
                If both pass, return nil.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>1. If name == "": return errors.New("name required")
                2. If age < 0 or age > 150: return errors.New("invalid age")
                3. Return nil</pre>
          solution: |-
            func validateUser(name string, age int) error {
                if name == "" {
                    return errors.New("name required")
                }
                if age < 0 || age > 150 {
                    return errors.New("invalid age")
                }
                return nil
            }
          difficulty: 3
        - id: v11
          title: Safe Get Element
          description: >-
            Write <code>func safeGet(nums []int, index int) (int, error)</code> that returns the element at the
            given index, or an error if the index is out of bounds.
          functionSignature: func safeGet(nums []int, index int) (int, error)
          testCases:
            - input: "[]int{10, 20, 30}, 1"
              output: "20, nil"
            - input: "[]int{10, 20, 30}, 5"
              output: "0, error"
            - input: "[]int{10, 20, 30}, -1"
              output: "0, error"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                Accessing a slice out of bounds causes a panic in Go. You need to check the bounds yourself
                before accessing the element. What are the valid index values?
            - title: "\U0001F4A1 Hint"
              content: >-
                Valid indices are 0 to len(nums)-1. Check if index < 0 or index >= len(nums). If out of
                bounds, return an error. Otherwise return the element.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>1. If index < 0 or index >= len(nums):
                   - return 0, fmt.Errorf("index %d out of bounds", index)
                2. Return nums[index], nil</pre>
          solution: |-
            func safeGet(nums []int, index int) (int, error) {
                if index < 0 || index >= len(nums) {
                    return 0, fmt.Errorf("index %d out of bounds", index)
                }
                return nums[index], nil
            }
          difficulty: 3
        - id: v12
          title: Process Pipeline
          description: >-
            Write <code>func processValue(s string) (float64, error)</code> that parses a string to an int,
            verifies it is non-negative, then converts to float64 and divides by 100. Return an error at any
            step that fails.
          functionSignature: func processValue(s string) (float64, error)
          testCases:
            - input: "\"250\""
              output: "2.5, nil"
            - input: "\"-5\""
              output: "0, error"
            - input: "\"abc\""
              output: "0, error"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                This is a multi-step pipeline where each step can fail. You need to check for errors after
                each operation before proceeding to the next.
            - title: "\U0001F4A1 Hint"
              content: >-
                First parse with strconv.Atoi (check error). Then check if negative (return error). Finally
                convert and divide. Each step has an if err != nil check.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>1. n, err := strconv.Atoi(s)
                2. If err != nil: return 0, err
                3. If n < 0: return 0, errors.New("negative")
                4. Return float64(n) / 100.0, nil</pre>
          solution: |-
            func processValue(s string) (float64, error) {
                n, err := strconv.Atoi(s)
                if err != nil {
                    return 0, err
                }
                if n < 0 {
                    return 0, errors.New("negative value")
                }
                return float64(n) / 100.0, nil
            }
          difficulty: 3
        - id: v13
          title: Format Error
          description: >-
            Write <code>func safeDivideFormat(a, b int) (string, error)</code> that divides a by b and returns
            a formatted result string "X / Y = Z", or an error if b is zero.
          functionSignature: func safeDivideFormat(a, b int) (string, error)
          testCases:
            - input: "10, 3"
              output: "\"10 / 3 = 3\", nil"
            - input: "10, 0"
              output: "\"\", error"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                You need to combine error checking with string formatting. Check for the error case first,
                then format the successful result.
            - title: "\U0001F4A1 Hint"
              content: >-
                Check b == 0 first and return an error. Otherwise use fmt.Sprintf to build the result
                string with the division values.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>1. If b == 0: return "", errors.New("division by zero")
                2. result := fmt.Sprintf("%d / %d = %d", a, b, a/b)
                3. Return result, nil</pre>
          solution: |-
            func safeDivideFormat(a, b int) (string, error) {
                if b == 0 {
                    return "", errors.New("division by zero")
                }
                return fmt.Sprintf("%d / %d = %d", a, b, a/b), nil
            }
          difficulty: 3
    - id: challenge_7
      block: 1
      difficulty: 1
      concept: "Building Slices"
      docLinks:
        - url: https://go.dev/blog/slices-intro
          title: "Go Blog: Go Slices intro"
          note: slice fundamentals
        - url: https://go.dev/tour/moretypes/7
          title: "Go Tour: Slices"
          note: slice basics
      patternPrimer:
        bruteForce: Pre-allocate a large array and track the size manually.
        bestApproach: Use append() to build slices dynamically; use make() when size is known ahead of time.
        typical: append() is amortized O(1) per element â€” slices grow automatically.
      quickRef: |
        <code>s := make([]int, 0, cap)</code> &nbsp; <code>s = append(s, v)</code><br>
                <code>s = append(s, other...)</code> (append slice)
      variants:
        - id: v1
          title: Generate Tags
          description: >-
            Write <code>func generateTags(n int) []string</code> that returns a slice of tags like
            ["tag-1", "tag-2", ..., "tag-n"]. Use fmt.Sprintf to format each tag.
          functionSignature: func generateTags(n int) []string
          testCases:
            - input: "3"
              output: "[]string{\"tag-1\", \"tag-2\", \"tag-3\"}"
            - input: "2"
              output: "[]string{\"tag-1\", \"tag-2\"}"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                You need to build up a slice one element at a time, where each element is a formatted string.
                How do you create a string from a format and a number?
            - title: "\U0001F4A1 Hint"
              content: >-
                Create an empty string slice. Loop from 1 to n, using fmt.Sprintf("tag-%d", i) to create each tag
                and append it.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>1. result := []string{}
                2. For i := 1 to n:
                   - result = append(result, fmt.Sprintf("tag-%d", i))
                3. Return result</pre>
          solution: |-
            func generateTags(n int) []string {
                result := []string{}
                for i := 1; i <= n; i++ {
                    result = append(result, fmt.Sprintf("tag-%d", i))
                }
                return result
            }
          difficulty: 1
        - id: v2
          title: Zeros
          description: >-
            Write <code>func zeros(n int) []int</code> that returns a slice of n zeros using make().
          functionSignature: func zeros(n int) []int
          testCases:
            - input: "3"
              output: "[]int{0, 0, 0}"
            - input: "5"
              output: "[]int{0, 0, 0, 0, 0}"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                Go has a built-in function that creates a slice of a given length with zero values. What is
                it called?
            - title: "\U0001F4A1 Hint"
              content: >-
                Use make([]int, n) to create a slice of length n. All elements are automatically initialized
                to 0.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>1. Return make([]int, n)</pre>
          solution: |-
            func zeros(n int) []int {
                return make([]int, n)
            }
          difficulty: 1
        - id: v3
          title: Repeat Value
          description: >-
            Write <code>func repeatValue(val string, n int) []string</code> that returns a slice with val
            repeated n times.
          functionSignature: func repeatValue(val string, n int) []string
          testCases:
            - input: "\"go\", 3"
              output: "[]string{\"go\", \"go\", \"go\"}"
            - input: "\"hi\", 2"
              output: "[]string{\"hi\", \"hi\"}"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                You need a loop that runs n times, appending the same value each iteration. What does the
                starting slice look like?
            - title: "\U0001F4A1 Hint"
              content: >-
                Start with an empty string slice. Loop n times and append val each time.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>1. result := []string{}
                2. For i := 0 to n:
                   - result = append(result, val)
                3. Return result</pre>
          solution: |-
            func repeatValue(val string, n int) []string {
                result := []string{}
                for i := 0; i < n; i++ {
                    result = append(result, val)
                }
                return result
            }
          difficulty: 1
        - id: v4
          title: Greet All
          description: >-
            Write <code>func greetAll(names []string) []string</code> that builds a slice of greetings from a
            list of names. For example, ["Alice", "Bob"] becomes ["Hello, Alice!", "Hello, Bob!"].
          functionSignature: func greetAll(names []string) []string
          testCases:
            - input: "[]string{\"Alice\", \"Bob\"}"
              output: "[]string{\"Hello, Alice!\", \"Hello, Bob!\"}"
            - input: "[]string{\"Go\"}"
              output: "[]string{\"Hello, Go!\"}"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                You need to transform each element by wrapping it in a greeting format. What function
                formats a string with a variable?
            - title: "\U0001F4A1 Hint"
              content: >-
                Loop through names. For each name, use fmt.Sprintf("Hello, %s!", name) and append to the result.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>1. result := []string{}
                2. For each name in names:
                   - result = append(result, fmt.Sprintf("Hello, %s!", name))
                3. Return result</pre>
          solution: |-
            func greetAll(names []string) []string {
                result := []string{}
                for _, name := range names {
                    result = append(result, fmt.Sprintf("Hello, %s!", name))
                }
                return result
            }
          difficulty: 1
        - id: v5
          title: Filter Positive
          description: >-
            Write <code>func filterPositive(nums []int) []int</code> that returns a new slice containing only
            the positive numbers.
          functionSignature: func filterPositive(nums []int) []int
          testCases:
            - input: "[]int{-1, 2, -3, 4, 0}"
              output: "[]int{2, 4}"
            - input: "[]int{1, -2, 3}"
              output: "[]int{1, 3}"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                You need to selectively include elements based on a condition. Start with an empty result
                and only add elements that pass the test.
            - title: "\U0001F4A1 Hint"
              content: >-
                Loop through the input. For each number, check if n > 0. If so, append it to the result
                slice.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>1. result := []int{}
                2. For each n in nums:
                   - If n > 0: result = append(result, n)
                3. Return result</pre>
          solution: |-
            func filterPositive(nums []int) []int {
                result := []int{}
                for _, n := range nums {
                    if n > 0 {
                        result = append(result, n)
                    }
                }
                return result
            }
          difficulty: 2
        - id: v6
          title: Filter Short Words
          description: >-
            Write <code>func filterShort(words []string, maxLen int) []string</code> that returns a new
            slice containing only words shorter than maxLen characters.
          functionSignature: func filterShort(words []string, maxLen int) []string
          testCases:
            - input: "[]string{\"go\", \"rust\", \"c\", \"python\"}, 4"
              output: "[]string{\"go\", \"c\"}"
            - input: "[]string{\"hi\", \"hello\", \"hey\"}, 4"
              output: "[]string{\"hi\", \"hey\"}"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                You need to selectively include elements based on their string length. Start with an empty
                result and only add words that pass the test.
            - title: "\U0001F4A1 Hint"
              content: >-
                Loop through words. For each word, check if len(word) < maxLen. If so, append it to the
                result slice.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>1. result := []string{}
                2. For each word in words:
                   - If len(word) < maxLen: result = append(result, word)
                3. Return result</pre>
          solution: |-
            func filterShort(words []string, maxLen int) []string {
                result := []string{}
                for _, word := range words {
                    if len(word) < maxLen {
                        result = append(result, word)
                    }
                }
                return result
            }
          difficulty: 2
        - id: v7
          title: Unique
          description: >-
            Write <code>func unique(nums []int) []int</code> that returns a new slice with duplicate values
            removed, preserving the original order.
          functionSignature: func unique(nums []int) []int
          testCases:
            - input: "[]int{1, 2, 2, 3, 1}"
              output: "[]int{1, 2, 3}"
            - input: "[]int{5, 5, 5}"
              output: "[]int{5}"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                You need to remember which values you have already seen. What Go data structure lets you
                quickly check if a value exists?
            - title: "\U0001F4A1 Hint"
              content: >-
                Use a map[int]bool to track seen values. For each number, check if it is in the map. If
                not, add it to both the map and the result slice.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>1. seen := map[int]bool{}
                2. result := []int{}
                3. For each n in nums:
                   - If !seen[n]:
                     - seen[n] = true
                     - result = append(result, n)
                4. Return result</pre>
          solution: |-
            func unique(nums []int) []int {
                seen := map[int]bool{}
                result := []int{}
                for _, n := range nums {
                    if !seen[n] {
                        seen[n] = true
                        result = append(result, n)
                    }
                }
                return result
            }
          difficulty: 2
        - id: v8
          title: Filter by Length
          description: >-
            Write <code>func filterByLength(words []string, minLen int) []string</code> that returns words
            with length greater than or equal to minLen.
          functionSignature: func filterByLength(words []string, minLen int) []string
          testCases:
            - input: "[]string{\"go\", \"rust\", \"c\", \"python\"}, 3"
              output: "[]string{\"rust\", \"python\"}"
            - input: "[]string{\"hi\", \"hello\", \"hey\"}, 3"
              output: "[]string{\"hello\", \"hey\"}"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                This is a filter operation: keep elements that satisfy a condition. The condition here is
                about the string's length.
            - title: "\U0001F4A1 Hint"
              content: >-
                Loop through words. For each word, check if len(word) >= minLen. If so, append it to the
                result.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>1. result := []string{}
                2. For each word in words:
                   - If len(word) >= minLen:
                     - result = append(result, word)
                3. Return result</pre>
          solution: |-
            func filterByLength(words []string, minLen int) []string {
                result := []string{}
                for _, word := range words {
                    if len(word) >= minLen {
                        result = append(result, word)
                    }
                }
                return result
            }
          difficulty: 2
        - id: v9
          title: Prefix All
          description: >-
            Write <code>func prefixAll(words []string, prefix string) []string</code> that adds a prefix
            to every element. For example, prefixAll(["alice", "bob"], "mr-") returns ["mr-alice", "mr-bob"].
          functionSignature: func prefixAll(words []string, prefix string) []string
          testCases:
            - input: "[]string{\"alice\", \"bob\"}, \"mr-\""
              output: "[]string{\"mr-alice\", \"mr-bob\"}"
            - input: "[]string{\"test\"}, \"v2-\""
              output: "[]string{\"v2-test\"}"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                You are transforming each element by prepending a string. You can pre-allocate the result
                since you know the output size.
            - title: "\U0001F4A1 Hint"
              content: >-
                Use make([]string, len(words)) to create a result of the right size. Loop with index and
                set result[i] = prefix + words[i].
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>1. result := make([]string, len(words))
                2. For i, word := range words:
                   - result[i] = prefix + word
                3. Return result</pre>
          solution: |-
            func prefixAll(words []string, prefix string) []string {
                result := make([]string, len(words))
                for i, word := range words {
                    result[i] = prefix + word
                }
                return result
            }
          difficulty: 2
        - id: v10
          title: Extract Initials
          description: >-
            Write <code>func initials(names []string) []string</code> that builds a slice of first characters
            from a list of names. For example, ["Alice", "Bob", "Charlie"] returns ["A", "B", "C"].
          functionSignature: func initials(names []string) []string
          testCases:
            - input: "[]string{\"Alice\", \"Bob\", \"Charlie\"}"
              output: "[]string{\"A\", \"B\", \"C\"}"
            - input: "[]string{\"Go\", \"Rust\"}"
              output: "[]string{\"G\", \"R\"}"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                You need to extract the first character of each string and collect them. How do you get
                the first character of a string as a new string?
            - title: "\U0001F4A1 Hint"
              content: >-
                Use string(name[0]) to get the first character as a string. Build a result slice by
                appending each initial.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>1. result := []string{}
                2. For each name in names:
                   - result = append(result, string(name[0]))
                3. Return result</pre>
          solution: |-
            func initials(names []string) []string {
                result := []string{}
                for _, name := range names {
                    result = append(result, string(name[0]))
                }
                return result
            }
          difficulty: 3
        - id: v11
          title: Zip Names
          description: >-
            Write <code>func zipNames(first, last []string) []string</code> that combines first name and
            last name slices into full names. For example, ["Alice", "Bob"] and ["Smith", "Jones"]
            returns ["Alice Smith", "Bob Jones"]. Assume slices are the same length.
          functionSignature: func zipNames(first, last []string) []string
          testCases:
            - input: "[]string{\"Alice\", \"Bob\"}, []string{\"Smith\", \"Jones\"}"
              output: "[]string{\"Alice Smith\", \"Bob Jones\"}"
            - input: "[]string{\"Go\"}, []string{\"Lang\"}"
              output: "[]string{\"Go Lang\"}"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                You need to combine elements at the same index from two slices. Since the output size is
                known, you can pre-allocate with make().
            - title: "\U0001F4A1 Hint"
              content: >-
                Use make([]string, len(first)). Loop with index and set result[i] = first[i] + " " + last[i].
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>1. result := make([]string, len(first))
                2. For i := 0 to len(first):
                   - result[i] = first[i] + " " + last[i]
                3. Return result</pre>
          solution: |-
            func zipNames(first, last []string) []string {
                result := make([]string, len(first))
                for i := 0; i < len(first); i++ {
                    result[i] = first[i] + " " + last[i]
                }
                return result
            }
          difficulty: 3
        - id: v12
          title: Interleave
          description: >-
            Write <code>func interleave(a, b []int) []int</code> that interleaves two slices. If one is
            longer, append the remaining elements at the end.
          functionSignature: func interleave(a, b []int) []int
          testCases:
            - input: "[]int{1, 3, 5}, []int{2, 4, 6}"
              output: "[]int{1, 2, 3, 4, 5, 6}"
            - input: "[]int{1, 2}, []int{3, 4, 5, 6}"
              output: "[]int{1, 3, 2, 4, 5, 6}"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                You need to alternate taking one element from each slice. What happens when one slice runs
                out before the other?
            - title: "\U0001F4A1 Hint"
              content: >-
                Use two indices. Loop while either index is valid. Append from a if its index is valid,
                then from b if its index is valid. Increment both indices.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>1. result := []int{}
                2. For i := 0; i < max(len(a), len(b)):
                   - If i < len(a): append a[i]
                   - If i < len(b): append b[i]
                3. Return result</pre>
          solution: |-
            func interleave(a, b []int) []int {
                result := []int{}
                maxLen := len(a)
                if len(b) > maxLen {
                    maxLen = len(b)
                }
                for i := 0; i < maxLen; i++ {
                    if i < len(a) {
                        result = append(result, a[i])
                    }
                    if i < len(b) {
                        result = append(result, b[i])
                    }
                }
                return result
            }
          difficulty: 3
        - id: v13
          title: Running Sum
          description: >-
            Write <code>func runningSum(nums []int) []int</code> that returns a slice where element i is the
            sum of nums[0] through nums[i].
          functionSignature: func runningSum(nums []int) []int
          testCases:
            - input: "[]int{1, 2, 3, 4}"
              output: "[]int{1, 3, 6, 10}"
            - input: "[]int{5, 10, 15}"
              output: "[]int{5, 15, 30}"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                Each output element depends on all input elements up to that point. But you don't need to
                re-sum from the beginning each time â€” the previous result already has the partial sum.
            - title: "\U0001F4A1 Hint"
              content: >-
                Create a result slice of the same length. Set result[0] = nums[0]. For each subsequent
                index, result[i] = result[i-1] + nums[i].
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>1. result := make([]int, len(nums))
                2. result[0] = nums[0]
                3. For i := 1 to len(nums):
                   - result[i] = result[i-1] + nums[i]
                4. Return result</pre>
          solution: |-
            func runningSum(nums []int) []int {
                result := make([]int, len(nums))
                result[0] = nums[0]
                for i := 1; i < len(nums); i++ {
                    result[i] = result[i-1] + nums[i]
                }
                return result
            }
          difficulty: 3
    - id: challenge_8
      block: 1
      difficulty: 2
      concept: "Slice Operations"
      docLinks:
        - url: https://go.dev/blog/slices-intro
          title: "Go Blog: Go Slices usage"
          note: slicing syntax
        - url: https://go.dev/ref/spec#Slice_expressions
          title: "Go Spec: Slice expressions"
          note: s[low:high]
      patternPrimer:
        bruteForce: Manually copy elements one by one into new slices.
        bestApproach: Use Go's slice expressions s[a:b] for clean sub-slice extraction; use copy() for safe duplication.
        typical: Slice expressions are O(1) (shared backing array); copy is O(n).
      quickRef: |
        <code>s[lo:hi]</code> &nbsp; <code>len(s)</code> &nbsp; <code>cap(s)</code><br>
                <code>copy(dst, src)</code> &nbsp; <code>s = append(s[:i], s[i+1:]...)</code> (delete)
      variants:
        - id: v1
          title: First N Elements
          description: >-
            Write <code>func firstN(nums []int, n int) []int</code> that returns the first n elements of the
            slice.
          functionSignature: func firstN(nums []int, n int) []int
          testCases:
            - input: "[]int{1, 2, 3, 4, 5}, 3"
              output: "[]int{1, 2, 3}"
            - input: "[]int{10, 20, 30}, 2"
              output: "[]int{10, 20}"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                Go's slice syntax lets you take a portion of a slice by specifying a range. How do you
                express "from the beginning up to n elements"?
            - title: "\U0001F4A1 Hint"
              content: >-
                Use the slice expression nums[:n] which takes elements from index 0 up to (but not
                including) index n.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>1. Return nums[:n]</pre>
          solution: |-
            func firstN(nums []int, n int) []int {
                return nums[:n]
            }
          difficulty: 1
        - id: v2
          title: Last N Elements
          description: >-
            Write <code>func lastN(nums []int, n int) []int</code> that returns the last n elements of the
            slice.
          functionSignature: func lastN(nums []int, n int) []int
          testCases:
            - input: "[]int{1, 2, 3, 4, 5}, 2"
              output: "[]int{4, 5}"
            - input: "[]int{10, 20, 30}, 1"
              output: "[]int{30}"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                To get the last n elements, you need to figure out the starting index. If the slice has 5
                elements and you want the last 2, where do you start?
            - title: "\U0001F4A1 Hint"
              content: >-
                The starting index is len(nums) - n. Use nums[len(nums)-n:] to get from that point to the
                end.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>1. Return nums[len(nums)-n:]</pre>
          solution: |-
            func lastN(nums []int, n int) []int {
                return nums[len(nums)-n:]
            }
          difficulty: 1
        - id: v3
          title: Remove First
          description: >-
            Write <code>func removeFirst(nums []int) []int</code> that returns the slice without the first
            element.
          functionSignature: func removeFirst(nums []int) []int
          testCases:
            - input: "[]int{1, 2, 3}"
              output: "[]int{2, 3}"
            - input: "[]int{10, 20}"
              output: "[]int{20}"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                Removing the first element means keeping everything from index 1 onward. What slice
                expression does this?
            - title: "\U0001F4A1 Hint"
              content: >-
                Use nums[1:] to get everything starting from index 1.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>1. Return nums[1:]</pre>
          solution: |-
            func removeFirst(nums []int) []int {
                return nums[1:]
            }
          difficulty: 1
        - id: v4
          title: Remove Last
          description: >-
            Write <code>func removeLast(nums []int) []int</code> that returns the slice without the last
            element.
          functionSignature: func removeLast(nums []int) []int
          testCases:
            - input: "[]int{1, 2, 3}"
              output: "[]int{1, 2}"
            - input: "[]int{10, 20, 30}"
              output: "[]int{10, 20}"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                Removing the last element means keeping everything up to but not including the last index.
                What slice expression does this?
            - title: "\U0001F4A1 Hint"
              content: >-
                Use nums[:len(nums)-1] to get everything except the last element.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>1. Return nums[:len(nums)-1]</pre>
          solution: |-
            func removeLast(nums []int) []int {
                return nums[:len(nums)-1]
            }
          difficulty: 1
        - id: v5
          title: Middle Element
          description: >-
            Write <code>func middle(nums []int) int</code> that returns the middle element of a slice. Assume
            the slice has an odd number of elements.
          functionSignature: func middle(nums []int) int
          testCases:
            - input: "[]int{1, 2, 3, 4, 5}"
              output: "3"
            - input: "[]int{10, 20, 30}"
              output: "20"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                For a slice of length 5, the middle element is at index 2. For length 3, it is at index 1.
                What is the formula?
            - title: "\U0001F4A1 Hint"
              content: >-
                The middle index is len(nums) / 2. Integer division automatically rounds down, which gives
                the correct middle for odd-length slices.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>1. Return nums[len(nums)/2]</pre>
          solution: |-
            func middle(nums []int) int {
                return nums[len(nums)/2]
            }
          difficulty: 2
        - id: v6
          title: Reverse
          description: >-
            Write <code>func reverse(nums []int) []int</code> that returns a new reversed slice without
            modifying the original.
          functionSignature: func reverse(nums []int) []int
          testCases:
            - input: "[]int{1, 2, 3, 4}"
              output: "[]int{4, 3, 2, 1}"
            - input: "[]int{5, 10}"
              output: "[]int{10, 5}"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                You need to create a new slice where the first element of the original becomes the last, and
                vice versa. How do you map from original index to reversed index?
            - title: "\U0001F4A1 Hint"
              content: >-
                Create a new slice with make(). For each element at index i, place it at position
                len(nums)-1-i in the result.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>1. result := make([]int, len(nums))
                2. For i, v := range nums:
                   - result[len(nums)-1-i] = v
                3. Return result</pre>
          solution: |-
            func reverse(nums []int) []int {
                result := make([]int, len(nums))
                for i, v := range nums {
                    result[len(nums)-1-i] = v
                }
                return result
            }
          difficulty: 2
        - id: v7
          title: Rotate Left
          description: >-
            Write <code>func rotateLeft(nums []int, k int) []int</code> that rotates the slice left by k
            positions.
          functionSignature: func rotateLeft(nums []int, k int) []int
          testCases:
            - input: "[]int{1, 2, 3, 4, 5}, 2"
              output: "[]int{3, 4, 5, 1, 2}"
            - input: "[]int{10, 20, 30}, 1"
              output: "[]int{20, 30, 10}"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                Rotating left by k means the first k elements move to the end. Can you split the slice into
                two parts and recombine?
            - title: "\U0001F4A1 Hint"
              content: >-
                Split at position k: take nums[k:] and nums[:k]. Combine them with append. Use k % len(nums)
                to handle k larger than the slice length.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>1. k = k % len(nums)
                2. Return append(nums[k:], nums[:k]...)</pre>
          solution: |-
            func rotateLeft(nums []int, k int) []int {
                k = k % len(nums)
                return append(nums[k:], nums[:k]...)
            }
          difficulty: 2
        - id: v8
          title: Split At
          description: >-
            Write <code>func splitAt(nums []int, index int) ([]int, []int)</code> that splits the slice into
            two parts at the given index.
          functionSignature: func splitAt(nums []int, index int) ([]int, []int)
          testCases:
            - input: "[]int{1, 2, 3, 4, 5}, 3"
              output: "[]int{1, 2, 3}, []int{4, 5}"
            - input: "[]int{10, 20, 30}, 1"
              output: "[]int{10}, []int{20, 30}"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                Splitting at an index means everything before that index goes into the first part, and
                everything from that index onward goes into the second part.
            - title: "\U0001F4A1 Hint"
              content: >-
                Use nums[:index] for the first part and nums[index:] for the second. Return both.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>1. Return nums[:index], nums[index:]</pre>
          solution: |-
            func splitAt(nums []int, index int) ([]int, []int) {
                return nums[:index], nums[index:]
            }
          difficulty: 2
        - id: v9
          title: Contains
          description: >-
            Write <code>func contains(nums []int, target int) bool</code> that checks if the target value
            exists in the slice.
          functionSignature: func contains(nums []int, target int) bool
          testCases:
            - input: "[]int{1, 2, 3}, 2"
              output: "true"
            - input: "[]int{1, 2, 3}, 5"
              output: "false"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                You need to scan through the slice looking for a match. What do you return if you find it?
                What if you reach the end without finding it?
            - title: "\U0001F4A1 Hint"
              content: >-
                Loop through and compare each element to target. Return true immediately when found. After
                the loop, return false.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>1. For each n in nums:
                   - If n == target: return true
                2. Return false</pre>
          solution: |-
            func contains(nums []int, target int) bool {
                for _, n := range nums {
                    if n == target {
                        return true
                    }
                }
                return false
            }
          difficulty: 2
        - id: v10
          title: Remove At Index
          description: >-
            Write <code>func removeAt(nums []int, index int) []int</code> that returns a new slice with the
            element at the given index removed.
          functionSignature: func removeAt(nums []int, index int) []int
          testCases:
            - input: "[]int{1, 2, 3, 4}, 2"
              output: "[]int{1, 2, 4}"
            - input: "[]int{10, 20, 30}, 0"
              output: "[]int{20, 30}"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                You need to combine the part before the index with the part after the index, skipping the
                element at that position. Be careful not to modify the original slice.
            - title: "\U0001F4A1 Hint"
              content: >-
                Create a new slice. Append everything before the index, then append everything after the
                index. Use the ... spread operator with append.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>1. result := make([]int, 0, len(nums)-1)
                2. result = append(result, nums[:index]...)
                3. result = append(result, nums[index+1:]...)
                4. Return result</pre>
          solution: |-
            func removeAt(nums []int, index int) []int {
                result := make([]int, 0, len(nums)-1)
                result = append(result, nums[:index]...)
                result = append(result, nums[index+1:]...)
                return result
            }
          difficulty: 3
        - id: v11
          title: Insert At
          description: >-
            Write <code>func insertAt(nums []int, index, value int) []int</code> that returns a new slice with
            the value inserted at the given index.
          functionSignature: func insertAt(nums []int, index, value int) []int
          testCases:
            - input: "[]int{1, 2, 4, 5}, 2, 3"
              output: "[]int{1, 2, 3, 4, 5}"
            - input: "[]int{10, 30}, 1, 20"
              output: "[]int{10, 20, 30}"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                Inserting means you take everything before the index, add the new value, then add everything
                from the index onward. The result is one element longer.
            - title: "\U0001F4A1 Hint"
              content: >-
                Build a new slice: append nums[:index], then the value, then nums[index:]. Use the ...
                spread operator for the slice parts.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>1. result := make([]int, 0, len(nums)+1)
                2. result = append(result, nums[:index]...)
                3. result = append(result, value)
                4. result = append(result, nums[index:]...)
                5. Return result</pre>
          solution: |-
            func insertAt(nums []int, index, value int) []int {
                result := make([]int, 0, len(nums)+1)
                result = append(result, nums[:index]...)
                result = append(result, value)
                result = append(result, nums[index:]...)
                return result
            }
          difficulty: 3
        - id: v12
          title: Chunk
          description: >-
            Write <code>func chunk(nums []int, size int) [][]int</code> that splits the slice into chunks of
            the given size. The last chunk may be smaller.
          functionSignature: func chunk(nums []int, size int) [][]int
          testCases:
            - input: "[]int{1, 2, 3, 4, 5}, 2"
              output: "[][]int{{1, 2}, {3, 4}, {5}}"
            - input: "[]int{1, 2, 3, 4}, 2"
              output: "[][]int{{1, 2}, {3, 4}}"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                You need to walk through the slice in steps of the given size, taking a sub-slice each time.
                What happens when the remaining elements are fewer than the chunk size?
            - title: "\U0001F4A1 Hint"
              content: >-
                Use a for loop that increments by size. For each step, calculate the end index as i + size,
                but cap it at len(nums) to avoid going out of bounds.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>1. result := [][]int{}
                2. For i := 0; i < len(nums); i += size:
                   - end := i + size
                   - If end > len(nums): end = len(nums)
                   - result = append(result, nums[i:end])
                3. Return result</pre>
          solution: |-
            func chunk(nums []int, size int) [][]int {
                result := [][]int{}
                for i := 0; i < len(nums); i += size {
                    end := i + size
                    if end > len(nums) {
                        end = len(nums)
                    }
                    result = append(result, nums[i:end])
                }
                return result
            }
          difficulty: 3
        - id: v13
          title: Window Sums
          description: >-
            Write <code>func windowSums(nums []int, size int) []int</code> that returns the sums of each
            sliding window of the given size.
          functionSignature: func windowSums(nums []int, size int) []int
          testCases:
            - input: "[]int{1, 2, 3, 4, 5}, 3"
              output: "[]int{6, 9, 12}"
            - input: "[]int{10, 20, 30, 40}, 2"
              output: "[]int{30, 50, 70}"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                A sliding window of size 3 over [1, 2, 3, 4, 5] gives windows [1,2,3], [2,3,4], [3,4,5].
                How many windows are there for a slice of length n with window size k?
            - title: "\U0001F4A1 Hint"
              content: >-
                There are len(nums) - size + 1 windows. For each starting position i from 0 to
                len(nums)-size, sum the elements from i to i+size-1.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>1. result := []int{}
                2. For i := 0; i <= len(nums)-size; i++:
                   - sum := 0
                   - For j := i; j < i+size; j++:
                     - sum += nums[j]
                   - result = append(result, sum)
                3. Return result</pre>
          solution: |-
            func windowSums(nums []int, size int) []int {
                result := []int{}
                for i := 0; i <= len(nums)-size; i++ {
                    sum := 0
                    for j := i; j < i+size; j++ {
                        sum += nums[j]
                    }
                    result = append(result, sum)
                }
                return result
            }
          difficulty: 3
    - id: challenge_9
      block: 1
      difficulty: 1
      concept: "For Loops"
      docLinks:
        - url: https://go.dev/tour/flowcontrol/1
          title: "Go Tour: For"
          note: the only loop in Go
        - url: https://go.dev/ref/spec#For_statements
          title: "Go Spec: For statements"
          note: three forms
      patternPrimer:
        bruteForce: Write separate loops for each variant of iteration.
        bestApproach: "Go has one loop keyword \u2014 for \u2014 with three forms: C-style, while-style, and infinite + break."
        typical: Most loops are O(n) \u2014 choose the right form for clarity.
      quickRef: |
        <code>for i := 0; i &lt; n; i++ { }</code><br>
                <code>for condition { }</code> &nbsp; <code>for { }</code> (infinite)
      variants:
        - id: v1
          title: Repeat String
          description: >-
            Write <code>func repeatStr(s string, n int) string</code> that builds a new string by repeating
            s exactly n times using a for loop. For example, repeatStr("Go", 3) returns "GoGoGo".
          functionSignature: func repeatStr(s string, n int) string
          testCases:
            - input: "\"Go\", 3"
              output: "\"GoGoGo\""
            - input: "\"ab\", 4"
              output: "\"abababab\""
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                You need to concatenate the same string n times. What kind of loop runs a fixed number of iterations?
            - title: "\U0001F4A1 Hint"
              content: >-
                Start with an empty result string. Use a C-style for loop running n times, appending s each iteration.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>1. result := ""
                2. for i := 0; i < n; i++:
                   - result += s
                3. return result</pre>
          solution: |-
            func repeatStr(s string, n int) string {
                result := ""
                for i := 0; i < n; i++ {
                    result += s
                }
                return result
            }
          difficulty: 1
        - id: v2
          title: Reverse String
          description: >-
            Write <code>func reverseStr(s string) string</code> that reverses a string character by character
            using a for loop. For example, reverseStr("hello") returns "olleh".
          functionSignature: func reverseStr(s string) string
          testCases:
            - input: "\"hello\""
              output: "\"olleh\""
            - input: "\"Go\""
              output: "\"oG\""
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                To reverse a string, you need to read characters from the end to the beginning. How do you loop
                backwards through a string?
            - title: "\U0001F4A1 Hint"
              content: >-
                Start with an empty result. Use for i := len(s) - 1; i >= 0; i-- and append each character using
                string(s[i]).
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>1. result := ""
                2. for i := len(s) - 1; i >= 0; i--:
                   - result += string(s[i])
                3. return result</pre>
          solution: |-
            func reverseStr(s string) string {
                result := ""
                for i := len(s) - 1; i >= 0; i-- {
                    result += string(s[i])
                }
                return result
            }
          difficulty: 1
        - id: v3
          title: Count Char
          description: >-
            Write <code>func countChar(s string, target byte) int</code> that counts how many times
            target appears in s. For example, countChar("banana", 'a') returns 3.
          functionSignature: func countChar(s string, target byte) int
          testCases:
            - input: "\"banana\", 'a'"
              output: "3"
            - input: "\"hello\", 'l'"
              output: "2"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                You need to examine every character in the string and keep a count. How do you compare a byte at
                a specific index?
            - title: "\U0001F4A1 Hint"
              content: >-
                Loop with for i := 0; i < len(s); i++. Compare s[i] to target. If equal, increment a counter.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>1. count := 0
                2. for i := 0; i < len(s); i++:
                   - if s[i] == target: count++
                3. return count</pre>
          solution: |-
            func countChar(s string, target byte) int {
                count := 0
                for i := 0; i < len(s); i++ {
                    if s[i] == target {
                        count++
                    }
                }
                return count
            }
          difficulty: 1
        - id: v4
          title: Count Down
          description: >-
            Write <code>func countDown(n int) []int</code> that returns a slice [n, n-1, ..., 1] using a for loop.
          functionSignature: func countDown(n int) []int
          testCases:
            - input: "5"
              output: "[]int{5, 4, 3, 2, 1}"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                You need to loop from n down to 1. How do you write a for loop that decrements?
            - title: "\U0001F4A1 Hint"
              content: >-
                Use for i := n; i >= 1; i-- and append each value to a result slice.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>1. result := []int{}
                2. for i := n; i >= 1; i--:
                   - append i to result
                3. return result</pre>
          solution: |-
            func countDown(n int) []int {
                result := []int{}
                for i := n; i >= 1; i-- {
                    result = append(result, i)
                }
                return result
            }
          difficulty: 1
        - id: v5
          title: Word Truncate
          description: >-
            Write <code>func truncate(s string, maxLen int) string</code> that returns s if it's shorter than
            or equal to maxLen, otherwise returns the first maxLen characters followed by "...".
          functionSignature: func truncate(s string, maxLen int) string
          testCases:
            - input: "\"Hello, World!\", 5"
              output: "\"Hello...\""
            - input: "\"Hi\", 5"
              output: "\"Hi\""
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                Check the length first. If the string is short enough, return it as-is. Otherwise, you need to
                take a substring of the first maxLen characters.
            - title: "\U0001F4A1 Hint"
              content: >-
                Use len(s) to check the length. If too long, use s[:maxLen] to take the first maxLen characters
                and concatenate "..." to the result.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>1. if len(s) <= maxLen: return s
                2. return s[:maxLen] + "..."</pre>
          solution: |-
            func truncate(s string, maxLen int) string {
                if len(s) <= maxLen {
                    return s
                }
                return s[:maxLen] + "..."
            }
          difficulty: 2
        - id: v6
          title: Remove Spaces
          description: >-
            Write <code>func removeSpaces(s string) string</code> that returns a new string with all spaces
            removed. For example, removeSpaces("hello world") returns "helloworld".
          functionSignature: func removeSpaces(s string) string
          testCases:
            - input: "\"hello world\""
              output: "\"helloworld\""
            - input: "\"a b c\""
              output: "\"abc\""
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                You need to build a new string that skips certain characters. What condition determines which
                characters to include?
            - title: "\U0001F4A1 Hint"
              content: >-
                Loop through each byte of s. If s[i] is not a space (' '), append it to the result string.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>1. result := ""
                2. for i := 0; i < len(s); i++:
                   - if s[i] != ' ': result += string(s[i])
                3. return result</pre>
          solution: |-
            func removeSpaces(s string) string {
                result := ""
                for i := 0; i < len(s); i++ {
                    if s[i] != ' ' {
                        result += string(s[i])
                    }
                }
                return result
            }
          difficulty: 2
        - id: v7
          title: Find First Match
          description: >-
            Write <code>func findPrefix(words []string, prefix string) int</code> that returns the index of
            the first string in words that starts with prefix. Return -1 if none found. Use a for loop, not range.
          functionSignature: func findPrefix(words []string, prefix string) int
          testCases:
            - input: "[]string{\"apple\", \"banana\", \"avocado\"}, \"av\""
              output: "2"
            - input: "[]string{\"cat\", \"dog\"}, \"fish\""
              output: "-1"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                You need to check each string and see if it starts with the given prefix. How do you check if a
                string starts with another string using a loop?
            - title: "\U0001F4A1 Hint"
              content: >-
                Loop through words with an index. For each word, check if len(word) >= len(prefix) and
                word[:len(prefix)] == prefix. Return the index of the first match.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>1. for i := 0; i < len(words); i++:
                   - if len(words[i]) >= len(prefix) && words[i][:len(prefix)] == prefix:
                     - return i
                2. return -1</pre>
          solution: |-
            func findPrefix(words []string, prefix string) int {
                for i := 0; i < len(words); i++ {
                    if len(words[i]) >= len(prefix) && words[i][:len(prefix)] == prefix {
                        return i
                    }
                }
                return -1
            }
          difficulty: 2
        - id: v8
          title: Build Acronym
          description: >-
            Write <code>func acronym(words []string) string</code> that builds an acronym from a slice of words
            by taking the first letter of each. For example, acronym(["Laugh", "Out", "Loud"]) returns "LOL".
          functionSignature: func acronym(words []string) string
          testCases:
            - input: "[]string{\"Laugh\", \"Out\", \"Loud\"}"
              output: "\"LOL\""
            - input: "[]string{\"As\", \"Soon\", \"As\", \"Possible\"}"
              output: "\"ASAP\""
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                You need the first character of each string. How do you access the first character and convert it
                to a string?
            - title: "\U0001F4A1 Hint"
              content: >-
                Loop through words. For each word, take string(word[0]) and concatenate it to the result.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>1. result := ""
                2. for i := 0; i < len(words); i++:
                   - result += string(words[i][0])
                3. return result</pre>
          solution: |-
            func acronym(words []string) string {
                result := ""
                for i := 0; i < len(words); i++ {
                    result += string(words[i][0])
                }
                return result
            }
          difficulty: 2
        - id: v9
          title: Validate PIN
          description: >-
            Write <code>func validatePIN(pin string) bool</code> that returns true if the PIN is 4-6 characters
            long and all characters are digits ('0'-'9'). Use a for loop to check each character.
          functionSignature: func validatePIN(pin string) bool
          testCases:
            - input: "\"1234\""
              output: "true"
            - input: "\"12ab\""
              output: "false"
            - input: "\"123\""
              output: "false"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                Two conditions must both be true: the length must be 4-6, and every character must be a digit.
                How do you check if a byte is a digit?
            - title: "\U0001F4A1 Hint"
              content: >-
                First check len(pin) >= 4 && len(pin) <= 6. Then loop through each byte: if any character
                is < '0' or > '9', return false.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>1. if len(pin) < 4 || len(pin) > 6: return false
                2. for i := 0; i < len(pin); i++:
                   - if pin[i] < '0' || pin[i] > '9': return false
                3. return true</pre>
          solution: |-
            func validatePIN(pin string) bool {
                if len(pin) < 4 || len(pin) > 6 {
                    return false
                }
                for i := 0; i < len(pin); i++ {
                    if pin[i] < '0' || pin[i] > '9' {
                        return false
                    }
                }
                return true
            }
          difficulty: 2
        - id: v10
          title: Run Length Count
          description: >-
            Write <code>func runLengthStart(s string) int</code> that counts how many consecutive identical
            characters appear at the start of a string. For example, "aaabbc" returns 3, "hello" returns 1.
            Use a <code>for</code> loop with a condition.
          functionSignature: func runLengthStart(s string) int
          testCases:
            - input: "\"aaabbc\""
              output: "3"
            - input: "\"hello\""
              output: "1"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                Start from the second character and keep going while the character matches the first one. What
                condition stops the loop?
            - title: "\U0001F4A1 Hint"
              content: >-
                Use count := 1 (at least the first char). Loop with for count < len(s) && s[count] == s[0].
                Increment count each iteration.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>1. if len(s) == 0: return 0
                2. count := 1
                3. for count < len(s) && s[count] == s[0]:
                   - count++
                4. return count</pre>
          solution: |-
            func runLengthStart(s string) int {
                if len(s) == 0 {
                    return 0
                }
                count := 1
                for count < len(s) && s[count] == s[0] {
                    count++
                }
                return count
            }
          difficulty: 3
        - id: v11
          title: Mask Email
          description: >-
            Write <code>func maskEmail(email string) string</code> that masks an email by replacing all
            characters of the username (before @) except the first and last with asterisks. For example,
            "alice@test.com" becomes "a***e@test.com".
          functionSignature: func maskEmail(email string) string
          testCases:
            - input: "\"alice@test.com\""
              output: "\"a***e@test.com\""
            - input: "\"ab@x.com\""
              output: "\"ab@x.com\""
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                First find the @ symbol. Then rebuild the username part: keep first and last characters, replace
                the middle with asterisks. What if the username is 2 chars or fewer?
            - title: "\U0001F4A1 Hint"
              content: >-
                Find @ with a loop. If the username is <= 2 chars, return as-is. Otherwise, build the masked
                part: first char + asterisks + last char + "@" + domain.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>1. Find atIdx (position of '@')
                2. user := email[:atIdx], domain := email[atIdx:]
                3. if len(user) <= 2: return email
                4. masked := string(user[0])
                5. for i := 1; i < len(user)-1; i++: masked += "*"
                6. masked += string(user[len(user)-1])
                7. return masked + domain</pre>
          solution: |-
            func maskEmail(email string) string {
                atIdx := 0
                for i := 0; i < len(email); i++ {
                    if email[i] == '@' {
                        atIdx = i
                        break
                    }
                }
                user := email[:atIdx]
                domain := email[atIdx:]
                if len(user) <= 2 {
                    return email
                }
                masked := string(user[0])
                for i := 1; i < len(user)-1; i++ {
                    masked += "*"
                }
                masked += string(user[len(user)-1])
                return masked + domain
            }
          difficulty: 3
        - id: v12
          title: Multiplication Table Row
          description: >-
            Write <code>func multiplicationRow(n, size int) []int</code> that returns row n of a multiplication
            table as a slice: [n*1, n*2, ..., n*size].
          functionSignature: func multiplicationRow(n, size int) []int
          testCases:
            - input: "3, 5"
              output: "[]int{3, 6, 9, 12, 15}"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                You need to generate size elements where each element is n multiplied by its position (starting at
                1). How can you pre-allocate the result slice?
            - title: "\U0001F4A1 Hint"
              content: >-
                Use make([]int, size) to create a slice of the right length. Loop with index and set each element
                to n * (i + 1).
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>1. result := make([]int, size)
                2. for i := 0; i < size; i++:
                   - result[i] = n * (i + 1)
                3. return result</pre>
          solution: |-
            func multiplicationRow(n, size int) []int {
                result := make([]int, size)
                for i := 0; i < size; i++ {
                    result[i] = n * (i + 1)
                }
                return result
            }
          difficulty: 3
        - id: v13
          title: Binary Digits
          description: >-
            Write <code>func toBinary(n int) string</code> that converts an integer to its binary string
            representation using repeated division by 2.
          functionSignature: func toBinary(n int) string
          testCases:
            - input: "10"
              output: "\"1010\""
            - input: "0"
              output: "\"0\""
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                To convert to binary, repeatedly divide by 2 and collect remainders. The remainders read in
                reverse order give the binary representation. How do you build a string in reverse?
            - title: "\U0001F4A1 Hint"
              content: >-
                Handle n == 0 as a special case. Then use for n > 0: prepend (n % 2) as "0" or "1" to the result
                string, and divide n by 2.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>1. if n == 0: return "0"
                2. result := ""
                3. for n > 0:
                   - if n % 2 == 0: result = "0" + result
                   - else: result = "1" + result
                   - n /= 2
                4. return result</pre>
          solution: |-
            func toBinary(n int) string {
                if n == 0 {
                    return "0"
                }
                result := ""
                for n > 0 {
                    if n%2 == 0 {
                        result = "0" + result
                    } else {
                        result = "1" + result
                    }
                    n /= 2
                }
                return result
            }
          difficulty: 3
    - id: challenge_10
      block: 1
      difficulty: 1
      concept: "Range Loops"
      docLinks:
        - url: https://go.dev/tour/moretypes/16
          title: "Go Tour: Range"
          note: iterating slices and maps
        - url: https://go.dev/doc/effective_go#for
          title: "Effective Go: For"
          note: range patterns
      patternPrimer:
        bruteForce: Use C-style for with manual index tracking.
        bestApproach: "Use for i, v := range to iterate slices idiomatically; use _ to discard unused index or value."
        typical: Range is the idiomatic way to iterate in Go \u2014 same O(n) complexity, cleaner syntax.
      quickRef: |
        <code>for i, v := range slice { }</code><br>
                <code>for k, v := range myMap { }</code> &nbsp; Use <code>_</code> to skip index/key
      variants:
        - id: v1
          title: Concat All
          description: >-
            Write <code>func concatAll(words []string, sep string) string</code> that joins all strings in
            a slice with the given separator using range. For example, concatAll(["go", "is", "fun"], "-")
            returns "go-is-fun".
          functionSignature: func concatAll(words []string, sep string) string
          testCases:
            - input: "[]string{\"go\", \"is\", \"fun\"}, \"-\""
              output: "\"go-is-fun\""
            - input: "[]string{\"a\", \"b\"}, \", \""
              output: "\"a, b\""
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                You want the separator between words, but not before the first word. How can the index from
                range help you decide when to add the separator?
            - title: "\U0001F4A1 Hint"
              content: >-
                Use for i, w := range words. If i > 0, append the separator before appending the word. The
                underscore or index lets you detect the first element.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>1. result := ""
                2. for i, w := range words:
                   - if i > 0: result += sep
                   - result += w
                3. return result</pre>
          solution: |-
            func concatAll(words []string, sep string) string {
                result := ""
                for i, w := range words {
                    if i > 0 {
                        result += sep
                    }
                    result += w
                }
                return result
            }
          difficulty: 1
        - id: v2
          title: Longest String
          description: >-
            Write <code>func longestStr(words []string) string</code> that returns the longest string in the
            slice using range. If there's a tie, return the first one found.
          functionSignature: func longestStr(words []string) string
          testCases:
            - input: "[]string{\"go\", \"python\", \"c\", \"rust\"}"
              output: "\"python\""
            - input: "[]string{\"abc\", \"de\"}"
              output: "\"abc\""
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                This is like finding the max, but comparing string lengths instead of numbers. What do you
                initialize the best candidate to?
            - title: "\U0001F4A1 Hint"
              content: >-
                Initialize best to words[0]. Range over the slice and update best whenever len(w) > len(best).
                Using > (not >=) ensures the first one wins on ties.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>1. best := words[0]
                2. for _, w := range words:
                   - if len(w) > len(best): best = w
                3. return best</pre>
          solution: |-
            func longestStr(words []string) string {
                best := words[0]
                for _, w := range words {
                    if len(w) > len(best) {
                        best = w
                    }
                }
                return best
            }
          difficulty: 1
        - id: v3
          title: Count Target
          description: >-
            Write <code>func countTarget(nums []int, target int) int</code> that counts how many times target
            appears in the slice.
          functionSignature: func countTarget(nums []int, target int) int
          testCases:
            - input: "[]int{1, 2, 2, 3, 2}, 2"
              output: "3"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                Loop through and compare each element to the target. What do you do when they match?
            - title: "\U0001F4A1 Hint"
              content: >-
                Start a counter at 0. Use for _, n := range nums. If n == target, increment the counter.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>1. count := 0
                2. for _, n := range nums:
                   - if n == target: count++
                3. return count</pre>
          solution: |-
            func countTarget(nums []int, target int) int {
                count := 0
                for _, n := range nums {
                    if n == target {
                        count++
                    }
                }
                return count
            }
          difficulty: 1
        - id: v4
          title: All Positive
          description: >-
            Write <code>func allPositive(nums []int) bool</code> that returns true if all elements are positive
            (greater than zero).
          functionSignature: func allPositive(nums []int) bool
          testCases:
            - input: "[]int{1, 2, 3}"
              output: "true"
            - input: "[]int{1, -2, 3}"
              output: "false"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                If you find even one non-positive element, the answer is false. Can you exit early?
            - title: "\U0001F4A1 Hint"
              content: >-
                Range over the slice. If any element is <= 0, return false immediately. If the loop completes,
                return true.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>1. for _, n := range nums:
                   - if n <= 0: return false
                2. return true</pre>
          solution: |-
            func allPositive(nums []int) bool {
                for _, n := range nums {
                    if n <= 0 {
                        return false
                    }
                }
                return true
            }
          difficulty: 1
        - id: v5
          title: Index Of
          description: >-
            Write <code>func indexOf(nums []int, target int) int</code> that returns the index of the first
            occurrence of target, or -1 if not found.
          functionSignature: func indexOf(nums []int, target int) int
          testCases:
            - input: "[]int{10, 20, 30}, 20"
              output: "1"
            - input: "[]int{10, 20, 30}, 50"
              output: "-1"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                You need the index this time, not just the value. How does range give you both?
            - title: "\U0001F4A1 Hint"
              content: >-
                Use for i, n := range nums. When n == target, return i immediately. If the loop finishes without
                finding it, return -1.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>1. for i, n := range nums:
                   - if n == target: return i
                2. return -1</pre>
          solution: |-
            func indexOf(nums []int, target int) int {
                for i, n := range nums {
                    if n == target {
                        return i
                    }
                }
                return -1
            }
          difficulty: 2
        - id: v6
          title: Title Case All
          description: >-
            Write <code>func titleCaseAll(words []string) []string</code> that capitalizes the first letter
            of each string in the slice using range. For example, ["hello", "world"] becomes ["Hello", "World"].
          functionSignature: func titleCaseAll(words []string) []string
          testCases:
            - input: "[]string{\"hello\", \"world\"}"
              output: "[]string{\"Hello\", \"World\"}"
            - input: "[]string{\"go\", \"is\", \"fun\"}"
              output: "[]string{\"Go\", \"Is\", \"Fun\"}"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                You need to transform each string by uppercasing its first character. How do you get the first
                character as uppercase and combine it with the rest?
            - title: "\U0001F4A1 Hint"
              content: >-
                Use strings.ToUpper(string(w[0])) + w[1:] to capitalize the first letter. Pre-allocate with
                make([]string, len(words)).
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>1. result := make([]string, len(words))
                2. for i, w := range words:
                   - result[i] = strings.ToUpper(string(w[0])) + w[1:]
                3. return result</pre>
          solution: |-
            func titleCaseAll(words []string) []string {
                result := make([]string, len(words))
                for i, w := range words {
                    result[i] = strings.ToUpper(string(w[0])) + w[1:]
                }
                return result
            }
          difficulty: 2
        - id: v7
          title: Join Strings
          description: >-
            Write <code>func joinWith(words []string, sep string) string</code> that joins all words with the
            given separator using range.
          functionSignature: func joinWith(words []string, sep string) string
          testCases:
            - input: "[]string{\"go\", \"is\", \"fun\"}, \"-\""
              output: "\"go-is-fun\""
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                You want to put the separator between words, but not before the first word. How can the index from
                range help?
            - title: "\U0001F4A1 Hint"
              content: >-
                Use for i, w := range words. If i > 0, append the separator before appending the word. This
                avoids a trailing or leading separator.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>1. result := ""
                2. for i, w := range words:
                   - if i > 0: result += sep
                   - result += w
                3. return result</pre>
          solution: |-
            func joinWith(words []string, sep string) string {
                result := ""
                for i, w := range words {
                    if i > 0 {
                        result += sep
                    }
                    result += w
                }
                return result
            }
          difficulty: 2
        - id: v8
          title: Any Above
          description: >-
            Write <code>func anyAbove(nums []int, threshold int) bool</code> that returns true if any element
            exceeds the threshold.
          functionSignature: func anyAbove(nums []int, threshold int) bool
          testCases:
            - input: "[]int{1, 5, 3}, 4"
              output: "true"
            - input: "[]int{1, 2, 3}, 4"
              output: "false"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                As soon as you find one element above the threshold, you know the answer. Can you return early?
            - title: "\U0001F4A1 Hint"
              content: >-
                Range over the slice. If any n > threshold, return true immediately. If the loop finishes, return
                false.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>1. for _, n := range nums:
                   - if n > threshold: return true
                2. return false</pre>
          solution: |-
            func anyAbove(nums []int, threshold int) bool {
                for _, n := range nums {
                    if n > threshold {
                        return true
                    }
                }
                return false
            }
          difficulty: 2
        - id: v9
          title: Enumerate
          description: >-
            Write <code>func enumerate(items []string) []string</code> that returns a slice of strings in the
            format "0: item", "1: item", etc.
          functionSignature: func enumerate(items []string) []string
          testCases:
            - input: "[]string{\"a\", \"b\", \"c\"}"
              output: "[]string{\"0: a\", \"1: b\", \"2: c\"}"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                You need both the index and the value from range. How do you format an integer and a string into a
                single string in Go?
            - title: "\U0001F4A1 Hint"
              content: >-
                Use fmt.Sprintf("%d: %s", i, item) to format each entry. Pre-allocate with make([]string,
                len(items)).
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>1. result := make([]string, len(items))
                2. for i, item := range items:
                   - result[i] = fmt.Sprintf("%d: %s", i, item)
                3. return result</pre>
          solution: |-
            func enumerate(items []string) []string {
                result := make([]string, len(items))
                for i, item := range items {
                    result[i] = fmt.Sprintf("%d: %s", i, item)
                }
                return result
            }
          difficulty: 2
        - id: v10
          title: Longest String
          description: >-
            Write <code>func longest(words []string) string</code> that returns the longest string in the slice.
            If there is a tie, return the first one found.
          functionSignature: func longest(words []string) string
          testCases:
            - input: "[]string{\"go\", \"python\", \"c\", \"rust\"}"
              output: "\"python\""
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                This is like finding the max, but instead of comparing numbers you compare string lengths. What do
                you track as you iterate?
            - title: "\U0001F4A1 Hint"
              content: >-
                Initialize best to words[0]. Range over the slice and update best whenever len(w) > len(best).
                Using > (not >=) ensures the first one wins on ties.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>1. best := words[0]
                2. for _, w := range words:
                   - if len(w) > len(best): best = w
                3. return best</pre>
          solution: |-
            func longest(words []string) string {
                best := words[0]
                for _, w := range words {
                    if len(w) > len(best) {
                        best = w
                    }
                }
                return best
            }
          difficulty: 3
        - id: v11
          title: Running Max
          description: >-
            Write <code>func runningMax(nums []int) []int</code> that returns a slice where each element is the
            maximum of all elements up to and including that index.
          functionSignature: func runningMax(nums []int) []int
          testCases:
            - input: "[]int{3, 1, 4, 1, 5}"
              output: "[]int{3, 3, 4, 4, 5}"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                At each position, the running max is either the current element or the previous running max,
                whichever is larger. How do you track this as you iterate?
            - title: "\U0001F4A1 Hint"
              content: >-
                Keep a max variable initialized to nums[0]. As you range, update max if the current value is
                larger, then store max in the result.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>1. result := make([]int, len(nums))
                2. max := nums[0]
                3. for i, n := range nums:
                   - if n > max: max = n
                   - result[i] = max
                4. return result</pre>
          solution: |-
            func runningMax(nums []int) []int {
                result := make([]int, len(nums))
                max := nums[0]
                for i, n := range nums {
                    if n > max {
                        max = n
                    }
                    result[i] = max
                }
                return result
            }
          difficulty: 3
        - id: v12
          title: Zip
          description: >-
            Write <code>func zip(a []int, b []int) [][2]int</code> that combines two slices into pairs. Use the
            shorter length if they differ.
          functionSignature: func zip(a []int, b []int) [][2]int
          testCases:
            - input: "[]int{1, 2, 3}, []int{4, 5, 6}"
              output: "[][2]int{{1, 4}, {2, 5}, {3, 6}}"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                You need to iterate two slices in parallel. Range only works on one collection at a time. What
                kind of loop lets you control the index explicitly?
            - title: "\U0001F4A1 Hint"
              content: >-
                Find the minimum of len(a) and len(b). Use a C-style for loop up to that length. At each index,
                create a [2]int pair from a[i] and b[i].
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>1. length := min(len(a), len(b))
                2. result := make([][2]int, length)
                3. for i := 0; i < length; i++:
                   - result[i] = [2]int{a[i], b[i]}
                4. return result</pre>
          solution: |-
            func zip(a []int, b []int) [][2]int {
                length := len(a)
                if len(b) < length {
                    length = len(b)
                }
                result := make([][2]int, length)
                for i := 0; i < length; i++ {
                    result[i] = [2]int{a[i], b[i]}
                }
                return result
            }
          difficulty: 3
        - id: v13
          title: Count Characters
          description: >-
            Write <code>func countChars(s string) map[rune]int</code> that counts the occurrences of each
            character in a string using range, which iterates over runes.
          functionSignature: func countChars(s string) map[rune]int
          testCases:
            - input: "\"hello\""
              output: "map[rune]int{'h': 1, 'e': 1, 'l': 2, 'o': 1}"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                When you range over a string in Go, you get runes (Unicode code points), not bytes. How do you
                store counts for each unique character?
            - title: "\U0001F4A1 Hint"
              content: >-
                Create a map[rune]int with make(). Range over the string to get each rune, then increment the
                count for that rune in the map.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>1. counts := make(map[rune]int)
                2. for _, c := range s:
                   - counts[c]++
                3. return counts</pre>
          solution: |-
            func countChars(s string) map[rune]int {
                counts := make(map[rune]int)
                for _, c := range s {
                    counts[c]++
                }
                return counts
            }
          difficulty: 3
    - id: challenge_11
      block: 1
      difficulty: 2
      concept: "Map Basics"
      docLinks:
        - url: https://go.dev/blog/maps
          title: "Go Blog: Go maps in action"
          note: comprehensive map guide
        - url: https://go.dev/tour/moretypes/19
          title: "Go Tour: Maps"
          note: map basics
      patternPrimer:
        bruteForce: Use parallel slices for keys and values and search linearly.
        bestApproach: Use maps for O(1) key lookups; build maps from data with make() or literals.
        typical: Map operations (get/set/delete) are O(1) average case.
      quickRef: |
        <code>m := map[string]int{}</code> &nbsp; <code>m := make(map[K]V)</code><br>
                <code>m[k] = v</code> &nbsp; <code>delete(m, k)</code> &nbsp; <code>len(m)</code>
      variants:
        - id: v1
          title: Word Count
          description: >-
            Write <code>func wordCount(words []string) map[string]int</code> that counts occurrences of each word.
          functionSignature: func wordCount(words []string) map[string]int
          testCases:
            - input: "[]string{\"go\", \"is\", \"go\"}"
              output: "map[string]int{\"go\": 2, \"is\": 1}"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                You need to track how many times each word appears. What data structure gives you O(1) lookups by
                key?
            - title: "\U0001F4A1 Hint"
              content: >-
                Create a map[string]int with make(). Range over words and use counts[w]++ to increment each
                word's count. Missing keys default to 0.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>1. counts := make(map[string]int)
                2. for _, w := range words:
                   - counts[w]++
                3. return counts</pre>
          solution: |-
            func wordCount(words []string) map[string]int {
                counts := make(map[string]int)
                for _, w := range words {
                    counts[w]++
                }
                return counts
            }
          difficulty: 1
        - id: v2
          title: Create Phone Book
          description: >-
            Write <code>func phoneBook(names, numbers []string) map[string]string</code> that builds a map from
            two parallel slices of names and numbers.
          functionSignature: func phoneBook(names, numbers []string) map[string]string
          testCases:
            - input: "[]string{\"alice\", \"bob\"}, []string{\"111\", \"222\"}"
              output: "map[string]string{\"alice\": \"111\", \"bob\": \"222\"}"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                You have two slices of the same length where corresponding elements are related. How do you access
                matching elements from both?
            - title: "\U0001F4A1 Hint"
              content: >-
                Use for i := range names to iterate by index. Set m[names[i]] = numbers[i] to build the mapping.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>1. m := make(map[string]string)
                2. for i := range names:
                   - m[names[i]] = numbers[i]
                3. return m</pre>
          solution: |-
            func phoneBook(names, numbers []string) map[string]string {
                m := make(map[string]string)
                for i := range names {
                    m[names[i]] = numbers[i]
                }
                return m
            }
          difficulty: 1
        - id: v3
          title: Abbreviation Lookup
          description: >-
            Write <code>func abbreviations(words []string) map[string]string</code> that creates a map from
            full words to their abbreviations (first 3 characters). For example, ["Monday", "Tuesday"]
            becomes {"Monday": "Mon", "Tuesday": "Tue"}.
          functionSignature: func abbreviations(words []string) map[string]string
          testCases:
            - input: "[]string{\"Monday\", \"Tuesday\", \"Wednesday\"}"
              output: "map[string]string{\"Monday\": \"Mon\", \"Tuesday\": \"Tue\", \"Wednesday\": \"Wed\"}"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                You need to generate key-value pairs where the key is the full word and the value is derived
                from it. How do you get the first 3 characters of a string?
            - title: "\U0001F4A1 Hint"
              content: >-
                Use make(map[string]string) and range over words. Set m[word] = word[:3] for each word.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>1. m := make(map[string]string)
                2. for _, word := range words:
                   - m[word] = word[:3]
                3. return m</pre>
          solution: |-
            func abbreviations(words []string) map[string]string {
                m := make(map[string]string)
                for _, word := range words {
                    m[word] = word[:3]
                }
                return m
            }
          difficulty: 1
        - id: v4
          title: Invert Map
          description: >-
            Write <code>func invertMap(m map[string]int) map[int]string</code> that swaps keys and values.
          functionSignature: func invertMap(m map[string]int) map[int]string
          testCases:
            - input: "map[string]int{\"a\": 1, \"b\": 2}"
              output: "map[int]string{1: \"a\", 2: \"b\"}"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                Each key becomes a value and each value becomes a key. What happens if two keys have the same
                value?
            - title: "\U0001F4A1 Hint"
              content: >-
                Create a new map with the types swapped. Range over the original map and set result[v] = k for
                each key-value pair.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>1. result := make(map[int]string)
                2. for k, v := range m:
                   - result[v] = k
                3. return result</pre>
          solution: |-
            func invertMap(m map[string]int) map[int]string {
                result := make(map[int]string)
                for k, v := range m {
                    result[v] = k
                }
                return result
            }
          difficulty: 1
        - id: v5
          title: Group by Length
          description: >-
            Write <code>func groupByLength(words []string) map[int][]string</code> that groups words by their
            string length.
          functionSignature: func groupByLength(words []string) map[int][]string
          testCases:
            - input: "[]string{\"go\", \"hi\", \"rust\", \"hey\"}"
              output: "map[int][]string{2: {\"go\", \"hi\"}, 4: {\"rust\"}, 3: {\"hey\"}}"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                The map values are slices. How do you add to a slice that might not exist in the map yet?
            - title: "\U0001F4A1 Hint"
              content: >-
                Use append. In Go, appending to a nil slice works fine, so groups[len(w)] = append(groups[len(w)],
                w) handles both new and existing keys.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>1. groups := make(map[int][]string)
                2. for _, w := range words:
                   - groups[len(w)] = append(groups[len(w)], w)
                3. return groups</pre>
          solution: |-
            func groupByLength(words []string) map[int][]string {
                groups := make(map[int][]string)
                for _, w := range words {
                    groups[len(w)] = append(groups[len(w)], w)
                }
                return groups
            }
          difficulty: 2
        - id: v6
          title: Keys
          description: >-
            Write <code>func keys(m map[string]int) []string</code> that returns all keys of a map as a slice.
          functionSignature: func keys(m map[string]int) []string
          testCases:
            - input: "map[string]int{\"a\": 1, \"b\": 2}"
              output: "[]string{\"a\", \"b\"} (order may vary)"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                When you range over a map, you get keys and values. How do you collect just the keys into a slice?
            - title: "\U0001F4A1 Hint"
              content: >-
                Use for k := range m to iterate only keys. Append each key to a result slice.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>1. result := []string{}
                2. for k := range m:
                   - append k to result
                3. return result</pre>
          solution: |-
            func keys(m map[string]int) []string {
                result := []string{}
                for k := range m {
                    result = append(result, k)
                }
                return result
            }
          difficulty: 2
        - id: v7
          title: Values
          description: >-
            Write <code>func values(m map[string]int) []int</code> that returns all values of a map as a slice.
          functionSignature: func values(m map[string]int) []int
          testCases:
            - input: "map[string]int{\"a\": 1, \"b\": 2}"
              output: "[]int{1, 2} (order may vary)"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                Similar to extracting keys, but you want the values. How do you get just the value in a range
                loop?
            - title: "\U0001F4A1 Hint"
              content: >-
                Use for _, v := range m to iterate values. The underscore discards the key. Append each value to a
                result slice.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>1. result := []int{}
                2. for _, v := range m:
                   - append v to result
                3. return result</pre>
          solution: |-
            func values(m map[string]int) []int {
                result := []int{}
                for _, v := range m {
                    result = append(result, v)
                }
                return result
            }
          difficulty: 2
        - id: v8
          title: Merge Maps
          description: >-
            Write <code>func mergeMaps(a, b map[string]int) map[string]int</code> that merges two maps into a
            new one. If both maps have the same key, the value from b wins.
          functionSignature: func mergeMaps(a, b map[string]int) map[string]int
          testCases:
            - input: "map[string]int{\"x\": 1}, map[string]int{\"x\": 2, \"y\": 3}"
              output: "map[string]int{\"x\": 2, \"y\": 3}"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                If you copy a first and then b, any overlapping keys from b will overwrite those from a. Does
                order of copying matter?
            - title: "\U0001F4A1 Hint"
              content: >-
                Create a new map. Copy all entries from a, then copy all entries from b. Since b is copied second,
                its values win on conflicts.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>1. result := make(map[string]int)
                2. for k, v := range a:
                   - result[k] = v
                3. for k, v := range b:
                   - result[k] = v
                4. return result</pre>
          solution: |-
            func mergeMaps(a, b map[string]int) map[string]int {
                result := make(map[string]int)
                for k, v := range a {
                    result[k] = v
                }
                for k, v := range b {
                    result[k] = v
                }
                return result
            }
          difficulty: 2
        - id: v9
          title: Filter Map
          description: >-
            Write <code>func filterMap(m map[string]int, minValue int) map[string]int</code> that returns a new
            map containing only entries where the value is >= minValue.
          functionSignature: func filterMap(m map[string]int, minValue int) map[string]int
          testCases:
            - input: "map[string]int{\"a\": 1, \"b\": 5, \"c\": 3}, 3"
              output: "map[string]int{\"b\": 5, \"c\": 3}"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                You want to keep only some entries from the original map. How do you selectively copy entries?
            - title: "\U0001F4A1 Hint"
              content: >-
                Create a new map. Range over the original and only add entries where v >= minValue.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>1. result := make(map[string]int)
                2. for k, v := range m:
                   - if v >= minValue: result[k] = v
                3. return result</pre>
          solution: |-
            func filterMap(m map[string]int, minValue int) map[string]int {
                result := make(map[string]int)
                for k, v := range m {
                    if v >= minValue {
                        result[k] = v
                    }
                }
                return result
            }
          difficulty: 2
        - id: v10
          title: Most Common Word
          description: >-
            Write <code>func mostCommon(words []string) string</code> that returns the most frequently
            occurring word in the slice. If there's a tie, any of the tied words is acceptable.
          functionSignature: func mostCommon(words []string) string
          testCases:
            - input: "[]string{\"the\", \"cat\", \"the\", \"dog\", \"the\"}"
              output: "\"the\""
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                This is a two-step problem: first count word frequencies, then find which word has the highest
                count. What data structure helps you count occurrences?
            - title: "\U0001F4A1 Hint"
              content: >-
                Build a word frequency map first. Then iterate the map to find the key with the highest value,
                just like finding a max.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>1. freq := make(map[string]int)
                2. for _, w := range words:
                   - freq[w]++
                3. best := ""; bestCount := 0
                4. for word, count := range freq:
                   - if count > bestCount: best = word; bestCount = count
                5. return best</pre>
          solution: |-
            func mostCommon(words []string) string {
                freq := make(map[string]int)
                for _, w := range words {
                    freq[w]++
                }
                best := ""
                bestCount := 0
                for word, count := range freq {
                    if count > bestCount {
                        best = word
                        bestCount = count
                    }
                }
                return best
            }
          difficulty: 3
        - id: v11
          title: Two Sum Map
          description: >-
            Write <code>func twoSumExists(nums []int, target int) bool</code> that uses a map to check if any
            two numbers in the slice sum to the target.
          functionSignature: func twoSumExists(nums []int, target int) bool
          testCases:
            - input: "[]int{2, 7, 11, 15}, 9"
              output: "true"
            - input: "[]int{2, 7, 11, 15}, 10"
              output: "false"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                For each number, you need to know if its complement (target - number) has already appeared. What
                data structure gives you O(1) lookups?
            - title: "\U0001F4A1 Hint"
              content: >-
                Use a map[int]bool as a "seen" set. For each number, check if target - n is in the map. If yes,
                return true. Otherwise, add n to the map.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>1. seen := make(map[int]bool)
                2. for _, n := range nums:
                   - if seen[target - n]: return true
                   - seen[n] = true
                3. return false</pre>
          solution: |-
            func twoSumExists(nums []int, target int) bool {
                seen := make(map[int]bool)
                for _, n := range nums {
                    if seen[target-n] {
                        return true
                    }
                    seen[n] = true
                }
                return false
            }
          difficulty: 3
        - id: v12
          title: Histogram
          description: >-
            Write <code>func histogram(data []int) map[int]string</code> that creates a map where each key is a
            number from data and the value is a bar of "*" characters whose length equals the count of that number
            in data.
          functionSignature: func histogram(data []int) map[int]string
          testCases:
            - input: "[]int{1, 2, 2, 3, 3, 3}"
              output: "map[int]string{1: \"*\", 2: \"**\", 3: \"***\"}"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                This is a two-phase problem: first count occurrences, then convert counts to strings of repeated
                characters. How do you repeat a string in Go?
            - title: "\U0001F4A1 Hint"
              content: >-
                First build a count map. Then create a result map where each value is strings.Repeat("*", count).
                You will need to import "strings".
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>1. count := make(map[int]int)
                2. for _, n := range data:
                   - count[n]++
                3. result := make(map[int]string)
                4. for k, v := range count:
                   - result[k] = strings.Repeat("*", v)
                5. return result</pre>
          solution: |-
            func histogram(data []int) map[int]string {
                count := make(map[int]int)
                for _, n := range data {
                    count[n]++
                }
                result := make(map[int]string)
                for k, v := range count {
                    result[k] = strings.Repeat("*", v)
                }
                return result
            }
          difficulty: 3
        - id: v13
          title: Top Characters
          description: >-
            Write <code>func topChars(s string, n int) []string</code> that returns the n most frequent
            characters in s as strings, sorted by frequency in descending order.
          functionSignature: func topChars(s string, n int) []string
          testCases:
            - input: "\"aabbbcc\", 2"
              output: "[]string{\"b\", \"a\"} or []string{\"b\", \"c\"}"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                You need to count characters, sort them by frequency, and return the top n. How do you sort map
                entries in Go?
            - title: "\U0001F4A1 Hint"
              content: >-
                Count characters into a map. Extract unique characters into a slice. Sort the slice using
                sort.Slice with a custom comparator that compares counts. Return the first n entries as strings.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>1. counts := make(map[rune]int)
                2. for _, c := range s: counts[c]++
                3. chars := collect keys into []rune
                4. sort.Slice(chars, by descending count)
                5. result := first n chars as []string
                6. return result</pre>
          solution: |-
            func topChars(s string, n int) []string {
                counts := make(map[rune]int)
                for _, c := range s {
                    counts[c]++
                }
                chars := make([]rune, 0, len(counts))
                for c := range counts {
                    chars = append(chars, c)
                }
                sort.Slice(chars, func(i, j int) bool {
                    return counts[chars[i]] > counts[chars[j]]
                })
                result := make([]string, n)
                for i := 0; i < n; i++ {
                    result[i] = string(chars[i])
                }
                return result
            }
          difficulty: 3
    - id: challenge_12
      block: 1
      difficulty: 2
      concept: "Comma-Ok Pattern"
      docLinks:
        - url: https://go.dev/doc/effective_go#maps
          title: "Effective Go: Maps"
          note: comma-ok idiom
        - url: https://go.dev/ref/spec#Index_expressions
          title: "Go Spec: Index expressions"
          note: two-value form
      patternPrimer:
        bruteForce: Check if zero value means the key is missing (unreliable for int/string maps).
        bestApproach: "Always use value, ok := m[key] to distinguish missing keys from zero values."
        typical: "Comma-ok lookup is O(1) â€” same as regular map access, but safe."
      quickRef: |
        <code>v, ok := m[key]</code> (map lookup)<br>
                <code>v, ok := i.(Type)</code> (type assertion)
      variants:
        - id: v1
          title: Safe Lookup
          description: >-
            Write <code>func safeLookup(m map[string]int, key string) (int, bool)</code> that returns the value for the
            given key and whether the key exists in the map.
          functionSignature: func safeLookup(m map[string]int, key string) (int, bool)
          testCases:
            - input: "map[string]int{\"a\": 1}, \"a\""
              output: "1, true"
            - input: "map[string]int{\"a\": 1}, \"z\""
              output: "0, false"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                When you access a map key that doesn't exist, Go returns the zero value. How can you tell the difference
                between a missing key and a key whose value really is zero?
            - title: "\U0001F4A1 Hint"
              content: >-
                Go's comma-ok idiom lets you get two values from a map lookup: the value and a boolean indicating whether
                the key was found. Use <code>v, ok := m[key]</code>.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>1. Use comma-ok: v, ok := m[key]
                2. Return both v and ok</pre>
          solution: |-
            func safeLookup(m map[string]int, key string) (int, bool) {
                v, ok := m[key]
                return v, ok
            }
          difficulty: 1
        - id: v2
          title: Get or Default
          description: >-
            Write <code>func getOrDefault(m map[string]int, key string, defaultVal int) int</code> that returns the value
            for the key if it exists, otherwise returns defaultVal.
          functionSignature: func getOrDefault(m map[string]int, key string, defaultVal int) int
          testCases:
            - input: "map[string]int{\"a\": 1}, \"a\", 99"
              output: "1"
            - input: "map[string]int{\"a\": 1}, \"z\", 99"
              output: "99"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                You need to check if the key exists before deciding what to return. What Go idiom lets you check
                existence and get the value at the same time?
            - title: "\U0001F4A1 Hint"
              content: >-
                Use the comma-ok pattern in an if statement: <code>if v, ok := m[key]; ok { return v }</code>. If the
                key is not found, fall through to return the default.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>1. if v, ok := m[key]; ok â†’ return v
                2. Otherwise â†’ return defaultVal</pre>
          solution: |-
            func getOrDefault(m map[string]int, key string, defaultVal int) int {
                if v, ok := m[key]; ok {
                    return v
                }
                return defaultVal
            }
          difficulty: 1
        - id: v3
          title: Key Exists
          description: >-
            Write <code>func keyExists(m map[string]string, key string) bool</code> that returns true if the key is
            present in the map.
          functionSignature: func keyExists(m map[string]string, key string) bool
          testCases:
            - input: "map[string]string{\"go\": \"fun\"}, \"go\""
              output: "true"
            - input: "map[string]string{\"go\": \"fun\"}, \"rust\""
              output: "false"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                You only care about whether the key is present, not its value. Is there a way to ignore the value and
                just get the boolean?
            - title: "\U0001F4A1 Hint"
              content: >-
                Use the blank identifier to discard the value: <code>_, ok := m[key]</code>. The ok boolean tells you
                if the key exists.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>1. _, ok := m[key]
                2. Return ok</pre>
          solution: |-
            func keyExists(m map[string]string, key string) bool {
                _, ok := m[key]
                return ok
            }
          difficulty: 1
        - id: v4
          title: Count Known Keys
          description: >-
            Write <code>func countKnown(m map[string]int, keys []string) int</code> that counts how many of the given
            keys exist in the map.
          functionSignature: func countKnown(m map[string]int, keys []string) int
          testCases:
            - input: "map[string]int{\"a\": 1, \"b\": 2}, []string{\"a\", \"c\", \"b\"}"
              output: "2"
            - input: "map[string]int{\"a\": 1}, []string{\"x\", \"y\"}"
              output: "0"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                You need to loop through the keys slice and check each one against the map. How do you count only the
                ones that are found?
            - title: "\U0001F4A1 Hint"
              content: >-
                Use a counter variable. For each key in the slice, use comma-ok to check if it exists in the map. If ok
                is true, increment the counter.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>1. count := 0
                2. For each key in keys:
                   - _, ok := m[key]
                   - If ok â†’ count++
                3. Return count</pre>
          solution: |-
            func countKnown(m map[string]int, keys []string) int {
                count := 0
                for _, k := range keys {
                    if _, ok := m[k]; ok {
                        count++
                    }
                }
                return count
            }
          difficulty: 1
        - id: v5
          title: Get with Fallback
          description: >-
            Write <code>func getWithFallback(m map[string]string, key, fallback string) string</code> that returns
            m[key] if present, else fallback. Important: an empty string "" is a valid value, so you must use comma-ok
            to distinguish it from a missing key.
          functionSignature: func getWithFallback(m map[string]string, key, fallback string) string
          testCases:
            - input: "map[string]string{\"a\": \"\"}, \"a\", \"none\""
              output: "\"\""
              note: key "a" exists with value "", so return ""
            - input: "map[string]string{\"a\": \"\"}, \"z\", \"none\""
              output: "\"none\""
              note: key "z" does not exist, so return fallback
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                Why can't you just check if m[key] == ""? Because "" might be a legitimate value stored in the map. You
                need a way to distinguish "key not found" from "key found with zero value."
            - title: "\U0001F4A1 Hint"
              content: >-
                The comma-ok pattern is essential here. <code>if v, ok := m[key]; ok</code> will correctly detect that
                the key exists even when its value is the zero value for the type.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>1. if v, ok := m[key]; ok â†’ return v
                2. Otherwise â†’ return fallback</pre>
          solution: |-
            func getWithFallback(m map[string]string, key, fallback string) string {
                if v, ok := m[key]; ok {
                    return v
                }
                return fallback
            }
          difficulty: 2
        - id: v6
          title: First Found
          description: >-
            Write <code>func firstFound(m map[string]int, keys []string) (int, bool)</code> that tries each key in
            order and returns the value of the first key found in the map, along with true. If none are found, return
            0 and false.
          functionSignature: func firstFound(m map[string]int, keys []string) (int, bool)
          testCases:
            - input: "map[string]int{\"b\": 2}, []string{\"a\", \"b\", \"c\"}"
              output: "2, true"
            - input: "map[string]int{\"x\": 1}, []string{\"a\", \"b\", \"c\"}"
              output: "0, false"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                You want to try multiple keys in priority order. As soon as you find one that exists, you should stop
                looking and return it.
            - title: "\U0001F4A1 Hint"
              content: >-
                Loop through the keys slice. For each key, use comma-ok to check the map. If ok is true, return the
                value immediately. If the loop finishes without finding anything, return 0 and false.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>1. For each key in keys:
                   - v, ok := m[key]
                   - If ok â†’ return v, true
                2. Return 0, false</pre>
          solution: |-
            func firstFound(m map[string]int, keys []string) (int, bool) {
                for _, k := range keys {
                    if v, ok := m[k]; ok {
                        return v, true
                    }
                }
                return 0, false
            }
          difficulty: 2
        - id: v7
          title: Collect Found
          description: >-
            Write <code>func collectFound(m map[string]int, keys []string) []int</code> that returns the values for all
            keys that exist in the map, skipping any missing keys. The result preserves the order of the keys slice.
          functionSignature: func collectFound(m map[string]int, keys []string) []int
          testCases:
            - input: "map[string]int{\"a\": 1, \"c\": 3}, []string{\"a\", \"b\", \"c\"}"
              output: "[]int{1, 3}"
            - input: "map[string]int{\"x\": 10}, []string{\"a\", \"b\"}"
              output: "[]int{}"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                You need to build a result slice containing only the values for keys that exist. How do you selectively
                add to a slice?
            - title: "\U0001F4A1 Hint"
              content: >-
                Start with an empty slice. For each key, use comma-ok to check the map. If the key exists, append its
                value to the result slice.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>1. result := []int{}
                2. For each key in keys:
                   - v, ok := m[key]
                   - If ok â†’ append v to result
                3. Return result</pre>
          solution: |-
            func collectFound(m map[string]int, keys []string) []int {
                result := []int{}
                for _, k := range keys {
                    if v, ok := m[k]; ok {
                        result = append(result, v)
                    }
                }
                return result
            }
          difficulty: 2
        - id: v8
          title: Update If Exists
          description: >-
            Write <code>func updateIfExists(m map[string]int, key string, delta int) bool</code> that adds delta to
            the value of key if it exists in the map and returns true. If the key does not exist, return false without
            modifying the map.
          functionSignature: func updateIfExists(m map[string]int, key string, delta int) bool
          testCases:
            - input: "map[string]int{\"a\": 10}, \"a\", 5"
              output: "true"
              note: "map is now {\"a\": 15}"
            - input: "map[string]int{\"a\": 10}, \"z\", 5"
              output: "false"
              note: map is unchanged
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                You only want to update the map if the key already exists. How can you conditionally modify a map entry?
            - title: "\U0001F4A1 Hint"
              content: >-
                Use comma-ok to check if the key exists. If it does, update the value using <code>m[key] += delta</code>
                and return true. Otherwise return false.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>1. _, ok := m[key]
                2. If ok â†’ m[key] += delta, return true
                3. Otherwise â†’ return false</pre>
          solution: |-
            func updateIfExists(m map[string]int, key string, delta int) bool {
                if _, ok := m[key]; ok {
                    m[key] += delta
                    return true
                }
                return false
            }
          difficulty: 2
        - id: v9
          title: Difference
          description: >-
            Write <code>func difference(a, b map[string]int) map[string]int</code> that returns a new map containing
            all entries from a whose keys are NOT present in b.
          functionSignature: func difference(a, b map[string]int) map[string]int
          testCases:
            - input: "map[string]int{\"x\": 1, \"y\": 2}, map[string]int{\"y\": 3}"
              output: "map[string]int{\"x\": 1}"
            - input: "map[string]int{\"a\": 1}, map[string]int{\"a\": 2, \"b\": 3}"
              output: "map[string]int{}"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                You want entries from a that are absent in b. For each key in a, how do you check if b has that key?
            - title: "\U0001F4A1 Hint"
              content: >-
                Loop through map a. For each key, use comma-ok on map b. If the key is NOT in b (ok is false), add it
                to your result map.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>1. result := make(map[string]int)
                2. For each k, v in a:
                   - _, ok := b[k]
                   - If !ok â†’ result[k] = v
                3. Return result</pre>
          solution: |-
            func difference(a, b map[string]int) map[string]int {
                result := make(map[string]int)
                for k, v := range a {
                    if _, ok := b[k]; !ok {
                        result[k] = v
                    }
                }
                return result
            }
          difficulty: 2
        - id: v10
          title: Intersection
          description: >-
            Write <code>func intersection(a, b map[string]int) map[string]int</code> that returns a new map containing
            entries where the key exists in both maps. Use the values from map a.
          functionSignature: func intersection(a, b map[string]int) map[string]int
          testCases:
            - input: "map[string]int{\"x\": 1, \"y\": 2}, map[string]int{\"y\": 3, \"z\": 4}"
              output: "map[string]int{\"y\": 2}"
            - input: "map[string]int{\"a\": 1}, map[string]int{\"b\": 2}"
              output: "map[string]int{}"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                Intersection means keys that appear in both maps. For each key in a, how do you verify it also exists
                in b?
            - title: "\U0001F4A1 Hint"
              content: >-
                Loop through map a. For each key, use comma-ok on map b. If the key IS in b (ok is true), add it to
                the result using a's value.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>1. result := make(map[string]int)
                2. For each k, v in a:
                   - _, ok := b[k]
                   - If ok â†’ result[k] = v
                3. Return result</pre>
          solution: |-
            func intersection(a, b map[string]int) map[string]int {
                result := make(map[string]int)
                for k, v := range a {
                    if _, ok := b[k]; ok {
                        result[k] = v
                    }
                }
                return result
            }
          difficulty: 3
        - id: v11
          title: Get Nested
          description: >-
            Write <code>func getNestedValue(m map[string]map[string]int, outer, inner string) (int, bool)</code> that
            safely looks up a value in a nested map. Return the value and true if both the outer and inner keys exist,
            otherwise return 0 and false.
          functionSignature: func getNestedValue(m map[string]map[string]int, outer, inner string) (int, bool)
          testCases:
            - input: "map[string]map[string]int{\"a\": {\"x\": 1}}, \"a\", \"x\""
              output: "1, true"
            - input: "map[string]map[string]int{\"a\": {\"x\": 1}}, \"b\", \"x\""
              output: "0, false"
            - input: "map[string]map[string]int{\"a\": {\"x\": 1}}, \"a\", \"y\""
              output: "0, false"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                With nested maps, you need two comma-ok checks: one for the outer key and one for the inner key. If
                either fails, the lookup fails.
            - title: "\U0001F4A1 Hint"
              content: >-
                First check if the outer key exists using comma-ok. If it does, check the inner key on the resulting
                inner map. Both must succeed for the lookup to return a valid value.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>1. innerMap, ok := m[outer]
                2. If !ok â†’ return 0, false
                3. v, ok := innerMap[inner]
                4. Return v, ok</pre>
          solution: |-
            func getNestedValue(m map[string]map[string]int, outer, inner string) (int, bool) {
                innerMap, ok := m[outer]
                if !ok {
                    return 0, false
                }
                v, ok := innerMap[inner]
                return v, ok
            }
          difficulty: 3
        - id: v12
          title: Unique Values
          description: >-
            Write <code>func uniqueValues(m map[string]int) []int</code> that returns a slice of the unique values in
            the map (deduplicated). The order of the result does not matter.
          functionSignature: func uniqueValues(m map[string]int) []int
          testCases:
            - input: "map[string]int{\"a\": 1, \"b\": 2, \"c\": 1}"
              output: "[]int{1, 2}"
              note: order may vary
            - input: "map[string]int{\"x\": 5, \"y\": 5}"
              output: "[]int{5}"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                Multiple keys can have the same value. How do you collect values while making sure each unique value
                only appears once in the result?
            - title: "\U0001F4A1 Hint"
              content: >-
                Use a second map as a "seen" set for values. For each value in the original map, use comma-ok to check
                if you've already seen it. If not, add it to both the seen map and the result slice.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>1. seen := make(map[int]bool)
                2. result := []int{}
                3. For each _, v in m:
                   - If !seen[v] â†’ seen[v] = true, append v
                4. Return result</pre>
          solution: |-
            func uniqueValues(m map[string]int) []int {
                seen := make(map[int]bool)
                result := []int{}
                for _, v := range m {
                    if _, ok := seen[v]; !ok {
                        seen[v] = true
                        result = append(result, v)
                    }
                }
                return result
            }
          difficulty: 3
        - id: v13
          title: Translate
          description: >-
            Write <code>func translate(words []string, dictionary map[string]string) []string</code> that replaces each
            word with its translation from the dictionary if found, or keeps the original word if not found.
          functionSignature: func translate(words []string, dictionary map[string]string) []string
          testCases:
            - input: "[]string{\"hello\", \"world\"}, map[string]string{\"hello\": \"hola\"}"
              output: "[]string{\"hola\", \"world\"}"
            - input: "[]string{\"cat\", \"dog\"}, map[string]string{\"cat\": \"gato\", \"dog\": \"perro\"}"
              output: "[]string{\"gato\", \"perro\"}"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                For each word, you need to check if a translation exists. If it does, use the translation; if not, keep
                the original. What pattern handles this check?
            - title: "\U0001F4A1 Hint"
              content: >-
                Create a result slice. For each word, use comma-ok on the dictionary. If ok, use the translated value.
                Otherwise, use the original word.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>1. result := make([]string, len(words))
                2. For each i, word in words:
                   - t, ok := dictionary[word]
                   - If ok â†’ result[i] = t
                   - Else â†’ result[i] = word
                3. Return result</pre>
          solution: |-
            func translate(words []string, dictionary map[string]string) []string {
                result := make([]string, len(words))
                for i, w := range words {
                    if t, ok := dictionary[w]; ok {
                        result[i] = t
                    } else {
                        result[i] = w
                    }
                }
                return result
            }
          difficulty: 3
    - id: challenge_13
      block: 1
      difficulty: 2
      concept: "Strings & Runes"
      docLinks:
        - url: https://go.dev/blog/strings
          title: "Go Blog: Strings, bytes, runes and characters"
          note: string internals
        - url: https://go.dev/ref/spec#String_types
          title: "Go Spec: String types"
          note: string specification
      patternPrimer:
        bruteForce: Treat strings as byte arrays and hope for ASCII.
        bestApproach: "Use []rune(s) for Unicode-safe character operations; range over string iterates runes automatically."
        typical: "len(s) returns bytes; len([]rune(s)) returns character count. Know the difference."
      quickRef: |
        <code>[]rune(s)</code> &nbsp; <code>[]byte(s)</code> &nbsp; <code>string(r)</code><br>
                <code>utf8.RuneCountInString(s)</code> &nbsp; <code>len(s)</code> counts bytes
      variants:
        - id: v1
          title: Rune Count
          description: >-
            Write <code>func runeCount(s string) int</code> that returns the number of runes (characters) in the
            string. Use <code>[]rune(s)</code> to convert and count correctly for Unicode strings.
          functionSignature: func runeCount(s string) int
          testCases:
            - input: "\"hello\""
              output: "5"
            - input: "\"caf\\u00e9\""
              output: "4"
              note: "cafe with accent: c-a-f-e is 4 runes"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                The built-in len() function returns the number of bytes in a string, not the number of characters. For
                ASCII strings these are the same, but for Unicode they differ. How do you count actual characters?
            - title: "\U0001F4A1 Hint"
              content: >-
                Convert the string to a rune slice with <code>[]rune(s)</code>, then use len() on the rune slice. Each
                rune represents one Unicode character regardless of its byte size.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>1. Convert string to []rune
                2. Return len of the rune slice</pre>
          solution: |-
            func runeCount(s string) int {
                return len([]rune(s))
            }
          difficulty: 1
        - id: v2
          title: Byte Count
          description: >-
            Write <code>func byteCount(s string) int</code> that returns the number of bytes in the string using
            the built-in <code>len()</code> function.
          functionSignature: func byteCount(s string) int
          testCases:
            - input: "\"hello\""
              output: "5"
            - input: "\"caf\\u00e9\""
              output: "5"
              note: "e-acute is 2 bytes in UTF-8, so cafe = 3 + 2 = 5 bytes"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                Go strings are sequences of bytes under the hood. The len() function on a string returns the byte count,
                not the character count. For multi-byte Unicode characters, these differ.
            - title: "\U0001F4A1 Hint"
              content: >-
                Simply use <code>len(s)</code> which returns the number of bytes. This is different from the rune count
                for strings containing multi-byte UTF-8 characters.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>1. Return len(s) â€” this counts bytes</pre>
          solution: |-
            func byteCount(s string) int {
                return len(s)
            }
          difficulty: 1
        - id: v3
          title: First Rune
          description: >-
            Write <code>func firstRune(s string) rune</code> that returns the first rune (character) of the string.
            You may assume the string is non-empty.
          functionSignature: func firstRune(s string) rune
          testCases:
            - input: "\"hello\""
              output: "'h'"
            - input: "\"caf\\u00e9\""
              output: "'c'"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                Indexing a string with s[0] gives you a byte, not a rune. For ASCII strings this works, but for Unicode
                it may give you only part of a character. How do you safely get the first character?
            - title: "\U0001F4A1 Hint"
              content: >-
                Convert to a rune slice first: <code>runes := []rune(s)</code>, then return <code>runes[0]</code>. This
                correctly handles multi-byte Unicode characters.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>1. Convert s to []rune
                2. Return the first element runes[0]</pre>
          solution: |-
            func firstRune(s string) rune {
                runes := []rune(s)
                return runes[0]
            }
          difficulty: 1
        - id: v4
          title: Is ASCII
          description: >-
            Write <code>func isASCII(s string) bool</code> that returns true if all characters in the string are ASCII
            (rune value less than 128).
          functionSignature: func isASCII(s string) bool
          testCases:
            - input: "\"hello\""
              output: "true"
            - input: "\"caf\\u00e9\""
              output: "false"
              note: "e-acute has rune value > 127"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                ASCII characters have values 0-127. You need to check every character in the string. What Go construct
                iterates over runes in a string?
            - title: "\U0001F4A1 Hint"
              content: >-
                Use <code>for _, r := range s</code> which iterates over runes. If any rune has a value greater than
                127, return false. If the loop finishes, all characters are ASCII.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>1. For each rune r in string:
                   - If r > 127 â†’ return false
                2. Return true</pre>
          solution: |-
            func isASCII(s string) bool {
                for _, r := range s {
                    if r > 127 {
                        return false
                    }
                }
                return true
            }
          difficulty: 1
        - id: v5
          title: Reverse String
          description: >-
            Write <code>func reverseString(s string) string</code> that reverses a string correctly, handling Unicode
            characters safely by converting to a rune slice first.
          functionSignature: func reverseString(s string) string
          testCases:
            - input: "\"hello\""
              output: "\"olleh\""
            - input: "\"caf\\u00e9\""
              output: "\"\\u00e9fac\""
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                Reversing a string byte-by-byte would break multi-byte Unicode characters. You need to reverse at the
                rune level. How do you swap elements from opposite ends of a slice?
            - title: "\U0001F4A1 Hint"
              content: >-
                Convert to []rune, then use two pointers (i from start, j from end) to swap elements moving inward.
                Convert back to string when done.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>1. runes := []rune(s)
                2. Two pointers: i=0, j=len-1
                3. While i < j:
                   - Swap runes[i] and runes[j]
                   - i++, j--
                4. Return string(runes)</pre>
          solution: |-
            func reverseString(s string) string {
                runes := []rune(s)
                for i, j := 0, len(runes)-1; i < j; i, j = i+1, j-1 {
                    runes[i], runes[j] = runes[j], runes[i]
                }
                return string(runes)
            }
          difficulty: 2
        - id: v6
          title: To Upper Manual
          description: >-
            Write <code>func toUpperManual(s string) string</code> that converts lowercase ASCII letters to uppercase
            by subtracting 32 from each rune value. Leave all other characters unchanged.
          functionSignature: func toUpperManual(s string) string
          testCases:
            - input: "\"hello\""
              output: "\"HELLO\""
            - input: "\"Go 123\""
              output: "\"GO 123\""
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                In ASCII, lowercase letters 'a' to 'z' are 32 positions higher than their uppercase counterparts 'A' to
                'Z'. How do you check if a rune is a lowercase letter?
            - title: "\U0001F4A1 Hint"
              content: >-
                Convert to []rune. For each rune, check if it is between 'a' and 'z'. If so, subtract 32 to get the
                uppercase version. Leave other runes unchanged.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>1. runes := []rune(s)
                2. For each rune:
                   - If 'a' <= r <= 'z' â†’ r -= 32
                3. Return string(runes)</pre>
          solution: |-
            func toUpperManual(s string) string {
                runes := []rune(s)
                for i, r := range runes {
                    if r >= 'a' && r <= 'z' {
                        runes[i] = r - 32
                    }
                }
                return string(runes)
            }
          difficulty: 2
        - id: v7
          title: Count Vowels
          description: >-
            Write <code>func countVowels(s string) int</code> that counts the number of vowels (a, e, i, o, u, both
            upper and lowercase) in the string.
          functionSignature: func countVowels(s string) int
          testCases:
            - input: "\"Hello World\""
              output: "3"
            - input: "\"AEIOU\""
              output: "5"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                You need to check each character against the set of vowels. How can you efficiently test if a character
                is one of several values?
            - title: "\U0001F4A1 Hint"
              content: >-
                Range over the string to get runes. For each rune, check if it is in the string "aeiouAEIOU" using
                <code>strings.ContainsRune</code> or a manual comparison loop.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>1. count := 0
                2. For each rune r in s:
                   - If r is a vowel â†’ count++
                3. Return count</pre>
          solution: |-
            func countVowels(s string) int {
                count := 0
                vowels := "aeiouAEIOU"
                for _, r := range s {
                    for _, v := range vowels {
                        if r == v {
                            count++
                            break
                        }
                    }
                }
                return count
            }
          difficulty: 2
        - id: v8
          title: Capitalize First
          description: >-
            Write <code>func capitalizeFirst(s string) string</code> that capitalizes the first character of the string
            and leaves the rest unchanged. If the first character is not a lowercase letter, return the string as-is.
          functionSignature: func capitalizeFirst(s string) string
          testCases:
            - input: "\"hello\""
              output: "\"Hello\""
            - input: "\"Go\""
              output: "\"Go\""
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                You only need to modify the first character. Convert to runes so you can safely access and modify the
                first character, then convert back.
            - title: "\U0001F4A1 Hint"
              content: >-
                Convert to []rune. Check if the first rune is between 'a' and 'z'. If so, subtract 32 to capitalize it.
                Convert back to string.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>1. runes := []rune(s)
                2. If len > 0 and runes[0] is lowercase:
                   - runes[0] -= 32
                3. Return string(runes)</pre>
          solution: |-
            func capitalizeFirst(s string) string {
                runes := []rune(s)
                if len(runes) > 0 && runes[0] >= 'a' && runes[0] <= 'z' {
                    runes[0] -= 32
                }
                return string(runes)
            }
          difficulty: 2
        - id: v9
          title: Is Palindrome
          description: >-
            Write <code>func isPalindrome(s string) bool</code> that checks if the string reads the same forwards and
            backwards. Handle Unicode correctly by converting to runes.
          functionSignature: func isPalindrome(s string) bool
          testCases:
            - input: "\"racecar\""
              output: "true"
            - input: "\"hello\""
              output: "false"
            - input: "\"a\""
              output: "true"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                A palindrome reads the same from both ends. You can compare characters from the start and end moving
                inward. If any pair doesn't match, it's not a palindrome.
            - title: "\U0001F4A1 Hint"
              content: >-
                Convert to []rune for Unicode safety. Use two pointers starting at opposite ends. Compare runes[i] and
                runes[j] as you move inward. If all pairs match, it's a palindrome.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>1. runes := []rune(s)
                2. i := 0, j := len(runes) - 1
                3. While i < j:
                   - If runes[i] != runes[j] â†’ return false
                   - i++, j--
                4. Return true</pre>
          solution: |-
            func isPalindrome(s string) bool {
                runes := []rune(s)
                for i, j := 0, len(runes)-1; i < j; i, j = i+1, j-1 {
                    if runes[i] != runes[j] {
                        return false
                    }
                }
                return true
            }
          difficulty: 2
        - id: v10
          title: Bytes vs Runes
          description: >-
            Write <code>func bytesAndRunes(s string) (int, int)</code> that returns both the byte count and the rune
            count of the string as a pair.
          functionSignature: func bytesAndRunes(s string) (int, int)
          testCases:
            - input: "\"caf\\u00e9\""
              output: "5, 4"
              note: "5 bytes (e-acute is 2 bytes), 4 runes"
            - input: "\"hello\""
              output: "5, 5"
              note: all ASCII, so bytes == runes
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                You already know how to count bytes and runes separately. This function combines both. What two built-in
                operations give you each count?
            - title: "\U0001F4A1 Hint"
              content: >-
                Use <code>len(s)</code> for byte count and <code>len([]rune(s))</code> for rune count. Return both
                values using Go's multiple return syntax.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>1. bytes := len(s)
                2. runes := len([]rune(s))
                3. Return bytes, runes</pre>
          solution: |-
            func bytesAndRunes(s string) (int, int) {
                return len(s), len([]rune(s))
            }
          difficulty: 3
        - id: v11
          title: Caesar Cipher
          description: >-
            Write <code>func caesarCipher(s string, shift int) string</code> that shifts each lowercase letter by
            shift positions in the alphabet, wrapping around from z to a. Leave non-lowercase characters unchanged.
          functionSignature: func caesarCipher(s string, shift int) string
          testCases:
            - input: "\"abc\", 1"
              output: "\"bcd\""
            - input: "\"xyz\", 3"
              output: "\"abc\""
            - input: "\"hello\", 0"
              output: "\"hello\""
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                To wrap around the alphabet, you need modular arithmetic. If you shift 'z' by 1, it should become 'a'.
                How can you use the modulo operator to handle this wrapping?
            - title: "\U0001F4A1 Hint"
              content: >-
                For each lowercase rune, compute its position (r - 'a'), add the shift, take modulo 26 to wrap, then
                add 'a' back. Use <code>'a' + (r - 'a' + rune(shift)) % 26</code>.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>1. runes := []rune(s)
                2. For each rune:
                   - If 'a' <= r <= 'z':
                     - runes[i] = 'a' + (r - 'a' + shift) % 26
                3. Return string(runes)</pre>
          solution: |-
            func caesarCipher(s string, shift int) string {
                runes := []rune(s)
                for i, r := range runes {
                    if r >= 'a' && r <= 'z' {
                        runes[i] = 'a' + (r-'a'+rune(shift))%26
                    }
                }
                return string(runes)
            }
          difficulty: 3
        - id: v12
          title: Run Length Encode
          description: >-
            Write <code>func runLengthEncode(s string) string</code> that encodes consecutive repeated characters as
            the count followed by the character. For example, "aaabbc" becomes "3a2b1c".
          functionSignature: func runLengthEncode(s string) string
          testCases:
            - input: "\"aaabbc\""
              output: "\"3a2b1c\""
            - input: "\"abc\""
              output: "\"1a1b1c\""
            - input: "\"\""
              output: "\"\""
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                You need to track runs of consecutive identical characters. As you scan, keep a count of the current
                character. When the character changes, output the count and character, then reset.
            - title: "\U0001F4A1 Hint"
              content: >-
                Convert to runes. Track the current count starting at 1. Compare each rune to the previous one. When
                they differ, append the count and previous character to the result using
                <code>fmt.Sprintf("%d%c", ...)</code>, then reset the count.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>1. If empty â†’ return ""
                2. runes := []rune(s), count := 1
                3. For i from 1 to len(runes):
                   - If runes[i] == runes[i-1] â†’ count++
                   - Else â†’ append count + runes[i-1], reset count
                4. Append final count + last rune
                5. Return result</pre>
          solution: |-
            func runLengthEncode(s string) string {
                if s == "" {
                    return ""
                }
                runes := []rune(s)
                result := ""
                count := 1
                for i := 1; i < len(runes); i++ {
                    if runes[i] == runes[i-1] {
                        count++
                    } else {
                        result += fmt.Sprintf("%d%c", count, runes[i-1])
                        count = 1
                    }
                }
                result += fmt.Sprintf("%d%c", count, runes[len(runes)-1])
                return result
            }
          difficulty: 3
        - id: v13
          title: Truncate with Ellipsis
          description: >-
            Write <code>func truncate(s string, maxRunes int) string</code> that truncates the string if it has more
            than maxRunes characters. When truncating, the result (including the "..." suffix) must be at most maxRunes
            characters. If the string fits within maxRunes, return it unchanged.
          functionSignature: func truncate(s string, maxRunes int) string
          testCases:
            - input: "\"Hello World\", 8"
              output: "\"Hello...\""
              note: "5 chars + 3 dots = 8"
            - input: "\"Hi\", 8"
              output: "\"Hi\""
              note: fits within limit, no truncation
            - input: "\"abcdef\", 5"
              output: "\"ab...\""
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                When you truncate, the "..." takes up 3 characters of your budget. So you can only keep maxRunes - 3
                characters of the original string before adding the ellipsis.
            - title: "\U0001F4A1 Hint"
              content: >-
                Convert to runes for correct Unicode handling. If the rune count is within the limit, return as-is.
                Otherwise, take the first maxRunes-3 runes and append "...".
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>1. runes := []rune(s)
                2. If len(runes) <= maxRunes â†’ return s
                3. Return string(runes[:maxRunes-3]) + "..."</pre>
          solution: |-
            func truncate(s string, maxRunes int) string {
                runes := []rune(s)
                if len(runes) <= maxRunes {
                    return s
                }
                return string(runes[:maxRunes-3]) + "..."
            }
          difficulty: 3
    - id: challenge_14
      block: 1
      difficulty: 3
      concept: "Go Fundamentals Combined"
      docLinks:
        - url: https://go.dev/doc/effective_go
          title: "Effective Go"
          note: comprehensive Go guide
        - url: https://go.dev/tour/welcome/1
          title: "A Tour of Go"
          note: complete Go tutorial
      patternPrimer:
        bruteForce: Solve each sub-problem independently without leveraging Go idioms.
        bestApproach: Combine slices, maps, loops, functions, and error handling into cohesive solutions using idiomatic Go.
        typical: Multi-step problems test your ability to choose the right tool from your Go toolkit.
      quickRef: |
        <code>:=</code> short declare &nbsp; <code>for range</code> iterate &nbsp; <code>v, ok := m[k]</code><br>
                <code>append(s, v)</code> &nbsp; <code>if err != nil { }</code>
      variants:
        - id: v1
          title: Word Frequency
          description: >-
            Write <code>func wordFrequency(words []string) map[string]int</code> that counts how many times each word
            appears in the slice and returns a map of word to count.
          functionSignature: func wordFrequency(words []string) map[string]int
          testCases:
            - input: "[]string{\"the\", \"cat\", \"the\", \"hat\"}"
              output: "map[string]int{\"the\": 2, \"cat\": 1, \"hat\": 1}"
            - input: "[]string{\"go\", \"go\", \"go\"}"
              output: "map[string]int{\"go\": 3}"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                You need to count occurrences. What data structure lets you associate each word with a count that you
                can easily increment?
            - title: "\U0001F4A1 Hint"
              content: >-
                Create a map with <code>make(map[string]int)</code>. Loop through the words and increment each word's
                count with <code>freq[w]++</code>. The zero value for int is 0, so missing keys start at 0.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>1. freq := make(map[string]int)
                2. For each word:
                   - freq[word]++
                3. Return freq</pre>
          solution: |-
            func wordFrequency(words []string) map[string]int {
                freq := make(map[string]int)
                for _, w := range words {
                    freq[w]++
                }
                return freq
            }
          difficulty: 1
        - id: v2
          title: Grade Calculator
          description: >-
            Write <code>func letterGrade(score int) string</code> that returns "A" for scores >= 90, "B" for >= 80,
            "C" for >= 70, "D" for >= 60, and "F" for anything below 60.
          functionSignature: func letterGrade(score int) string
          testCases:
            - input: "85"
              output: "\"B\""
            - input: "55"
              output: "\"F\""
            - input: "92"
              output: "\"A\""
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                You have multiple thresholds to check. What Go construct lets you check conditions in order and take
                different actions?
            - title: "\U0001F4A1 Hint"
              content: >-
                Use if/else if chains, checking from highest threshold to lowest. Once a condition matches, return the
                corresponding grade letter.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>1. If score >= 90 â†’ return "A"
                2. Else if score >= 80 â†’ return "B"
                3. Else if score >= 70 â†’ return "C"
                4. Else if score >= 60 â†’ return "D"
                5. Else â†’ return "F"</pre>
          solution: |-
            func letterGrade(score int) string {
                if score >= 90 {
                    return "A"
                } else if score >= 80 {
                    return "B"
                } else if score >= 70 {
                    return "C"
                } else if score >= 60 {
                    return "D"
                }
                return "F"
            }
          difficulty: 1
        - id: v3
          title: Filter and Format
          description: >-
            Write <code>func filterAndFormat(names []string, prefix string) []string</code> that filters names
            starting with prefix and returns them formatted as "- Name". For example, with names ["Alice", "Bob",
            "Anna"] and prefix "A", return ["- Alice", "- Anna"].
          functionSignature: func filterAndFormat(names []string, prefix string) []string
          testCases:
            - input: "[]string{\"Alice\", \"Bob\", \"Anna\"}, \"A\""
              output: "[]string{\"- Alice\", \"- Anna\"}"
            - input: "[]string{\"cat\", \"car\", \"dog\"}, \"ca\""
              output: "[]string{\"- cat\", \"- car\"}"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                You need to combine filtering (checking if a string starts with prefix) with transformation (adding
                "- " to the front). How do you check if a string starts with another?
            - title: "\U0001F4A1 Hint"
              content: >-
                Use len(name) >= len(prefix) && name[:len(prefix)] == prefix to check the prefix. If it matches,
                append "- " + name to the result.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>1. result := []string{}
                2. For each name:
                   - If starts with prefix â†’ append "- " + name
                3. Return result</pre>
          solution: |-
            func filterAndFormat(names []string, prefix string) []string {
                result := []string{}
                for _, name := range names {
                    if len(name) >= len(prefix) && name[:len(prefix)] == prefix {
                        result = append(result, "- "+name)
                    }
                }
                return result
            }
          difficulty: 1
        - id: v4
          title: Count Words in Sentence
          description: >-
            Write <code>func countWords(sentence string) int</code> that counts the number of words in a sentence.
            Use <code>strings.Fields()</code> which splits on any whitespace and handles multiple spaces correctly.
          functionSignature: func countWords(sentence string) int
          testCases:
            - input: "\"hello world\""
              output: "2"
            - input: "\"  go  is  fun  \""
              output: "3"
              note: strings.Fields handles extra whitespace
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                Splitting by a single space won't handle multiple spaces or leading/trailing whitespace correctly. What
                standard library function handles this for you?
            - title: "\U0001F4A1 Hint"
              content: >-
                Use <code>strings.Fields(sentence)</code> which splits on any whitespace and ignores leading, trailing,
                and consecutive spaces. Then just return the length of the resulting slice.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>1. words := strings.Fields(sentence)
                2. Return len(words)</pre>
          solution: |-
            func countWords(sentence string) int {
                return len(strings.Fields(sentence))
            }
          difficulty: 1
        - id: v5
          title: Unique Words
          description: >-
            Write <code>func uniqueWords(words []string) []string</code> that returns the unique words from the slice,
            preserving the order of their first occurrence.
          functionSignature: func uniqueWords(words []string) []string
          testCases:
            - input: "[]string{\"go\", \"rust\", \"go\", \"python\"}"
              output: "[]string{\"go\", \"rust\", \"python\"}"
            - input: "[]string{\"a\", \"a\", \"a\"}"
              output: "[]string{\"a\"}"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                You need to track which words you've already seen while also preserving order. A map alone won't
                preserve order. What combination of data structures works here?
            - title: "\U0001F4A1 Hint"
              content: >-
                Use a map as a "seen" set and a slice for the result. For each word, check the map. If the word hasn't
                been seen, add it to both the map and the result slice.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>1. seen := make(map[string]bool)
                2. result := []string{}
                3. For each word:
                   - If !seen[word]:
                     - seen[word] = true
                     - Append word to result
                4. Return result</pre>
          solution: |-
            func uniqueWords(words []string) []string {
                seen := make(map[string]bool)
                result := []string{}
                for _, w := range words {
                    if !seen[w] {
                        seen[w] = true
                        result = append(result, w)
                    }
                }
                return result
            }
          difficulty: 2
        - id: v6
          title: Leaderboard
          description: >-
            Write <code>func leaderboard(scores map[string]int) []string</code> that takes a map of names to
            scores and returns a sorted slice of names from highest to lowest score. Use a simple selection
            approach: find the max, add it, remove it, repeat.
          functionSignature: func leaderboard(scores map[string]int) []string
          testCases:
            - input: "map[string]int{\"Alice\": 90, \"Bob\": 75, \"Charlie\": 85}"
              output: "[]string{\"Alice\", \"Charlie\", \"Bob\"}"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                You need to sort names by their score. One approach: repeatedly find the name with the highest score,
                add it to the result, and mark it as used. How do you track which names are already placed?
            - title: "\U0001F4A1 Hint"
              content: >-
                Use a used map to track placed names. Loop len(scores) times: each iteration, find the unused name with
                the highest score and append it to the result.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>1. result := []string{}; used := map[string]bool{}
                2. Repeat len(scores) times:
                   - Find unused name with highest score
                   - Append to result, mark as used
                3. Return result</pre>
          solution: |-
            func leaderboard(scores map[string]int) []string {
                result := []string{}
                used := map[string]bool{}
                for i := 0; i < len(scores); i++ {
                    bestName := ""
                    bestScore := -1
                    for name, score := range scores {
                        if !used[name] && score > bestScore {
                            bestName = name
                            bestScore = score
                        }
                    }
                    result = append(result, bestName)
                    used[bestName] = true
                }
                return result
            }
          difficulty: 2
        - id: v7
          title: Inventory Check
          description: >-
            Write <code>func inStock(inventory map[string]int, items []string) []string</code> that returns the items
            from the list that are present in the inventory map with a count greater than 0.
          functionSignature: func inStock(inventory map[string]int, items []string) []string
          testCases:
            - input: "map[string]int{\"pen\": 5, \"paper\": 0, \"ink\": 3}, []string{\"pen\", \"paper\", \"stapler\"}"
              output: "[]string{\"pen\"}"
              note: "paper has count 0, stapler is missing"
            - input: "map[string]int{\"a\": 1, \"b\": 2}, []string{\"a\", \"b\"}"
              output: "[]string{\"a\", \"b\"}"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                You need two checks for each item: does the key exist in the inventory map, and is the quantity greater
                than zero? How can you combine comma-ok with a value check?
            - title: "\U0001F4A1 Hint"
              content: >-
                Loop through the items slice. For each item, use comma-ok to look it up in the inventory. If ok is true
                AND the quantity is greater than 0, add it to the result.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>1. result := []string{}
                2. For each item in items:
                   - qty, ok := inventory[item]
                   - If ok && qty > 0 â†’ append item
                3. Return result</pre>
          solution: |-
            func inStock(inventory map[string]int, items []string) []string {
                result := []string{}
                for _, item := range items {
                    if qty, ok := inventory[item]; ok && qty > 0 {
                        result = append(result, item)
                    }
                }
                return result
            }
          difficulty: 2
        - id: v8
          title: Unique Words
          description: >-
            Write <code>func uniqueWords(sentence string) []string</code> that splits a sentence into words and
            returns the unique words preserving their first-appearance order. For example,
            "the cat and the dog" returns ["the", "cat", "and", "dog"].
          functionSignature: func uniqueWords(sentence string) []string
          testCases:
            - input: "\"the cat and the dog\""
              output: "[]string{\"the\", \"cat\", \"and\", \"dog\"}"
            - input: "\"go go go\""
              output: "[]string{\"go\"}"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                You need to split the string into words and track which ones you've already seen. What data structure
                helps you quickly check if a word has appeared before?
            - title: "\U0001F4A1 Hint"
              content: >-
                Use strings.Fields to split, then iterate with a map[string]bool to track seen words. Only append
                a word if it hasn't been seen yet.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>1. words := strings.Fields(sentence)
                2. seen := map[string]bool{}; result := []string{}
                3. For each word:
                   - If !seen[word] â†’ append, mark seen
                4. Return result</pre>
          solution: |-
            func uniqueWords(sentence string) []string {
                words := strings.Fields(sentence)
                seen := map[string]bool{}
                result := []string{}
                for _, word := range words {
                    if !seen[word] {
                        seen[word] = true
                        result = append(result, word)
                    }
                }
                return result
            }
          difficulty: 2
        - id: v9
          title: Title Case
          description: >-
            Write <code>func titleCase(s string) string</code> that capitalizes the first letter of each word in the
            string. Use <code>strings.Fields</code> to split and <code>strings.Join</code> to reassemble.
          functionSignature: func titleCase(s string) string
          testCases:
            - input: "\"hello world\""
              output: "\"Hello World\""
            - input: "\"go is fun\""
              output: "\"Go Is Fun\""
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                You need to split the string into words, capitalize the first character of each word, and join them back
                together. This combines string splitting, rune manipulation, and string building.
            - title: "\U0001F4A1 Hint"
              content: >-
                Use <code>strings.Fields(s)</code> to split into words. For each word, convert to runes, uppercase the
                first rune, convert back. Use <code>strings.Join</code> to combine with spaces.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>1. words := strings.Fields(s)
                2. For each word:
                   - Convert to []rune
                   - Uppercase first rune
                   - Convert back to string
                3. Return strings.Join(words, " ")</pre>
          solution: |-
            func titleCase(s string) string {
                words := strings.Fields(s)
                for i, w := range words {
                    runes := []rune(w)
                    if len(runes) > 0 && runes[0] >= 'a' && runes[0] <= 'z' {
                        runes[0] -= 32
                    }
                    words[i] = string(runes)
                }
                return strings.Join(words, " ")
            }
          difficulty: 2
        - id: v10
          title: Validate Password
          description: >-
            Write <code>func validatePassword(password string) (bool, []string)</code> that validates a password
            against these rules: length >= 8, contains at least one uppercase letter, one lowercase letter, and one
            digit. Return true with an empty slice if valid, or false with a slice of failure messages.
          functionSignature: func validatePassword(password string) (bool, []string)
          testCases:
            - input: "\"Abc12345\""
              output: "true, []string{}"
            - input: "\"abc\""
              output: "false, []string{\"too short\", \"no uppercase\", \"no digit\"}"
            - input: "\"ABCDEFGH\""
              output: "false, []string{\"no lowercase\", \"no digit\"}"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                You need to check multiple independent conditions and collect all failure messages. How do you track
                which conditions have been met as you scan the string?
            - title: "\U0001F4A1 Hint"
              content: >-
                Use boolean flags for hasUpper, hasLower, hasDigit. Loop through the string's runes to set the flags.
                After the loop, check each condition and build a list of failure messages.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>1. Check length, set flags to false
                2. For each rune in password:
                   - Set hasUpper/hasLower/hasDigit flags
                3. Collect failure messages
                4. Return len(failures) == 0, failures</pre>
          solution: |-
            func validatePassword(password string) (bool, []string) {
                failures := []string{}
                if len([]rune(password)) < 8 {
                    failures = append(failures, "too short")
                }
                hasUpper, hasLower, hasDigit := false, false, false
                for _, r := range password {
                    if r >= 'A' && r <= 'Z' {
                        hasUpper = true
                    }
                    if r >= 'a' && r <= 'z' {
                        hasLower = true
                    }
                    if r >= '0' && r <= '9' {
                        hasDigit = true
                    }
                }
                if !hasUpper {
                    failures = append(failures, "no uppercase")
                }
                if !hasLower {
                    failures = append(failures, "no lowercase")
                }
                if !hasDigit {
                    failures = append(failures, "no digit")
                }
                return len(failures) == 0, failures
            }
          difficulty: 3
        - id: v11
          title: Missing Keys
          description: >-
            Write <code>func missingKeys(data map[string]string, required []string) []string</code> that checks
            which required keys are missing from the map and returns them. For example, if data has "name" and
            "email" but required is ["name", "email", "phone"], return ["phone"].
          functionSignature: func missingKeys(data map[string]string, required []string) []string
          testCases:
            - input: "map[string]string{\"name\": \"Alice\", \"email\": \"a@b.c\"}, []string{\"name\", \"email\", \"phone\"}"
              output: "[]string{\"phone\"}"
            - input: "map[string]string{\"a\": \"1\"}, []string{\"a\", \"b\", \"c\"}"
              output: "[]string{\"b\", \"c\"}"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                For each required key, you need to check if it exists in the map. What Go idiom checks if a key
                is present in a map?
            - title: "\U0001F4A1 Hint"
              content: >-
                Use the comma-ok pattern: _, ok := data[key]. If !ok, the key is missing. Collect all missing keys
                into a result slice.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>1. missing := []string{}
                2. For each key in required:
                   - If _, ok := data[key]; !ok â†’ append key
                3. Return missing</pre>
          solution: |-
            func missingKeys(data map[string]string, required []string) []string {
                missing := []string{}
                for _, key := range required {
                    if _, ok := data[key]; !ok {
                        missing = append(missing, key)
                    }
                }
                return missing
            }
          difficulty: 3
        - id: v12
          title: Matrix Sum
          description: >-
            Write <code>func matrixSum(matrix [][]int) int</code> that returns the sum of all elements in a 2D slice
            (matrix).
          functionSignature: func matrixSum(matrix [][]int) int
          testCases:
            - input: "[][]int{{1, 2}, {3, 4}, {5, 6}}"
              output: "21"
            - input: "[][]int{{10}, {20}, {30}}"
              output: "60"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                A 2D slice is a slice of slices. You need to iterate through two levels: the outer slice (rows) and
                each inner slice (columns). How do you nest range loops?
            - title: "\U0001F4A1 Hint"
              content: >-
                Use nested range loops. The outer loop iterates over rows, the inner loop iterates over elements in
                each row. Add each element to a running sum.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>1. sum := 0
                2. For each row in matrix:
                   - For each element in row:
                     - sum += element
                3. Return sum</pre>
          solution: |-
            func matrixSum(matrix [][]int) int {
                sum := 0
                for _, row := range matrix {
                    for _, n := range row {
                        sum += n
                    }
                }
                return sum
            }
          difficulty: 3
        - id: v13
          title: Group and Count
          description: >-
            Write <code>func groupAndCount(items []string) []string</code> that counts the frequency of each item and
            returns formatted strings "item: N" sorted by count descending, then alphabetically for ties.
          functionSignature: func groupAndCount(items []string) []string
          testCases:
            - input: "[]string{\"b\", \"a\", \"b\", \"a\", \"a\"}"
              output: "[]string{\"a: 3\", \"b: 2\"}"
            - input: "[]string{\"x\", \"y\", \"x\", \"y\"}"
              output: "[]string{\"x: 2\", \"y: 2\"}"
              note: same count, sorted alphabetically
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                This problem has multiple steps: count frequencies, sort by count then alphabetically, and format the
                output. Break it into sub-problems.
            - title: "\U0001F4A1 Hint"
              content: >-
                First count frequencies with a map. Collect the unique keys into a slice. Sort the slice using
                <code>sort.Slice</code> with a custom less function that compares counts first, then names. Finally,
                format each entry with <code>fmt.Sprintf</code>.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>1. Count frequencies into a map
                2. Collect unique keys into a slice
                3. Sort: by count descending, then alphabetically
                4. Format each as "item: N"
                5. Return formatted slice</pre>
          solution: |-
            func groupAndCount(items []string) []string {
                freq := make(map[string]int)
                for _, item := range items {
                    freq[item]++
                }
                keys := []string{}
                for k := range freq {
                    keys = append(keys, k)
                }
                sort.Slice(keys, func(i, j int) bool {
                    if freq[keys[i]] != freq[keys[j]] {
                        return freq[keys[i]] > freq[keys[j]]
                    }
                    return keys[i] < keys[j]
                })
                result := []string{}
                for _, k := range keys {
                    result = append(result, fmt.Sprintf("%s: %d", k, freq[k]))
                }
                return result
            }
          difficulty: 3
