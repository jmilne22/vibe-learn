conceptLinks:
  Pointer Basics: "#lesson-pointers"
  Dereferencing: "#lesson-dereferencing"
  Pointer Parameters: "#lesson-pointer-params"
  Nil Pointers: "#lesson-nil"
  Pointer Receivers: "#lesson-pointer-receivers"
  Structs & Pointers: "#lesson-structs-pointers"
  Linked Structures: "#lesson-linked-structures"
  Struct Basics: "#lesson-struct-basics"
  Methods: "#lesson-methods"
  Value vs Pointer Receivers: "#lesson-receivers"
  Encapsulation: "#lesson-encapsulation"
  Struct Embedding: "#lesson-embedding"
  JSON Tags: "#lesson-json"
  Nested Structs: "#lesson-nested-structs"
sharedContent: {}
variants:
  warmups:
    - id: warmup_1
      concept: Pointer Basics
      variants:
        - id: v1
          title: Get an Address
          description: >-
            Create an integer variable, get its address using <code>&amp;</code>, and print both the value and the
            address.
          hints:
            - Use <code>&amp;x</code> to get the address of variable <code>x</code>
            - The pointer will print as a hex memory address like <code>0xc0000b6010</code>
          solution: |-
            x := 42
            ptr := &x
            fmt.Println("Value:", x)
            fmt.Println("Address:", ptr)
          annotations:
            - type: idiom
              label: Address-of Operator
              text: >-
                The <code>&</code> operator returns a pointer to the variable's memory location. In Go, you cannot take
                the address of a constant or literal.
            - type: gotcha
              label: Pointer Formatting
              text: >-
                Printing a pointer with <code>fmt.Println</code> displays the hex address. Use <code>%p</code> with
                <code>fmt.Printf</code> for explicit formatting.
        - id: v2
          title: Address of a String
          description: >-
            Create a string variable holding your name. Get a pointer to it and print the pointer's type using
            <code>fmt.Sprintf("%T", ptr)</code>.
          hints:
            - Use <code>&amp;name</code> to get the pointer
            - <code>%T</code> prints the type, which should be <code>*string</code>
          solution: |-
            name := "Gopher"
            ptr := &name
            fmt.Printf("Type: %T\n", ptr)   // *string
            fmt.Printf("Value: %s\n", name) // Gopher
          annotations:
            - type: idiom
              label: Pointer Types
              text: >-
                A pointer to a <code>string</code> has type <code>*string</code>. The asterisk prefix denotes a pointer
                type in Go's type system.
        - id: v3
          title: Two Pointers, One Variable
          description: >-
            Create an integer variable and two pointers that both point to it. Print the value through both pointers to
            show they reference the same data.
          hints:
            - Both <code>p1 := &amp;x</code> and <code>p2 := &amp;x</code> will point to the same memory
            - Dereference with <code>*p1</code> and <code>*p2</code>
          solution: |-
            x := 100
            p1 := &x
            p2 := &x
            fmt.Println(*p1, *p2) // 100 100
            fmt.Println(p1 == p2) // true
          annotations:
            - type: idiom
              label: Pointer Equality
              text: >-
                Two pointers are equal (<code>==</code>) when they point to the same memory address. This is identity
                comparison, not value comparison.
        - id: v4
          title: Pointer to a Boolean
          description: >-
            Create a <code>bool</code> variable set to <code>false</code>. Get a pointer to it, print the dereferenced
            value, then explain what <code>*ptr</code> gives you.
          hints:
            - "Declare: <code>flag := false</code>"
            - Use <code>*ptr</code> to read the value through the pointer
          solution: |-
            flag := false
            ptr := &flag
            fmt.Println(*ptr) // false
            *ptr = true
            fmt.Println(flag) // true
          annotations:
            - type: gotcha
              label: Zero Values
              text: >-
                In Go, <code>bool</code> defaults to <code>false</code>, <code>int</code> defaults to <code>0</code>,
                and <code>string</code> defaults to <code>""</code>. A pointer itself defaults to <code>nil</code>.
    - id: warmup_2
      concept: Dereferencing
      variants:
        - id: v1
          title: Modify Through Pointer
          description: >-
            Create a variable, get a pointer to it, then change the value using <code>*ptr = newValue</code>. Print
            before and after.
          hints:
            - Use <code>*ptr = 50</code> to write through the pointer
            - The original variable changes because the pointer references its memory
          solution: |-
            x := 10
            fmt.Println("Before:", x)
            ptr := &x
            *ptr = 50
            fmt.Println("After:", x) // 50
          annotations:
            - type: idiom
              label: Dereference Assignment
              text: >-
                Writing <code>*ptr = value</code> modifies the variable the pointer points to. This is how Go achieves
                pass-by-reference semantics.
        - id: v2
          title: Increment Via Pointer
          description: >-
            Create an integer set to <code>0</code>. Get a pointer and use it to increment the value 3 times. Print the
            final result.
          hints:
            - Use <code>*ptr++</code> or <code>*ptr = *ptr + 1</code> to increment
            - After 3 increments, the value should be 3
          solution: |-
            count := 0
            ptr := &count
            *ptr++
            *ptr++
            *ptr++
            fmt.Println(count) // 3
          annotations:
            - type: gotcha
              label: Operator Precedence
              text: >-
                In Go, <code>*ptr++</code> works as <code>(*ptr)++</code> because the dereference binds tighter. This
                differs from C where you might need explicit parentheses.
        - id: v3
          title: Swap Two Variables
          description: >-
            Create two variables <code>a</code> and <code>b</code>. Using only pointers, swap their values. Print to
            verify.
          hints:
            - "Get pointers to both: <code>pa, pb := &amp;a, &amp;b</code>"
            - "Swap with: <code>*pa, *pb = *pb, *pa</code>"
          solution: |-
            a, b := 10, 20
            pa, pb := &a, &b
            *pa, *pb = *pb, *pa
            fmt.Println(a, b) // 20 10
          annotations:
            - type: idiom
              label: Parallel Assignment
              text: >-
                Go supports parallel assignment: <code>*a, *b = *b, *a</code>. No temporary variable needed because Go
                evaluates the right side fully before assigning.
        - id: v4
          title: Double a Float
          description: >-
            Create a <code>float64</code> variable set to <code>3.14</code>. Get a pointer and use it to double the
            value. Print the result.
          hints:
            - "Dereference to read and write: <code>*ptr = *ptr * 2</code>"
            - Or use <code>*ptr *= 2</code>
          solution: |-
            pi := 3.14
            ptr := &pi
            *ptr *= 2
            fmt.Println(pi) // 6.28
          annotations:
            - type: idiom
              label: Compound Assignment
              text: >-
                Go supports compound assignment through pointers: <code>*ptr *= 2</code> is shorthand for <code>*ptr =
                *ptr * 2</code>.
    - id: warmup_3
      concept: Pointer Parameters
      variants:
        - id: v1
          title: Double Function
          description: Write <code>func double(n *int)</code> that doubles the value at the pointer.
          hints:
            - "Dereference the pointer to get and set the value: <code>*n = *n * 2</code>"
            - Call it with <code>double(&amp;x)</code>
          solution: |-
            func double(n *int) {
                *n = *n * 2
            }

            // Test:
            x := 5
            double(&x)
            fmt.Println(x) // 10
          annotations:
            - type: idiom
              label: Pointer Parameters
              text: >-
                Passing a pointer parameter lets functions modify the caller's variable. This is Go's way of simulating
                pass-by-reference.
            - type: gotcha
              label: Don't Forget &
              text: >-
                When calling a function that takes <code>*int</code>, you must pass <code>&x</code> (the address), not
                <code>x</code> itself.
        - id: v2
          title: Negate In Place
          description: Write <code>func negate(n *int)</code> that negates the integer (positive becomes negative, and vice versa).
          hints:
            - Use <code>*n = -*n</code> to flip the sign
            - Call with <code>negate(&amp;x)</code>
          solution: |-
            func negate(n *int) {
                *n = -*n
            }

            // Test:
            x := 7
            negate(&x)
            fmt.Println(x) // -7
            negate(&x)
            fmt.Println(x) // 7
          annotations:
            - type: idiom
              label: In-Place Mutation
              text: >-
                Functions that modify values in place via pointers typically return nothing. The side effect IS the
                result.
        - id: v3
          title: Set to Zero
          description: Write <code>func reset(n *int)</code> that sets the pointed-to value to zero.
          hints:
            - "Simply assign: <code>*n = 0</code>"
          solution: |-
            func reset(n *int) {
                *n = 0
            }

            // Test:
            x := 999
            reset(&x)
            fmt.Println(x) // 0
          annotations:
            - type: alternative
              label: Value vs Pointer
              text: >-
                Without pointers, <code>func reset(n int)</code> would only modify a local copy. The pointer version
                modifies the original.
        - id: v4
          title: Add To Variable
          description: >-
            Write <code>func addTo(n *int, amount int)</code> that adds <code>amount</code> to the value pointed to by
            <code>n</code>.
          hints:
            - Use <code>*n += amount</code> to add in place
            - The second parameter is a plain int, not a pointer
          solution: |-
            func addTo(n *int, amount int) {
                *n += amount
            }

            // Test:
            balance := 100
            addTo(&balance, 50)
            fmt.Println(balance) // 150
            addTo(&balance, -30)
            fmt.Println(balance) // 120
          annotations:
            - type: idiom
              label: Mixed Parameters
              text: It is common to mix pointer and value parameters. Only use pointers for values you intend to modify.
    - id: warmup_4
      concept: Nil Pointers
      variants:
        - id: v1
          title: Check for Nil
          description: >-
            Write a function <code>func printValue(p *int)</code> that prints the value if p is not nil, or prints
            "pointer is nil" if it is.
          hints:
            - Check <code>if p != nil</code> before dereferencing
            - Dereferencing a nil pointer causes a runtime panic
          solution: |-
            func printValue(p *int) {
                if p != nil {
                    fmt.Println("Value:", *p)
                } else {
                    fmt.Println("pointer is nil")
                }
            }
          annotations:
            - type: gotcha
              label: Nil Panic
              text: >-
                Dereferencing a nil pointer (<code>*p</code> when <code>p == nil</code>) causes a runtime panic. Always
                check for nil before dereferencing.
            - type: idiom
              label: Guard Clause
              text: Checking for nil at the top of a function is a common Go pattern called a guard clause.
        - id: v2
          title: Safe String Length
          description: >-
            Write <code>func safeLen(s *string) int</code> that returns the length of the string if s is not nil, or
            <code>-1</code> if it is nil.
          hints:
            - Check <code>if s == nil</code> and return <code>-1</code>
            - Otherwise return <code>len(*s)</code>
          solution: |-
            func safeLen(s *string) int {
                if s == nil {
                    return -1
                }
                return len(*s)
            }
          annotations:
            - type: idiom
              label: Sentinel Values
              text: >-
                Returning <code>-1</code> as a sentinel for 'no value' is common in Go. Alternatively, return
                <code>(int, bool)</code> or <code>(int, error)</code>.
        - id: v3
          title: Default Value on Nil
          description: >-
            Write <code>func valueOrDefault(p *int, fallback int) int</code> that returns <code>*p</code> if p is not
            nil, or <code>fallback</code> otherwise.
          hints:
            - This is a simple nil check with a fallback
            - Return <code>*p</code> only when <code>p != nil</code>
          solution: |-
            func valueOrDefault(p *int, fallback int) int {
                if p != nil {
                    return *p
                }
                return fallback
            }
          annotations:
            - type: pattern
              label: Default Pattern
              text: >-
                The 'value-or-default' pattern is used throughout the Go standard library, especially in configuration
                structs where nil means 'use default'.
        - id: v4
          title: Compare Optional Values
          description: >-
            Write <code>func bothEqual(a, b *int) bool</code> that returns true if both pointers are non-nil and point
            to equal values, or both are nil.
          hints:
            - Handle the case where both are nil first
            - Then check if exactly one is nil
            - Finally compare <code>*a == *b</code>
          solution: |-
            func bothEqual(a, b *int) bool {
                if a == nil && b == nil {
                    return true
                }
                if a == nil || b == nil {
                    return false
                }
                return *a == *b
            }
          annotations:
            - type: gotcha
              label: Pointer vs Value Equality
              text: >-
                Comparing pointers with <code>==</code> checks if they point to the same address. To compare the values
                they point to, you must dereference: <code>*a == *b</code>.
            - type: pattern
              label: Nil-safe Comparison
              text: >-
                This three-step pattern (both nil, one nil, compare values) is the standard way to safely compare
                optional/nullable values.
    - id: warmup_5
      concept: Struct Basics
      variants:
        - id: v1
          title: Rectangle Area and Perimeter
          description: >-
            Create a <code>Rectangle</code> struct with <code>Width</code> and <code>Height float64</code>. Add methods
            <code>Area() float64</code> and <code>Perimeter() float64</code>.
          hints:
            - Area = width * height
            - Perimeter = 2 * (width + height)
            - Value receivers are fine since these methods don't modify the struct
          solution: |-
            type Rectangle struct {
                Width  float64
                Height float64
            }

            func (r Rectangle) Area() float64 {
                return r.Width * r.Height
            }

            func (r Rectangle) Perimeter() float64 {
                return 2 * (r.Width + r.Height)
            }
          annotations:
            - type: idiom
              label: Value Receivers
              text: >-
                Methods that only read struct fields should use value receivers. This makes the intent clear: the method
                does not modify the struct.
            - type: gotcha
              label: Exported Fields
              text: >-
                Uppercase field names (<code>Width</code>, <code>Height</code>) are exported and accessible from other
                packages. Use lowercase for encapsulation.
        - id: v2
          title: Circle Area and Circumference
          description: >-
            Create a <code>Circle</code> struct with <code>Radius float64</code>. Add methods <code>Area()
            float64</code> and <code>Circumference() float64</code>. Use <code>math.Pi</code>.
          hints:
            - Area = math.Pi * r * r
            - Circumference = 2 * math.Pi * r
            - Import <code>math</code> for <code>math.Pi</code>
          solution: |-
            type Circle struct {
                Radius float64
            }

            func (c Circle) Area() float64 {
                return math.Pi * c.Radius * c.Radius
            }

            func (c Circle) Circumference() float64 {
                return 2 * math.Pi * c.Radius
            }
          annotations:
            - type: stdlib
              label: math.Pi
              text: >-
                Go provides <code>math.Pi</code> as a high-precision constant. Never hard-code 3.14 -- use the standard
                library.
            - type: idiom
              label: Method Naming
              text: >-
                Go convention is short, descriptive method names. <code>Area()</code> not <code>GetArea()</code> or
                <code>CalculateArea()</code>.
        - id: v3
          title: Triangle Calculations
          description: >-
            Create a <code>Triangle</code> struct with <code>Base</code> and <code>Height float64</code>. Add an
            <code>Area() float64</code> method.
          hints:
            - Triangle area = 0.5 * base * height
            - Use a value receiver
          solution: |-
            type Triangle struct {
                Base   float64
                Height float64
            }

            func (t Triangle) Area() float64 {
                return 0.5 * t.Base * t.Height
            }
          annotations:
            - type: idiom
              label: Consistent API
              text: >-
                Giving different shapes the same <code>Area()</code> method signature prepares them for satisfying a
                common interface later.
        - id: v4
          title: 2D Point with Distance
          description: >-
            Create a <code>Point</code> struct with <code>X, Y float64</code>. Add a method <code>DistanceTo(other
            Point) float64</code> using the distance formula.
          hints:
            - Distance = sqrt((x2-x1)^2 + (y2-y1)^2)
            - Use <code>math.Sqrt</code> and <code>math.Pow</code> (or just multiply)
          solution: |-
            type Point struct {
                X, Y float64
            }

            func (p Point) DistanceTo(other Point) float64 {
                dx := p.X - other.X
                dy := p.Y - other.Y
                return math.Sqrt(dx*dx + dy*dy)
            }
          annotations:
            - type: alternative
              label: math.Hypot
              text: >-
                The standard library provides <code>math.Hypot(dx, dy)</code> which computes the hypotenuse with better
                numerical stability than manual sqrt.
            - type: idiom
              label: Struct as Parameter
              text: >-
                Passing a <code>Point</code> as a parameter (not a pointer) is fine for small structs. Go copies them
                efficiently.
    - id: warmup_6
      concept: Encapsulation
      variants:
        - id: v1
          title: Bank Account
          description: >-
            Create a <code>BankAccount</code> with an unexported <code>balance float64</code> field. Add methods
            <code>Deposit(amount float64)</code>, <code>Withdraw(amount float64) error</code>, and <code>Balance()
            float64</code>.
          hints:
            - Lowercase <code>balance</code> makes it unexported (private)
            - Use pointer receivers for Deposit and Withdraw since they modify state
            - Return <code>fmt.Errorf(...)</code> for insufficient funds
          solution: |-
            type BankAccount struct {
                balance float64
            }

            func (a *BankAccount) Deposit(amount float64) {
                a.balance += amount
            }

            func (a *BankAccount) Withdraw(amount float64) error {
                if amount > a.balance {
                    return fmt.Errorf("insufficient funds: have %.2f, want %.2f", a.balance, amount)
                }
                a.balance -= amount
                return nil
            }

            func (a *BankAccount) Balance() float64 {
                return a.balance
            }
          annotations:
            - type: idiom
              label: Unexported Fields
              text: >-
                Lowercase field names in Go are unexported (package-private). This enforces encapsulation -- external
                code must use methods to interact with the data.
            - type: gotcha
              label: Error on Insufficient Funds
              text: >-
                Always validate inputs that could leave the struct in an invalid state. Negative balances should be
                prevented, not fixed later.
        - id: v2
          title: Temperature Tracker
          description: >-
            Create a <code>TempTracker</code> with unexported fields for tracking min, max, sum, and count. Add
            <code>Record(temp float64)</code>, <code>Min() float64</code>, <code>Max() float64</code>, and
            <code>Average() float64</code>.
          hints:
            - On first record, initialize min and max to that value
            - Use a <code>count</code> field to know if any temperatures were recorded
            - Average = sum / count
          solution: |-
            type TempTracker struct {
                min, max, sum float64
                count         int
            }

            func (t *TempTracker) Record(temp float64) {
                if t.count == 0 {
                    t.min = temp
                    t.max = temp
                } else {
                    if temp < t.min {
                        t.min = temp
                    }
                    if temp > t.max {
                        t.max = temp
                    }
                }
                t.sum += temp
                t.count++
            }

            func (t TempTracker) Min() float64 { return t.min }
            func (t TempTracker) Max() float64 { return t.max }
            func (t TempTracker) Average() float64 {
                if t.count == 0 {
                    return 0
                }
                return t.sum / float64(t.count)
            }
          annotations:
            - type: gotcha
              label: Division by Zero
              text: >-
                Always check <code>count == 0</code> before computing the average. Dividing by zero in Go produces
                <code>+Inf</code> for floats, which may confuse callers.
            - type: pattern
              label: Running Statistics
              text: >-
                Tracking min, max, sum, and count in a struct lets you compute statistics in a single pass without
                storing all values.
        - id: v3
          title: Score Keeper
          description: >-
            Create a <code>ScoreKeeper</code> with an unexported <code>scores []int</code>. Add <code>Add(score
            int)</code>, <code>Total() int</code>, and <code>Count() int</code>.
          hints:
            - Use <code>append</code> to add scores
            - Loop through scores to calculate total
            - Count is just <code>len(s.scores)</code>
          solution: |-
            type ScoreKeeper struct {
                scores []int
            }

            func (s *ScoreKeeper) Add(score int) {
                s.scores = append(s.scores, score)
            }

            func (s ScoreKeeper) Total() int {
                total := 0
                for _, sc := range s.scores {
                    total += sc
                }
                return total
            }

            func (s ScoreKeeper) Count() int {
                return len(s.scores)
            }
          annotations:
            - type: idiom
              label: Slice in Struct
              text: >-
                Storing a slice as a struct field is idiomatic Go. The struct methods control how the slice is accessed
                and modified.
            - type: gotcha
              label: Append Needs Pointer Receiver
              text: >-
                <code>append</code> may create a new underlying array, so <code>Add</code> must use a pointer receiver
                or the new slice header is lost.
        - id: v4
          title: Inventory Item
          description: >-
            Create an <code>Inventory</code> struct with unexported fields <code>name string</code>, <code>quantity
            int</code>, <code>price float64</code>. Add <code>NewInventory(name string, qty int, price float64)
            *Inventory</code> constructor, <code>Restock(n int)</code>, <code>Sell(n int) error</code>, and
            <code>Value() float64</code>.
          hints:
            - The constructor function returns a pointer to a new struct
            - Sell returns an error if quantity is insufficient
            - Value = quantity * price
          solution: |-
            type Inventory struct {
                name     string
                quantity int
                price    float64
            }

            func NewInventory(name string, qty int, price float64) *Inventory {
                return &Inventory{name: name, quantity: qty, price: price}
            }

            func (inv *Inventory) Restock(n int) {
                inv.quantity += n
            }

            func (inv *Inventory) Sell(n int) error {
                if n > inv.quantity {
                    return fmt.Errorf("not enough stock: have %d, want %d", inv.quantity, n)
                }
                inv.quantity -= n
                return nil
            }

            func (inv Inventory) Value() float64 {
                return float64(inv.quantity) * inv.price
            }
          annotations:
            - type: idiom
              label: Constructor Functions
              text: >-
                Go has no constructors. By convention, <code>NewTypeName</code> functions create and return initialized
                struct pointers.
            - type: pattern
              label: Returning Pointers from Constructors
              text: >-
                Returning <code>*Inventory</code> from <code>NewInventory</code> is idiomatic. Go's escape analysis
                allocates it on the heap automatically.
  challenges:
    - id: challenge_1
      block: 1
      difficulty: 2
      concept: Pointer Parameters
      docLinks:
        - url: https://go.dev/ref/spec#Pointer_types
          title: "Go Spec: Pointer types"
          note: pointer type declarations
        - url: https://go.dev/doc/effective_go#pointers_vs_values
          title: "Effective Go: Pointers vs. Values"
          note: when to use pointer parameters
      variants:
        - id: v1
          title: Swap Two Integers
          description: Write a function <code>func swap(a, b *int)</code> that swaps two integers using pointers.
          functionSignature: func swap(a, b *int)
          testCases:
            - input: x, y := 5, 10; swap(&x, &y)
              output: x == 10, y == 5
            - input: x, y := -1, 1; swap(&x, &y)
              output: x == 1, y == -1
            - input: x, y := 0, 0; swap(&x, &y)
              output: x == 0, y == 0
          hints:
            - title: ðŸ¤” Think about it
              content: >-
                How do you swap two values in any language? You usually need a temporary variable -- but Go has a
                shortcut.
            - title: ðŸ’¡ Hint
              content: >-
                Go supports parallel assignment: <code>*a, *b = *b, *a</code>. Both sides are evaluated before
                assignment.
            - title: ðŸ”§ Pattern
              content: |-
                <pre>1. Dereference both pointers
                2. Assign in parallel: *a, *b = *b, *a
                   (or use a temp variable)</pre>
          solution: |-
            func swap(a, b *int) {
                *a, *b = *b, *a
            }
          difficulty: 1
          annotations:
            - type: idiom
              label: Parallel Assignment
              text: >-
                Go evaluates the entire right-hand side before assigning, making swaps a one-liner without a temp
                variable.
            - type: complexity
              label: O(1)
              text: Constant time and space. Only pointer dereferences and assignments.
        - id: v2
          title: Swap Two Strings
          description: Write a function <code>func swapStrings(a, b *string)</code> that swaps two strings using pointers.
          functionSignature: func swapStrings(a, b *string)
          testCases:
            - input: a, b := "hello", "world"; swapStrings(&a, &b)
              output: a == "world", b == "hello"
            - input: a, b := "", "Go"; swapStrings(&a, &b)
              output: a == "Go", b == ""
          hints:
            - title: ðŸ¤” Think about it
              content: Swapping strings works exactly the same as swapping ints with pointers.
            - title: ðŸ’¡ Hint
              content: "Use parallel assignment: <code>*a, *b = *b, *a</code>"
            - title: ðŸ”§ Pattern
              content: |-
                <pre>1. Dereference both string pointers
                2. Parallel assign: *a, *b = *b, *a</pre>
          solution: |-
            func swapStrings(a, b *string) {
                *a, *b = *b, *a
            }
          difficulty: 1
          annotations:
            - type: idiom
              label: Generic Pattern
              text: >-
                The pointer swap pattern works identically for any type. Before Go generics, you needed separate
                functions per type.
        - id: v3
          title: Conditional Swap
          description: >-
            Write <code>func sortPair(a, b *int)</code> that ensures <code>*a &lt;= *b</code> after the call. Swap only
            if needed.
          functionSignature: func sortPair(a, b *int)
          testCases:
            - input: a, b := 10, 5; sortPair(&a, &b)
              output: a == 5, b == 10
            - input: a, b := 3, 7; sortPair(&a, &b)
              output: a == 3, b == 7
            - input: a, b := 4, 4; sortPair(&a, &b)
              output: a == 4, b == 4
          hints:
            - title: ðŸ¤” Think about it
              content: When should you swap? Only when the first value is greater than the second.
            - title: ðŸ’¡ Hint
              content: Check <code>if *a > *b</code> before swapping.
            - title: ðŸ”§ Pattern
              content: |-
                <pre>1. Compare *a and *b
                2. If *a > *b, swap them
                3. Otherwise do nothing</pre>
          solution: |-
            func sortPair(a, b *int) {
                if *a > *b {
                    *a, *b = *b, *a
                }
            }
          difficulty: 2
          annotations:
            - type: pattern
              label: Conditional Mutation
              text: >-
                Only mutate through pointers when a condition is met. This is the building block of in-place sorting
                algorithms.
            - type: complexity
              label: O(1)
              text: Single comparison and at most one swap.
        - id: v4
          title: Rotate Three Values
          description: >-
            Write <code>func rotateRight(a, b, c *int)</code> that rotates three values to the right: a gets c's value,
            b gets a's value, c gets b's value.
          functionSignature: func rotateRight(a, b, c *int)
          testCases:
            - input: a, b, c := 1, 2, 3; rotateRight(&a, &b, &c)
              output: a == 3, b == 1, c == 2
            - input: a, b, c := 10, 20, 30; rotateRight(&a, &b, &c)
              output: a == 30, b == 10, c == 20
          hints:
            - title: ðŸ¤” Think about it
              content: A right rotation means each element takes the value of the one before it (wrapping around).
            - title: ðŸ’¡ Hint
              content: "Use Go's parallel assignment with three variables: <code>*a, *b, *c = *c, *a, *b</code>"
            - title: ðŸ”§ Pattern
              content: |-
                <pre>Right rotate: each gets its left neighbor
                *a, *b, *c = *c, *a, *b</pre>
          solution: |-
            func rotateRight(a, b, c *int) {
                *a, *b, *c = *c, *a, *b
            }
          difficulty: 2
          annotations:
            - type: idiom
              label: Multi-way Parallel Assignment
              text: Go's parallel assignment extends to any number of variables, making rotations elegant one-liners.
            - type: gotcha
              label: Direction Matters
              text: >-
                Right rotation vs left rotation is easy to confuse. Right rotation: each position gets the value from
                its left neighbor.
    - id: challenge_2
      block: 1
      difficulty: 2
      concept: Pointer Receivers
      docLinks:
        - url: https://go.dev/doc/effective_go#pointers_vs_values
          title: "Effective Go: Pointers vs. Values"
          note: pointer receivers modify the receiver
        - url: https://go.dev/ref/spec#Method_declarations
          title: "Go Spec: Method declarations"
          note: method syntax with receivers
      variants:
        - id: v1
          title: Counter Struct
          description: >-
            Create a <code>Counter</code> struct with an <code>int</code> value. Add methods <code>Increment()</code>,
            <code>Decrement()</code>, and <code>Value() int</code>.
          functionSignature: |-
            func (c *Counter) Increment()
            func (c *Counter) Decrement()
            func (c Counter) Value() int
          testCases:
            - input: c := Counter{}; c.Increment(); c.Increment(); c.Decrement()
              output: c.Value() == 1
            - input: c := Counter{}; c.Decrement()
              output: c.Value() == -1
          hints:
            - title: ðŸ¤” Think about it
              content: Which methods need to modify the struct? Those need pointer receivers.
            - title: ðŸ’¡ Hint
              content: Increment and Decrement need <code>*Counter</code> receivers. Value can use a value receiver.
            - title: ðŸ”§ Pattern
              content: |-
                <pre>type Counter struct { value int }
                func (c *Counter) Increment() { c.value++ }
                func (c *Counter) Decrement() { c.value-- }
                func (c Counter) Value() int { return c.value }</pre>
          solution: |-
            type Counter struct {
                value int
            }

            func (c *Counter) Increment() {
                c.value++
            }

            func (c *Counter) Decrement() {
                c.value--
            }

            func (c Counter) Value() int {
                return c.value
            }
          difficulty: 2
          annotations:
            - type: idiom
              label: Pointer Receivers
              text: >-
                Methods that modify struct state must use pointer receivers (<code>*Counter</code>). Value receivers get
                a copy and cannot mutate the original.
            - type: gotcha
              label: Value Receiver Trap
              text: >-
                If <code>Increment</code> used a value receiver <code>(c Counter)</code>, it would increment a copy. The
                original counter would never change.
        - id: v2
          title: Stack Struct
          description: >-
            Create a <code>Stack</code> struct backed by a slice of <code>int</code>. Add <code>Push(val int)</code>,
            <code>Pop() (int, bool)</code>, and <code>Size() int</code>.
          functionSignature: |-
            func (s *Stack) Push(val int)
            func (s *Stack) Pop() (int, bool)
            func (s Stack) Size() int
          testCases:
            - input: s := Stack{}; s.Push(10); s.Push(20); val, ok := s.Pop()
              output: val == 20, ok == true, s.Size() == 1
            - input: s := Stack{}; val, ok := s.Pop()
              output: val == 0, ok == false
          hints:
            - title: ðŸ¤” Think about it
              content: A stack is last-in-first-out (LIFO). Which end of a slice is cheapest to add/remove from?
            - title: ðŸ’¡ Hint
              content: >-
                Use <code>append</code> for Push. For Pop, grab the last element and reslice: <code>s.items =
                s.items[:len(s.items)-1]</code>
            - title: ðŸ”§ Pattern
              content: |-
                <pre>Push: s.items = append(s.items, val)
                Pop: get last, shrink slice
                Return (0, false) if empty</pre>
          solution: |-
            type Stack struct {
                items []int
            }

            func (s *Stack) Push(val int) {
                s.items = append(s.items, val)
            }

            func (s *Stack) Pop() (int, bool) {
                if len(s.items) == 0 {
                    return 0, false
                }
                val := s.items[len(s.items)-1]
                s.items = s.items[:len(s.items)-1]
                return val, true
            }

            func (s Stack) Size() int {
                return len(s.items)
            }
          difficulty: 2
          annotations:
            - type: idiom
              label: Comma-ok Pattern
              text: >-
                Returning <code>(int, bool)</code> from Pop follows Go's comma-ok idiom: the second return signals
                whether the operation succeeded.
            - type: gotcha
              label: Slice Append Receiver
              text: >-
                Push must use a pointer receiver because <code>append</code> may allocate a new underlying array,
                changing the slice header.
        - id: v3
          title: Toggle Switch
          description: >-
            Create a <code>Toggle</code> struct with a <code>bool</code> state. Add <code>Flip()</code> to toggle the
            state and <code>IsOn() bool</code> to read it.
          functionSignature: |-
            func (t *Toggle) Flip()
            func (t Toggle) IsOn() bool
          testCases:
            - input: t := Toggle{}; t.Flip()
              output: t.IsOn() == true
            - input: t := Toggle{}; t.Flip(); t.Flip()
              output: t.IsOn() == false
          hints:
            - title: ðŸ¤” Think about it
              content: How do you toggle a boolean? Think about the NOT operator.
            - title: ðŸ’¡ Hint
              content: Use <code>t.on = !t.on</code> in the Flip method with a pointer receiver.
            - title: ðŸ”§ Pattern
              content: |-
                <pre>type Toggle struct { on bool }
                func (t *Toggle) Flip() { t.on = !t.on }
                func (t Toggle) IsOn() bool { return t.on }</pre>
          solution: |-
            type Toggle struct {
                on bool
            }

            func (t *Toggle) Flip() {
                t.on = !t.on
            }

            func (t Toggle) IsOn() bool {
                return t.on
            }
          difficulty: 1
          annotations:
            - type: idiom
              label: Encapsulation
              text: >-
                Lowercase field <code>on</code> is unexported. Only the struct's methods can access it, providing
                encapsulation.
        - id: v4
          title: Accumulator Struct
          description: >-
            Create an <code>Accumulator</code> struct that tracks a running sum. Add <code>Add(n int)</code>,
            <code>Reset()</code>, and <code>Total() int</code>.
          functionSignature: |-
            func (a *Accumulator) Add(n int)
            func (a *Accumulator) Reset()
            func (a Accumulator) Total() int
          testCases:
            - input: a := Accumulator{}; a.Add(5); a.Add(3)
              output: a.Total() == 8
            - input: a := Accumulator{}; a.Add(10); a.Reset()
              output: a.Total() == 0
          hints:
            - title: ðŸ¤” Think about it
              content: This is like Counter but with arbitrary additions and a reset capability.
            - title: ðŸ’¡ Hint
              content: Add increments by n, Reset sets to 0, Total returns the current sum.
            - title: ðŸ”§ Pattern
              content: |-
                <pre>type Accumulator struct { sum int }
                Add: a.sum += n
                Reset: a.sum = 0
                Total: return a.sum</pre>
          solution: |-
            type Accumulator struct {
                sum int
            }

            func (a *Accumulator) Add(n int) {
                a.sum += n
            }

            func (a *Accumulator) Reset() {
                a.sum = 0
            }

            func (a Accumulator) Total() int {
                return a.sum
            }
          difficulty: 2
          annotations:
            - type: idiom
              label: Consistent Receivers
              text: >-
                Go convention: if any method needs a pointer receiver, use pointer receivers for all methods on that
                type for consistency.
            - type: alternative
              label: Functional Approach
              text: >-
                An alternative is a closure: <code>func NewAccumulator() func(int) int</code>. Structs with methods are
                more idiomatic in Go.
    - id: challenge_3
      block: 2
      difficulty: 2
      concept: Nil Pointers
      docLinks:
        - url: https://go.dev/ref/spec#The_zero_value
          title: "Go Spec: The zero value"
          note: nil is the zero value for pointers
        - url: https://go.dev/doc/effective_go#pointers_vs_values
          title: "Effective Go: Pointers vs. Values"
          note: nil checks and safe dereferencing
      variants:
        - id: v1
          title: Safe Dereference
          description: >-
            Write <code>func safeDeref(p *string) string</code> that returns the string value if p is not nil, or
            <code>"&lt;nil&gt;"</code> if it is.
          functionSignature: func safeDeref(p *string) string
          testCases:
            - input: s := "hello"; safeDeref(&s)
              output: "\"hello\""
            - input: safeDeref(nil)
              output: "\"<nil>\""
          hints:
            - title: ðŸ¤” Think about it
              content: What happens if you dereference a nil pointer? You need to guard against that.
            - title: ðŸ’¡ Hint
              content: Check <code>p == nil</code> before dereferencing. Return the fallback string if nil.
            - title: ðŸ”§ Pattern
              content: |-
                <pre>1. Check if p == nil
                2. If nil, return "<nil>"
                3. Otherwise return *p</pre>
          solution: |-
            func safeDeref(p *string) string {
                if p == nil {
                    return "<nil>"
                }
                return *p
            }
          difficulty: 1
          annotations:
            - type: idiom
              label: Nil Guard
              text: Always check for nil before dereferencing. This is the most basic pointer safety pattern in Go.
            - type: stdlib
              label: Optional Values
              text: Go doesn't have an Option/Maybe type. Nil pointers serve as the 'absent value' convention.
        - id: v2
          title: Coalesce Values
          description: >-
            Write <code>func coalesce(ptrs ...*int) (int, bool)</code> that returns the first non-nil value among the
            given pointers, or <code>(0, false)</code> if all are nil.
          functionSignature: func coalesce(ptrs ...*int) (int, bool)
          testCases:
            - input: a := 5; coalesce(nil, &a, nil)
              output: 5, true
            - input: coalesce(nil, nil)
              output: 0, false
            - input: a, b := 1, 2; coalesce(&a, &b)
              output: 1, true
          hints:
            - title: ðŸ¤” Think about it
              content: You need to iterate through the pointers and find the first non-nil one.
            - title: ðŸ’¡ Hint
              content: Use a range loop over the variadic parameter. Check each for nil.
            - title: ðŸ”§ Pattern
              content: |-
                <pre>1. For each pointer in ptrs:
                   - If not nil, return *ptr, true
                2. All nil: return 0, false</pre>
          solution: |-
            func coalesce(ptrs ...*int) (int, bool) {
                for _, p := range ptrs {
                    if p != nil {
                        return *p, true
                    }
                }
                return 0, false
            }
          difficulty: 2
          annotations:
            - type: idiom
              label: Variadic + Pointers
              text: >-
                Variadic pointer parameters let you pass a flexible number of optional values, similar to SQL's COALESCE
                function.
            - type: complexity
              label: O(n)
              text: Linear in the number of pointers. Exits early on first non-nil value.
        - id: v3
          title: Safe Add
          description: >-
            Write <code>func safeAdd(a, b *int) (int, error)</code> that adds the values if both are non-nil. Return an
            error if either is nil.
          functionSignature: func safeAdd(a, b *int) (int, error)
          testCases:
            - input: x, y := 3, 4; safeAdd(&x, &y)
              output: 7, nil
            - input: x := 3; safeAdd(&x, nil)
              output: 0, error
            - input: safeAdd(nil, nil)
              output: 0, error
          hints:
            - title: ðŸ¤” Think about it
              content: You need to validate both inputs before operating on them.
            - title: ðŸ’¡ Hint
              content: Check <code>a == nil || b == nil</code> and return an error using <code>fmt.Errorf</code>.
            - title: ðŸ”§ Pattern
              content: |-
                <pre>1. Check if either pointer is nil
                2. If yes, return 0 and an error
                3. Otherwise return *a + *b, nil</pre>
          solution: |-
            func safeAdd(a, b *int) (int, error) {
                if a == nil || b == nil {
                    return 0, fmt.Errorf("nil pointer argument")
                }
                return *a + *b, nil
            }
          difficulty: 2
          annotations:
            - type: idiom
              label: Error Returns
              text: >-
                Returning <code>(value, error)</code> is the canonical Go error handling pattern. The caller decides how
                to handle the error.
            - type: gotcha
              label: Check Both
              text: >-
                A common mistake is checking only one pointer. Both <code>a</code> and <code>b</code> could
                independently be nil.
        - id: v4
          title: Nil-safe Max
          description: >-
            Write <code>func safeMax(a, b *int) *int</code> that returns a pointer to the larger value. If one is nil,
            return the other. If both nil, return nil.
          functionSignature: func safeMax(a, b *int) *int
          testCases:
            - input: x, y := 5, 10; safeMax(&x, &y)
              output: "*result == 10"
            - input: x := 5; safeMax(&x, nil)
              output: "*result == 5"
            - input: safeMax(nil, nil)
              output: result == nil
          hints:
            - title: ðŸ¤” Think about it
              content: Handle the nil cases first, then compare the dereferenced values.
            - title: ðŸ’¡ Hint
              content: If a is nil, return b (and vice versa). If neither is nil, compare <code>*a</code> and <code>*b</code>.
            - title: ðŸ”§ Pattern
              content: |-
                <pre>1. If a == nil, return b
                2. If b == nil, return a
                3. If *a >= *b, return a
                4. Else return b</pre>
          solution: |-
            func safeMax(a, b *int) *int {
                if a == nil {
                    return b
                }
                if b == nil {
                    return a
                }
                if *a >= *b {
                    return a
                }
                return b
            }
          difficulty: 3
          annotations:
            - type: pattern
              label: Returning Pointers
              text: >-
                Returning one of the input pointers means the caller gets a reference to the original variable, not a
                copy.
            - type: gotcha
              label: Pointer Aliasing
              text: >-
                The returned pointer aliases one of the inputs. Modifying through the returned pointer changes the
                original variable.
    - id: challenge_4
      block: 2
      difficulty: 3
      concept: Linked Structures
      docLinks:
        - url: https://go.dev/ref/spec#Pointer_types
          title: "Go Spec: Pointer types"
          note: self-referential struct pointers
        - url: https://go.dev/ref/spec#Struct_types
          title: "Go Spec: Struct types"
          note: defining linked node structs
        - url: https://pkg.go.dev/container/list
          title: Package container/list
          note: stdlib doubly linked list for reference
      variants:
        - id: v1
          title: "Linked List: Build and Traverse"
          description: >-
            Define a <code>Node</code> struct with <code>Value int</code> and <code>Next *Node</code>. Write <code>func
            buildList(values []int) *Node</code> and <code>func traverse(head *Node) []int</code>.
          functionSignature: |-
            func buildList(values []int) *Node
            func traverse(head *Node) []int
          testCases:
            - input: traverse(buildList([]int{1, 2, 3}))
              output: "[]int{1, 2, 3}"
            - input: traverse(buildList([]int{}))
              output: "[]int{}"
            - input: traverse(buildList([]int{42}))
              output: "[]int{42}"
          hints:
            - title: ðŸ¤” Think about it
              content: >-
                To build a list preserving order, consider building from the back. To traverse, follow Next pointers
                until nil.
            - title: ðŸ’¡ Hint
              content: >-
                Build in reverse: start from the last element. Each new node's Next points to the previous head.
                Traverse with <code>for node != nil</code>.
            - title: ðŸ”§ Pattern
              content: |-
                <pre>Build:
                  var head *Node
                  for i := len(values)-1; i >= 0; i--
                    head = &Node{values[i], head}

                Traverse:
                  for node := head; node != nil; node = node.Next
                    append to result</pre>
          solution: |-
            type Node struct {
                Value int
                Next  *Node
            }

            func buildList(values []int) *Node {
                var head *Node
                for i := len(values) - 1; i >= 0; i-- {
                    head = &Node{Value: values[i], Next: head}
                }
                return head
            }

            func traverse(head *Node) []int {
                var result []int
                for node := head; node != nil; node = node.Next {
                    result = append(result, node.Value)
                }
                return result
            }
          difficulty: 2
          annotations:
            - type: idiom
              label: Self-referential Structs
              text: >-
                A struct can contain a pointer to its own type (<code>Next *Node</code>). This enables linked data
                structures like lists and trees.
            - type: complexity
              label: O(n)
              text: Both build and traverse are O(n) where n is the number of elements.
        - id: v2
          title: "Linked List: Length"
          description: >-
            Given the <code>Node</code> struct, write <code>func listLength(head *Node) int</code> that returns the
            number of nodes in the linked list.
          functionSignature: func listLength(head *Node) int
          testCases:
            - input: listLength(buildList([]int{1, 2, 3}))
              output: "3"
            - input: listLength(nil)
              output: "0"
            - input: listLength(buildList([]int{42}))
              output: "1"
          hints:
            - title: ðŸ¤” Think about it
              content: Walk the list, counting each node until you hit nil.
            - title: ðŸ’¡ Hint
              content: Initialize a counter. Loop with <code>for node != nil</code>, incrementing each iteration.
            - title: ðŸ”§ Pattern
              content: |-
                <pre>count := 0
                for node := head; node != nil; node = node.Next {
                    count++
                }
                return count</pre>
          solution: |-
            func listLength(head *Node) int {
                count := 0
                for node := head; node != nil; node = node.Next {
                    count++
                }
                return count
            }
          difficulty: 1
          annotations:
            - type: idiom
              label: Nil-terminated Traversal
              text: >-
                Linked list traversal uses <code>node != nil</code> as the loop condition. The nil at the end acts as a
                natural terminator.
        - id: v3
          title: "Linked List: Search"
          description: >-
            Write <code>func contains(head *Node, target int) bool</code> that returns true if any node in the list has
            the given value.
          functionSignature: func contains(head *Node, target int) bool
          testCases:
            - input: contains(buildList([]int{1, 2, 3}), 2)
              output: "true"
            - input: contains(buildList([]int{1, 2, 3}), 5)
              output: "false"
            - input: contains(nil, 1)
              output: "false"
          hints:
            - title: ðŸ¤” Think about it
              content: Traverse the list, comparing each node's value to the target.
            - title: ðŸ’¡ Hint
              content: Return true immediately when you find a match. If the loop ends, the value wasn't found.
            - title: ðŸ”§ Pattern
              content: |-
                <pre>for node := head; node != nil; node = node.Next {
                    if node.Value == target { return true }
                }
                return false</pre>
          solution: |-
            func contains(head *Node, target int) bool {
                for node := head; node != nil; node = node.Next {
                    if node.Value == target {
                        return true
                    }
                }
                return false
            }
          difficulty: 2
          annotations:
            - type: idiom
              label: Early Return
              text: >-
                Returning early when the condition is met avoids unnecessary traversal. This is idiomatic Go -- don't
                use a found variable.
            - type: complexity
              label: O(n)
              text: Worst case traverses all nodes. Average case exits early when found.
        - id: v4
          title: "Linked List: Reverse"
          description: >-
            Write <code>func reverse(head *Node) *Node</code> that reverses a linked list in place and returns the new
            head.
          functionSignature: func reverse(head *Node) *Node
          testCases:
            - input: traverse(reverse(buildList([]int{1, 2, 3})))
              output: "[]int{3, 2, 1}"
            - input: traverse(reverse(buildList([]int{1})))
              output: "[]int{1}"
            - input: reverse(nil)
              output: nil
          hints:
            - title: ðŸ¤” Think about it
              content: You need to reverse all the Next pointers. What pointers do you need to track to avoid losing nodes?
            - title: ðŸ’¡ Hint
              content: >-
                Use three pointers: <code>prev</code> (starts nil), <code>current</code>, and <code>next</code>. For
                each node, save next, point current.Next to prev, advance prev and current.
            - title: ðŸ”§ Pattern
              content: |-
                <pre>var prev *Node
                current := head
                for current != nil {
                    next := current.Next
                    current.Next = prev
                    prev = current
                    current = next
                }
                return prev</pre>
          solution: |-
            func reverse(head *Node) *Node {
                var prev *Node
                current := head
                for current != nil {
                    next := current.Next
                    current.Next = prev
                    prev = current
                    current = next
                }
                return prev
            }
          difficulty: 3
          annotations:
            - type: pattern
              label: Three-pointer Reversal
              text: >-
                The prev/current/next pattern is the classic iterative linked list reversal. It's O(n) time and O(1)
                space.
            - type: complexity
              label: O(n) time, O(1) space
              text: Traverses each node exactly once. Only uses a constant number of extra pointer variables.
            - type: gotcha
              label: Save Next First
              text: You must save <code>current.Next</code> before overwriting it, or you lose the rest of the list.
    - id: challenge_5
      block: 1
      difficulty: 2
      concept: Struct Embedding
      docLinks:
        - url: https://go.dev/doc/effective_go#embedding
          title: "Effective Go: Embedding"
          note: struct embedding and promoted methods
        - url: https://go.dev/ref/spec#Struct_types
          title: "Go Spec: Struct types"
          note: anonymous (embedded) fields
      variants:
        - id: v1
          title: Animal Embedding
          description: >-
            Create <code>Animal</code> with <code>Name string</code> and <code>Speak() string</code>. Create
            <code>Dog</code> and <code>Cat</code> that embed <code>Animal</code> and override <code>Speak()</code>.
          functionSignature: |-
            func (d Dog) Speak() string
            func (c Cat) Speak() string
          testCases:
            - input: "d := Dog{Animal{Name: \"Buddy\"}}; d.Speak()"
              output: "\"Woof!\""
            - input: "c := Cat{Animal{Name: \"Whiskers\"}}; c.Speak()"
              output: "\"Meow!\""
            - input: "d := Dog{Animal{Name: \"Rex\"}}; d.Name"
              output: "\"Rex\""
          hints:
            - title: ðŸ¤” Think about it
              content: >-
                Embedding lets a struct 'inherit' fields and methods. How do you override a method from the embedded
                type?
            - title: ðŸ’¡ Hint
              content: >-
                Embed by putting <code>Animal</code> as a field without a name. Override by defining
                <code>Speak()</code> on the embedding struct.
            - title: ðŸ”§ Pattern
              content: |-
                <pre>type Dog struct { Animal }
                func (d Dog) Speak() string { return "Woof!" }

                // Dog.Name works because Animal is embedded</pre>
          solution: |-
            type Animal struct {
                Name string
            }

            func (a Animal) Speak() string {
                return "..."
            }

            type Dog struct {
                Animal
            }

            func (d Dog) Speak() string {
                return "Woof!"
            }

            type Cat struct {
                Animal
            }

            func (c Cat) Speak() string {
                return "Meow!"
            }
          difficulty: 2
          annotations:
            - type: idiom
              label: Struct Embedding
              text: >-
                Embedding promotes the embedded type's fields and methods. <code>Dog</code> gets <code>Name</code> from
                <code>Animal</code> without explicit delegation.
            - type: gotcha
              label: Not Inheritance
              text: >-
                Go embedding is not OOP inheritance. The embedded type doesn't know about the outer type. There is no
                virtual dispatch.
        - id: v2
          title: Vehicle Embedding
          description: >-
            Create a <code>Vehicle</code> struct with <code>Make string</code>, <code>Year int</code>. Create
            <code>Car</code> (with <code>Doors int</code>) and <code>Truck</code> (with <code>PayloadTons
            float64</code>) that embed <code>Vehicle</code>. Add <code>Description() string</code> to each.
          functionSignature: |-
            func (c Car) Description() string
            func (t Truck) Description() string
          testCases:
            - input: c := Car{Vehicle{"Toyota", 2023}, 4}; c.Description()
              output: "\"2023 Toyota (4 doors)\""
            - input: t := Truck{Vehicle{"Ford", 2022}, 2.5}; t.Description()
              output: "\"2022 Ford (2.5 ton payload)\""
            - input: c := Car{Vehicle{"Honda", 2024}, 2}; c.Make
              output: "\"Honda\""
          hints:
            - title: ðŸ¤” Think about it
              content: Each embedded struct gets access to the Vehicle fields. Each type adds its own specific field.
            - title: ðŸ’¡ Hint
              content: >-
                Use <code>fmt.Sprintf</code> to format the description string using both Vehicle and type-specific
                fields.
            - title: ðŸ”§ Pattern
              content: |-
                <pre>type Car struct {
                    Vehicle
                    Doors int
                }
                func (c Car) Description() string {
                    return fmt.Sprintf("%d %s (%d doors)", c.Year, c.Make, c.Doors)
                }</pre>
          solution: |-
            type Vehicle struct {
                Make string
                Year int
            }

            type Car struct {
                Vehicle
                Doors int
            }

            func (c Car) Description() string {
                return fmt.Sprintf("%d %s (%d doors)", c.Year, c.Make, c.Doors)
            }

            type Truck struct {
                Vehicle
                PayloadTons float64
            }

            func (t Truck) Description() string {
                return fmt.Sprintf("%d %s (%.1f ton payload)", t.Year, t.Make, t.PayloadTons)
            }
          difficulty: 2
          annotations:
            - type: idiom
              label: Promoted Fields
              text: >-
                Embedded fields are promoted: <code>c.Make</code> is shorthand for <code>c.Vehicle.Make</code>. Both
                forms work.
            - type: alternative
              label: Named Field
              text: >-
                Instead of embedding, you could use a named field: <code>vehicle Vehicle</code>. But then you'd write
                <code>c.vehicle.Make</code> instead of <code>c.Make</code>.
        - id: v3
          title: Employee Hierarchy
          description: >-
            Create a <code>Person</code> struct with <code>Name string</code> and <code>Email string</code>. Create
            <code>Employee</code> embedding <code>Person</code> with additional <code>Role string</code>. Create
            <code>Manager</code> embedding <code>Employee</code> with <code>Reports []string</code>. Add a
            <code>Summary() string</code> to each.
          functionSignature: |-
            func (e Employee) Summary() string
            func (m Manager) Summary() string
          testCases:
            - input: e := Employee{Person{"Alice", "alice@co.com"}, "Dev"}; e.Summary()
              output: "\"Alice (Dev)\""
            - input: m := Manager{Employee{Person{"Bob", "bob@co.com"}, "Lead"}, []string{"Alice"}}; m.Summary()
              output: "\"Bob (Lead) - 1 reports\""
            - input: m.Name
              output: "\"Bob\""
          hints:
            - title: ðŸ¤” Think about it
              content: "Embedding can be multi-level: Manager embeds Employee which embeds Person."
            - title: ðŸ’¡ Hint
              content: >-
                Manager accesses <code>m.Name</code> through two levels of embedding. Its Summary should include report
                count.
            - title: ðŸ”§ Pattern
              content: |-
                <pre>type Manager struct {
                    Employee
                    Reports []string
                }
                func (m Manager) Summary() string {
                    return fmt.Sprintf("%s (%s) - %d reports", m.Name, m.Role, len(m.Reports))
                }</pre>
          solution: |-
            type Person struct {
                Name  string
                Email string
            }

            type Employee struct {
                Person
                Role string
            }

            func (e Employee) Summary() string {
                return fmt.Sprintf("%s (%s)", e.Name, e.Role)
            }

            type Manager struct {
                Employee
                Reports []string
            }

            func (m Manager) Summary() string {
                return fmt.Sprintf("%s (%s) - %d reports", m.Name, m.Role, len(m.Reports))
            }
          difficulty: 2
          annotations:
            - type: pattern
              label: Multi-level Embedding
              text: >-
                Go supports multi-level embedding. Fields are promoted through all levels: <code>m.Name</code> reaches
                through <code>Employee</code> into <code>Person</code>.
            - type: gotcha
              label: Ambiguous Selectors
              text: >-
                If two embedded types have a field with the same name, you must qualify it explicitly (e.g.,
                <code>m.Employee.Name</code>).
        - id: v4
          title: Logging with Embedding
          description: >-
            Create a <code>Logger</code> struct with a <code>Prefix string</code> and method <code>Log(msg string)
            string</code>. Create <code>AppServer</code> embedding <code>Logger</code> with <code>Port int</code>. Show
            that <code>AppServer</code> can call <code>Log</code> directly.
          functionSignature: func (l Logger) Log(msg string) string
          testCases:
            - input: s := AppServer{Logger{"[SERVER]"}, 8080}; s.Log("started")
              output: "\"[SERVER] started\""
            - input: s := AppServer{Logger{"[APP]"}, 3000}; s.Log("ready")
              output: "\"[APP] ready\""
          hints:
            - title: ðŸ¤” Think about it
              content: Embedding Logger gives AppServer all of Logger's methods for free.
            - title: ðŸ’¡ Hint
              content: The Log method concatenates the prefix with the message.
            - title: ðŸ”§ Pattern
              content: |-
                <pre>type Logger struct { Prefix string }
                func (l Logger) Log(msg string) string {
                    return l.Prefix + " " + msg
                }
                type AppServer struct {
                    Logger
                    Port int
                }</pre>
          solution: |-
            type Logger struct {
                Prefix string
            }

            func (l Logger) Log(msg string) string {
                return l.Prefix + " " + msg
            }

            type AppServer struct {
                Logger
                Port int
            }
          difficulty: 1
          annotations:
            - type: pattern
              label: Composition via Embedding
              text: >-
                Embedding provides composition. AppServer 'has a' Logger and gains its methods. This is Go's alternative
                to inheritance.
            - type: idiom
              label: Reusable Behavior
              text: >-
                Small, focused structs like Logger can be embedded into many types, providing shared behavior without
                code duplication.
    - id: challenge_6
      block: 1
      difficulty: 2
      concept: JSON Tags
      docLinks:
        - url: https://pkg.go.dev/encoding/json
          title: Package encoding/json
          note: Marshal, Unmarshal, and struct tags
        - url: https://go.dev/blog/json
          title: "Go Blog: JSON and Go"
          note: encoding/decoding JSON with structs
      variants:
        - id: v1
          title: JSON Config Parser
          description: >-
            Define a struct that matches this JSON and parse it:<br><code>{"server": {"host": "localhost", "port":
            8080}, "debug": true, "allowed_origins": ["http://localhost"]}</code>
          functionSignature: type Config struct { ... }
          testCases:
            - input: json.Unmarshal([]byte(jsonStr), &cfg); cfg.Server.Host
              output: "\"localhost\""
            - input: cfg.Server.Port
              output: "8080"
            - input: cfg.Debug
              output: "true"
            - input: len(cfg.AllowedOrigins)
              output: "1"
          hints:
            - title: ðŸ¤” Think about it
              content: JSON keys often use snake_case but Go fields use PascalCase. How do you map between them?
            - title: ðŸ’¡ Hint
              content: "Use struct tags: <code>json:\"field_name\"</code>. Nested JSON objects become nested structs."
            - title: ðŸ”§ Pattern
              content: |-
                <pre>type Config struct {
                    Server struct {
                        Host string `json:"host"`
                        Port int    `json:"port"`
                    } `json:"server"`
                    Debug          bool     `json:"debug"`
                    AllowedOrigins []string `json:"allowed_origins"`
                }</pre>
          solution: |-
            type Config struct {
                Server struct {
                    Host string `json:"host"`
                    Port int    `json:"port"`
                } `json:"server"`
                Debug          bool     `json:"debug"`
                AllowedOrigins []string `json:"allowed_origins"`
            }

            var cfg Config
            json.Unmarshal([]byte(jsonStr), &cfg)
          difficulty: 2
          annotations:
            - type: idiom
              label: Struct Tags
              text: >-
                Struct tags like <code>`json:"field_name"`</code> control how <code>encoding/json</code> maps JSON keys
                to struct fields.
            - type: gotcha
              label: Exported Fields Required
              text: >-
                Only exported (uppercase) fields are marshaled/unmarshaled by <code>encoding/json</code>. Lowercase
                fields are silently ignored.
        - id: v2
          title: User Profile JSON
          description: >-
            Define a <code>UserProfile</code> struct to match this JSON:<br><code>{"username": "gopher", "email":
            "go@go.dev", "age": 15, "is_active": true, "tags": ["developer", "gopher"]}</code><br>Add an
            <code>omitempty</code> tag on the <code>tags</code> field.
          functionSignature: type UserProfile struct { ... }
          testCases:
            - input: json.Unmarshal([]byte(jsonStr), &u); u.Username
              output: "\"gopher\""
            - input: u.IsActive
              output: "true"
            - input: len(u.Tags)
              output: "2"
          hints:
            - title: ðŸ¤” Think about it
              content: The <code>omitempty</code> option skips a field in JSON output when it has its zero value.
            - title: ðŸ’¡ Hint
              content: Use <code>`json:"tags,omitempty"`</code> to omit the tags array when empty.
            - title: ðŸ”§ Pattern
              content: |-
                <pre>type UserProfile struct {
                    Username string   `json:"username"`
                    Email    string   `json:"email"`
                    Age      int      `json:"age"`
                    IsActive bool     `json:"is_active"`
                    Tags     []string `json:"tags,omitempty"`
                }</pre>
          solution: |-
            type UserProfile struct {
                Username string   `json:"username"`
                Email    string   `json:"email"`
                Age      int      `json:"age"`
                IsActive bool     `json:"is_active"`
                Tags     []string `json:"tags,omitempty"`
            }
          difficulty: 2
          annotations:
            - type: idiom
              label: omitempty
              text: >-
                The <code>omitempty</code> option skips fields with zero values during marshaling. Useful for optional
                fields.
            - type: gotcha
              label: Bool with omitempty
              text: >-
                Be careful with <code>omitempty</code> on booleans: <code>false</code> is the zero value and will be
                omitted. Use <code>*bool</code> if false is meaningful.
        - id: v3
          title: API Response Struct
          description: >-
            Define structs to unmarshal this API response JSON:<br><code>{"status": "ok", "data": {"items": [{"id": 1,
            "name": "Widget"}, {"id": 2, "name": "Gadget"}], "total": 2}}</code>
          functionSignature: |-
            type APIResponse struct { ... }
            type Item struct { ... }
          testCases:
            - input: json.Unmarshal([]byte(jsonStr), &resp); resp.Status
              output: "\"ok\""
            - input: resp.Data.Total
              output: "2"
            - input: resp.Data.Items[0].Name
              output: "\"Widget\""
          hints:
            - title: ðŸ¤” Think about it
              content: Nested JSON requires nested structs. Arrays of objects become slices of structs.
            - title: ðŸ’¡ Hint
              content: Define an <code>Item</code> struct separately, then use <code>[]Item</code> in the data struct.
            - title: ðŸ”§ Pattern
              content: |-
                <pre>type Item struct {
                    ID   int    `json:"id"`
                    Name string `json:"name"`
                }
                type APIResponse struct {
                    Status string `json:"status"`
                    Data struct {
                        Items []Item `json:"items"`
                        Total int    `json:"total"`
                    } `json:"data"`
                }</pre>
          solution: |-
            type Item struct {
                ID   int    `json:"id"`
                Name string `json:"name"`
            }

            type APIResponse struct {
                Status string `json:"status"`
                Data   struct {
                    Items []Item `json:"items"`
                    Total int    `json:"total"`
                } `json:"data"`
            }
          difficulty: 2
          annotations:
            - type: pattern
              label: Nested Anonymous Structs
              text: >-
                For one-off nested objects, inline anonymous structs avoid polluting the package namespace. Extract to
                named types if reused.
            - type: stdlib
              label: encoding/json
              text: >-
                Go's <code>encoding/json</code> package handles marshaling and unmarshaling. Use
                <code>json.Unmarshal</code> for parsing and <code>json.Marshal</code> for serialization.
        - id: v4
          title: Database Config with Defaults
          description: >-
            Define a <code>DBConfig</code> struct for this JSON:<br><code>{"host": "db.example.com", "port": 5432,
            "name": "mydb", "ssl_mode": "require", "max_connections": 25}</code><br>Write a <code>func DefaultDBConfig()
            DBConfig</code> that returns sensible defaults, then show how to override with JSON.
          functionSignature: |-
            type DBConfig struct { ... }
            func DefaultDBConfig() DBConfig
          testCases:
            - input: cfg := DefaultDBConfig(); cfg.Port
              output: "5432"
            - input: cfg := DefaultDBConfig(); cfg.SSLMode
              output: "\"disable\""
            - input: json.Unmarshal([]byte(jsonStr), &cfg); cfg.Host
              output: "\"db.example.com\""
          hints:
            - title: ðŸ¤” Think about it
              content: >-
                The trick is to create a default config first, then unmarshal JSON on top of it. Only provided fields
                get overwritten.
            - title: ðŸ’¡ Hint
              content: >-
                Start with <code>cfg := DefaultDBConfig()</code>, then <code>json.Unmarshal(data, &cfg)</code>. Missing
                JSON fields keep their defaults.
            - title: ðŸ”§ Pattern
              content: |-
                <pre>func DefaultDBConfig() DBConfig {
                    return DBConfig{
                        Host: "localhost", Port: 5432,
                        SSLMode: "disable", MaxConn: 10,
                    }
                }
                cfg := DefaultDBConfig()
                json.Unmarshal(data, &cfg)</pre>
          solution: |-
            type DBConfig struct {
                Host    string `json:"host"`
                Port    int    `json:"port"`
                Name    string `json:"name"`
                SSLMode string `json:"ssl_mode"`
                MaxConn int    `json:"max_connections"`
            }

            func DefaultDBConfig() DBConfig {
                return DBConfig{
                    Host:    "localhost",
                    Port:    5432,
                    Name:    "app",
                    SSLMode: "disable",
                    MaxConn: 10,
                }
            }
          difficulty: 3
          annotations:
            - type: pattern
              label: Defaults + Override
              text: >-
                Creating a default struct then unmarshaling JSON on top is a powerful pattern. JSON only overwrites
                fields it contains.
            - type: idiom
              label: Constructor Returns Value
              text: >-
                When the struct is small and has no pointer receivers, returning a value (not pointer) from the
                constructor is fine.
            - type: gotcha
              label: Zero Value Ambiguity
              text: >-
                If JSON contains <code>"port": 0</code>, you can't distinguish between 'explicitly set to 0' and 'not
                provided'. Use <code>*int</code> to handle this.
