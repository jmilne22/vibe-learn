conceptLinks:
  Struct Basics: "#lesson-struct-basics"
  Methods: "#lesson-methods"
  Value vs Pointer Receivers: "#lesson-receivers"
  Encapsulation: "#lesson-encapsulation"
  Struct Embedding: "#lesson-embedding"
  JSON Tags: "#lesson-json"
  Nested Structs: "#lesson-nested-structs"
sharedContent: {}
variants:
  warmups:
    - id: warmup_1
      concept: Struct Basics
      quickRef: |
        <code>type S struct { Name string; Age int }</code><br>
                <code>s := S{Name: "Alice", Age: 30}</code>
      variants:
        - id: v1
          title: Rectangle Area and Perimeter
          description: >-
            Create a <code>Rectangle</code> struct with <code>Width</code> and <code>Height float64</code>. Add methods
            <code>Area() float64</code> and <code>Perimeter() float64</code>.
          hints:
            - Area = width * height
            - Perimeter = 2 * (width + height)
            - Value receivers are fine since these methods don't modify the struct
          solution: |-
            type Rectangle struct {
                Width  float64
                Height float64
            }

            func (r Rectangle) Area() float64 {
                return r.Width * r.Height
            }

            func (r Rectangle) Perimeter() float64 {
                return 2 * (r.Width + r.Height)
            }
          annotations:
            - type: idiom
              label: Value Receivers
              text: >-
                Methods that only read struct fields should use value receivers. This makes the intent clear: the method
                does not modify the struct.
            - type: gotcha
              label: Exported Fields
              text: >-
                Uppercase field names (<code>Width</code>, <code>Height</code>) are exported and accessible from other
                packages. Use lowercase for encapsulation.
        - id: v2
          title: Circle Area and Circumference
          description: >-
            Create a <code>Circle</code> struct with <code>Radius float64</code>. Add methods <code>Area()
            float64</code> and <code>Circumference() float64</code>. Use <code>math.Pi</code>.
          hints:
            - Area = math.Pi * r * r
            - Circumference = 2 * math.Pi * r
            - Import <code>math</code> for <code>math.Pi</code>
          solution: |-
            type Circle struct {
                Radius float64
            }

            func (c Circle) Area() float64 {
                return math.Pi * c.Radius * c.Radius
            }

            func (c Circle) Circumference() float64 {
                return 2 * math.Pi * c.Radius
            }
          annotations:
            - type: stdlib
              label: math.Pi
              text: >-
                Go provides <code>math.Pi</code> as a high-precision constant. Never hard-code 3.14 -- use the standard
                library.
            - type: idiom
              label: Method Naming
              text: >-
                Go convention is short, descriptive method names. <code>Area()</code> not <code>GetArea()</code> or
                <code>CalculateArea()</code>.
        - id: v3
          title: Triangle Calculations
          description: >-
            Create a <code>Triangle</code> struct with <code>Base</code> and <code>Height float64</code>. Add an
            <code>Area() float64</code> method.
          hints:
            - Triangle area = 0.5 * base * height
            - Use a value receiver
          solution: |-
            type Triangle struct {
                Base   float64
                Height float64
            }

            func (t Triangle) Area() float64 {
                return 0.5 * t.Base * t.Height
            }
          annotations:
            - type: idiom
              label: Consistent API
              text: >-
                Giving different shapes the same <code>Area()</code> method signature prepares them for satisfying a
                common interface later.
        - id: v4
          title: 2D Point with Distance
          description: >-
            Create a <code>Point</code> struct with <code>X, Y float64</code>. Add a method <code>DistanceTo(other
            Point) float64</code> using the distance formula.
          hints:
            - Distance = sqrt((x2-x1)^2 + (y2-y1)^2)
            - Use <code>math.Sqrt</code> and <code>math.Pow</code> (or just multiply)
          solution: |-
            type Point struct {
                X, Y float64
            }

            func (p Point) DistanceTo(other Point) float64 {
                dx := p.X - other.X
                dy := p.Y - other.Y
                return math.Sqrt(dx*dx + dy*dy)
            }
          annotations:
            - type: alternative
              label: math.Hypot
              text: >-
                The standard library provides <code>math.Hypot(dx, dy)</code> which computes the hypotenuse with better
                numerical stability than manual sqrt.
            - type: idiom
              label: Struct as Parameter
              text: >-
                Passing a <code>Point</code> as a parameter (not a pointer) is fine for small structs. Go copies them
                efficiently.
    - id: warmup_2
      concept: Encapsulation
      quickRef: |
        Uppercase = exported, lowercase = unexported<br>
                <code>type Server struct { port int }</code> (port is private)
      variants:
        - id: v1
          title: Bank Account
          description: >-
            Create a <code>BankAccount</code> with an unexported <code>balance float64</code> field. Add methods
            <code>Deposit(amount float64)</code>, <code>Withdraw(amount float64) error</code>, and <code>Balance()
            float64</code>.
          hints:
            - Lowercase <code>balance</code> makes it unexported (private)
            - Use pointer receivers for Deposit and Withdraw since they modify state
            - Return <code>fmt.Errorf(...)</code> for insufficient funds
          solution: |-
            type BankAccount struct {
                balance float64
            }

            func (a *BankAccount) Deposit(amount float64) {
                a.balance += amount
            }

            func (a *BankAccount) Withdraw(amount float64) error {
                if amount > a.balance {
                    return fmt.Errorf("insufficient funds: have %.2f, want %.2f", a.balance, amount)
                }
                a.balance -= amount
                return nil
            }

            func (a *BankAccount) Balance() float64 {
                return a.balance
            }
          annotations:
            - type: idiom
              label: Unexported Fields
              text: >-
                Lowercase field names in Go are unexported (package-private). This enforces encapsulation -- external
                code must use methods to interact with the data.
            - type: gotcha
              label: Error on Insufficient Funds
              text: >-
                Always validate inputs that could leave the struct in an invalid state. Negative balances should be
                prevented, not fixed later.
        - id: v2
          title: Temperature Tracker
          description: >-
            Create a <code>TempTracker</code> with unexported fields for tracking min, max, sum, and count. Add
            <code>Record(temp float64)</code>, <code>Min() float64</code>, <code>Max() float64</code>, and
            <code>Average() float64</code>.
          hints:
            - On first record, initialize min and max to that value
            - Use a <code>count</code> field to know if any temperatures were recorded
            - Average = sum / count
          solution: |-
            type TempTracker struct {
                min, max, sum float64
                count         int
            }

            func (t *TempTracker) Record(temp float64) {
                if t.count == 0 {
                    t.min = temp
                    t.max = temp
                } else {
                    if temp < t.min {
                        t.min = temp
                    }
                    if temp > t.max {
                        t.max = temp
                    }
                }
                t.sum += temp
                t.count++
            }

            func (t TempTracker) Min() float64 { return t.min }
            func (t TempTracker) Max() float64 { return t.max }
            func (t TempTracker) Average() float64 {
                if t.count == 0 {
                    return 0
                }
                return t.sum / float64(t.count)
            }
          annotations:
            - type: gotcha
              label: Division by Zero
              text: >-
                Always check <code>count == 0</code> before computing the average. Dividing by zero in Go produces
                <code>+Inf</code> for floats, which may confuse callers.
            - type: pattern
              label: Running Statistics
              text: >-
                Tracking min, max, sum, and count in a struct lets you compute statistics in a single pass without
                storing all values.
        - id: v3
          title: Score Keeper
          description: >-
            Create a <code>ScoreKeeper</code> with an unexported <code>scores []int</code>. Add <code>Add(score
            int)</code>, <code>Total() int</code>, and <code>Count() int</code>.
          hints:
            - Use <code>append</code> to add scores
            - Loop through scores to calculate total
            - Count is just <code>len(s.scores)</code>
          solution: |-
            type ScoreKeeper struct {
                scores []int
            }

            func (s *ScoreKeeper) Add(score int) {
                s.scores = append(s.scores, score)
            }

            func (s ScoreKeeper) Total() int {
                total := 0
                for _, sc := range s.scores {
                    total += sc
                }
                return total
            }

            func (s ScoreKeeper) Count() int {
                return len(s.scores)
            }
          annotations:
            - type: idiom
              label: Slice in Struct
              text: >-
                Storing a slice as a struct field is idiomatic Go. The struct methods control how the slice is accessed
                and modified.
            - type: gotcha
              label: Append Needs Pointer Receiver
              text: >-
                <code>append</code> may create a new underlying array, so <code>Add</code> must use a pointer receiver
                or the new slice header is lost.
        - id: v4
          title: Inventory Item
          description: >-
            Create an <code>Inventory</code> struct with unexported fields <code>name string</code>, <code>quantity
            int</code>, <code>price float64</code>. Add <code>NewInventory(name string, qty int, price float64)
            *Inventory</code> constructor, <code>Restock(n int)</code>, <code>Sell(n int) error</code>, and
            <code>Value() float64</code>.
          hints:
            - The constructor function returns a pointer to a new struct
            - Sell returns an error if quantity is insufficient
            - Value = quantity * price
          solution: |-
            type Inventory struct {
                name     string
                quantity int
                price    float64
            }

            func NewInventory(name string, qty int, price float64) *Inventory {
                return &Inventory{name: name, quantity: qty, price: price}
            }

            func (inv *Inventory) Restock(n int) {
                inv.quantity += n
            }

            func (inv *Inventory) Sell(n int) error {
                if n > inv.quantity {
                    return fmt.Errorf("not enough stock: have %d, want %d", inv.quantity, n)
                }
                inv.quantity -= n
                return nil
            }

            func (inv Inventory) Value() float64 {
                return float64(inv.quantity) * inv.price
            }
          annotations:
            - type: idiom
              label: Constructor Functions
              text: >-
                Go has no constructors. By convention, <code>NewTypeName</code> functions create and return initialized
                struct pointers.
            - type: pattern
              label: Returning Pointers from Constructors
              text: >-
                Returning <code>*Inventory</code> from <code>NewInventory</code> is idiomatic. Go's escape analysis
                allocates it on the heap automatically.
  challenges:
    - id: challenge_1
      block: 1
      difficulty: 2
      concept: Struct Embedding
      docLinks:
        - url: https://go.dev/doc/effective_go#embedding
          title: "Effective Go: Embedding"
          note: struct embedding and promoted methods
        - url: https://go.dev/ref/spec#Struct_types
          title: "Go Spec: Struct types"
          note: anonymous (embedded) fields
      quickRef: |
        <code>type Outer struct { Inner }</code><br>
                Outer gets Inner's methods. Access via <code>o.InnerMethod()</code>
      variants:
        - id: v1
          title: Animal Embedding
          description: >-
            Create <code>Animal</code> with <code>Name string</code> and <code>Speak() string</code>. Create
            <code>Dog</code> and <code>Cat</code> that embed <code>Animal</code> and override <code>Speak()</code>.
          functionSignature: |-
            func (d Dog) Speak() string
            func (c Cat) Speak() string
          testCases:
            - input: "d := Dog{Animal{Name: \"Buddy\"}}; d.Speak()"
              output: "\"Woof!\""
            - input: "c := Cat{Animal{Name: \"Whiskers\"}}; c.Speak()"
              output: "\"Meow!\""
            - input: "d := Dog{Animal{Name: \"Rex\"}}; d.Name"
              output: "\"Rex\""
          hints:
            - title: ðŸ¤” Think about it
              content: >-
                Embedding lets a struct 'inherit' fields and methods. How do you override a method from the embedded
                type?
            - title: ðŸ’¡ Hint
              content: >-
                Embed by putting <code>Animal</code> as a field without a name. Override by defining
                <code>Speak()</code> on the embedding struct.
            - title: ðŸ”§ Pattern
              content: |-
                <pre>type Dog struct { Animal }
                func (d Dog) Speak() string { return "Woof!" }

                // Dog.Name works because Animal is embedded</pre>
          solution: |-
            type Animal struct {
                Name string
            }

            func (a Animal) Speak() string {
                return "..."
            }

            type Dog struct {
                Animal
            }

            func (d Dog) Speak() string {
                return "Woof!"
            }

            type Cat struct {
                Animal
            }

            func (c Cat) Speak() string {
                return "Meow!"
            }
          difficulty: 2
          annotations:
            - type: idiom
              label: Struct Embedding
              text: >-
                Embedding promotes the embedded type's fields and methods. <code>Dog</code> gets <code>Name</code> from
                <code>Animal</code> without explicit delegation.
            - type: gotcha
              label: Not Inheritance
              text: >-
                Go embedding is not OOP inheritance. The embedded type doesn't know about the outer type. There is no
                virtual dispatch.
        - id: v2
          title: Vehicle Embedding
          description: >-
            Create a <code>Vehicle</code> struct with <code>Make string</code>, <code>Year int</code>. Create
            <code>Car</code> (with <code>Doors int</code>) and <code>Truck</code> (with <code>PayloadTons
            float64</code>) that embed <code>Vehicle</code>. Add <code>Description() string</code> to each.
          functionSignature: |-
            func (c Car) Description() string
            func (t Truck) Description() string
          testCases:
            - input: c := Car{Vehicle{"Toyota", 2023}, 4}; c.Description()
              output: "\"2023 Toyota (4 doors)\""
            - input: t := Truck{Vehicle{"Ford", 2022}, 2.5}; t.Description()
              output: "\"2022 Ford (2.5 ton payload)\""
            - input: c := Car{Vehicle{"Honda", 2024}, 2}; c.Make
              output: "\"Honda\""
          hints:
            - title: ðŸ¤” Think about it
              content: Each embedded struct gets access to the Vehicle fields. Each type adds its own specific field.
            - title: ðŸ’¡ Hint
              content: >-
                Use <code>fmt.Sprintf</code> to format the description string using both Vehicle and type-specific
                fields.
            - title: ðŸ”§ Pattern
              content: |-
                <pre>type Car struct {
                    Vehicle
                    Doors int
                }
                func (c Car) Description() string {
                    return fmt.Sprintf("%d %s (%d doors)", c.Year, c.Make, c.Doors)
                }</pre>
          solution: |-
            type Vehicle struct {
                Make string
                Year int
            }

            type Car struct {
                Vehicle
                Doors int
            }

            func (c Car) Description() string {
                return fmt.Sprintf("%d %s (%d doors)", c.Year, c.Make, c.Doors)
            }

            type Truck struct {
                Vehicle
                PayloadTons float64
            }

            func (t Truck) Description() string {
                return fmt.Sprintf("%d %s (%.1f ton payload)", t.Year, t.Make, t.PayloadTons)
            }
          difficulty: 2
          annotations:
            - type: idiom
              label: Promoted Fields
              text: >-
                Embedded fields are promoted: <code>c.Make</code> is shorthand for <code>c.Vehicle.Make</code>. Both
                forms work.
            - type: alternative
              label: Named Field
              text: >-
                Instead of embedding, you could use a named field: <code>vehicle Vehicle</code>. But then you'd write
                <code>c.vehicle.Make</code> instead of <code>c.Make</code>.
        - id: v3
          title: Employee Hierarchy
          description: >-
            Create a <code>Person</code> struct with <code>Name string</code> and <code>Email string</code>. Create
            <code>Employee</code> embedding <code>Person</code> with additional <code>Role string</code>. Create
            <code>Manager</code> embedding <code>Employee</code> with <code>Reports []string</code>. Add a
            <code>Summary() string</code> to each.
          functionSignature: |-
            func (e Employee) Summary() string
            func (m Manager) Summary() string
          testCases:
            - input: e := Employee{Person{"Alice", "alice@co.com"}, "Dev"}; e.Summary()
              output: "\"Alice (Dev)\""
            - input: m := Manager{Employee{Person{"Bob", "bob@co.com"}, "Lead"}, []string{"Alice"}}; m.Summary()
              output: "\"Bob (Lead) - 1 reports\""
            - input: m.Name
              output: "\"Bob\""
          hints:
            - title: ðŸ¤” Think about it
              content: "Embedding can be multi-level: Manager embeds Employee which embeds Person."
            - title: ðŸ’¡ Hint
              content: >-
                Manager accesses <code>m.Name</code> through two levels of embedding. Its Summary should include report
                count.
            - title: ðŸ”§ Pattern
              content: |-
                <pre>type Manager struct {
                    Employee
                    Reports []string
                }
                func (m Manager) Summary() string {
                    return fmt.Sprintf("%s (%s) - %d reports", m.Name, m.Role, len(m.Reports))
                }</pre>
          solution: |-
            type Person struct {
                Name  string
                Email string
            }

            type Employee struct {
                Person
                Role string
            }

            func (e Employee) Summary() string {
                return fmt.Sprintf("%s (%s)", e.Name, e.Role)
            }

            type Manager struct {
                Employee
                Reports []string
            }

            func (m Manager) Summary() string {
                return fmt.Sprintf("%s (%s) - %d reports", m.Name, m.Role, len(m.Reports))
            }
          difficulty: 2
          annotations:
            - type: pattern
              label: Multi-level Embedding
              text: >-
                Go supports multi-level embedding. Fields are promoted through all levels: <code>m.Name</code> reaches
                through <code>Employee</code> into <code>Person</code>.
            - type: gotcha
              label: Ambiguous Selectors
              text: >-
                If two embedded types have a field with the same name, you must qualify it explicitly (e.g.,
                <code>m.Employee.Name</code>).
        - id: v4
          title: Logging with Embedding
          description: >-
            Create a <code>Logger</code> struct with a <code>Prefix string</code> and method <code>Log(msg string)
            string</code>. Create <code>AppServer</code> embedding <code>Logger</code> with <code>Port int</code>. Show
            that <code>AppServer</code> can call <code>Log</code> directly.
          functionSignature: func (l Logger) Log(msg string) string
          testCases:
            - input: s := AppServer{Logger{"[SERVER]"}, 8080}; s.Log("started")
              output: "\"[SERVER] started\""
            - input: s := AppServer{Logger{"[APP]"}, 3000}; s.Log("ready")
              output: "\"[APP] ready\""
          hints:
            - title: ðŸ¤” Think about it
              content: Embedding Logger gives AppServer all of Logger's methods for free.
            - title: ðŸ’¡ Hint
              content: The Log method concatenates the prefix with the message.
            - title: ðŸ”§ Pattern
              content: |-
                <pre>type Logger struct { Prefix string }
                func (l Logger) Log(msg string) string {
                    return l.Prefix + " " + msg
                }
                type AppServer struct {
                    Logger
                    Port int
                }</pre>
          solution: |-
            type Logger struct {
                Prefix string
            }

            func (l Logger) Log(msg string) string {
                return l.Prefix + " " + msg
            }

            type AppServer struct {
                Logger
                Port int
            }
          difficulty: 1
          annotations:
            - type: pattern
              label: Composition via Embedding
              text: >-
                Embedding provides composition. AppServer 'has a' Logger and gains its methods. This is Go's alternative
                to inheritance.
            - type: idiom
              label: Reusable Behavior
              text: >-
                Small, focused structs like Logger can be embedded into many types, providing shared behavior without
                code duplication.
    - id: challenge_2
      block: 1
      difficulty: 2
      concept: JSON Tags
      docLinks:
        - url: https://pkg.go.dev/encoding/json
          title: Package encoding/json
          note: Marshal, Unmarshal, and struct tags
        - url: https://go.dev/blog/json
          title: "Go Blog: JSON and Go"
          note: encoding/decoding JSON with structs
      quickRef: |
        <code>type T struct { Name string `json:"name"` }</code><br>
                <code>json.Marshal(v)</code> &nbsp; <code>json.Unmarshal(data, &amp;v)</code>
      variants:
        - id: v1
          title: JSON Config Parser
          description: >-
            Define a struct that matches this JSON and parse it:<br><code>{"server": {"host": "localhost", "port":
            8080}, "debug": true, "allowed_origins": ["http://localhost"]}</code>
          functionSignature: type Config struct { ... }
          testCases:
            - input: json.Unmarshal([]byte(jsonStr), &cfg); cfg.Server.Host
              output: "\"localhost\""
            - input: cfg.Server.Port
              output: "8080"
            - input: cfg.Debug
              output: "true"
            - input: len(cfg.AllowedOrigins)
              output: "1"
          hints:
            - title: ðŸ¤” Think about it
              content: JSON keys often use snake_case but Go fields use PascalCase. How do you map between them?
            - title: ðŸ’¡ Hint
              content: "Use struct tags: <code>json:\"field_name\"</code>. Nested JSON objects become nested structs."
            - title: ðŸ”§ Pattern
              content: |-
                <pre>type Config struct {
                    Server struct {
                        Host string `json:"host"`
                        Port int    `json:"port"`
                    } `json:"server"`
                    Debug          bool     `json:"debug"`
                    AllowedOrigins []string `json:"allowed_origins"`
                }</pre>
          solution: |-
            type Config struct {
                Server struct {
                    Host string `json:"host"`
                    Port int    `json:"port"`
                } `json:"server"`
                Debug          bool     `json:"debug"`
                AllowedOrigins []string `json:"allowed_origins"`
            }

            var cfg Config
            json.Unmarshal([]byte(jsonStr), &cfg)
          difficulty: 2
          annotations:
            - type: idiom
              label: Struct Tags
              text: >-
                Struct tags like <code>`json:"field_name"`</code> control how <code>encoding/json</code> maps JSON keys
                to struct fields.
            - type: gotcha
              label: Exported Fields Required
              text: >-
                Only exported (uppercase) fields are marshaled/unmarshaled by <code>encoding/json</code>. Lowercase
                fields are silently ignored.
        - id: v2
          title: User Profile JSON
          description: >-
            Define a <code>UserProfile</code> struct to match this JSON:<br><code>{"username": "gopher", "email":
            "go@go.dev", "age": 15, "is_active": true, "tags": ["developer", "gopher"]}</code><br>Add an
            <code>omitempty</code> tag on the <code>tags</code> field.
          functionSignature: type UserProfile struct { ... }
          testCases:
            - input: json.Unmarshal([]byte(jsonStr), &u); u.Username
              output: "\"gopher\""
            - input: u.IsActive
              output: "true"
            - input: len(u.Tags)
              output: "2"
          hints:
            - title: ðŸ¤” Think about it
              content: The <code>omitempty</code> option skips a field in JSON output when it has its zero value.
            - title: ðŸ’¡ Hint
              content: Use <code>`json:"tags,omitempty"`</code> to omit the tags array when empty.
            - title: ðŸ”§ Pattern
              content: |-
                <pre>type UserProfile struct {
                    Username string   `json:"username"`
                    Email    string   `json:"email"`
                    Age      int      `json:"age"`
                    IsActive bool     `json:"is_active"`
                    Tags     []string `json:"tags,omitempty"`
                }</pre>
          solution: |-
            type UserProfile struct {
                Username string   `json:"username"`
                Email    string   `json:"email"`
                Age      int      `json:"age"`
                IsActive bool     `json:"is_active"`
                Tags     []string `json:"tags,omitempty"`
            }
          difficulty: 2
          annotations:
            - type: idiom
              label: omitempty
              text: >-
                The <code>omitempty</code> option skips fields with zero values during marshaling. Useful for optional
                fields.
            - type: gotcha
              label: Bool with omitempty
              text: >-
                Be careful with <code>omitempty</code> on booleans: <code>false</code> is the zero value and will be
                omitted. Use <code>*bool</code> if false is meaningful.
        - id: v3
          title: API Response Struct
          description: >-
            Define structs to unmarshal this API response JSON:<br><code>{"status": "ok", "data": {"items": [{"id": 1,
            "name": "Widget"}, {"id": 2, "name": "Gadget"}], "total": 2}}</code>
          functionSignature: |-
            type APIResponse struct { ... }
            type Item struct { ... }
          testCases:
            - input: json.Unmarshal([]byte(jsonStr), &resp); resp.Status
              output: "\"ok\""
            - input: resp.Data.Total
              output: "2"
            - input: resp.Data.Items[0].Name
              output: "\"Widget\""
          hints:
            - title: ðŸ¤” Think about it
              content: Nested JSON requires nested structs. Arrays of objects become slices of structs.
            - title: ðŸ’¡ Hint
              content: Define an <code>Item</code> struct separately, then use <code>[]Item</code> in the data struct.
            - title: ðŸ”§ Pattern
              content: |-
                <pre>type Item struct {
                    ID   int    `json:"id"`
                    Name string `json:"name"`
                }
                type APIResponse struct {
                    Status string `json:"status"`
                    Data struct {
                        Items []Item `json:"items"`
                        Total int    `json:"total"`
                    } `json:"data"`
                }</pre>
          solution: |-
            type Item struct {
                ID   int    `json:"id"`
                Name string `json:"name"`
            }

            type APIResponse struct {
                Status string `json:"status"`
                Data   struct {
                    Items []Item `json:"items"`
                    Total int    `json:"total"`
                } `json:"data"`
            }
          difficulty: 2
          annotations:
            - type: pattern
              label: Nested Anonymous Structs
              text: >-
                For one-off nested objects, inline anonymous structs avoid polluting the package namespace. Extract to
                named types if reused.
            - type: stdlib
              label: encoding/json
              text: >-
                Go's <code>encoding/json</code> package handles marshaling and unmarshaling. Use
                <code>json.Unmarshal</code> for parsing and <code>json.Marshal</code> for serialization.
        - id: v4
          title: Database Config with Defaults
          description: >-
            Define a <code>DBConfig</code> struct for this JSON:<br><code>{"host": "db.example.com", "port": 5432,
            "name": "mydb", "ssl_mode": "require", "max_connections": 25}</code><br>Write a <code>func DefaultDBConfig()
            DBConfig</code> that returns sensible defaults, then show how to override with JSON.
          functionSignature: |-
            type DBConfig struct { ... }
            func DefaultDBConfig() DBConfig
          testCases:
            - input: cfg := DefaultDBConfig(); cfg.Port
              output: "5432"
            - input: cfg := DefaultDBConfig(); cfg.SSLMode
              output: "\"disable\""
            - input: json.Unmarshal([]byte(jsonStr), &cfg); cfg.Host
              output: "\"db.example.com\""
          hints:
            - title: ðŸ¤” Think about it
              content: >-
                The trick is to create a default config first, then unmarshal JSON on top of it. Only provided fields
                get overwritten.
            - title: ðŸ’¡ Hint
              content: >-
                Start with <code>cfg := DefaultDBConfig()</code>, then <code>json.Unmarshal(data, &cfg)</code>. Missing
                JSON fields keep their defaults.
            - title: ðŸ”§ Pattern
              content: |-
                <pre>func DefaultDBConfig() DBConfig {
                    return DBConfig{
                        Host: "localhost", Port: 5432,
                        SSLMode: "disable", MaxConn: 10,
                    }
                }
                cfg := DefaultDBConfig()
                json.Unmarshal(data, &cfg)</pre>
          solution: |-
            type DBConfig struct {
                Host    string `json:"host"`
                Port    int    `json:"port"`
                Name    string `json:"name"`
                SSLMode string `json:"ssl_mode"`
                MaxConn int    `json:"max_connections"`
            }

            func DefaultDBConfig() DBConfig {
                return DBConfig{
                    Host:    "localhost",
                    Port:    5432,
                    Name:    "app",
                    SSLMode: "disable",
                    MaxConn: 10,
                }
            }
          difficulty: 3
          annotations:
            - type: pattern
              label: Defaults + Override
              text: >-
                Creating a default struct then unmarshaling JSON on top is a powerful pattern. JSON only overwrites
                fields it contains.
            - type: idiom
              label: Constructor Returns Value
              text: >-
                When the struct is small and has no pointer receivers, returning a value (not pointer) from the
                constructor is fine.
            - type: gotcha
              label: Zero Value Ambiguity
              text: >-
                If JSON contains <code>"port": 0</code>, you can't distinguish between 'explicitly set to 0' and 'not
                provided'. Use <code>*int</code> to handle this.
