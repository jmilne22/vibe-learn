conceptLinks:
  Table-Driven Tests: "#lesson-table-tests"
  Test Helpers: "#lesson-test-helpers"
  Mocking with Interfaces: "#lesson-mocking"
  Edge Case Testing: "#lesson-edge-cases"
  Code Coverage: "#lesson-coverage"
sharedContent: {}
variants:
  warmups:
    - id: warmup_1
      concept: Table-Driven Tests
      variants:
        - id: v1
          title: Test a KV Parser
          description: >-
            Write a function <code>parseKV(s string) (string, string, error)</code> that parses <code>"KEY=value"</code>
            strings. Then write table-driven tests covering: valid input, missing <code>=</code>, empty key, empty
            value, and value containing <code>=</code>.
          hints:
            - Use <code>strings.Index(s, "=")</code> to find the separator.
            - Table-driven tests use a slice of structs with input and expected fields.
            - Use <code>t.Run(name, func(t *testing.T) {...})</code> for subtests.
          solution: |-
            func parseKV(s string) (string, string, error) {
                idx := strings.Index(s, "=")
                if idx == -1 {
                    return "", "", fmt.Errorf("missing = in %q", s)
                }
                return s[:idx], s[idx+1:], nil
            }

            func TestParseKV(t *testing.T) {
                tests := []struct {
                    name    string
                    input   string
                    key     string
                    value   string
                    wantErr bool
                }{
                    {"valid", "HOST=localhost", "HOST", "localhost", false},
                    {"missing equals", "noequals", "", "", true},
                    {"empty key", "=value", "", "value", false},
                    {"empty value", "KEY=", "KEY", "", false},
                    {"value with equals", "DSN=user=admin", "DSN", "user=admin", false},
                }
                for _, tt := range tests {
                    t.Run(tt.name, func(t *testing.T) {
                        k, v, err := parseKV(tt.input)
                        if (err != nil) != tt.wantErr {
                            t.Errorf("wantErr=%v, got err=%v", tt.wantErr, err)
                        }
                        if k != tt.key || v != tt.value {
                            t.Errorf("got (%q, %q), want (%q, %q)", k, v, tt.key, tt.value)
                        }
                    })
                }
            }
          annotations:
            - type: idiom
              label: Table-Driven Tests
              text: "Table-driven tests are the idiomatic Go pattern: define cases as a slice of structs, loop with t.Run."
            - type: gotcha
              label: strings.Index vs Split
              text: strings.Index finds the first =, preserving = in values. strings.Split would break on all = signs.
        - id: v2
          title: Test a URL Parser
          description: >-
            Write a function <code>parseURL(s string) (scheme, host string, err error)</code> that extracts the scheme
            and host from a URL like <code>"https://example.com"</code>. Write table-driven tests for valid URLs,
            missing <code>://</code>, empty scheme, and empty host.
          hints:
            - Use <code>strings.Index(s, "://")</code> to find the separator.
            - Define test cases with input, expected scheme, expected host, and wantErr.
          solution: |-
            func parseURL(s string) (string, string, error) {
                idx := strings.Index(s, "://")
                if idx == -1 {
                    return "", "", fmt.Errorf("missing :// in %q", s)
                }
                scheme := s[:idx]
                host := s[idx+3:]
                if scheme == "" {
                    return "", "", fmt.Errorf("empty scheme")
                }
                return scheme, host, nil
            }

            func TestParseURL(t *testing.T) {
                tests := []struct {
                    name    string
                    input   string
                    scheme  string
                    host    string
                    wantErr bool
                }{
                    {"valid https", "https://example.com", "https", "example.com", false},
                    {"valid http", "http://localhost", "http", "localhost", false},
                    {"missing separator", "example.com", "", "", true},
                    {"empty scheme", "://host", "", "", true},
                    {"with path", "https://api.io/v1", "https", "api.io/v1", false},
                }
                for _, tt := range tests {
                    t.Run(tt.name, func(t *testing.T) {
                        s, h, err := parseURL(tt.input)
                        if (err != nil) != tt.wantErr {
                            t.Errorf("wantErr=%v, got err=%v", tt.wantErr, err)
                        }
                        if !tt.wantErr && (s != tt.scheme || h != tt.host) {
                            t.Errorf("got (%q, %q), want (%q, %q)", s, h, tt.scheme, tt.host)
                        }
                    })
                }
            }
          annotations:
            - type: idiom
              label: Subtests with t.Run
              text: t.Run creates named subtests, making it easy to identify which case failed.
            - type: stdlib
              label: net/url Package
              text: In production, use net/url.Parse instead of hand-rolling URL parsing.
        - id: v3
          title: Test a CSV Line Parser
          description: >-
            Write a function <code>parseCSVLine(line string) []string</code> that splits a CSV line by commas and trims
            whitespace from each field. Write table-driven tests for normal input, extra spaces, empty fields, and
            single field.
          hints:
            - Use <code>strings.Split(line, ",")</code> then <code>strings.TrimSpace</code> on each part.
            - "Test edge cases: empty string, trailing comma, spaces around commas."
          solution: |-
            func parseCSVLine(line string) []string {
                if line == "" {
                    return nil
                }
                parts := strings.Split(line, ",")
                result := make([]string, len(parts))
                for i, p := range parts {
                    result[i] = strings.TrimSpace(p)
                }
                return result
            }

            func TestParseCSVLine(t *testing.T) {
                tests := []struct {
                    name  string
                    input string
                    want  []string
                }{
                    {"normal", "a,b,c", []string{"a", "b", "c"}},
                    {"with spaces", " a , b , c ", []string{"a", "b", "c"}},
                    {"empty fields", "a,,c", []string{"a", "", "c"}},
                    {"single field", "hello", []string{"hello"}},
                    {"empty string", "", nil},
                    {"trailing comma", "a,b,", []string{"a", "b", ""}},
                }
                for _, tt := range tests {
                    t.Run(tt.name, func(t *testing.T) {
                        got := parseCSVLine(tt.input)
                        if !reflect.DeepEqual(got, tt.want) {
                            t.Errorf("got %v, want %v", got, tt.want)
                        }
                    })
                }
            }
          annotations:
            - type: gotcha
              label: nil vs Empty Slice
              text: reflect.DeepEqual distinguishes nil from []string{}. Be explicit about which your function returns.
            - type: stdlib
              label: encoding/csv
              text: For real CSV parsing, use encoding/csv which handles quoting, escaping, and multi-line fields.
        - id: v4
          title: Test a Duration Parser
          description: >-
            Write a function <code>parseDuration(s string) (int, error)</code> that parses strings like
            <code>"30s"</code>, <code>"5m"</code>, <code>"2h"</code> into total seconds. Write table-driven tests for
            each unit, invalid formats, and edge cases.
          hints:
            - Extract the numeric part and the suffix. Use a switch on the suffix to multiply.
            - "Test: valid durations, unknown units, empty string, non-numeric values."
          solution: |-
            func parseDuration(s string) (int, error) {
                if len(s) < 2 {
                    return 0, fmt.Errorf("invalid duration: %q", s)
                }
                unit := s[len(s)-1]
                numStr := s[:len(s)-1]
                n, err := strconv.Atoi(numStr)
                if err != nil {
                    return 0, fmt.Errorf("invalid number in %q: %w", s, err)
                }
                switch unit {
                case 's':
                    return n, nil
                case 'm':
                    return n * 60, nil
                case 'h':
                    return n * 3600, nil
                default:
                    return 0, fmt.Errorf("unknown unit %q in %q", string(unit), s)
                }
            }

            func TestParseDuration(t *testing.T) {
                tests := []struct {
                    name    string
                    input   string
                    want    int
                    wantErr bool
                }{
                    {"seconds", "30s", 30, false},
                    {"minutes", "5m", 300, false},
                    {"hours", "2h", 7200, false},
                    {"unknown unit", "10d", 0, true},
                    {"empty", "", 0, true},
                    {"no number", "s", 0, true},
                    {"no unit", "123", 0, true},
                }
                for _, tt := range tests {
                    t.Run(tt.name, func(t *testing.T) {
                        got, err := parseDuration(tt.input)
                        if (err != nil) != tt.wantErr {
                            t.Errorf("wantErr=%v, got err=%v", tt.wantErr, err)
                        }
                        if got != tt.want {
                            t.Errorf("got %d, want %d", got, tt.want)
                        }
                    })
                }
            }
          annotations:
            - type: idiom
              label: Error Wrapping
              text: Use %w in fmt.Errorf to wrap errors, allowing callers to use errors.Is/As.
            - type: stdlib
              label: time.ParseDuration
              text: Go's standard library has time.ParseDuration for real duration parsing with more units.
    - id: warmup_2
      concept: Mocking with Interfaces
      variants:
        - id: v1
          title: Test with Mock HTTP Client
          description: >-
            Create a <code>WeatherService</code> struct that depends on an <code>HTTPClient</code> interface. Write a
            mock implementation for testing and verify that the service handles success and error responses correctly.
          hints:
            - >-
              Define <code>HTTPClient</code> interface with a <code>Get(url string) (*http.Response, error)</code>
              method.
            - Create a <code>mockClient</code> struct with fields for the canned response and error.
            - Use <code>io.NopCloser</code> to wrap a string reader as a response body.
          solution: |-
            type HTTPClient interface {
                Get(url string) (*http.Response, error)
            }

            type WeatherService struct {
                client HTTPClient
            }

            func (ws *WeatherService) GetTemp(city string) (float64, error) {
                resp, err := ws.client.Get("https://api.weather.com/" + city)
                if err != nil {
                    return 0, err
                }
                defer resp.Body.Close()
                var data struct{ Temp float64 }
                json.NewDecoder(resp.Body).Decode(&data)
                return data.Temp, nil
            }

            type mockClient struct {
                resp *http.Response
                err  error
            }

            func (m *mockClient) Get(url string) (*http.Response, error) {
                return m.resp, m.err
            }

            func TestGetTemp_Success(t *testing.T) {
                body := io.NopCloser(strings.NewReader(`{"Temp": 72.5}`))
                mock := &mockClient{
                    resp: &http.Response{StatusCode: 200, Body: body},
                }
                svc := &WeatherService{client: mock}
                temp, err := svc.GetTemp("london")
                if err != nil {
                    t.Fatalf("unexpected error: %v", err)
                }
                if temp != 72.5 {
                    t.Errorf("got %.1f, want 72.5", temp)
                }
            }

            func TestGetTemp_Error(t *testing.T) {
                mock := &mockClient{err: fmt.Errorf("network error")}
                svc := &WeatherService{client: mock}
                _, err := svc.GetTemp("london")
                if err == nil {
                    t.Error("expected error, got nil")
                }
            }
          annotations:
            - type: idiom
              label: Interface for Mocking
              text: Define small interfaces at the consumer site. This is Go's implicit interface satisfaction at work.
            - type: pattern
              label: Dependency Injection
              text: Pass dependencies as interfaces through struct fields to enable easy testing with mocks.
        - id: v2
          title: Test with Mock Database
          description: >-
            Create a <code>UserService</code> that depends on a <code>UserStore</code> interface with <code>FindByID(id
            int) (User, error)</code>. Mock the store for testing both found and not-found cases.
          hints:
            - Define <code>UserStore</code> interface with a single method.
            - Create a mock that returns a predefined user or an error.
            - Test both the happy path and the not-found error path.
          solution: |-
            type User struct {
                ID   int
                Name string
            }

            type UserStore interface {
                FindByID(id int) (User, error)
            }

            type UserService struct {
                store UserStore
            }

            func (s *UserService) GetUser(id int) (User, error) {
                return s.store.FindByID(id)
            }

            type mockStore struct {
                user User
                err  error
            }

            func (m *mockStore) FindByID(id int) (User, error) {
                return m.user, m.err
            }

            func TestGetUser_Found(t *testing.T) {
                mock := &mockStore{user: User{ID: 1, Name: "Alice"}}
                svc := &UserService{store: mock}
                u, err := svc.GetUser(1)
                if err != nil {
                    t.Fatalf("unexpected error: %v", err)
                }
                if u.Name != "Alice" {
                    t.Errorf("got %q, want %q", u.Name, "Alice")
                }
            }

            func TestGetUser_NotFound(t *testing.T) {
                mock := &mockStore{err: fmt.Errorf("not found")}
                svc := &UserService{store: mock}
                _, err := svc.GetUser(999)
                if err == nil {
                    t.Error("expected error, got nil")
                }
            }
          annotations:
            - type: idiom
              label: Small Interfaces
              text: Go prefers small, focused interfaces. A single-method interface is easy to mock and test.
            - type: gotcha
              label: Nil Error Check
              text: Always check err first before using the result. A non-nil error means the result may be invalid.
        - id: v3
          title: Test with Mock Logger
          description: >-
            Create a <code>PaymentProcessor</code> that depends on a <code>Logger</code> interface with <code>Log(msg
            string)</code>. Mock the logger to verify that processing logs the correct messages.
          hints:
            - The mock logger can store messages in a <code>[]string</code> slice field.
            - After calling the processor, inspect the mock's recorded messages.
            - This pattern is called a 'spy' -- a mock that records calls.
          solution: |-
            type Logger interface {
                Log(msg string)
            }

            type PaymentProcessor struct {
                logger Logger
            }

            func (p *PaymentProcessor) Process(amount float64) error {
                if amount <= 0 {
                    p.logger.Log("invalid amount")
                    return fmt.Errorf("amount must be positive")
                }
                p.logger.Log(fmt.Sprintf("processed %.2f", amount))
                return nil
            }

            type spyLogger struct {
                messages []string
            }

            func (s *spyLogger) Log(msg string) {
                s.messages = append(s.messages, msg)
            }

            func TestProcess_ValidAmount(t *testing.T) {
                spy := &spyLogger{}
                proc := &PaymentProcessor{logger: spy}
                err := proc.Process(50.00)
                if err != nil {
                    t.Fatalf("unexpected error: %v", err)
                }
                if len(spy.messages) != 1 || spy.messages[0] != "processed 50.00" {
                    t.Errorf("got messages %v", spy.messages)
                }
            }

            func TestProcess_InvalidAmount(t *testing.T) {
                spy := &spyLogger{}
                proc := &PaymentProcessor{logger: spy}
                err := proc.Process(-10)
                if err == nil {
                    t.Error("expected error for negative amount")
                }
                if len(spy.messages) != 1 || spy.messages[0] != "invalid amount" {
                    t.Errorf("got messages %v", spy.messages)
                }
            }
          annotations:
            - type: pattern
              label: Spy Pattern
              text: A spy is a mock that records interactions. Store calls in a slice to verify behavior after the fact.
            - type: idiom
              label: Interface Segregation
              text: The Logger interface has a single method. Go encourages narrow interfaces that are easy to implement.
        - id: v4
          title: Test with Mock Notifier
          description: >-
            Create an <code>AlertService</code> that depends on a <code>Notifier</code> interface with <code>Send(to,
            msg string) error</code>. Mock the notifier to test success, failure, and verify the correct arguments are
            passed.
          hints:
            - Store both <code>to</code> and <code>msg</code> in the mock to verify call arguments.
            - Use a configurable error field so you can test both success and failure paths.
            - Check that the mock received the expected arguments after calling the service.
          solution: |-
            type Notifier interface {
                Send(to, msg string) error
            }

            type AlertService struct {
                notifier Notifier
            }

            func (a *AlertService) Alert(user, message string) error {
                return a.notifier.Send(user, "ALERT: "+message)
            }

            type mockNotifier struct {
                lastTo  string
                lastMsg string
                err     error
            }

            func (m *mockNotifier) Send(to, msg string) error {
                m.lastTo = to
                m.lastMsg = msg
                return m.err
            }

            func TestAlert_Success(t *testing.T) {
                mock := &mockNotifier{}
                svc := &AlertService{notifier: mock}
                err := svc.Alert("alice", "server down")
                if err != nil {
                    t.Fatalf("unexpected error: %v", err)
                }
                if mock.lastTo != "alice" {
                    t.Errorf("sent to %q, want %q", mock.lastTo, "alice")
                }
                if mock.lastMsg != "ALERT: server down" {
                    t.Errorf("sent msg %q, want %q", mock.lastMsg, "ALERT: server down")
                }
            }

            func TestAlert_Failure(t *testing.T) {
                mock := &mockNotifier{err: fmt.Errorf("send failed")}
                svc := &AlertService{notifier: mock}
                err := svc.Alert("bob", "disk full")
                if err == nil {
                    t.Error("expected error, got nil")
                }
            }
          annotations:
            - type: pattern
              label: Argument Capture
              text: Store method arguments in mock fields to verify the correct values were passed.
            - type: gotcha
              label: Mock Reuse
              text: If a mock is reused across calls, previous values are overwritten. Use slices to capture multiple calls.
  challenges:
    - id: challenge_1
      block: 1
      difficulty: 2
      concept: Edge Case Testing
      docLinks:
        - url: https://pkg.go.dev/testing
          title: Package testing
          note: test functions and subtests
        - url: https://go.dev/blog/subtests
          title: "Go Blog: Using Subtests and Sub-benchmarks"
          note: organizing test cases
      variants:
        - id: v1
          title: Test SafeDivide Edge Cases
          description: >-
            Write a function <code>safeDivide(a, b float64) (float64, error)</code> that divides a by b, returning an
            error for division by zero. Then write comprehensive tests covering: normal division, division by zero, zero
            dividend, negative numbers, and very large numbers.
          functionSignature: func safeDivide(a, b float64) (float64, error)
          testCases:
            - input: 10.0, 2.0
              output: 5.0, nil
            - input: 10.0, 0.0
              output: 0.0, error
            - input: 0.0, 5.0
              output: 0.0, nil
            - input: "-10.0, 2.0"
              output: "-5.0, nil"
          hints:
            - title: ðŸ¤” Think about it
              content: >-
                What are all the ways division can go wrong or produce surprising results? Think about zero, negatives,
                and extreme values.
            - title: ðŸ’¡ Hint
              content: >-
                Check b == 0 first and return an error. Otherwise return a/b. Your tests should cover normal, zero
                divisor, zero dividend, negative values, and math.MaxFloat64.
            - title: ðŸ”§ Pattern
              content: |-
                <pre>1. Define function with error return
                2. Guard clause for b == 0
                3. Table-driven tests with:
                   - Normal positive values
                   - Division by zero
                   - Zero / nonzero
                   - Negative values
                   - Very large values</pre>
          solution: |-
            func safeDivide(a, b float64) (float64, error) {
                if b == 0 {
                    return 0, fmt.Errorf("division by zero")
                }
                return a / b, nil
            }

            func TestSafeDivide(t *testing.T) {
                tests := []struct {
                    name    string
                    a, b    float64
                    want    float64
                    wantErr bool
                }{
                    {"normal", 10, 2, 5, false},
                    {"divide by zero", 10, 0, 0, true},
                    {"zero dividend", 0, 5, 0, false},
                    {"negatives", -10, 2, -5, false},
                    {"both negative", -10, -2, 5, false},
                    {"large numbers", 1e18, 1e9, 1e9, false},
                    {"small result", 1, 3, 0.3333333333333333, false},
                }
                for _, tt := range tests {
                    t.Run(tt.name, func(t *testing.T) {
                        got, err := safeDivide(tt.a, tt.b)
                        if (err != nil) != tt.wantErr {
                            t.Errorf("wantErr=%v, got err=%v", tt.wantErr, err)
                        }
                        if !tt.wantErr && got != tt.want {
                            t.Errorf("got %v, want %v", got, tt.want)
                        }
                    })
                }
            }
          difficulty: 2
          annotations:
            - type: gotcha
              label: Float Comparison
              text: >-
                Comparing floats with == can fail due to precision. For approximate equality, use math.Abs(got-want) <
                epsilon.
            - type: idiom
              label: Guard Clause
              text: Check error conditions first and return early. This keeps the happy path unindented.
        - id: v2
          title: Test StringReverse Edge Cases
          description: >-
            Write a function <code>reverseString(s string) string</code> that reverses a string. Write tests for: empty
            string, single character, ASCII string, Unicode string with multi-byte characters, and string with spaces.
          functionSignature: func reverseString(s string) string
          testCases:
            - input: "\"hello\""
              output: "\"olleh\""
            - input: "\"\""
              output: "\"\""
            - input: "\"a\""
              output: "\"a\""
            - input: "\"ä¸–ç•Œ\""
              output: "\"ç•Œä¸–\""
          hints:
            - title: ðŸ¤” Think about it
              content: Strings in Go are byte sequences. What happens if you reverse bytes of a multi-byte Unicode character?
            - title: ðŸ’¡ Hint
              content: >-
                Convert to []rune first to handle Unicode correctly. Then reverse the rune slice using a two-pointer
                swap.
            - title: ðŸ”§ Pattern
              content: |-
                <pre>1. Convert string to []rune
                2. Two-pointer swap: left=0, right=len-1
                3. While left < right: swap and move inward
                4. Convert back to string
                5. Test: empty, single char, ASCII, Unicode, spaces</pre>
          solution: |-
            func reverseString(s string) string {
                runes := []rune(s)
                for i, j := 0, len(runes)-1; i < j; i, j = i+1, j-1 {
                    runes[i], runes[j] = runes[j], runes[i]
                }
                return string(runes)
            }

            func TestReverseString(t *testing.T) {
                tests := []struct {
                    name  string
                    input string
                    want  string
                }{
                    {"empty", "", ""},
                    {"single char", "a", "a"},
                    {"ascii", "hello", "olleh"},
                    {"unicode", "ä¸–ç•Œ", "ç•Œä¸–"},
                    {"with spaces", "go lang", "gnal og"},
                    {"palindrome", "racecar", "racecar"},
                    {"emoji", "ðŸ˜€ðŸ˜", "ðŸ˜ðŸ˜€"},
                }
                for _, tt := range tests {
                    t.Run(tt.name, func(t *testing.T) {
                        got := reverseString(tt.input)
                        if got != tt.want {
                            t.Errorf("got %q, want %q", got, tt.want)
                        }
                    })
                }
            }
          difficulty: 2
          annotations:
            - type: gotcha
              label: Bytes vs Runes
              text: >-
                Reversing bytes breaks multi-byte UTF-8 characters. Always convert to []rune for character-level
                operations.
            - type: idiom
              label: Multi-Variable Assignment
              text: Go allows i, j = i+1, j-1 in for loop post statements for clean two-pointer iteration.
        - id: v3
          title: Test Contains Edge Cases
          description: >-
            Write a function <code>contains(haystack []string, needle string) bool</code>. Write tests for: found at
            start, found at end, not found, empty slice, empty needle, and nil slice.
          functionSignature: func contains(haystack []string, needle string) bool
          testCases:
            - input: "[]string{\"a\", \"b\", \"c\"}, \"b\""
              output: "true"
            - input: "[]string{\"a\", \"b\", \"c\"}, \"d\""
              output: "false"
            - input: "[]string{}, \"a\""
              output: "false"
            - input: nil, "a"
              output: "false"
          hints:
            - title: ðŸ¤” Think about it
              content: What should happen with a nil slice? An empty slice? An empty needle that might be in the slice?
            - title: ðŸ’¡ Hint
              content: A simple range loop handles nil and empty slices identically -- they both iterate zero times.
            - title: ðŸ”§ Pattern
              content: |-
                <pre>1. Range over haystack
                2. If item == needle, return true
                3. After loop, return false
                4. Test: found first, found last, not found,
                   empty slice, nil slice, empty needle</pre>
          solution: |-
            func contains(haystack []string, needle string) bool {
                for _, s := range haystack {
                    if s == needle {
                        return true
                    }
                }
                return false
            }

            func TestContains(t *testing.T) {
                tests := []struct {
                    name     string
                    haystack []string
                    needle   string
                    want     bool
                }{
                    {"found at start", []string{"a", "b", "c"}, "a", true},
                    {"found at end", []string{"a", "b", "c"}, "c", true},
                    {"found in middle", []string{"a", "b", "c"}, "b", true},
                    {"not found", []string{"a", "b", "c"}, "d", false},
                    {"empty slice", []string{}, "a", false},
                    {"nil slice", nil, "a", false},
                    {"empty needle exists", []string{"a", "", "b"}, "", true},
                    {"empty needle missing", []string{"a", "b"}, "", false},
                }
                for _, tt := range tests {
                    t.Run(tt.name, func(t *testing.T) {
                        got := contains(tt.haystack, tt.needle)
                        if got != tt.want {
                            t.Errorf("got %v, want %v", got, tt.want)
                        }
                    })
                }
            }
          difficulty: 2
          annotations:
            - type: idiom
              label: Nil Slice Safety
              text: Range over a nil slice is safe in Go -- it simply iterates zero times.
            - type: stdlib
              label: slices.Contains
              text: Go 1.21+ provides slices.Contains for this exact pattern.
        - id: v4
          title: Test Max Edge Cases
          description: >-
            Write a function <code>max(nums []int) (int, error)</code> that returns the maximum value from a slice.
            Write tests for: normal slice, single element, all same values, negative numbers, empty slice, and nil
            slice.
          functionSignature: func max(nums []int) (int, error)
          testCases:
            - input: "[]int{3, 1, 4, 1, 5}"
              output: 5, nil
            - input: "[]int{42}"
              output: 42, nil
            - input: "[]int{}"
              output: 0, error
            - input: nil
              output: 0, error
          hints:
            - title: ðŸ¤” Think about it
              content: >-
                What should you return for an empty or nil slice? What should the initial max be -- zero, or the first
                element?
            - title: ðŸ’¡ Hint
              content: >-
                Return an error for empty/nil slices. Initialize max to nums[0], then compare each subsequent element.
                This avoids the trap of initializing to 0 (which fails for all-negative slices).
            - title: ðŸ”§ Pattern
              content: |-
                <pre>1. Check len(nums) == 0 -> return error
                2. Set result = nums[0]
                3. For each remaining element:
                   - If element > result, update result
                4. Return result
                5. Test: normal, single, same, negatives, empty, nil</pre>
          solution: |-
            func maxVal(nums []int) (int, error) {
                if len(nums) == 0 {
                    return 0, fmt.Errorf("empty slice")
                }
                m := nums[0]
                for _, n := range nums[1:] {
                    if n > m {
                        m = n
                    }
                }
                return m, nil
            }

            func TestMax(t *testing.T) {
                tests := []struct {
                    name    string
                    input   []int
                    want    int
                    wantErr bool
                }{
                    {"normal", []int{3, 1, 4, 1, 5}, 5, false},
                    {"single", []int{42}, 42, false},
                    {"all same", []int{7, 7, 7}, 7, false},
                    {"negatives", []int{-3, -1, -4}, -1, false},
                    {"mixed", []int{-2, 0, 2}, 2, false},
                    {"empty", []int{}, 0, true},
                    {"nil", nil, 0, true},
                }
                for _, tt := range tests {
                    t.Run(tt.name, func(t *testing.T) {
                        got, err := maxVal(tt.input)
                        if (err != nil) != tt.wantErr {
                            t.Errorf("wantErr=%v, got err=%v", tt.wantErr, err)
                        }
                        if !tt.wantErr && got != tt.want {
                            t.Errorf("got %d, want %d", got, tt.want)
                        }
                    })
                }
            }
          difficulty: 2
          annotations:
            - type: gotcha
              label: Init to First Element
              text: Never initialize max to 0 or math.MinInt. Use nums[0] to handle all-negative slices correctly.
            - type: idiom
              label: Error for Empty Input
              text: Return an error when the input is invalid rather than returning a misleading zero value.
    - id: challenge_2
      block: 2
      difficulty: 3
      concept: Code Coverage
      docLinks:
        - url: https://go.dev/blog/cover
          title: "Go Blog: The cover story"
          note: go test -cover and -coverprofile
        - url: https://pkg.go.dev/cmd/go#hdr-Testing_flags
          title: "Go Command: Testing flags"
          note: -covermode, -coverprofile flags
      variants:
        - id: v1
          title: Achieve Coverage for FizzBuzz
          description: >-
            Write a function <code>fizzBuzz(n int) string</code> that returns <code>"FizzBuzz"</code> for multiples of
            15, <code>"Fizz"</code> for multiples of 3, <code>"Buzz"</code> for multiples of 5, and the number as a
            string otherwise. Write enough tests to achieve 100% branch coverage.
          functionSignature: func fizzBuzz(n int) string
          testCases:
            - input: "15"
              output: "\"FizzBuzz\""
            - input: "3"
              output: "\"Fizz\""
            - input: "5"
              output: "\"Buzz\""
            - input: "7"
              output: "\"7\""
          hints:
            - title: ðŸ¤” Think about it
              content: How many branches does this function have? You need at least one test per branch to get 100% coverage.
            - title: ðŸ’¡ Hint
              content: >-
                There are 4 branches: divisible by 15, divisible by 3 (not 15), divisible by 5 (not 15), and neither.
                One test per branch gives full coverage.
            - title: ðŸ”§ Pattern
              content: |-
                <pre>1. Write the function with if/else if chain
                2. Count branches: 4
                3. Write one test case per branch
                4. Run: go test -cover
                5. Verify: coverage: 100%</pre>
          solution: |-
            func fizzBuzz(n int) string {
                switch {
                case n%15 == 0:
                    return "FizzBuzz"
                case n%3 == 0:
                    return "Fizz"
                case n%5 == 0:
                    return "Buzz"
                default:
                    return strconv.Itoa(n)
                }
            }

            func TestFizzBuzz(t *testing.T) {
                tests := []struct {
                    input int
                    want  string
                }{
                    {15, "FizzBuzz"},
                    {30, "FizzBuzz"},
                    {3, "Fizz"},
                    {9, "Fizz"},
                    {5, "Buzz"},
                    {10, "Buzz"},
                    {7, "7"},
                    {1, "1"},
                }
                for _, tt := range tests {
                    t.Run(strconv.Itoa(tt.input), func(t *testing.T) {
                        got := fizzBuzz(tt.input)
                        if got != tt.want {
                            t.Errorf("fizzBuzz(%d) = %q, want %q", tt.input, got, tt.want)
                        }
                    })
                }
            }

            // Run: go test -coverprofile=coverage.out
            // View: go tool cover -html=coverage.out
          difficulty: 3
          annotations:
            - type: idiom
              label: Switch with No Condition
              text: switch {} with case expressions is cleaner than if/else chains for multiple conditions.
            - type: gotcha
              label: Check 15 First
              text: Check divisible-by-15 before 3 or 5. Otherwise, 15 matches the first condition it hits.
            - type: pattern
              label: Coverage Strategy
              text: Map each branch to at least one test case. Use go test -cover to verify.
        - id: v2
          title: Achieve Coverage for GradeCalculator
          description: >-
            Write a function <code>grade(score int) (string, error)</code> that returns a letter grade (A/B/C/D/F) for
            scores 0-100, and an error for out-of-range scores. Write tests to achieve at least 80% coverage using
            <code>go test -cover</code>.
          functionSignature: func grade(score int) (string, error)
          testCases:
            - input: "95"
              output: "\"A\", nil"
            - input: "85"
              output: "\"B\", nil"
            - input: "75"
              output: "\"C\", nil"
            - input: "65"
              output: "\"D\", nil"
            - input: "50"
              output: "\"F\", nil"
            - input: "-1"
              output: "\"\", error"
            - input: "101"
              output: "\"\", error"
          hints:
            - title: ðŸ¤” Think about it
              content: "Count the branches: invalid low, invalid high, A, B, C, D, F. That's 7 branches to cover."
            - title: ðŸ’¡ Hint
              content: >-
                Write at least one test per branch. Use go test -coverprofile=coverage.out and go tool cover
                -html=coverage.out to find uncovered lines.
            - title: ðŸ”§ Pattern
              content: |-
                <pre>1. Write function with range validation + grade logic
                2. List all branches (7 total)
                3. Write table-driven tests with one case per branch
                4. Run: go test -cover
                5. Check coverage report for gaps</pre>
          solution: |-
            func grade(score int) (string, error) {
                if score < 0 || score > 100 {
                    return "", fmt.Errorf("score %d out of range 0-100", score)
                }
                switch {
                case score >= 90:
                    return "A", nil
                case score >= 80:
                    return "B", nil
                case score >= 70:
                    return "C", nil
                case score >= 60:
                    return "D", nil
                default:
                    return "F", nil
                }
            }

            func TestGrade(t *testing.T) {
                tests := []struct {
                    name    string
                    score   int
                    want    string
                    wantErr bool
                }{
                    {"A grade", 95, "A", false},
                    {"A boundary", 90, "A", false},
                    {"B grade", 85, "B", false},
                    {"C grade", 75, "C", false},
                    {"D grade", 65, "D", false},
                    {"F grade", 50, "F", false},
                    {"zero", 0, "F", false},
                    {"perfect", 100, "A", false},
                    {"too low", -1, "", true},
                    {"too high", 101, "", true},
                }
                for _, tt := range tests {
                    t.Run(tt.name, func(t *testing.T) {
                        got, err := grade(tt.score)
                        if (err != nil) != tt.wantErr {
                            t.Errorf("wantErr=%v, got err=%v", tt.wantErr, err)
                        }
                        if got != tt.want {
                            t.Errorf("got %q, want %q", got, tt.want)
                        }
                    })
                }
            }
          difficulty: 3
          annotations:
            - type: pattern
              label: Boundary Testing
              text: Test boundary values (90, 80, 70, 60) in addition to mid-range values for thorough coverage.
            - type: idiom
              label: Coverage Profiling
              text: Use go test -coverprofile=c.out && go tool cover -html=c.out to visualize coverage.
        - id: v3
          title: Achieve Coverage for PasswordValidator
          description: >-
            Write a function <code>validatePassword(pw string) []string</code> that returns a slice of validation error
            messages. Rules: min 8 chars, at least one uppercase, one lowercase, one digit. Write tests to cover all
            validation branches.
          functionSignature: func validatePassword(pw string) []string
          testCases:
            - input: "\"Abcdef1x\""
              output: "[]"
            - input: "\"short\""
              output: "[\"must be at least 8 characters\", \"must contain uppercase\", \"must contain digit\"]"
            - input: "\"abcdefgh\""
              output: "[\"must contain uppercase\", \"must contain digit\"]"
            - input: "\"ABCDEFGH\""
              output: "[\"must contain lowercase\", \"must contain digit\"]"
          hints:
            - title: ðŸ¤” Think about it
              content: >-
                Each validation rule is an independent branch. You need tests where each rule fails individually and in
                combination.
            - title: ðŸ’¡ Hint
              content: >-
                Use unicode.IsUpper, unicode.IsLower, and unicode.IsDigit to check characters. Collect all errors rather
                than returning on the first one.
            - title: ðŸ”§ Pattern
              content: |-
                <pre>1. Check length >= 8
                2. Range over runes checking:
                   - hasUpper (unicode.IsUpper)
                   - hasLower (unicode.IsLower)
                   - hasDigit (unicode.IsDigit)
                3. Collect all failures into []string
                4. Test: valid, too short, missing upper,
                   missing lower, missing digit, combinations</pre>
          solution: |-
            func validatePassword(pw string) []string {
                var errors []string
                if len(pw) < 8 {
                    errors = append(errors, "must be at least 8 characters")
                }
                var hasUpper, hasLower, hasDigit bool
                for _, r := range pw {
                    switch {
                    case unicode.IsUpper(r):
                        hasUpper = true
                    case unicode.IsLower(r):
                        hasLower = true
                    case unicode.IsDigit(r):
                        hasDigit = true
                    }
                }
                if !hasUpper {
                    errors = append(errors, "must contain uppercase")
                }
                if !hasLower {
                    errors = append(errors, "must contain lowercase")
                }
                if !hasDigit {
                    errors = append(errors, "must contain digit")
                }
                return errors
            }

            func TestValidatePassword(t *testing.T) {
                tests := []struct {
                    name     string
                    password string
                    wantErrs int
                }{
                    {"valid", "Abcdef1x", 0},
                    {"too short", "Ab1", 1},
                    {"no upper", "abcdefg1", 1},
                    {"no lower", "ABCDEFG1", 1},
                    {"no digit", "Abcdefgh", 1},
                    {"empty", "", 4},
                    {"all lower", "abcdefgh", 2},
                    {"all upper", "ABCDEFGH", 2},
                    {"all digits", "12345678", 2},
                }
                for _, tt := range tests {
                    t.Run(tt.name, func(t *testing.T) {
                        errs := validatePassword(tt.password)
                        if len(errs) != tt.wantErrs {
                            t.Errorf("got %d errors %v, want %d", len(errs), errs, tt.wantErrs)
                        }
                    })
                }
            }
          difficulty: 3
          annotations:
            - type: idiom
              label: Collect All Errors
              text: >-
                Return all validation errors at once rather than stopping at the first. This gives users complete
                feedback.
            - type: stdlib
              label: unicode Package
              text: The unicode package provides IsUpper, IsLower, IsDigit for rune classification.
        - id: v4
          title: Achieve Coverage for RomanNumeral
          description: >-
            Write a function <code>toRoman(n int) (string, error)</code> that converts integers 1-3999 to Roman numeral
            strings. Write tests to achieve at least 80% coverage, including boundary values and error cases.
          functionSignature: func toRoman(n int) (string, error)
          testCases:
            - input: "1"
              output: "\"I\", nil"
            - input: "4"
              output: "\"IV\", nil"
            - input: "1994"
              output: "\"MCMXCIV\", nil"
            - input: "0"
              output: "\"\", error"
            - input: "4000"
              output: "\"\", error"
          hints:
            - title: ðŸ¤” Think about it
              content: >-
                Roman numerals use a greedy algorithm: subtract the largest possible value at each step. What values
                should your lookup table contain?
            - title: ðŸ’¡ Hint
              content: >-
                Use parallel slices of values [1000, 900, 500, 400, ...] and symbols ["M", "CM", "D", "CD", ...]. Loop
                from largest to smallest, appending symbols while the value fits.
            - title: ðŸ”§ Pattern
              content: |-
                <pre>1. Validate n is 1-3999
                2. Define values and symbols arrays
                3. For each value/symbol pair:
                   - While n >= value: append symbol, subtract value
                4. Return accumulated string
                5. Test boundaries: 1, 3999, 0, 4000, and key values</pre>
          solution: |-
            func toRoman(n int) (string, error) {
                if n < 1 || n > 3999 {
                    return "", fmt.Errorf("%d out of range 1-3999", n)
                }
                values := []int{1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1}
                symbols := []string{"M", "CM", "D", "CD", "C", "XC", "L", "XL", "X", "IX", "V", "IV", "I"}
                var result strings.Builder
                for i, val := range values {
                    for n >= val {
                        result.WriteString(symbols[i])
                        n -= val
                    }
                }
                return result.String(), nil
            }

            func TestToRoman(t *testing.T) {
                tests := []struct {
                    name    string
                    input   int
                    want    string
                    wantErr bool
                }{
                    {"one", 1, "I", false},
                    {"four", 4, "IV", false},
                    {"nine", 9, "IX", false},
                    {"fourteen", 14, "XIV", false},
                    {"forty", 40, "XL", false},
                    {"ninety", 90, "XC", false},
                    {"four hundred", 400, "CD", false},
                    {"nine hundred", 900, "CM", false},
                    {"1994", 1994, "MCMXCIV", false},
                    {"3999", 3999, "MMMCMXCIX", false},
                    {"zero", 0, "", true},
                    {"negative", -1, "", true},
                    {"too large", 4000, "", true},
                }
                for _, tt := range tests {
                    t.Run(tt.name, func(t *testing.T) {
                        got, err := toRoman(tt.input)
                        if (err != nil) != tt.wantErr {
                            t.Errorf("wantErr=%v, got err=%v", tt.wantErr, err)
                        }
                        if got != tt.want {
                            t.Errorf("got %q, want %q", got, tt.want)
                        }
                    })
                }
            }
          difficulty: 3
          annotations:
            - type: idiom
              label: strings.Builder
              text: >-
                Use strings.Builder for efficient string concatenation in loops. It avoids allocating new strings each
                iteration.
            - type: pattern
              label: Greedy Algorithm
              text: The greedy approach works here because Roman numeral values are specifically designed to allow it.
            - type: complexity
              label: O(1)
              text: >-
                The maximum number of iterations is bounded (3999 / 1 = 3999 symbols max), making this effectively
                constant time.
