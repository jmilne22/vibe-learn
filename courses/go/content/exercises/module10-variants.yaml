conceptLinks:
  Table-Driven Tests: "#lesson-table-tests"
  t.Run: "#lesson-subtests"
  Test Coverage: "#lesson-coverage"
  Interfaces: "#lesson-interfaces"
  Mock Testing: "#lesson-mocks"
sharedContent: {}
variants:
  warmups:
    - id: warmup_1
      concept: Table-Driven Tests
      variants:
        - id: v1
          title: Table-Driven Test for Reverse
          description: >-
            Write a table-driven test for a <code>reverse(s string) string</code> function. Include test cases for:
            empty string, single character, regular string, and Unicode string.
          hints:
            - Define a struct with <code>input</code> and <code>want</code> fields.
            - Use <code>t.Run(tt.input, func(t *testing.T) { ... })</code> for subtests.
            - Use <code>t.Errorf</code> to report mismatches with both expected and actual values.
          solution: |-
            func TestReverse(t *testing.T) {
                tests := []struct {
                    input, want string
                }{
                    {"", ""},
                    {"a", "a"},
                    {"hello", "olleh"},
                    {"世界", "界世"},
                }
                for _, tt := range tests {
                    t.Run(tt.input, func(t *testing.T) {
                        if got := reverse(tt.input); got != tt.want {
                            t.Errorf("reverse(%q) = %q, want %q", tt.input, got, tt.want)
                        }
                    })
                }
            }
          annotations:
            - type: idiom
              label: Table-Driven Tests
              text: >-
                Table-driven tests are the canonical Go testing pattern. Define test cases as a slice of structs, then
                loop and run each with <code>t.Run()</code>.
            - type: idiom
              label: tt Convention
              text: >-
                The variable name <code>tt</code> (for 'test table') is a widely used convention in Go table-driven
                tests.
        - id: v2
          title: Table-Driven Test for FizzBuzz
          description: >-
            Write a table-driven test for a <code>fizzBuzz(n int) string</code> function that returns "Fizz" for
            multiples of 3, "Buzz" for 5, "FizzBuzz" for both, or the number as a string.
          hints:
            - "Include test cases for: regular numbers, multiples of 3, multiples of 5, and multiples of 15."
            - Use <code>fmt.Sprintf("%d", tt.input)</code> as the subtest name for clarity.
            - Test edge cases like 0 and 1.
          solution: |-
            func TestFizzBuzz(t *testing.T) {
                tests := []struct {
                    input int
                    want  string
                }{
                    {1, "1"},
                    {3, "Fizz"},
                    {5, "Buzz"},
                    {15, "FizzBuzz"},
                    {7, "7"},
                    {30, "FizzBuzz"},
                }
                for _, tt := range tests {
                    t.Run(fmt.Sprintf("%d", tt.input), func(t *testing.T) {
                        if got := fizzBuzz(tt.input); got != tt.want {
                            t.Errorf("fizzBuzz(%d) = %q, want %q", tt.input, got, tt.want)
                        }
                    })
                }
            }
          annotations:
            - type: idiom
              label: Subtest Names
              text: >-
                Use <code>t.Run(name, ...)</code> so that each test case can be run independently with <code>go test
                -run TestFizzBuzz/15</code>.
            - type: gotcha
              label: Order Matters in FizzBuzz
              text: >-
                Check divisibility by 15 first (or check 3 and 5 separately). A common bug is checking 3 and 5
                independently without handling the 15 case.
        - id: v3
          title: Table-Driven Test with Errors
          description: >-
            Write a table-driven test for a <code>divide(a, b float64) (float64, error)</code> function. Include cases
            for normal division and division by zero.
          hints:
            - Add a <code>wantErr bool</code> field to your test struct.
            - >-
              When <code>wantErr</code> is true, check that error is non-nil. When false, check that error is nil and
              the value is correct.
            - Use a small epsilon for float comparison or compare formatted strings.
          solution: |-
            func TestDivide(t *testing.T) {
                tests := []struct {
                    name    string
                    a, b    float64
                    want    float64
                    wantErr bool
                }{
                    {"normal", 10, 2, 5, false},
                    {"decimal result", 7, 2, 3.5, false},
                    {"divide by zero", 10, 0, 0, true},
                    {"zero numerator", 0, 5, 0, false},
                }
                for _, tt := range tests {
                    t.Run(tt.name, func(t *testing.T) {
                        got, err := divide(tt.a, tt.b)
                        if tt.wantErr {
                            if err == nil {
                                t.Error("expected error, got nil")
                            }
                            return
                        }
                        if err != nil {
                            t.Fatalf("unexpected error: %v", err)
                        }
                        if got != tt.want {
                            t.Errorf("divide(%v, %v) = %v, want %v", tt.a, tt.b, got, tt.want)
                        }
                    })
                }
            }
          annotations:
            - type: idiom
              label: wantErr Pattern
              text: >-
                Adding a <code>wantErr bool</code> field to test structs is the standard Go pattern for testing
                functions that return errors.
            - type: gotcha
              label: Float Comparison
              text: >-
                Floating point comparison with <code>==</code> can fail due to rounding. For precise work, compare with
                an epsilon: <code>math.Abs(got - want) < 1e-9</code>.
        - id: v4
          title: Table-Driven Test for Word Count
          description: >-
            Write a table-driven test for a <code>wordCount(s string) map[string]int</code> function. Include cases for
            empty strings, single words, multiple words, and repeated words.
          hints:
            - Use <code>reflect.DeepEqual</code> to compare maps.
            - "Include edge cases: empty string, extra whitespace, mixed case (if your function is case-sensitive)."
            - Give each test case a descriptive name.
          solution: |-
            func TestWordCount(t *testing.T) {
                tests := []struct {
                    name  string
                    input string
                    want  map[string]int
                }{
                    {
                        name:  "empty string",
                        input: "",
                        want:  map[string]int{},
                    },
                    {
                        name:  "single word",
                        input: "hello",
                        want:  map[string]int{"hello": 1},
                    },
                    {
                        name:  "multiple words",
                        input: "go is fun",
                        want:  map[string]int{"go": 1, "is": 1, "fun": 1},
                    },
                    {
                        name:  "repeated words",
                        input: "go go go",
                        want:  map[string]int{"go": 3},
                    },
                }
                for _, tt := range tests {
                    t.Run(tt.name, func(t *testing.T) {
                        got := wordCount(tt.input)
                        if !reflect.DeepEqual(got, tt.want) {
                            t.Errorf("wordCount(%q) = %v, want %v", tt.input, got, tt.want)
                        }
                    })
                }
            }
          annotations:
            - type: stdlib
              label: reflect.DeepEqual
              text: >-
                <code>reflect.DeepEqual</code> compares maps, slices, and nested structures by value. It is the standard
                way to compare complex types in tests.
            - type: gotcha
              label: Nil vs Empty Map
              text: >-
                <code>reflect.DeepEqual(nil, map[string]int{})</code> is false. Make sure your function and test agree
                on whether to return nil or an empty map for no input.
  challenges:
    - id: challenge_1
      block: 1
      difficulty: 2
      concept: Test Coverage
      docLinks:
        - url: https://pkg.go.dev/testing
          title: Package testing
          note: Go testing framework
        - url: https://go.dev/blog/cover
          title: "Go Blog: The cover story"
          note: test coverage analysis
      variants:
        - id: v1
          title: Full Coverage for Absolute Value
          description: >-
            Write a function <code>func abs(n int) int</code> that returns the absolute value. Then write tests to
            achieve 100% coverage. Use <code>go test -cover</code> to verify.
          functionSignature: func abs(n int) int
          testCases:
            - input: abs(5)
              output: "5"
            - input: abs(-3)
              output: "3"
            - input: abs(0)
              output: "0"
          hints:
            - title: "\U0001F914 Think about it"
              content: How many code paths does an if/else have? What inputs trigger each path?
            - title: "\U0001F4A1 Hint"
              content: >-
                The function has two branches: <code>n < 0</code> (return <code>-n</code>) and the else case (return
                <code>n</code>). Test both a positive and negative number to cover both branches.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>1. Write the function with an if/else
                2. Test with a positive number (covers else branch)
                3. Test with a negative number (covers if branch)
                4. Test with zero (edge case)
                5. Run: go test -cover</pre>
          solution: |-
            func abs(n int) int {
                if n < 0 {
                    return -n
                }
                return n
            }

            func TestAbs(t *testing.T) {
                tests := []struct {
                    input, want int
                }{
                    {5, 5},
                    {-3, 3},
                    {0, 0},
                }
                for _, tt := range tests {
                    t.Run(fmt.Sprintf("%d", tt.input), func(t *testing.T) {
                        if got := abs(tt.input); got != tt.want {
                            t.Errorf("abs(%d) = %d, want %d", tt.input, got, tt.want)
                        }
                    })
                }
            }
          difficulty: 2
          annotations:
            - type: idiom
              label: go test -cover
              text: >-
                Run <code>go test -cover</code> to see the coverage percentage. Use <code>-coverprofile=c.out</code> and
                <code>go tool cover -html=c.out</code> for a visual report.
            - type: pattern
              label: Branch Coverage
              text: >-
                To achieve 100% coverage, you need at least one test input that triggers each branch in your code (if,
                else, switch cases).
        - id: v2
          title: Coverage for Grade Calculator
          description: >-
            Write <code>func grade(score int) (string, error)</code> that returns a letter grade: A (90-100), B (80-89),
            C (70-79), D (60-69), F (0-59), or error for out-of-range. Achieve 100% coverage.
          functionSignature: func grade(score int) (string, error)
          testCases:
            - input: grade(95)
              output: "\"A\", nil"
            - input: grade(85)
              output: "\"B\", nil"
            - input: grade(42)
              output: "\"F\", nil"
            - input: grade(-1)
              output: "\"\", error"
            - input: grade(101)
              output: "\"\", error"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                How many distinct code paths does this function have? Each grade range plus the error case is a separate
                path.
            - title: "\U0001F4A1 Hint"
              content: >-
                Use a switch with range checks or cascading if/else. You need at least one test for each grade letter
                plus both error conditions (negative and over 100).
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>1. Validate range (0-100), return error if invalid
                2. Use switch/case for grade ranges
                3. Test one value per grade: 95, 85, 75, 65, 42
                4. Test both boundaries: -1 and 101
                5. Run: go test -cover</pre>
          solution: |-
            func grade(score int) (string, error) {
                if score < 0 || score > 100 {
                    return "", fmt.Errorf("score %d out of range 0-100", score)
                }
                switch {
                case score >= 90:
                    return "A", nil
                case score >= 80:
                    return "B", nil
                case score >= 70:
                    return "C", nil
                case score >= 60:
                    return "D", nil
                default:
                    return "F", nil
                }
            }

            func TestGrade(t *testing.T) {
                tests := []struct {
                    name    string
                    score   int
                    want    string
                    wantErr bool
                }{
                    {"A grade", 95, "A", false},
                    {"B grade", 85, "B", false},
                    {"C grade", 75, "C", false},
                    {"D grade", 65, "D", false},
                    {"F grade", 42, "F", false},
                    {"too low", -1, "", true},
                    {"too high", 101, "", true},
                }
                for _, tt := range tests {
                    t.Run(tt.name, func(t *testing.T) {
                        got, err := grade(tt.score)
                        if tt.wantErr {
                            if err == nil {
                                t.Error("expected error")
                            }
                            return
                        }
                        if err != nil {
                            t.Fatalf("unexpected error: %v", err)
                        }
                        if got != tt.want {
                            t.Errorf("grade(%d) = %q, want %q", tt.score, got, tt.want)
                        }
                    })
                }
            }
          difficulty: 2
          annotations:
            - type: idiom
              label: Tagless Switch
              text: >-
                A <code>switch</code> without a tag expression (just <code>switch {</code>) evaluates each case as a
                boolean, acting like cascading if/else. Idiomatic for range checks.
            - type: complexity
              label: O(1)
              text: A fixed number of comparisons regardless of input. The function has constant time complexity.
        - id: v3
          title: Coverage for Password Validator
          description: >-
            Write <code>func validatePassword(pw string) []string</code> that returns a list of validation failures.
            Check: minimum 8 characters, at least one uppercase, one lowercase, and one digit. Achieve 100% coverage.
          functionSignature: func validatePassword(pw string) []string
          testCases:
            - input: validatePassword("Abc12345")
              output: "[]string{} (empty)"
            - input: validatePassword("short")
              output: "[\"at least 8 characters\", \"one uppercase\", \"one digit\"]"
            - input: validatePassword("alllowercase1")
              output: "[\"one uppercase\"]"
          hints:
            - title: "\U0001F914 Think about it"
              content: Each validation rule is a separate code path. How do you test each rule independently?
            - title: "\U0001F4A1 Hint"
              content: >-
                Use <code>unicode.IsUpper</code>, <code>unicode.IsLower</code>, <code>unicode.IsDigit</code> to check
                character classes. Each check is independent, so test passwords that fail each rule individually.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>1. Check length >= 8
                2. Loop through runes, track hasUpper, hasLower, hasDigit
                3. Collect failure messages in a slice
                4. Test: valid password, too short, missing uppercase,
                   missing lowercase, missing digit</pre>
          solution: |-
            func validatePassword(pw string) []string {
                var errors []string
                if len(pw) < 8 {
                    errors = append(errors, "at least 8 characters")
                }
                var hasUpper, hasLower, hasDigit bool
                for _, ch := range pw {
                    if unicode.IsUpper(ch) {
                        hasUpper = true
                    }
                    if unicode.IsLower(ch) {
                        hasLower = true
                    }
                    if unicode.IsDigit(ch) {
                        hasDigit = true
                    }
                }
                if !hasUpper {
                    errors = append(errors, "one uppercase")
                }
                if !hasLower {
                    errors = append(errors, "one lowercase")
                }
                if !hasDigit {
                    errors = append(errors, "one digit")
                }
                return errors
            }

            func TestValidatePassword(t *testing.T) {
                tests := []struct {
                    name string
                    pw   string
                    want int
                }{
                    {"valid", "Abc12345", 0},
                    {"too short", "Ab1", 1},
                    {"no upper", "abcdefg1", 1},
                    {"no lower", "ABCDEFG1", 1},
                    {"no digit", "Abcdefgh", 1},
                    {"all fail", "", 4},
                }
                for _, tt := range tests {
                    t.Run(tt.name, func(t *testing.T) {
                        got := validatePassword(tt.pw)
                        if len(got) != tt.want {
                            t.Errorf("validatePassword(%q) returned %d errors, want %d: %v",
                                tt.pw, len(got), tt.want, got)
                        }
                    })
                }
            }
          difficulty: 3
          annotations:
            - type: stdlib
              label: unicode Package
              text: >-
                The <code>unicode</code> package provides character classification functions: <code>IsUpper</code>,
                <code>IsLower</code>, <code>IsDigit</code>, <code>IsLetter</code>, and more.
            - type: pattern
              label: Error Accumulation
              text: >-
                Collecting all validation errors instead of returning on the first failure gives users a complete
                picture of what needs fixing.
        - id: v4
          title: Coverage for Clamp Function
          description: >-
            Write <code>func clamp(val, min, max int) (int, error)</code> that clamps a value to the range [min, max].
            Return an error if min > max. Achieve 100% coverage.
          functionSignature: func clamp(val, min, max int) (int, error)
          testCases:
            - input: clamp(5, 0, 10)
              output: 5, nil
            - input: clamp(-1, 0, 10)
              output: 0, nil
            - input: clamp(15, 0, 10)
              output: 10, nil
            - input: clamp(5, 10, 0)
              output: 0, error
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                There are four paths: error (invalid range), below min, above max, and within range. Each needs a test
                case.
            - title: "\U0001F4A1 Hint"
              content: >-
                First validate that min <= max. Then check: if val < min, return min. If val > max, return max.
                Otherwise return val.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>1. Check min <= max (error if not)
                2. If val < min, return min
                3. If val > max, return max
                4. Otherwise return val
                5. Tests: in range, below, above, invalid range</pre>
          solution: |-
            func clamp(val, min, max int) (int, error) {
                if min > max {
                    return 0, fmt.Errorf("min (%d) must not exceed max (%d)", min, max)
                }
                if val < min {
                    return min, nil
                }
                if val > max {
                    return max, nil
                }
                return val, nil
            }

            func TestClamp(t *testing.T) {
                tests := []struct {
                    name        string
                    val, min, max int
                    want        int
                    wantErr     bool
                }{
                    {"in range", 5, 0, 10, 5, false},
                    {"below min", -1, 0, 10, 0, false},
                    {"above max", 15, 0, 10, 10, false},
                    {"at min", 0, 0, 10, 0, false},
                    {"at max", 10, 0, 10, 10, false},
                    {"invalid range", 5, 10, 0, 0, true},
                }
                for _, tt := range tests {
                    t.Run(tt.name, func(t *testing.T) {
                        got, err := clamp(tt.val, tt.min, tt.max)
                        if tt.wantErr {
                            if err == nil {
                                t.Error("expected error")
                            }
                            return
                        }
                        if err != nil {
                            t.Fatalf("unexpected error: %v", err)
                        }
                        if got != tt.want {
                            t.Errorf("clamp(%d, %d, %d) = %d, want %d",
                                tt.val, tt.min, tt.max, got, tt.want)
                        }
                    })
                }
            }
          difficulty: 2
          annotations:
            - type: idiom
              label: Validate Then Process
              text: >-
                Validate inputs at the top of the function and return errors early. This 'guard clause' pattern keeps
                the happy path unindented.
            - type: complexity
              label: O(1)
              text: Simple comparisons with constant time. The clamp operation is O(1) regardless of input values.
    - id: challenge_2
      block: 2
      difficulty: 3
      concept: Interfaces
      docLinks:
        - url: https://go.dev/doc/effective_go#interfaces
          title: "Effective Go: Interfaces"
          note: designing testable interfaces
        - url: https://pkg.go.dev/errors
          title: Package errors
          note: error wrapping and inspection
      variants:
        - id: v1
          title: Mock a Fetcher Interface
          description: >-
            Define a <code>Fetcher</code> interface with <code>Fetch(url string) ([]byte, error)</code>. Write
            <code>func GetTitle(f Fetcher, url string) (string, error)</code> that fetches a URL and extracts a title.
            Test with a mock that returns canned data.
          functionSignature: func GetTitle(f Fetcher, url string) (string, error)
          testCases:
            - input: mock returns []byte("<title>Go</title>"); GetTitle(mock, "http://x")
              output: "\"Go\", nil"
            - input: mock returns error; GetTitle(mock, "http://x")
              output: "\"\", error"
          hints:
            - title: "\U0001F914 Think about it"
              content: How do you define a mock struct that satisfies an interface? How do you control what the mock returns?
            - title: "\U0001F4A1 Hint"
              content: >-
                Define a <code>mockFetcher</code> struct with <code>data []byte</code> and <code>err error</code>
                fields. Its <code>Fetch</code> method just returns those fields. Create different mock instances for
                success and failure tests.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>1. Define Fetcher interface
                2. Write GetTitle using only the interface
                3. Create mockFetcher with configurable data/err
                4. Test success: mock returns valid data
                5. Test failure: mock returns an error</pre>
          solution: |-
            type Fetcher interface {
                Fetch(url string) ([]byte, error)
            }

            func GetTitle(f Fetcher, url string) (string, error) {
                data, err := f.Fetch(url)
                if err != nil {
                    return "", err
                }
                s := string(data)
                start := strings.Index(s, "<title>")
                end := strings.Index(s, "</title>")
                if start == -1 || end == -1 {
                    return "", fmt.Errorf("no title found")
                }
                return s[start+7 : end], nil
            }

            type mockFetcher struct {
                data []byte
                err  error
            }

            func (m *mockFetcher) Fetch(url string) ([]byte, error) {
                return m.data, m.err
            }

            func TestGetTitle(t *testing.T) {
                t.Run("success", func(t *testing.T) {
                    mock := &mockFetcher{data: []byte("<title>Go</title>")}
                    got, err := GetTitle(mock, "http://example.com")
                    if err != nil {
                        t.Fatalf("unexpected error: %v", err)
                    }
                    if got != "Go" {
                        t.Errorf("got %q, want %q", got, "Go")
                    }
                })
                t.Run("fetch error", func(t *testing.T) {
                    mock := &mockFetcher{err: fmt.Errorf("network error")}
                    _, err := GetTitle(mock, "http://example.com")
                    if err == nil {
                        t.Error("expected error")
                    }
                })
            }
          difficulty: 3
          annotations:
            - type: idiom
              label: Implicit Interfaces
              text: >-
                Go interfaces are satisfied implicitly. A <code>mockFetcher</code> satisfies <code>Fetcher</code> just
                by having the right method, no 'implements' keyword needed.
            - type: pattern
              label: Dependency Injection
              text: >-
                Accepting an interface parameter instead of a concrete type lets you swap implementations for testing.
                This is Go's primary approach to testability.
        - id: v2
          title: Mock a Store Interface
          description: >-
            Define a <code>Store</code> interface with <code>Save(key, value string) error</code> and <code>Load(key
            string) (string, error)</code>. Write <code>func CopyValue(s Store, from, to string) error</code>. Test with
            a mock.
          functionSignature: func CopyValue(s Store, from, to string) error
          testCases:
            - input: mock has key "a"="hello"; CopyValue(mock, "a", "b")
              output: nil ("b" now has "hello")
            - input: mock has no key "a"; CopyValue(mock, "a", "b")
              output: error
          hints:
            - title: "\U0001F914 Think about it"
              content: CopyValue loads a value from one key and saves it to another. What can go wrong at each step?
            - title: "\U0001F4A1 Hint"
              content: >-
                Use a <code>map[string]string</code> inside your mock. <code>Load</code> returns an error if the key is
                missing. <code>Save</code> writes to the map. Test both the happy path and the 'key not found' path.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>1. Define Store interface with Save and Load
                2. CopyValue: Load from source, Save to destination
                3. Mock uses an internal map for storage
                4. Test success: source key exists
                5. Test failure: source key missing</pre>
          solution: |-
            type Store interface {
                Save(key, value string) error
                Load(key string) (string, error)
            }

            func CopyValue(s Store, from, to string) error {
                val, err := s.Load(from)
                if err != nil {
                    return fmt.Errorf("load %s: %w", from, err)
                }
                if err := s.Save(to, val); err != nil {
                    return fmt.Errorf("save %s: %w", to, err)
                }
                return nil
            }

            type mockStore struct {
                data map[string]string
            }

            func (m *mockStore) Save(key, value string) error {
                m.data[key] = value
                return nil
            }

            func (m *mockStore) Load(key string) (string, error) {
                val, ok := m.data[key]
                if !ok {
                    return "", fmt.Errorf("key %q not found", key)
                }
                return val, nil
            }

            func TestCopyValue(t *testing.T) {
                t.Run("success", func(t *testing.T) {
                    s := &mockStore{data: map[string]string{"a": "hello"}}
                    err := CopyValue(s, "a", "b")
                    if err != nil {
                        t.Fatalf("unexpected error: %v", err)
                    }
                    if s.data["b"] != "hello" {
                        t.Errorf("expected b=hello, got b=%s", s.data["b"])
                    }
                })
                t.Run("source missing", func(t *testing.T) {
                    s := &mockStore{data: map[string]string{}}
                    err := CopyValue(s, "a", "b")
                    if err == nil {
                        t.Error("expected error")
                    }
                })
            }
          difficulty: 3
          annotations:
            - type: idiom
              label: Error Wrapping
              text: >-
                Use <code>fmt.Errorf("context: %w", err)</code> to wrap errors with context while preserving the
                original error for <code>errors.Is</code> and <code>errors.As</code>.
            - type: pattern
              label: In-Memory Mock
              text: >-
                Using a map inside a mock struct simulates real storage behavior. This lets tests verify state changes
                (e.g., checking that Save actually stored the value).
        - id: v3
          title: Mock a Logger Interface
          description: >-
            Define a <code>Logger</code> interface with <code>Log(level, message string)</code>. Write <code>func
            ProcessOrder(log Logger, orderID string) error</code> that logs its progress. Test that the correct log
            messages are emitted using a mock that records calls.
          functionSignature: func ProcessOrder(log Logger, orderID string) error
          testCases:
            - input: ProcessOrder(mockLog, "order-1")
              output: "nil; mock recorded [\"INFO: processing order-1\", \"INFO: order-1 complete\"]"
            - input: ProcessOrder(mockLog, "")
              output: "error; mock recorded [\"ERROR: empty order ID\"]"
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                How do you verify that certain methods were called with certain arguments? What kind of mock records
                calls?
            - title: "\U0001F4A1 Hint"
              content: >-
                Create a <code>mockLogger</code> with a <code>calls []string</code> field. Each call to <code>Log</code>
                appends a formatted string. After the test, inspect <code>mock.calls</code> to verify behavior.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>1. Define Logger interface with Log(level, message)
                2. ProcessOrder logs progress at key steps
                3. Mock records all calls in a slice
                4. Test: run function, then assert mock.calls
                   contains expected messages</pre>
          solution: |-
            type Logger interface {
                Log(level, message string)
            }

            func ProcessOrder(log Logger, orderID string) error {
                if orderID == "" {
                    log.Log("ERROR", "empty order ID")
                    return fmt.Errorf("order ID required")
                }
                log.Log("INFO", "processing "+orderID)
                log.Log("INFO", orderID+" complete")
                return nil
            }

            type mockLogger struct {
                calls []string
            }

            func (m *mockLogger) Log(level, message string) {
                m.calls = append(m.calls, level+": "+message)
            }

            func TestProcessOrder(t *testing.T) {
                t.Run("success", func(t *testing.T) {
                    mock := &mockLogger{}
                    err := ProcessOrder(mock, "order-1")
                    if err != nil {
                        t.Fatalf("unexpected error: %v", err)
                    }
                    if len(mock.calls) != 2 {
                        t.Fatalf("expected 2 log calls, got %d", len(mock.calls))
                    }
                    if mock.calls[0] != "INFO: processing order-1" {
                        t.Errorf("unexpected first log: %s", mock.calls[0])
                    }
                })
                t.Run("empty ID", func(t *testing.T) {
                    mock := &mockLogger{}
                    err := ProcessOrder(mock, "")
                    if err == nil {
                        t.Error("expected error")
                    }
                    if len(mock.calls) != 1 || mock.calls[0] != "ERROR: empty order ID" {
                        t.Errorf("unexpected logs: %v", mock.calls)
                    }
                })
            }
          difficulty: 3
          annotations:
            - type: pattern
              label: Recording Mock
              text: >-
                A recording mock captures method calls for later assertion. This is more flexible than a stub because
                you can verify behavior (what was called) not just state.
            - type: idiom
              label: Small Interfaces
              text: >-
                Go favors small interfaces (1-2 methods). The <code>Logger</code> interface with a single
                <code>Log</code> method is easy to mock and easy to implement.
        - id: v4
          title: Mock a Notifier Interface
          description: >-
            Define a <code>Notifier</code> interface with <code>Send(to, subject, body string) error</code>. Write
            <code>func NotifyUsers(n Notifier, users []string, subject, body string) (int, error)</code> that sends to
            all users and returns the count of successful sends. Test with mocks that simulate both success and partial
            failure.
          functionSignature: func NotifyUsers(n Notifier, users []string, subject, body string) (int, error)
          testCases:
            - input: all succeed; NotifyUsers(mock, ["a","b","c"], "hi", "body")
              output: 3, nil
            - input: mock fails for "b"; NotifyUsers(mock, ["a","b","c"], "hi", "body")
              output: 2, error
          hints:
            - title: "\U0001F914 Think about it"
              content: >-
                Should the function stop on the first error or continue and report all errors? How do you count
                successes?
            - title: "\U0001F4A1 Hint"
              content: >-
                Loop through users, call <code>Send</code> for each. Count successes. Collect errors. A mock can fail
                for specific recipients by checking the <code>to</code> parameter.
            - title: "\U0001F527 Pattern"
              content: |-
                <pre>1. For each user, call n.Send()
                2. Count successes, collect errors
                3. Return count and joined errors
                4. Mock: use a failFor set to control which sends fail
                5. Test: all succeed, some fail</pre>
          solution: |-
            type Notifier interface {
                Send(to, subject, body string) error
            }

            func NotifyUsers(n Notifier, users []string, subject, body string) (int, error) {
                sent := 0
                var errs []string
                for _, user := range users {
                    if err := n.Send(user, subject, body); err != nil {
                        errs = append(errs, fmt.Sprintf("%s: %v", user, err))
                    } else {
                        sent++
                    }
                }
                if len(errs) > 0 {
                    return sent, fmt.Errorf("failed to notify: %s", strings.Join(errs, "; "))
                }
                return sent, nil
            }

            type mockNotifier struct {
                failFor map[string]bool
            }

            func (m *mockNotifier) Send(to, subject, body string) error {
                if m.failFor[to] {
                    return fmt.Errorf("send failed")
                }
                return nil
            }

            func TestNotifyUsers(t *testing.T) {
                t.Run("all succeed", func(t *testing.T) {
                    mock := &mockNotifier{failFor: map[string]bool{}}
                    count, err := NotifyUsers(mock, []string{"a", "b", "c"}, "hi", "body")
                    if err != nil {
                        t.Fatalf("unexpected error: %v", err)
                    }
                    if count != 3 {
                        t.Errorf("sent %d, want 3", count)
                    }
                })
                t.Run("partial failure", func(t *testing.T) {
                    mock := &mockNotifier{failFor: map[string]bool{"b": true}}
                    count, err := NotifyUsers(mock, []string{"a", "b", "c"}, "hi", "body")
                    if err == nil {
                        t.Error("expected error")
                    }
                    if count != 2 {
                        t.Errorf("sent %d, want 2", count)
                    }
                })
            }
          difficulty: 3
          annotations:
            - type: pattern
              label: Configurable Mock
              text: >-
                A mock with a <code>failFor</code> map lets you control exactly which calls fail, enabling precise
                testing of partial failure scenarios.
            - type: idiom
              label: Continue on Error
              text: >-
                Continuing despite individual failures and returning a summary (count + aggregated errors) is common in
                batch operations like notifications.
            - type: alternative
              label: errgroup
              text: >-
                For concurrent sends, consider <code>golang.org/x/sync/errgroup</code> which manages goroutines and
                collects the first error.
