conceptLinks:
  Generics: "#lesson-generics"
  Stacks: "#lesson-stacks"
  Slices: "#lesson-slices"
sharedContent: {}
variants:
  warmups:
    - id: warmup_1
      concept: Generics
      variants:
        - id: v1
          title: Merge String Maps
          description: >-
            Write <code>func merge[K comparable, V any](a, b map[K]V) map[K]V</code> that merges two maps. Values from
            <code>b</code> override values from <code>a</code> when keys conflict.
          hints:
            - Create a new map with <code>make(map[K]V)</code>.
            - >-
              Copy all entries from <code>a</code> first, then copy all from <code>b</code> to let <code>b</code>
              override.
          solution: |-
            func merge[K comparable, V any](a, b map[K]V) map[K]V {
                result := make(map[K]V)
                for k, v := range a {
                    result[k] = v
                }
                for k, v := range b {
                    result[k] = v
                }
                return result
            }
          annotations:
            - type: idiom
              label: Generic Constraints
              text: >-
                The <code>comparable</code> constraint is required for map keys because Go maps need keys that support
                <code>==</code> and <code>!=</code>.
            - type: gotcha
              label: Nil Map Write
              text: Writing to a nil map panics. Always use <code>make()</code> to initialize a map before writing to it.
        - id: v2
          title: Merge with Priority Flag
          description: >-
            Write <code>func mergeWith[K comparable, V any](a, b map[K]V, preferA bool) map[K]V</code>. If
            <code>preferA</code> is true, values from <code>a</code> take priority on conflicts; otherwise
            <code>b</code> wins.
          hints:
            - Start by copying both maps into the result.
            - Control which map you copy second to determine which one overrides.
          solution: |-
            func mergeWith[K comparable, V any](a, b map[K]V, preferA bool) map[K]V {
                result := make(map[K]V)
                if preferA {
                    for k, v := range b {
                        result[k] = v
                    }
                    for k, v := range a {
                        result[k] = v
                    }
                } else {
                    for k, v := range a {
                        result[k] = v
                    }
                    for k, v := range b {
                        result[k] = v
                    }
                }
                return result
            }
          annotations:
            - type: idiom
              label: Copy Order Matters
              text: >-
                When merging maps, the map copied second wins on conflicts. This is a common Go idiom for setting
                defaults then overriding.
            - type: alternative
              label: Conditional Insert
              text: >-
                Alternatively, copy both maps in any order but check existence with the comma-ok pattern before
                overwriting.
        - id: v3
          title: Merge Integer Maps with Sum
          description: >-
            Write <code>func mergeSum(a, b map[string]int) map[string]int</code> that merges two maps by
            <strong>summing</strong> values for shared keys instead of overriding.
          hints:
            - >-
              Create a result map, copy all from <code>a</code>, then for each entry in <code>b</code> add to the
              existing value.
            - Remember that accessing a missing int map key returns <code>0</code>.
          solution: |-
            func mergeSum(a, b map[string]int) map[string]int {
                result := make(map[string]int)
                for k, v := range a {
                    result[k] += v
                }
                for k, v := range b {
                    result[k] += v
                }
                return result
            }
          annotations:
            - type: idiom
              label: Zero Value Addition
              text: >-
                In Go, <code>result[k] += v</code> works even if <code>k</code> is not yet in the map because the zero
                value for <code>int</code> is <code>0</code>.
            - type: complexity
              label: O(n+m)
              text: Iterates through both maps once, where n and m are the sizes of maps a and b.
        - id: v4
          title: Merge Multiple Maps
          description: >-
            Write <code>func mergeAll[K comparable, V any](maps ...map[K]V) map[K]V</code> that merges any number of
            maps. Later maps override earlier ones on conflicts.
          hints:
            - Use a variadic parameter <code>...map[K]V</code>.
            - Iterate through each map in order, copying entries into a single result map.
          solution: |-
            func mergeAll[K comparable, V any](maps ...map[K]V) map[K]V {
                result := make(map[K]V)
                for _, m := range maps {
                    for k, v := range m {
                        result[k] = v
                    }
                }
                return result
            }
          annotations:
            - type: idiom
              label: Variadic Generics
              text: >-
                Combining generics with variadic parameters (<code>...map[K]V</code>) creates flexible, reusable utility
                functions.
            - type: gotcha
              label: Nil Map in Variadic
              text: Ranging over a nil map is safe in Go (zero iterations), so nil entries in the variadic list won't panic.
  challenges:
    - id: challenge_1
      block: 1
      difficulty: 2
      concept: Generics
      docLinks:
        - url: https://go.dev/ref/spec#Type_parameter_declarations
          title: "Go Spec: Type parameters"
          note: generic type syntax
        - url: https://go.dev/blog/intro-generics
          title: "Go Blog: An Introduction To Generics"
          note: generics tutorial
      variants:
        - id: v1
          title: Generic Filter
          description: >-
            Write <code>func Filter[T any](items []T, pred func(T) bool) []T</code> that returns a new slice containing
            only elements for which the predicate returns true.
          functionSignature: func Filter[T any](items []T, pred func(T) bool) []T
          testCases:
            - input: Filter([]int{1, 2, 3, 4, 5}, func(n int) bool { return n%2 == 0 })
              output: "[]int{2, 4}"
            - input: Filter([]string{"go", "rust", "zig"}, func(s string) bool { return len(s) == 2 })
              output: "[]string{\"go\"}"
          hints:
            - title: ðŸ¤” Think about it
              content: How do you build a new slice from a subset of elements? What determines which elements to keep?
            - title: ðŸ’¡ Hint
              content: >-
                Create an empty result slice. Range over items, call <code>pred(item)</code>, and append if it returns
                true.
            - title: ðŸ”§ Pattern
              content: |-
                <pre>1. Create empty result slice
                2. For each item:
                   - Call pred(item)
                   - If true, append to result
                3. Return result</pre>
          solution: |-
            func Filter[T any](items []T, pred func(T) bool) []T {
                result := make([]T, 0)
                for _, item := range items {
                    if pred(item) {
                        result = append(result, item)
                    }
                }
                return result
            }
          difficulty: 2
          annotations:
            - type: idiom
              label: Generic Functions
              text: >-
                Go 1.18+ supports type parameters. <code>[T any]</code> means T can be any type. The function works with
                int, string, or any other type.
            - type: complexity
              label: O(n)
              text: Single pass through the slice. The predicate is called once per element.
        - id: v2
          title: Generic Map (Transform)
          description: >-
            Write <code>func Map[T any, U any](items []T, fn func(T) U) []U</code> that applies a transformation
            function to each element and returns a new slice.
          functionSignature: func Map[T any, U any](items []T, fn func(T) U) []U
          testCases:
            - input: Map([]int{1, 2, 3}, func(n int) int { return n * 2 })
              output: "[]int{2, 4, 6}"
            - input: Map([]string{"go", "rust"}, func(s string) int { return len(s) })
              output: "[]int{2, 4}"
          hints:
            - title: ðŸ¤” Think about it
              content: You need to transform each element from type T to type U. What does the result slice look like?
            - title: ðŸ’¡ Hint
              content: >-
                Pre-allocate <code>result := make([]U, len(items))</code> since you know the output size. Assign
                <code>result[i] = fn(items[i])</code>.
            - title: ðŸ”§ Pattern
              content: |-
                <pre>1. Allocate result slice of same length
                2. For each index and item:
                   - result[i] = fn(item)
                3. Return result</pre>
          solution: |-
            func Map[T any, U any](items []T, fn func(T) U) []U {
                result := make([]U, len(items))
                for i, item := range items {
                    result[i] = fn(item)
                }
                return result
            }
          difficulty: 2
          annotations:
            - type: idiom
              label: Two Type Parameters
              text: >-
                Generic functions can have multiple type parameters. <code>[T any, U any]</code> allows input and output
                to be different types.
            - type: alternative
              label: Pre-allocate vs Append
              text: >-
                When the output length equals the input length, pre-allocate with <code>make([]U, len(items))</code>
                instead of using append for better performance.
        - id: v3
          title: Generic Reduce
          description: >-
            Write <code>func Reduce[T any, U any](items []T, initial U, fn func(U, T) U) U</code> that reduces a slice
            to a single value by applying a function cumulatively.
          functionSignature: func Reduce[T any, U any](items []T, initial U, fn func(U, T) U) U
          testCases:
            - input: Reduce([]int{1, 2, 3, 4}, 0, func(acc, n int) int { return acc + n })
              output: "10"
            - input: Reduce([]string{"a", "b", "c"}, "", func(acc, s string) string { return acc + s })
              output: "\"abc\""
          hints:
            - title: ðŸ¤” Think about it
              content: >-
                You need to accumulate a result by processing each element. What is the starting value and how does it
                change with each element?
            - title: ðŸ’¡ Hint
              content: >-
                Start with <code>acc := initial</code>. For each item, update <code>acc = fn(acc, item)</code>. Return
                acc at the end.
            - title: ðŸ”§ Pattern
              content: |-
                <pre>1. Set accumulator = initial value
                2. For each item:
                   - accumulator = fn(accumulator, item)
                3. Return accumulator</pre>
          solution: |-
            func Reduce[T any, U any](items []T, initial U, fn func(U, T) U) U {
                acc := initial
                for _, item := range items {
                    acc = fn(acc, item)
                }
                return acc
            }
          difficulty: 3
          annotations:
            - type: pattern
              label: Fold/Reduce
              text: >-
                Reduce (also called fold) is a fundamental functional programming pattern. It can express sum, product,
                concatenation, and many other aggregations.
            - type: complexity
              label: O(n)
              text: Single pass through the slice. Total complexity depends on the provided function.
        - id: v4
          title: Generic Contains
          description: >-
            Write <code>func Contains[T comparable](items []T, target T) bool</code> that returns true if the target
            element is found in the slice.
          functionSignature: func Contains[T comparable](items []T, target T) bool
          testCases:
            - input: Contains([]int{1, 2, 3}, 2)
              output: "true"
            - input: Contains([]string{"go", "rust"}, "python")
              output: "false"
            - input: Contains([]int{}, 1)
              output: "false"
          hints:
            - title: ðŸ¤” Think about it
              content: Why does this function need the <code>comparable</code> constraint instead of <code>any</code>?
            - title: ðŸ’¡ Hint
              content: Loop through items, compare each with <code>==</code>. Return true on first match, false after the loop.
            - title: ðŸ”§ Pattern
              content: |-
                <pre>1. For each item:
                   - If item == target, return true
                2. Return false (not found)</pre>
          solution: |-
            func Contains[T comparable](items []T, target T) bool {
                for _, item := range items {
                    if item == target {
                        return true
                    }
                }
                return false
            }
          difficulty: 2
          annotations:
            - type: idiom
              label: Comparable Constraint
              text: >-
                The <code>comparable</code> constraint is needed because <code>==</code> is not defined for all types
                (e.g., slices, maps, functions cannot be compared).
            - type: stdlib
              label: slices.Contains
              text: >-
                Go 1.21+ provides <code>slices.Contains()</code> in the standard library, but implementing it yourself
                teaches the underlying pattern.
    - id: challenge_2
      block: 2
      difficulty: 3
      concept: Stacks
      docLinks:
        - url: https://go.dev/ref/spec#Slice_types
          title: "Go Spec: Slice types"
          note: slices as dynamic arrays for stacks
        - url: https://go.dev/ref/spec#Appending_and_copying_slices
          title: "Go Spec: Appending and copying slices"
          note: append for push, reslice for pop
      variants:
        - id: v1
          title: Balanced Brackets
          description: >-
            Write <code>func isBalanced(s string) bool</code> that checks if a string of brackets <code>()[]{}</code> is
            properly balanced. Non-bracket characters should be ignored.
          functionSignature: func isBalanced(s string) bool
          testCases:
            - input: "\"({[]})\""
              output: "true"
            - input: "\"([)]\""
              output: "false"
            - input: "\"((())\""
              output: "false"
            - input: "\"\""
              output: "true"
          hints:
            - title: ðŸ¤” Think about it
              content: >-
                When you see a closing bracket, what do you need to check? What data structure helps you remember the
                most recent unmatched opening bracket?
            - title: ðŸ’¡ Hint
              content: >-
                Use a slice as a stack. Push opening brackets, pop on closing brackets and check if they match. The
                stack should be empty at the end.
            - title: ðŸ”§ Pattern
              content: |-
                <pre>1. Create bracket pairs map: closing -> opening
                2. For each character:
                   - Opening bracket? Push to stack
                   - Closing bracket? Pop and verify match
                3. Return: is stack empty?</pre>
          solution: |-
            func isBalanced(s string) bool {
                stack := make([]rune, 0)
                pairs := map[rune]rune{')': '(', ']': '[', '}': '{'}

                for _, ch := range s {
                    switch ch {
                    case '(', '[', '{':
                        stack = append(stack, ch)
                    case ')', ']', '}':
                        if len(stack) == 0 || stack[len(stack)-1] != pairs[ch] {
                            return false
                        }
                        stack = stack[:len(stack)-1]
                    }
                }
                return len(stack) == 0
            }
          difficulty: 3
          annotations:
            - type: idiom
              label: Slice as Stack
              text: >-
                Go has no built-in stack type. Use a slice with <code>append()</code> for push and
                <code>s[:len(s)-1]</code> for pop.
            - type: complexity
              label: O(n)
              text: Single pass through the string. Each character is pushed and popped at most once.
        - id: v2
          title: Valid HTML Tags
          description: >-
            Write <code>func isValidHTML(s string) bool</code> that checks if simple HTML tags are properly nested. Tags
            are like <code>&lt;b&gt;</code> and <code>&lt;/b&gt;</code>. Self-closing tags and attributes are not used.
          functionSignature: func isValidHTML(s string) bool
          testCases:
            - input: "\"<b><i></i></b>\""
              output: "true"
            - input: "\"<b><i></b></i>\""
              output: "false"
            - input: "\"<p></p><div></div>\""
              output: "true"
            - input: "\"<p>\""
              output: "false"
          hints:
            - title: ðŸ¤” Think about it
              content: >-
                This is the bracket matching problem but with named tags. What needs to match when you encounter a
                closing tag?
            - title: ðŸ’¡ Hint
              content: >-
                Extract tag names between < and >. Push opening tags onto a stack. When you see a closing tag (starts
                with /), pop and check if the names match.
            - title: ðŸ”§ Pattern
              content: |-
                <pre>1. Parse tag names from the string
                2. For each tag:
                   - Opening tag? Push name to stack
                   - Closing tag? Pop and verify name matches
                3. Return: is stack empty?</pre>
          solution: |-
            func isValidHTML(s string) bool {
                stack := make([]string, 0)
                i := 0
                for i < len(s) {
                    if s[i] == '<' {
                        j := i + 1
                        for j < len(s) && s[j] != '>' {
                            j++
                        }
                        if j >= len(s) {
                            return false
                        }
                        tag := s[i+1 : j]
                        if len(tag) > 0 && tag[0] == '/' {
                            name := tag[1:]
                            if len(stack) == 0 || stack[len(stack)-1] != name {
                                return false
                            }
                            stack = stack[:len(stack)-1]
                        } else {
                            stack = append(stack, tag)
                        }
                        i = j + 1
                    } else {
                        i++
                    }
                }
                return len(stack) == 0
            }
          difficulty: 3
          annotations:
            - type: pattern
              label: Stack-Based Parsing
              text: >-
                Stacks are fundamental to parsing nested structures. Compilers and interpreters use this same pattern
                for syntax analysis.
            - type: gotcha
              label: String Slicing
              text: >-
                Go string slicing <code>s[i:j]</code> operates on bytes. For ASCII HTML tags this is fine, but be
                careful with Unicode content.
        - id: v3
          title: Reverse Polish Notation
          description: >-
            Write <code>func evalRPN(tokens []string) int</code> that evaluates an expression in Reverse Polish
            Notation. Supports <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code> (integer division).
          functionSignature: func evalRPN(tokens []string) int
          testCases:
            - input: "[]string{\"2\", \"3\", \"+\"}"
              output: "5"
            - input: "[]string{\"4\", \"13\", \"5\", \"/\", \"+\"}"
              output: "6"
            - input: "[]string{\"3\", \"4\", \"*\", \"2\", \"-\"}"
              output: "10"
          hints:
            - title: ðŸ¤” Think about it
              content: >-
                In RPN, operators act on the two most recent numbers. What data structure naturally gives you access to
                the most recent items?
            - title: ðŸ’¡ Hint
              content: >-
                Use a stack. Push numbers. When you see an operator, pop two numbers, apply the operator, push the
                result. The final answer is the last item on the stack.
            - title: ðŸ”§ Pattern
              content: |-
                <pre>1. For each token:
                   - Number? Parse and push to stack
                   - Operator? Pop b, pop a, push a op b
                2. Return top of stack</pre>
          solution: |-
            func evalRPN(tokens []string) int {
                stack := make([]int, 0)
                for _, tok := range tokens {
                    switch tok {
                    case "+", "-", "*", "/":
                        b := stack[len(stack)-1]
                        a := stack[len(stack)-2]
                        stack = stack[:len(stack)-2]
                        switch tok {
                        case "+":
                            stack = append(stack, a+b)
                        case "-":
                            stack = append(stack, a-b)
                        case "*":
                            stack = append(stack, a*b)
                        case "/":
                            stack = append(stack, a/b)
                        }
                    default:
                        n, _ := strconv.Atoi(tok)
                        stack = append(stack, n)
                    }
                }
                return stack[0]
            }
          difficulty: 3
          annotations:
            - type: pattern
              label: Stack-Based Evaluation
              text: >-
                RPN evaluation is a classic stack application. Calculators like the HP-48 use this notation because it
                eliminates the need for parentheses.
            - type: gotcha
              label: Operand Order
              text: >-
                When popping two operands, the first popped is the right operand (b) and the second is the left (a).
                Getting this wrong breaks subtraction and division.
            - type: complexity
              label: O(n)
              text: Each token is processed exactly once. Stack operations are O(1) amortized.
        - id: v4
          title: Min Stack
          description: >-
            Implement a <code>MinStack</code> that supports <code>Push(val int)</code>, <code>Pop() int</code>,
            <code>Top() int</code>, and <code>Min() int</code>. All operations must be O(1).
          functionSignature: func NewMinStack() *MinStack
          testCases:
            - input: s := NewMinStack(); s.Push(3); s.Push(1); s.Push(2); s.Min()
              output: "1"
            - input: s := NewMinStack(); s.Push(3); s.Push(1); s.Pop(); s.Min()
              output: "3"
          hints:
            - title: ðŸ¤” Think about it
              content: >-
                If you only track one minimum value, what happens when you pop that minimum? How can you remember the
                previous minimum?
            - title: ðŸ’¡ Hint
              content: >-
                Use two stacks: one for values and one for minimums. When pushing, also push the current minimum onto
                the min stack. When popping, pop from both.
            - title: ðŸ”§ Pattern
              content: |-
                <pre>1. Maintain two parallel stacks: values and mins
                2. Push: push value; push min(value, current min) to mins
                3. Pop: pop from both stacks
                4. Min: peek at top of mins stack</pre>
          solution: |-
            type MinStack struct {
                values []int
                mins   []int
            }

            func NewMinStack() *MinStack {
                return &MinStack{}
            }

            func (s *MinStack) Push(val int) {
                s.values = append(s.values, val)
                if len(s.mins) == 0 || val <= s.mins[len(s.mins)-1] {
                    s.mins = append(s.mins, val)
                } else {
                    s.mins = append(s.mins, s.mins[len(s.mins)-1])
                }
            }

            func (s *MinStack) Pop() int {
                val := s.values[len(s.values)-1]
                s.values = s.values[:len(s.values)-1]
                s.mins = s.mins[:len(s.mins)-1]
                return val
            }

            func (s *MinStack) Top() int {
                return s.values[len(s.values)-1]
            }

            func (s *MinStack) Min() int {
                return s.mins[len(s.mins)-1]
            }
          difficulty: 3
          annotations:
            - type: pattern
              label: Auxiliary Stack
              text: >-
                Using a parallel stack to track metadata (like minimums) is a classic pattern for achieving O(1)
                operations on additional properties.
            - type: complexity
              label: O(1) all ops
              text: Push, Pop, Top, and Min are all O(1) time. The trade-off is O(n) extra space for the mins stack.
            - type: alternative
              label: Space Optimization
              text: >-
                An optimization: only push to the min stack when the new value is less than or equal to the current min,
                and only pop from it when the popped value equals the current min.
