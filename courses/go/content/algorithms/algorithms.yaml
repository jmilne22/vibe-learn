categories:
  - id: arrays-hashing
    name: Arrays & Hashing
    icon: "#"
    order: 1
    description: "Hash maps, frequency counting, set operations"
    problems:
      - id: two-sum
        name: Two Sum
        concept: "Hash Map Complement"
        difficulty: 2
        docLinks:
          - url: https://go.dev/doc/effective_go#maps
            title: "Effective Go: Maps"
            note: "How to use maps as hash tables in Go"
          - url: https://go.dev/blog/maps
            title: "Go Maps in Action"
            note: "Map operations, existence checks with comma-ok"
        patternPrimer:
          bruteForce: "Nested loops checking all pairs - O(n^2)"
          bestApproach: "Single pass with hash map storing complement - O(n)"
          typical: "Build map of value->index, check if complement exists"
        variants:
          - id: v1
            title: Two Sum
            difficulty: 1
            description: "Given an array of integers nums and an integer target, return the indices of the two numbers that add up to target. You may assume each input has exactly one solution, and you may not use the same element twice."
            hints:
              - "For each number, its complement is target - num. Can you look up complements quickly?"
              - "Use a map to store each number's index as you iterate. Before inserting, check if the complement already exists in the map."
              - "One pass: for each num, check if target-num is in the map. If yes, return both indices. If no, store num->index."
            solution: |
              func twoSum(nums []int, target int) []int {
                  seen := make(map[int]int)
                  for i, num := range nums {
                      complement := target - num
                      if j, ok := seen[complement]; ok {
                          return []int{j, i}
                      }
                      seen[num] = i
                  }
                  return nil
              }
            testCases: |
              fmt.Println(twoSum([]int{2, 7, 11, 15}, 9))  // [0 1]
              fmt.Println(twoSum([]int{3, 2, 4}, 6))        // [1 2]
              fmt.Println(twoSum([]int{3, 3}, 6))            // [0 1]
          - id: v2
            title: Two Sum - Return Values
            difficulty: 2
            description: "Given an array of integers and a target, return all unique pairs of values that add up to the target. Each pair should be sorted in ascending order, and the result should not contain duplicate pairs."
            hints:
              - "Use a set (map[int]bool) to track which numbers you have seen. For each number, check if its complement has been seen."
              - "To avoid duplicate pairs, also track which numbers have already been paired using a second set."
              - "Sort each pair before adding to results, and use a seen-pairs set or sort final results to ensure uniqueness."
            solution: |
              func twoSumPairs(nums []int, target int) [][]int {
                  seen := make(map[int]bool)
                  used := make(map[int]bool)
                  var result [][]int
                  for _, num := range nums {
                      complement := target - num
                      if seen[complement] && !used[complement] {
                          a, b := complement, num
                          if a > b {
                              a, b = b, a
                          }
                          result = append(result, []int{a, b})
                          used[num] = true
                          used[complement] = true
                      }
                      seen[num] = true
                  }
                  return result
              }
            testCases: |
              fmt.Println(twoSumPairs([]int{1, 5, 3, 7, 4, 2, 6}, 7))  // [[1 6] [3 4] [5 2]] or similar unique pairs
              fmt.Println(twoSumPairs([]int{1, 1, 1, 1}, 2))            // [[1 1]]
              fmt.Println(twoSumPairs([]int{2, 4}, 10))                  // []
          - id: v3
            title: Three Sum
            difficulty: 3
            description: "Given an integer array nums, return all unique triplets [nums[i], nums[j], nums[k]] such that i != j != k and nums[i] + nums[j] + nums[k] == 0. The solution set must not contain duplicate triplets."
            hints:
              - "Sort the array first, then reduce to two-sum. For each element, find pairs in the remaining array that sum to its negative."
              - "After sorting, iterate with index i. For each i, use two pointers (lo, hi) on the subarray to the right to find pairs summing to -nums[i]."
              - "Skip duplicate values for i, lo, and hi to avoid duplicate triplets."
            solution: |
              func threeSum(nums []int) [][]int {
                  sort.Ints(nums)
                  var result [][]int
                  for i := 0; i < len(nums)-2; i++ {
                      if i > 0 && nums[i] == nums[i-1] {
                          continue
                      }
                      lo, hi := i+1, len(nums)-1
                      for lo < hi {
                          sum := nums[i] + nums[lo] + nums[hi]
                          if sum == 0 {
                              result = append(result, []int{nums[i], nums[lo], nums[hi]})
                              for lo < hi && nums[lo] == nums[lo+1] {
                                  lo++
                              }
                              for lo < hi && nums[hi] == nums[hi-1] {
                                  hi--
                              }
                              lo++
                              hi--
                          } else if sum < 0 {
                              lo++
                          } else {
                              hi--
                          }
                      }
                  }
                  return result
              }
            testCases: |
              fmt.Println(threeSum([]int{-1, 0, 1, 2, -1, -4}))  // [[-1 -1 2] [-1 0 1]]
              fmt.Println(threeSum([]int{0, 0, 0}))               // [[0 0 0]]
              fmt.Println(threeSum([]int{1, 2, -3}))              // [[-3 1 2]]

      - id: contains-duplicate
        name: Contains Duplicate
        concept: "Set Membership"
        difficulty: 1
        docLinks:
          - url: https://go.dev/doc/effective_go#maps
            title: "Effective Go: Maps"
            note: "Using maps as sets for O(1) lookups"
          - url: https://go.dev/blog/maps
            title: "Go Maps in Action"
            note: "Map existence checks and iteration"
        patternPrimer:
          bruteForce: "Compare every pair with nested loops - O(n^2)"
          bestApproach: "Use a hash set to check membership in O(1) - total O(n)"
          typical: "Insert into set, check if already present before inserting"
        variants:
          - id: v1
            title: Contains Duplicate
            difficulty: 1
            description: "Given an integer array nums, return true if any value appears at least twice in the array, and return false if every element is distinct."
            hints:
              - "A set lets you check if you have seen a value before in O(1) time."
              - "Iterate through the array. For each element, check if it is already in the set. If yes, return true. Otherwise, add it."
            solution: |
              func containsDuplicate(nums []int) bool {
                  seen := make(map[int]bool)
                  for _, num := range nums {
                      if seen[num] {
                          return true
                      }
                      seen[num] = true
                  }
                  return false
              }
            testCases: |
              fmt.Println(containsDuplicate([]int{1, 2, 3, 1}))     // true
              fmt.Println(containsDuplicate([]int{1, 2, 3, 4}))     // false
              fmt.Println(containsDuplicate([]int{1, 1, 1, 3, 3}))  // true
          - id: v2
            title: Contains Duplicate II
            difficulty: 2
            description: "Given an integer array nums and an integer k, return true if there are two distinct indices i and j such that nums[i] == nums[j] and abs(i - j) <= k."
            hints:
              - "You need to check not just for duplicates but that they are within distance k of each other."
              - "Use a map from value to its most recent index. When you find a duplicate, check the index distance."
              - "Alternatively, maintain a sliding window set of size k. Add the new element and remove the element that fell out of the window."
            solution: |
              func containsNearbyDuplicate(nums []int, k int) bool {
                  seen := make(map[int]int)
                  for i, num := range nums {
                      if j, ok := seen[num]; ok && i-j <= k {
                          return true
                      }
                      seen[num] = i
                  }
                  return false
              }
            testCases: |
              fmt.Println(containsNearbyDuplicate([]int{1, 2, 3, 1}, 3))      // true
              fmt.Println(containsNearbyDuplicate([]int{1, 0, 1, 1}, 1))      // true
              fmt.Println(containsNearbyDuplicate([]int{1, 2, 3, 1, 2, 3}, 2)) // false
          - id: v3
            title: Contains Duplicate III
            difficulty: 3
            description: "Given an integer array nums and two integers indexDiff and valueDiff, return true if there exists a pair of indices (i, j) such that i != j, abs(i - j) <= indexDiff, and abs(nums[i] - nums[j]) <= valueDiff."
            hints:
              - "Think about bucketing: if you put numbers into buckets of size valueDiff+1, numbers in the same bucket are within valueDiff of each other."
              - "Maintain a sliding window of size indexDiff. For each new number, compute its bucket. Check the same bucket and adjacent buckets."
              - "Use bucket ID = num / (valueDiff+1). Be careful with negative numbers: shift values so all are non-negative, or adjust bucket calculation."
            solution: |
              func containsNearbyAlmostDuplicate(nums []int, indexDiff int, valueDiff int) bool {
                  if valueDiff < 0 {
                      return false
                  }
                  buckets := make(map[int]int)
                  w := valueDiff + 1

                  getBucket := func(val int) int {
                      if val >= 0 {
                          return val / w
                      }
                      return (val+1)/w - 1
                  }

                  for i, num := range nums {
                      b := getBucket(num)
                      if _, ok := buckets[b]; ok {
                          return true
                      }
                      if v, ok := buckets[b-1]; ok && num-v <= valueDiff {
                          return true
                      }
                      if v, ok := buckets[b+1]; ok && v-num <= valueDiff {
                          return true
                      }
                      buckets[b] = num
                      if i >= indexDiff {
                          delete(buckets, getBucket(nums[i-indexDiff]))
                      }
                  }
                  return false
              }
            testCases: |
              fmt.Println(containsNearbyAlmostDuplicate([]int{1, 2, 3, 1}, 3, 0))      // true
              fmt.Println(containsNearbyAlmostDuplicate([]int{1, 5, 9, 1, 5, 9}, 2, 3)) // false
              fmt.Println(containsNearbyAlmostDuplicate([]int{1, 2, 1, 1}, 1, 0))       // true

      - id: valid-anagram
        name: Valid Anagram
        concept: "Frequency Counting"
        difficulty: 1
        docLinks:
          - url: https://go.dev/doc/effective_go#maps
            title: "Effective Go: Maps"
            note: "Counting character frequencies with maps"
          - url: https://pkg.go.dev/strings
            title: "strings package"
            note: "String manipulation helpers"
        patternPrimer:
          bruteForce: "Sort both strings and compare - O(n log n)"
          bestApproach: "Count character frequencies with a map or array - O(n)"
          typical: "Build frequency map from first string, decrement from second, check all zeros"
        variants:
          - id: v1
            title: Valid Anagram
            difficulty: 1
            description: "Given two strings s and t, return true if t is an anagram of s, and false otherwise. An anagram uses all the original letters exactly once."
            hints:
              - "Two strings are anagrams if they have the same character frequencies."
              - "Count character frequencies for both strings and compare, or increment for one and decrement for the other."
            solution: |
              func isAnagram(s string, t string) bool {
                  if len(s) != len(t) {
                      return false
                  }
                  count := make(map[rune]int)
                  for _, ch := range s {
                      count[ch]++
                  }
                  for _, ch := range t {
                      count[ch]--
                      if count[ch] < 0 {
                          return false
                      }
                  }
                  return true
              }
            testCases: |
              fmt.Println(isAnagram("anagram", "nagaram"))  // true
              fmt.Println(isAnagram("rat", "car"))          // false
              fmt.Println(isAnagram("listen", "silent"))    // true
          - id: v2
            title: Group Anagrams
            difficulty: 2
            description: "Given an array of strings strs, group the anagrams together. You can return the answer in any order. An anagram is a word formed by rearranging the letters of another word."
            hints:
              - "All anagrams produce the same string when sorted. Use the sorted version as a map key."
              - "Build a map from sorted-string to list of original strings. Then collect the map values."
              - "In Go, convert string to []byte, sort it with sort.Slice, convert back to use as key."
            solution: |
              func groupAnagrams(strs []string) [][]string {
                  groups := make(map[string][]string)
                  for _, s := range strs {
                      bs := []byte(s)
                      sort.Slice(bs, func(i, j int) bool { return bs[i] < bs[j] })
                      key := string(bs)
                      groups[key] = append(groups[key], s)
                  }
                  result := make([][]string, 0, len(groups))
                  for _, group := range groups {
                      result = append(result, group)
                  }
                  return result
              }
            testCases: |
              fmt.Println(groupAnagrams([]string{"eat", "tea", "tan", "ate", "nat", "bat"}))
              // [["eat","tea","ate"],["tan","nat"],["bat"]] (order may vary)
              fmt.Println(groupAnagrams([]string{""}))   // [[""]]
              fmt.Println(groupAnagrams([]string{"a"}))  // [["a"]]
          - id: v3
            title: Find All Anagram Substrings
            difficulty: 2
            description: "Given two strings s and p, return a list of start indices of p's anagrams in s. An anagram of p is any permutation of p. The output can be in any order."
            hints:
              - "Use a sliding window of length len(p) over s. Compare character frequencies."
              - "Maintain a frequency count for the window. When sliding right, add the new char and remove the old one."
              - "Track how many characters have the correct count to avoid comparing full maps each step."
            solution: |
              func findAnagrams(s string, p string) []int {
                  if len(s) < len(p) {
                      return nil
                  }
                  var result []int
                  var sCount, pCount [26]int
                  for _, ch := range p {
                      pCount[ch-'a']++
                  }
                  for i := 0; i < len(s); i++ {
                      sCount[s[i]-'a']++
                      if i >= len(p) {
                          sCount[s[i-len(p)]-'a']--
                      }
                      if i >= len(p)-1 && sCount == pCount {
                          result = append(result, i-len(p)+1)
                      }
                  }
                  return result
              }
            testCases: |
              fmt.Println(findAnagrams("cbaebabacd", "abc"))  // [0 6]
              fmt.Println(findAnagrams("abab", "ab"))          // [0 1 2]
              fmt.Println(findAnagrams("af", "be"))            // []

      - id: top-k-frequent
        name: Top K Frequent Elements
        concept: "Frequency + Sorting"
        difficulty: 2
        docLinks:
          - url: https://go.dev/doc/effective_go#maps
            title: "Effective Go: Maps"
            note: "Building frequency maps"
          - url: https://pkg.go.dev/sort
            title: "sort package"
            note: "Sorting slices with custom comparators"
        patternPrimer:
          bruteForce: "Count frequencies, sort all entries by frequency - O(n log n)"
          bestApproach: "Count frequencies, use bucket sort by frequency - O(n)"
          typical: "Build frequency map, then sort or bucket-sort to extract top k"
        variants:
          - id: v1
            title: Top K Frequent Elements
            difficulty: 2
            description: "Given an integer array nums and an integer k, return the k most frequent elements. You may return the answer in any order."
            hints:
              - "First count the frequency of each element using a map."
              - "You can sort by frequency, but bucket sort is O(n). Create buckets where index = frequency, and values = elements with that frequency."
              - "Walk the buckets from highest to lowest, collecting elements until you have k."
            solution: |
              func topKFrequent(nums []int, k int) []int {
                  freq := make(map[int]int)
                  for _, num := range nums {
                      freq[num]++
                  }
                  // Bucket sort: index = frequency
                  buckets := make([][]int, len(nums)+1)
                  for num, count := range freq {
                      buckets[count] = append(buckets[count], num)
                  }
                  var result []int
                  for i := len(buckets) - 1; i >= 0 && len(result) < k; i-- {
                      result = append(result, buckets[i]...)
                  }
                  return result[:k]
              }
            testCases: |
              fmt.Println(topKFrequent([]int{1, 1, 1, 2, 2, 3}, 2))  // [1 2]
              fmt.Println(topKFrequent([]int{1}, 1))                   // [1]
              fmt.Println(topKFrequent([]int{4, 4, 4, 2, 2, 5}, 2))  // [4 2]
          - id: v2
            title: Sort Characters By Frequency
            difficulty: 2
            description: "Given a string s, sort it in decreasing order based on the frequency of the characters. If multiple characters have the same frequency, their order does not matter. Return the sorted string."
            hints:
              - "Count the frequency of each character using a map."
              - "Collect unique characters and sort them by their frequency in descending order."
              - "Build the result by repeating each character by its frequency."
            solution: |
              func frequencySort(s string) string {
                  freq := make(map[byte]int)
                  for i := 0; i < len(s); i++ {
                      freq[s[i]]++
                  }
                  chars := make([]byte, 0, len(freq))
                  for ch := range freq {
                      chars = append(chars, ch)
                  }
                  sort.Slice(chars, func(i, j int) bool {
                      return freq[chars[i]] > freq[chars[j]]
                  })
                  var result []byte
                  for _, ch := range chars {
                      for k := 0; k < freq[ch]; k++ {
                          result = append(result, ch)
                      }
                  }
                  return string(result)
              }
            testCases: |
              fmt.Println(frequencySort("tree"))    // "eert" or "eetr"
              fmt.Println(frequencySort("cccaaa"))  // "cccaaa" or "aaaccc"
              fmt.Println(frequencySort("Aabb"))    // "bbAa" or "aaBb"
          - id: v3
            title: Top K Frequent Words
            difficulty: 3
            description: "Given an array of strings words and an integer k, return the k most frequent strings. Return the answer sorted by frequency from highest to lowest. If two words have the same frequency, sort them in alphabetical order."
            hints:
              - "Count word frequencies with a map, then sort unique words by frequency (descending) with alphabetical tie-breaking."
              - "Use sort.Slice with a custom comparator that checks frequency first, then alphabetical order."
              - "Return the first k elements from the sorted list."
            solution: |
              func topKFrequentWords(words []string, k int) []string {
                  freq := make(map[string]int)
                  for _, w := range words {
                      freq[w]++
                  }
                  unique := make([]string, 0, len(freq))
                  for w := range freq {
                      unique = append(unique, w)
                  }
                  sort.Slice(unique, func(i, j int) bool {
                      if freq[unique[i]] != freq[unique[j]] {
                          return freq[unique[i]] > freq[unique[j]]
                      }
                      return unique[i] < unique[j]
                  })
                  return unique[:k]
              }
            testCases: |
              fmt.Println(topKFrequentWords([]string{"i", "love", "leetcode", "i", "love", "coding"}, 2))
              // [i love]
              fmt.Println(topKFrequentWords([]string{"the", "day", "is", "sunny", "the", "the", "the", "sunny", "is", "is"}, 4))
              // [the is sunny day]

      - id: product-except-self
        name: Product of Array Except Self
        concept: "Prefix/Suffix Products"
        difficulty: 2
        docLinks:
          - url: https://go.dev/doc/effective_go#slices
            title: "Effective Go: Slices"
            note: "Working with slices and pre-allocation"
          - url: https://go.dev/ref/spec#For_statements
            title: "Go Spec: For Statements"
            note: "Range loops and index-based iteration"
        patternPrimer:
          bruteForce: "For each element, multiply all others - O(n^2)"
          bestApproach: "Two passes: prefix products left-to-right, suffix products right-to-left - O(n)"
          typical: "Build prefix product array, then multiply in suffix products on a second pass"
        variants:
          - id: v1
            title: Product of Array Except Self
            difficulty: 2
            description: "Given an integer array nums, return an array answer such that answer[i] is equal to the product of all the elements of nums except nums[i]. You must solve it without using division and in O(n) time."
            hints:
              - "The product except self at index i is (product of all elements to the left) * (product of all elements to the right)."
              - "First pass: build an array of prefix products (left to right). Second pass: multiply in suffix products (right to left)."
              - "You can use the output array for prefix products, then a running variable for the suffix pass to achieve O(1) extra space."
            solution: |
              func productExceptSelf(nums []int) []int {
                  n := len(nums)
                  result := make([]int, n)
                  result[0] = 1
                  for i := 1; i < n; i++ {
                      result[i] = result[i-1] * nums[i-1]
                  }
                  suffix := 1
                  for i := n - 2; i >= 0; i-- {
                      suffix *= nums[i+1]
                      result[i] *= suffix
                  }
                  return result
              }
            testCases: |
              fmt.Println(productExceptSelf([]int{1, 2, 3, 4}))   // [24 12 8 6]
              fmt.Println(productExceptSelf([]int{-1, 1, 0, -3, 3})) // [0 0 9 0 0]
              fmt.Println(productExceptSelf([]int{2, 3}))          // [3 2]
          - id: v2
            title: Running Sum of Array
            difficulty: 1
            description: "Given an array nums, return the running sum of nums. The running sum at index i is the sum of all elements from index 0 to i inclusive."
            hints:
              - "This is a prefix sum: each element becomes the sum of all elements up to and including itself."
              - "Iterate and keep a running total, storing it at each index."
            solution: |
              func runningSum(nums []int) []int {
                  result := make([]int, len(nums))
                  result[0] = nums[0]
                  for i := 1; i < len(nums); i++ {
                      result[i] = result[i-1] + nums[i]
                  }
                  return result
              }
            testCases: |
              fmt.Println(runningSum([]int{1, 2, 3, 4}))      // [1 3 6 10]
              fmt.Println(runningSum([]int{1, 1, 1, 1, 1}))   // [1 2 3 4 5]
              fmt.Println(runningSum([]int{3, 1, 2, 10, 1}))  // [3 4 6 16 17]
          - id: v3
            title: Subarray Sum Equals K
            difficulty: 2
            description: "Given an array of integers nums and an integer k, return the total number of subarrays whose sum equals k."
            hints:
              - "A subarray sum from index i to j equals prefixSum[j+1] - prefixSum[i]. So you need pairs where the difference is k."
              - "Use a hash map to count prefix sums. For each prefix sum, check how many times (currentSum - k) has appeared."
              - "Initialize the map with {0: 1} to handle subarrays starting from index 0."
            solution: |
              func subarraySum(nums []int, k int) int {
                  count := 0
                  sum := 0
                  prefixCounts := map[int]int{0: 1}
                  for _, num := range nums {
                      sum += num
                      if c, ok := prefixCounts[sum-k]; ok {
                          count += c
                      }
                      prefixCounts[sum]++
                  }
                  return count
              }
            testCases: |
              fmt.Println(subarraySum([]int{1, 1, 1}, 2))       // 2
              fmt.Println(subarraySum([]int{1, 2, 3}, 3))       // 2
              fmt.Println(subarraySum([]int{1, -1, 0}, 0))      // 3

  - id: two-pointers
    name: Two Pointers
    icon: "â†”"
    order: 2
    description: "Opposite-end and same-direction pointer techniques"
    problems:
      - id: valid-palindrome
        name: Valid Palindrome
        concept: "Opposite-End Pointers"
        difficulty: 1
        docLinks:
          - url: https://pkg.go.dev/strings
            title: "strings package"
            note: "String utilities including ToLower"
          - url: https://pkg.go.dev/unicode
            title: "unicode package"
            note: "Character classification functions like IsLetter, IsDigit"
        patternPrimer:
          bruteForce: "Reverse the string and compare - O(n) space"
          bestApproach: "Two pointers from both ends, skip non-alphanumeric - O(1) space"
          typical: "Left pointer starts at 0, right at end. Move inward comparing characters."
        variants:
          - id: v1
            title: Valid Palindrome
            difficulty: 1
            description: "Given a string s, return true if it is a palindrome after converting all uppercase letters to lowercase and removing all non-alphanumeric characters."
            hints:
              - "Use two pointers: one at the start and one at the end. Move them toward each other."
              - "Skip non-alphanumeric characters. Use unicode.IsLetter and unicode.IsDigit to check."
              - "Compare lowercase versions of characters at both pointers."
            solution: |
              func isPalindrome(s string) bool {
                  s = strings.ToLower(s)
                  l, r := 0, len(s)-1
                  for l < r {
                      for l < r && !isAlphaNum(s[l]) {
                          l++
                      }
                      for l < r && !isAlphaNum(s[r]) {
                          r--
                      }
                      if s[l] != s[r] {
                          return false
                      }
                      l++
                      r--
                  }
                  return true
              }

              func isAlphaNum(c byte) bool {
                  return (c >= 'a' && c <= 'z') || (c >= '0' && c <= '9')
              }
            testCases: |
              fmt.Println(isPalindrome("A man, a plan, a canal: Panama"))  // true
              fmt.Println(isPalindrome("race a car"))                      // false
              fmt.Println(isPalindrome(" "))                               // true
          - id: v2
            title: Valid Palindrome II
            difficulty: 2
            description: "Given a string s, return true if s can be a palindrome after deleting at most one character from it."
            hints:
              - "Start with two pointers from both ends. When you find a mismatch, you have one chance to skip either the left or right character."
              - "When a mismatch occurs at (l, r), check if s[l+1..r] or s[l..r-1] is a palindrome."
              - "Write a helper function that checks if a substring is a palindrome."
            solution: |
              func validPalindrome(s string) bool {
                  l, r := 0, len(s)-1
                  for l < r {
                      if s[l] != s[r] {
                          return isPalin(s, l+1, r) || isPalin(s, l, r-1)
                      }
                      l++
                      r--
                  }
                  return true
              }

              func isPalin(s string, l, r int) bool {
                  for l < r {
                      if s[l] != s[r] {
                          return false
                      }
                      l++
                      r--
                  }
                  return true
              }
            testCases: |
              fmt.Println(validPalindrome("aba"))    // true
              fmt.Println(validPalindrome("abca"))   // true (remove 'c' or 'b')
              fmt.Println(validPalindrome("abc"))    // false
          - id: v3
            title: Longest Palindromic Substring
            difficulty: 3
            description: "Given a string s, return the longest palindromic substring in s."
            hints:
              - "A palindrome expands outward from its center. Try expanding from each possible center."
              - "There are 2n-1 possible centers: n single characters (odd-length palindromes) and n-1 gaps between characters (even-length)."
              - "For each center, expand outward while characters match. Track the longest found."
            solution: |
              func longestPalindrome(s string) string {
                  if len(s) < 2 {
                      return s
                  }
                  start, maxLen := 0, 1

                  expand := func(l, r int) {
                      for l >= 0 && r < len(s) && s[l] == s[r] {
                          if r-l+1 > maxLen {
                              start = l
                              maxLen = r - l + 1
                          }
                          l--
                          r++
                      }
                  }

                  for i := 0; i < len(s); i++ {
                      expand(i, i)   // odd length
                      expand(i, i+1) // even length
                  }
                  return s[start : start+maxLen]
              }
            testCases: |
              fmt.Println(longestPalindrome("babad"))  // "bab" or "aba"
              fmt.Println(longestPalindrome("cbbd"))   // "bb"
              fmt.Println(longestPalindrome("a"))      // "a"

      - id: two-sum-sorted
        name: Two Sum II - Sorted Array
        concept: "Sorted Array Pointers"
        difficulty: 1
        docLinks:
          - url: https://pkg.go.dev/sort
            title: "sort package"
            note: "Sorting slices for two-pointer technique"
          - url: https://go.dev/doc/effective_go#slices
            title: "Effective Go: Slices"
            note: "Working with sorted slices"
        patternPrimer:
          bruteForce: "Nested loops checking all pairs - O(n^2)"
          bestApproach: "Two pointers from ends of sorted array - O(n)"
          typical: "If sum too small, move left pointer right. If too large, move right pointer left."
        variants:
          - id: v1
            title: Two Sum II - Input Array Is Sorted
            difficulty: 1
            description: "Given a 1-indexed sorted array of integers, find two numbers that add up to a specific target. Return their indices (1-indexed). The solution must use constant extra space."
            hints:
              - "Since the array is sorted, start with one pointer at the beginning and one at the end."
              - "If the sum is too small, move the left pointer right to increase the sum. If too large, move the right pointer left."
            solution: |
              func twoSumSorted(numbers []int, target int) []int {
                  l, r := 0, len(numbers)-1
                  for l < r {
                      sum := numbers[l] + numbers[r]
                      if sum == target {
                          return []int{l + 1, r + 1}
                      } else if sum < target {
                          l++
                      } else {
                          r--
                      }
                  }
                  return nil
              }
            testCases: |
              fmt.Println(twoSumSorted([]int{2, 7, 11, 15}, 9))    // [1 2]
              fmt.Println(twoSumSorted([]int{2, 3, 4}, 6))          // [1 3]
              fmt.Println(twoSumSorted([]int{-1, 0}, -1))           // [1 2]
          - id: v2
            title: Three Sum with Two Pointers
            difficulty: 2
            description: "Given an integer array nums, return all unique triplets that sum to zero. Use sorting and two pointers (not hash maps)."
            hints:
              - "Sort the array. For each element, use two pointers on the remaining subarray to find pairs summing to its negative."
              - "Skip duplicates: if nums[i] == nums[i-1], skip i. Similarly skip duplicate lo and hi values."
              - "The two-pointer approach works because the array is sorted: move lo right if sum is too small, hi left if too large."
            solution: |
              func threeSumTP(nums []int) [][]int {
                  sort.Ints(nums)
                  var result [][]int
                  for i := 0; i < len(nums)-2; i++ {
                      if i > 0 && nums[i] == nums[i-1] {
                          continue
                      }
                      lo, hi := i+1, len(nums)-1
                      for lo < hi {
                          sum := nums[i] + nums[lo] + nums[hi]
                          if sum == 0 {
                              result = append(result, []int{nums[i], nums[lo], nums[hi]})
                              for lo < hi && nums[lo] == nums[lo+1] {
                                  lo++
                              }
                              for lo < hi && nums[hi] == nums[hi-1] {
                                  hi--
                              }
                              lo++
                              hi--
                          } else if sum < 0 {
                              lo++
                          } else {
                              hi--
                          }
                      }
                  }
                  return result
              }
            testCases: |
              fmt.Println(threeSumTP([]int{-1, 0, 1, 2, -1, -4}))  // [[-1 -1 2] [-1 0 1]]
              fmt.Println(threeSumTP([]int{0, 0, 0}))               // [[0 0 0]]
              fmt.Println(threeSumTP([]int{0, 0, 0, 0}))            // [[0 0 0]]
          - id: v3
            title: Four Sum
            difficulty: 3
            description: "Given an array nums of n integers and a target, return all unique quadruplets [nums[a], nums[b], nums[c], nums[d]] such that a, b, c, d are distinct indices and nums[a] + nums[b] + nums[c] + nums[d] == target."
            hints:
              - "Extend three-sum: fix two elements with outer loops, then use two pointers for the remaining pair."
              - "Sort the array first. Use two nested loops for the first two elements, then two pointers for the last two."
              - "Skip duplicates at every level to avoid duplicate quadruplets."
            solution: |
              func fourSum(nums []int, target int) [][]int {
                  sort.Ints(nums)
                  var result [][]int
                  n := len(nums)
                  for i := 0; i < n-3; i++ {
                      if i > 0 && nums[i] == nums[i-1] {
                          continue
                      }
                      for j := i + 1; j < n-2; j++ {
                          if j > i+1 && nums[j] == nums[j-1] {
                              continue
                          }
                          lo, hi := j+1, n-1
                          for lo < hi {
                              sum := nums[i] + nums[j] + nums[lo] + nums[hi]
                              if sum == target {
                                  result = append(result, []int{nums[i], nums[j], nums[lo], nums[hi]})
                                  for lo < hi && nums[lo] == nums[lo+1] {
                                      lo++
                                  }
                                  for lo < hi && nums[hi] == nums[hi-1] {
                                      hi--
                                  }
                                  lo++
                                  hi--
                              } else if sum < target {
                                  lo++
                              } else {
                                  hi--
                              }
                          }
                      }
                  }
                  return result
              }
            testCases: |
              fmt.Println(fourSum([]int{1, 0, -1, 0, -2, 2}, 0))
              // [[-2 -1 1 2] [-2 0 0 2] [-1 0 0 1]]
              fmt.Println(fourSum([]int{2, 2, 2, 2, 2}, 8))  // [[2 2 2 2]]

      - id: container-water
        name: Container With Most Water
        concept: "Maximize Area"
        difficulty: 2
        docLinks:
          - url: https://go.dev/doc/effective_go#slices
            title: "Effective Go: Slices"
            note: "Working with integer slices"
          - url: https://go.dev/ref/spec#For_statements
            title: "Go Spec: For Statements"
            note: "While-style loops in Go"
        patternPrimer:
          bruteForce: "Check all pairs of lines - O(n^2)"
          bestApproach: "Two pointers from ends, always move the shorter line inward - O(n)"
          typical: "Area = min(height[l], height[r]) * (r - l). Move the shorter pointer inward."
        variants:
          - id: v1
            title: Container With Most Water
            difficulty: 2
            description: "Given n non-negative integers height[0..n-1] where each represents a vertical line at position i, find two lines that together with the x-axis form a container that holds the most water. Return the maximum area."
            hints:
              - "Area between two lines is min(height[l], height[r]) * (r - l). Start with the widest container."
              - "Use two pointers at the ends. The width can only decrease, so to potentially increase area, move the shorter line inward."
              - "Moving the taller line can never help because the area is limited by the shorter line."
            solution: |
              func maxArea(height []int) int {
                  l, r := 0, len(height)-1
                  maxWater := 0
                  for l < r {
                      h := height[l]
                      if height[r] < h {
                          h = height[r]
                      }
                      area := h * (r - l)
                      if area > maxWater {
                          maxWater = area
                      }
                      if height[l] < height[r] {
                          l++
                      } else {
                          r--
                      }
                  }
                  return maxWater
              }
            testCases: |
              fmt.Println(maxArea([]int{1, 8, 6, 2, 5, 4, 8, 3, 7}))  // 49
              fmt.Println(maxArea([]int{1, 1}))                         // 1
              fmt.Println(maxArea([]int{4, 3, 2, 1, 4}))               // 16
          - id: v2
            title: Trapping Rain Water
            difficulty: 3
            description: "Given n non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it can trap after raining."
            hints:
              - "Water at position i = min(maxLeft, maxRight) - height[i]. The water level is determined by the shorter of the two tallest walls on each side."
              - "Two-pointer approach: maintain leftMax and rightMax. Process the side with the smaller max, since that determines the water level."
              - "If leftMax <= rightMax, water at l is leftMax - height[l]. Move l right. Otherwise process r."
            solution: |
              func trap(height []int) int {
                  if len(height) < 3 {
                      return 0
                  }
                  l, r := 0, len(height)-1
                  leftMax, rightMax := height[l], height[r]
                  water := 0
                  for l < r {
                      if leftMax <= rightMax {
                          l++
                          if height[l] > leftMax {
                              leftMax = height[l]
                          } else {
                              water += leftMax - height[l]
                          }
                      } else {
                          r--
                          if height[r] > rightMax {
                              rightMax = height[r]
                          } else {
                              water += rightMax - height[r]
                          }
                      }
                  }
                  return water
              }
            testCases: |
              fmt.Println(trap([]int{0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1}))  // 6
              fmt.Println(trap([]int{4, 2, 0, 3, 2, 5}))                      // 9
              fmt.Println(trap([]int{1, 2, 3}))                                // 0
          - id: v3
            title: Largest Rectangle in Histogram
            difficulty: 3
            description: "Given an array of integers heights representing the histogram's bar heights where the width of each bar is 1, return the area of the largest rectangle in the histogram."
            hints:
              - "For each bar, find how far left and right it can extend as the shortest bar. This determines the rectangle width."
              - "Use a monotonic increasing stack of indices. When a bar is shorter than the stack top, pop and calculate the area with the popped bar as the shortest."
              - "The width for a popped bar extends from the new stack top to the current index."
            solution: |
              func largestRectangleArea(heights []int) int {
                  stack := []int{}
                  maxArea := 0
                  for i := 0; i <= len(heights); i++ {
                      h := 0
                      if i < len(heights) {
                          h = heights[i]
                      }
                      for len(stack) > 0 && h < heights[stack[len(stack)-1]] {
                          top := stack[len(stack)-1]
                          stack = stack[:len(stack)-1]
                          width := i
                          if len(stack) > 0 {
                              width = i - stack[len(stack)-1] - 1
                          }
                          area := heights[top] * width
                          if area > maxArea {
                              maxArea = area
                          }
                      }
                      stack = append(stack, i)
                  }
                  return maxArea
              }
            testCases: |
              fmt.Println(largestRectangleArea([]int{2, 1, 5, 6, 2, 3}))  // 10
              fmt.Println(largestRectangleArea([]int{2, 4}))               // 4
              fmt.Println(largestRectangleArea([]int{1, 1, 1, 1}))        // 4

      - id: remove-duplicates
        name: Remove Duplicates
        concept: "Fast/Slow Pointers"
        difficulty: 1
        docLinks:
          - url: https://go.dev/doc/effective_go#slices
            title: "Effective Go: Slices"
            note: "In-place slice manipulation"
          - url: https://go.dev/ref/spec#For_statements
            title: "Go Spec: For Statements"
            note: "Index-based for loops"
        patternPrimer:
          bruteForce: "Create a new array with unique elements - O(n) space"
          bestApproach: "Two pointers: slow pointer tracks insertion position, fast pointer scans - O(1) space"
          typical: "Slow pointer marks where next unique element goes; fast pointer finds it"
        variants:
          - id: v1
            title: Remove Duplicates from Sorted Array
            difficulty: 1
            description: "Given an integer array nums sorted in non-decreasing order, remove the duplicates in-place such that each unique element appears only once. Return the number of unique elements k, with the first k elements of nums containing the unique elements."
            hints:
              - "Use a slow pointer to track the position where the next unique element should go."
              - "Fast pointer scans forward. When it finds a value different from nums[slow], increment slow and copy the value."
            solution: |
              func removeDuplicates(nums []int) int {
                  if len(nums) == 0 {
                      return 0
                  }
                  slow := 0
                  for fast := 1; fast < len(nums); fast++ {
                      if nums[fast] != nums[slow] {
                          slow++
                          nums[slow] = nums[fast]
                      }
                  }
                  return slow + 1
              }
            testCases: |
              nums1 := []int{1, 1, 2}
              k1 := removeDuplicates(nums1)
              fmt.Println(k1, nums1[:k1])  // 2 [1 2]

              nums2 := []int{0, 0, 1, 1, 1, 2, 2, 3, 3, 4}
              k2 := removeDuplicates(nums2)
              fmt.Println(k2, nums2[:k2])  // 5 [0 1 2 3 4]
          - id: v2
            title: Move Zeroes
            difficulty: 1
            description: "Given an integer array nums, move all 0's to the end while maintaining the relative order of the non-zero elements. You must do this in-place."
            hints:
              - "Use a slow pointer to track where the next non-zero element should go."
              - "Fast pointer scans forward. When it finds a non-zero value, swap it with the slow pointer position, then increment slow."
            solution: |
              func moveZeroes(nums []int) {
                  slow := 0
                  for fast := 0; fast < len(nums); fast++ {
                      if nums[fast] != 0 {
                          nums[slow], nums[fast] = nums[fast], nums[slow]
                          slow++
                      }
                  }
              }
            testCases: |
              nums1 := []int{0, 1, 0, 3, 12}
              moveZeroes(nums1)
              fmt.Println(nums1)  // [1 3 12 0 0]

              nums2 := []int{0}
              moveZeroes(nums2)
              fmt.Println(nums2)  // [0]

              nums3 := []int{1, 0, 0, 2}
              moveZeroes(nums3)
              fmt.Println(nums3)  // [1 2 0 0]
          - id: v3
            title: Remove Element
            difficulty: 1
            description: "Given an integer array nums and an integer val, remove all occurrences of val in-place. Return the number of elements that are not equal to val, with those elements placed in the first part of the array."
            hints:
              - "Similar to move zeroes but for a specific value. Use a slow pointer for the insertion position."
              - "When fast pointer finds a value not equal to val, place it at the slow pointer position."
            solution: |
              func removeElement(nums []int, val int) int {
                  slow := 0
                  for fast := 0; fast < len(nums); fast++ {
                      if nums[fast] != val {
                          nums[slow] = nums[fast]
                          slow++
                      }
                  }
                  return slow
              }
            testCases: |
              nums1 := []int{3, 2, 2, 3}
              k1 := removeElement(nums1, 3)
              fmt.Println(k1, nums1[:k1])  // 2 [2 2]

              nums2 := []int{0, 1, 2, 2, 3, 0, 4, 2}
              k2 := removeElement(nums2, 2)
              fmt.Println(k2, nums2[:k2])  // 5 [0 1 3 0 4]

      - id: merge-sorted
        name: Merge Sorted Arrays
        concept: "Merge Pattern"
        difficulty: 1
        docLinks:
          - url: https://go.dev/doc/effective_go#slices
            title: "Effective Go: Slices"
            note: "Slice operations and append"
          - url: https://pkg.go.dev/sort
            title: "sort package"
            note: "Sorting utilities"
        patternPrimer:
          bruteForce: "Concatenate and sort - O((n+m) log(n+m))"
          bestApproach: "Two pointers merge technique - O(n+m)"
          typical: "Compare elements from both arrays, pick the smaller, advance that pointer"
        variants:
          - id: v1
            title: Merge Sorted Array
            difficulty: 1
            description: "You are given two integer arrays nums1 and nums2, sorted in non-decreasing order, and two integers m and n representing the number of elements in each. Merge nums2 into nums1 as one sorted array. nums1 has length m + n, with the last n elements set to 0 for placeholder."
            hints:
              - "Merge from the end to avoid overwriting elements in nums1 that haven't been processed yet."
              - "Use three pointers: p1 at m-1, p2 at n-1, and write pointer at m+n-1. Place the larger element at the write position."
              - "If p2 finishes first, nums1 elements are already in place. If p1 finishes first, copy remaining nums2 elements."
            solution: |
              func merge(nums1 []int, m int, nums2 []int, n int) {
                  p1, p2, w := m-1, n-1, m+n-1
                  for p2 >= 0 {
                      if p1 >= 0 && nums1[p1] > nums2[p2] {
                          nums1[w] = nums1[p1]
                          p1--
                      } else {
                          nums1[w] = nums2[p2]
                          p2--
                      }
                      w--
                  }
              }
            testCases: |
              nums1 := []int{1, 2, 3, 0, 0, 0}
              merge(nums1, 3, []int{2, 5, 6}, 3)
              fmt.Println(nums1)  // [1 2 2 3 5 6]

              nums2 := []int{1}
              merge(nums2, 1, []int{}, 0)
              fmt.Println(nums2)  // [1]

              nums3 := []int{0}
              merge(nums3, 0, []int{1}, 1)
              fmt.Println(nums3)  // [1]
          - id: v2
            title: Sort Colors
            difficulty: 2
            description: "Given an array nums with n objects colored red, white, or blue (represented as 0, 1, and 2), sort them in-place so that objects of the same color are adjacent, in the order red, white, blue. Do not use the library sort function."
            hints:
              - "This is the Dutch National Flag problem. Use three pointers: lo for 0s boundary, hi for 2s boundary, and mid for scanning."
              - "If nums[mid] == 0, swap with lo and advance both. If nums[mid] == 2, swap with hi and decrement hi (don't advance mid since swapped value is unknown). If 1, just advance mid."
            solution: |
              func sortColors(nums []int) {
                  lo, mid, hi := 0, 0, len(nums)-1
                  for mid <= hi {
                      switch nums[mid] {
                      case 0:
                          nums[lo], nums[mid] = nums[mid], nums[lo]
                          lo++
                          mid++
                      case 1:
                          mid++
                      case 2:
                          nums[mid], nums[hi] = nums[hi], nums[mid]
                          hi--
                      }
                  }
              }
            testCases: |
              nums1 := []int{2, 0, 2, 1, 1, 0}
              sortColors(nums1)
              fmt.Println(nums1)  // [0 0 1 1 2 2]

              nums2 := []int{2, 0, 1}
              sortColors(nums2)
              fmt.Println(nums2)  // [0 1 2]

              nums3 := []int{0}
              sortColors(nums3)
              fmt.Println(nums3)  // [0]
          - id: v3
            title: Squares of a Sorted Array
            difficulty: 1
            description: "Given an integer array nums sorted in non-decreasing order, return an array of the squares of each number sorted in non-decreasing order."
            hints:
              - "After squaring, the largest values are at the ends of the array (negative numbers become large when squared)."
              - "Use two pointers at both ends. Compare absolute values, place the larger square at the end of the result, and move that pointer inward."
            solution: |
              func sortedSquares(nums []int) []int {
                  n := len(nums)
                  result := make([]int, n)
                  l, r := 0, n-1
                  pos := n - 1
                  for l <= r {
                      lSq := nums[l] * nums[l]
                      rSq := nums[r] * nums[r]
                      if lSq > rSq {
                          result[pos] = lSq
                          l++
                      } else {
                          result[pos] = rSq
                          r--
                      }
                      pos--
                  }
                  return result
              }
            testCases: |
              fmt.Println(sortedSquares([]int{-4, -1, 0, 3, 10}))  // [0 1 9 16 100]
              fmt.Println(sortedSquares([]int{-7, -3, 2, 3, 11}))  // [4 9 9 49 121]
              fmt.Println(sortedSquares([]int{-1}))                 // [1]

  - id: sliding-window
    name: Sliding Window
    icon: "âŠž"
    order: 3
    description: "Fixed and variable-size window techniques"
    problems:
      - id: max-sum-subarray
        name: Maximum Sum Subarray of Size K
        concept: "Fixed Window"
        difficulty: 1
        docLinks:
          - url: https://go.dev/doc/effective_go#slices
            title: "Effective Go: Slices"
            note: "Iterating through slices with index"
          - url: https://go.dev/ref/spec#For_statements
            title: "Go Spec: For Statements"
            note: "For loops and range clauses"
        patternPrimer:
          bruteForce: "Calculate sum for every window of size k - O(n*k)"
          bestApproach: "Sliding window: add new element, subtract old - O(n)"
          typical: "Maintain running sum. Slide window by adding right element and removing left element."
        variants:
          - id: v1
            title: Maximum Sum Subarray of Size K
            difficulty: 1
            description: "Given an array of integers and a number k, find the maximum sum of any contiguous subarray of size k."
            hints:
              - "Compute the sum of the first k elements. Then slide the window: add the next element and subtract the element leaving the window."
              - "Track the maximum sum seen as you slide the window across the array."
            solution: |
              func maxSumSubarray(nums []int, k int) int {
                  windowSum := 0
                  for i := 0; i < k; i++ {
                      windowSum += nums[i]
                  }
                  maxSum := windowSum
                  for i := k; i < len(nums); i++ {
                      windowSum += nums[i] - nums[i-k]
                      if windowSum > maxSum {
                          maxSum = windowSum
                      }
                  }
                  return maxSum
              }
            testCases: |
              fmt.Println(maxSumSubarray([]int{2, 1, 5, 1, 3, 2}, 3))   // 9
              fmt.Println(maxSumSubarray([]int{2, 3, 4, 1, 5}, 2))      // 7
              fmt.Println(maxSumSubarray([]int{1, 1, 1, 1, 1}, 3))      // 3
          - id: v2
            title: Maximum Average Subarray
            difficulty: 1
            description: "Given an integer array nums and an integer k, find a contiguous subarray of length k that has the maximum average value and return the average as a float64."
            hints:
              - "This is the same as maximum sum subarray of size k, but divide by k at the end."
              - "Find the maximum window sum, then convert to average."
            solution: |
              func findMaxAverage(nums []int, k int) float64 {
                  windowSum := 0
                  for i := 0; i < k; i++ {
                      windowSum += nums[i]
                  }
                  maxSum := windowSum
                  for i := k; i < len(nums); i++ {
                      windowSum += nums[i] - nums[i-k]
                      if windowSum > maxSum {
                          maxSum = windowSum
                      }
                  }
                  return float64(maxSum) / float64(k)
              }
            testCases: |
              fmt.Println(findMaxAverage([]int{1, 12, -5, -6, 50, 3}, 4))  // 12.75
              fmt.Println(findMaxAverage([]int{5}, 1))                       // 5
              fmt.Println(findMaxAverage([]int{0, 4, 0, 3, 2}, 1))         // 4
          - id: v3
            title: Averages of Subarrays of Size K
            difficulty: 1
            description: "Given an array of integers and a number k, find the average of all contiguous subarrays of size k and return them as a float64 slice."
            hints:
              - "Use the sliding window technique: compute the first window sum, then slide and compute each subsequent average."
              - "For each position, the average is windowSum / k."
            solution: |
              func findAverages(nums []int, k int) []float64 {
                  result := make([]float64, 0, len(nums)-k+1)
                  windowSum := 0
                  for i := 0; i < len(nums); i++ {
                      windowSum += nums[i]
                      if i >= k-1 {
                          result = append(result, float64(windowSum)/float64(k))
                          windowSum -= nums[i-k+1]
                      }
                  }
                  return result
              }
            testCases: |
              fmt.Println(findAverages([]int{1, 3, 2, 6, -1, 4, 1, 8, 2}, 5))
              // [2.2 2.8 2.4 3.6 2.8]
              fmt.Println(findAverages([]int{1, 2, 3}, 2))
              // [1.5 2.5]

      - id: best-time-stock
        name: Best Time to Buy and Sell Stock
        concept: "Track Minimum"
        difficulty: 1
        docLinks:
          - url: https://go.dev/doc/effective_go#slices
            title: "Effective Go: Slices"
            note: "Iterating through price arrays"
          - url: https://go.dev/ref/spec#For_statements
            title: "Go Spec: For Statements"
            note: "Range-based iteration"
        patternPrimer:
          bruteForce: "Check all buy/sell pairs - O(n^2)"
          bestApproach: "Track minimum price seen so far, calculate profit at each step - O(n)"
          typical: "One pass: maintain minPrice, update maxProfit = max(maxProfit, price - minPrice)"
        variants:
          - id: v1
            title: Best Time to Buy and Sell Stock
            difficulty: 1
            description: "Given an array prices where prices[i] is the price of a stock on the ith day, find the maximum profit from one buy and one sell. You must buy before you sell. Return 0 if no profit is possible."
            hints:
              - "Track the minimum price seen so far as you scan left to right."
              - "At each day, the best profit if selling today is price - minPriceSoFar. Track the maximum of these."
            solution: |
              func maxProfit(prices []int) int {
                  minPrice := prices[0]
                  maxProfit := 0
                  for _, price := range prices {
                      if price < minPrice {
                          minPrice = price
                      } else if price-minPrice > maxProfit {
                          maxProfit = price - minPrice
                      }
                  }
                  return maxProfit
              }
            testCases: |
              fmt.Println(maxProfit([]int{7, 1, 5, 3, 6, 4}))  // 5
              fmt.Println(maxProfit([]int{7, 6, 4, 3, 1}))     // 0
              fmt.Println(maxProfit([]int{2, 4, 1}))            // 2
          - id: v2
            title: Best Time to Buy and Sell Stock II
            difficulty: 1
            description: "Given an array prices, find the maximum profit you can achieve. You may complete as many transactions as you like (buy one, sell one, then buy again). You cannot hold multiple shares at the same time."
            hints:
              - "You can collect every upward price movement. If tomorrow's price is higher, you should have bought today."
              - "Sum up all positive differences between consecutive days: if prices[i+1] > prices[i], add the difference."
            solution: |
              func maxProfitII(prices []int) int {
                  profit := 0
                  for i := 1; i < len(prices); i++ {
                      if prices[i] > prices[i-1] {
                          profit += prices[i] - prices[i-1]
                      }
                  }
                  return profit
              }
            testCases: |
              fmt.Println(maxProfitII([]int{7, 1, 5, 3, 6, 4}))  // 7
              fmt.Println(maxProfitII([]int{1, 2, 3, 4, 5}))     // 4
              fmt.Println(maxProfitII([]int{7, 6, 4, 3, 1}))     // 0
          - id: v3
            title: Best Time to Buy and Sell Stock with Transaction Fee
            difficulty: 2
            description: "Given an array prices and an integer fee representing a transaction fee, find the maximum profit you can achieve. You may complete as many transactions as you like, but you must pay the fee for each transaction."
            hints:
              - "Use dynamic programming with two states: holding a stock and not holding a stock."
              - "cash = max profit when not holding stock. hold = max profit when holding stock."
              - "Each day: cash = max(cash, hold + price - fee). hold = max(hold, cash - price)."
            solution: |
              func maxProfitWithFee(prices []int, fee int) int {
                  cash := 0
                  hold := -prices[0]
                  for i := 1; i < len(prices); i++ {
                      newCash := cash
                      if hold+prices[i]-fee > cash {
                          newCash = hold + prices[i] - fee
                      }
                      newHold := hold
                      if cash-prices[i] > hold {
                          newHold = cash - prices[i]
                      }
                      cash = newCash
                      hold = newHold
                  }
                  return cash
              }
            testCases: |
              fmt.Println(maxProfitWithFee([]int{1, 3, 2, 8, 4, 9}, 2))  // 8
              fmt.Println(maxProfitWithFee([]int{1, 3, 7, 5, 10, 3}, 3)) // 6
              fmt.Println(maxProfitWithFee([]int{1, 4, 6, 2, 8, 3}, 2))  // 6

      - id: longest-substring
        name: Longest Substring Without Repeating Characters
        concept: "Variable Window + Set"
        difficulty: 2
        docLinks:
          - url: https://go.dev/doc/effective_go#maps
            title: "Effective Go: Maps"
            note: "Using maps as character sets"
          - url: https://pkg.go.dev/strings
            title: "strings package"
            note: "String operations and byte access"
        patternPrimer:
          bruteForce: "Check all substrings for uniqueness - O(n^3)"
          bestApproach: "Sliding window with hash set tracking characters in window - O(n)"
          typical: "Expand right pointer. If duplicate found, shrink from left until window is valid."
        variants:
          - id: v1
            title: Longest Substring Without Repeating Characters
            difficulty: 2
            description: "Given a string s, find the length of the longest substring without repeating characters."
            hints:
              - "Use a sliding window with a set to track characters in the current window."
              - "Expand the window to the right. When a duplicate is found, shrink from the left until the duplicate is removed."
              - "Optimization: use a map storing the last index of each character. When a duplicate is found, jump the left pointer directly."
            solution: |
              func lengthOfLongestSubstring(s string) int {
                  lastSeen := make(map[byte]int)
                  maxLen := 0
                  left := 0
                  for right := 0; right < len(s); right++ {
                      if idx, ok := lastSeen[s[right]]; ok && idx >= left {
                          left = idx + 1
                      }
                      if right-left+1 > maxLen {
                          maxLen = right - left + 1
                      }
                      lastSeen[s[right]] = right
                  }
                  return maxLen
              }
            testCases: |
              fmt.Println(lengthOfLongestSubstring("abcabcbb"))  // 3
              fmt.Println(lengthOfLongestSubstring("bbbbb"))     // 1
              fmt.Println(lengthOfLongestSubstring("pwwkew"))    // 3
          - id: v2
            title: Longest Substring with At Most K Distinct Characters
            difficulty: 2
            description: "Given a string s and an integer k, return the length of the longest substring that contains at most k distinct characters."
            hints:
              - "Use a sliding window with a map counting character frequencies."
              - "Expand right pointer, adding characters to the count. When distinct characters exceed k, shrink from the left."
              - "Remove characters from the map when their count drops to zero."
            solution: |
              func lengthOfLongestSubstringKDistinct(s string, k int) int {
                  if k == 0 {
                      return 0
                  }
                  freq := make(map[byte]int)
                  maxLen := 0
                  left := 0
                  for right := 0; right < len(s); right++ {
                      freq[s[right]]++
                      for len(freq) > k {
                          freq[s[left]]--
                          if freq[s[left]] == 0 {
                              delete(freq, s[left])
                          }
                          left++
                      }
                      if right-left+1 > maxLen {
                          maxLen = right - left + 1
                      }
                  }
                  return maxLen
              }
            testCases: |
              fmt.Println(lengthOfLongestSubstringKDistinct("eceba", 2))        // 3 ("ece")
              fmt.Println(lengthOfLongestSubstringKDistinct("aa", 1))           // 2
              fmt.Println(lengthOfLongestSubstringKDistinct("abcadcacacaca", 3)) // 11
          - id: v3
            title: Minimum Window Substring
            difficulty: 3
            description: "Given two strings s and t, return the minimum window substring of s such that every character in t (including duplicates) is included in the window. If there is no such window, return the empty string."
            hints:
              - "Use a sliding window with character frequency maps. Track how many characters from t are satisfied in the window."
              - "Expand right to include more characters. When all characters are satisfied, try shrinking from left to minimize the window."
              - "Use a 'formed' counter tracking how many unique characters in t have the required frequency in the window."
            solution: |
              func minWindow(s string, t string) string {
                  if len(s) < len(t) {
                      return ""
                  }
                  need := make(map[byte]int)
                  for i := 0; i < len(t); i++ {
                      need[t[i]]++
                  }
                  window := make(map[byte]int)
                  have, required := 0, len(need)
                  bestLeft, bestLen := 0, len(s)+1
                  left := 0
                  for right := 0; right < len(s); right++ {
                      c := s[right]
                      window[c]++
                      if need[c] > 0 && window[c] == need[c] {
                          have++
                      }
                      for have == required {
                          if right-left+1 < bestLen {
                              bestLeft = left
                              bestLen = right - left + 1
                          }
                          lc := s[left]
                          window[lc]--
                          if need[lc] > 0 && window[lc] < need[lc] {
                              have--
                          }
                          left++
                      }
                  }
                  if bestLen > len(s) {
                      return ""
                  }
                  return s[bestLeft : bestLeft+bestLen]
              }
            testCases: |
              fmt.Println(minWindow("ADOBECODEBANC", "ABC"))  // "BANC"
              fmt.Println(minWindow("a", "a"))                 // "a"
              fmt.Println(minWindow("a", "aa"))                // ""

      - id: max-consecutive-ones
        name: Max Consecutive Ones
        concept: "Window with Budget"
        difficulty: 1
        docLinks:
          - url: https://go.dev/doc/effective_go#slices
            title: "Effective Go: Slices"
            note: "Iterating and tracking state in slices"
          - url: https://go.dev/ref/spec#For_statements
            title: "Go Spec: For Statements"
            note: "Index-based loops for sliding window"
        patternPrimer:
          bruteForce: "Check all subarrays for consecutive ones - O(n^2)"
          bestApproach: "Single pass counting consecutive ones, reset on zero - O(n)"
          typical: "For flip variant: sliding window maintaining at most k zeros in window"
        variants:
          - id: v1
            title: Max Consecutive Ones
            difficulty: 1
            description: "Given a binary array nums, return the maximum number of consecutive 1's in the array."
            hints:
              - "Keep a running count of consecutive ones. Reset to zero when you hit a zero."
              - "Track the maximum count seen."
            solution: |
              func findMaxConsecutiveOnes(nums []int) int {
                  maxCount := 0
                  count := 0
                  for _, num := range nums {
                      if num == 1 {
                          count++
                          if count > maxCount {
                              maxCount = count
                          }
                      } else {
                          count = 0
                      }
                  }
                  return maxCount
              }
            testCases: |
              fmt.Println(findMaxConsecutiveOnes([]int{1, 1, 0, 1, 1, 1}))  // 3
              fmt.Println(findMaxConsecutiveOnes([]int{1, 0, 1, 1, 0, 1}))  // 2
              fmt.Println(findMaxConsecutiveOnes([]int{0, 0, 0}))            // 0
          - id: v2
            title: Max Consecutive Ones III
            difficulty: 2
            description: "Given a binary array nums and an integer k, return the maximum number of consecutive 1's in the array if you can flip at most k 0's."
            hints:
              - "Use a sliding window. Track the number of zeros in the window."
              - "Expand right. When zeros exceed k, shrink from left until zeros are within budget."
              - "The window always contains at most k zeros, and the window length is the answer candidate."
            solution: |
              func longestOnes(nums []int, k int) int {
                  left := 0
                  zeros := 0
                  maxLen := 0
                  for right := 0; right < len(nums); right++ {
                      if nums[right] == 0 {
                          zeros++
                      }
                      for zeros > k {
                          if nums[left] == 0 {
                              zeros--
                          }
                          left++
                      }
                      if right-left+1 > maxLen {
                          maxLen = right - left + 1
                      }
                  }
                  return maxLen
              }
            testCases: |
              fmt.Println(longestOnes([]int{1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 0}, 2))  // 6
              fmt.Println(longestOnes([]int{0, 0, 1, 1, 0, 0, 1, 1, 1, 0, 1, 1, 0, 0, 0, 1, 1, 1, 1}, 3))  // 10
              fmt.Println(longestOnes([]int{1, 1, 1}, 0))  // 3
          - id: v3
            title: Longest Repeating Character Replacement
            difficulty: 2
            description: "Given a string s and an integer k, you can change at most k characters to any character. Return the length of the longest substring containing the same letter after performing at most k changes."
            hints:
              - "Use a sliding window with a frequency count. The key insight: window is valid if windowLen - maxFreq <= k."
              - "The number of characters to replace is window length minus the frequency of the most common character."
              - "You do not need to decrement maxFreq when shrinking because a smaller maxFreq cannot produce a longer valid window."
            solution: |
              func characterReplacement(s string, k int) int {
                  var count [26]int
                  left := 0
                  maxFreq := 0
                  maxLen := 0
                  for right := 0; right < len(s); right++ {
                      count[s[right]-'A']++
                      if count[s[right]-'A'] > maxFreq {
                          maxFreq = count[s[right]-'A']
                      }
                      for (right-left+1)-maxFreq > k {
                          count[s[left]-'A']--
                          left++
                      }
                      if right-left+1 > maxLen {
                          maxLen = right - left + 1
                      }
                  }
                  return maxLen
              }
            testCases: |
              fmt.Println(characterReplacement("ABAB", 2))     // 4
              fmt.Println(characterReplacement("AABABBA", 1))  // 4
              fmt.Println(characterReplacement("AAAA", 0))     // 4

      - id: fruit-baskets
        name: Fruits Into Baskets
        concept: "Window + Counter"
        difficulty: 2
        docLinks:
          - url: https://go.dev/doc/effective_go#maps
            title: "Effective Go: Maps"
            note: "Map as frequency counter in sliding windows"
          - url: https://go.dev/doc/effective_go#slices
            title: "Effective Go: Slices"
            note: "Iterating through arrays with index tracking"
        patternPrimer:
          bruteForce: "Check all subarrays for at most 2 distinct elements - O(n^2)"
          bestApproach: "Sliding window with frequency map, shrink when distinct > 2 - O(n)"
          typical: "Variable-size window maintaining at most k distinct elements using a counter map"
        variants:
          - id: v1
            title: Fruits Into Baskets
            difficulty: 2
            description: "You have a row of trees, each bearing a type of fruit given as fruits[i]. You have two baskets, each of which can hold only one type of fruit. Starting from any tree, pick one fruit from each tree moving right. You stop when you have to pick a third type. Return the maximum number of fruits you can collect."
            hints:
              - "This is equivalent to finding the longest subarray with at most 2 distinct values."
              - "Use a sliding window with a map counting fruit types. When the map has more than 2 keys, shrink from the left."
              - "When shrinking, decrement the count of the leftmost fruit and remove it from the map if count reaches 0."
            solution: |
              func totalFruit(fruits []int) int {
                  basket := make(map[int]int)
                  maxLen := 0
                  left := 0
                  for right := 0; right < len(fruits); right++ {
                      basket[fruits[right]]++
                      for len(basket) > 2 {
                          basket[fruits[left]]--
                          if basket[fruits[left]] == 0 {
                              delete(basket, fruits[left])
                          }
                          left++
                      }
                      if right-left+1 > maxLen {
                          maxLen = right - left + 1
                      }
                  }
                  return maxLen
              }
            testCases: |
              fmt.Println(totalFruit([]int{1, 2, 1}))        // 3
              fmt.Println(totalFruit([]int{0, 1, 2, 2}))     // 3
              fmt.Println(totalFruit([]int{1, 2, 3, 2, 2}))  // 4
          - id: v2
            title: Subarrays with K Different Integers
            difficulty: 3
            description: "Given an integer array nums and an integer k, return the number of subarrays that contain exactly k different integers."
            hints:
              - "Exactly k distinct = atMost(k) - atMost(k-1). This transforms the problem into two simpler sliding window problems."
              - "Write a helper that counts subarrays with at most k distinct integers using a sliding window."
              - "For each valid window ending at right with left as the smallest valid start, there are (right - left + 1) subarrays ending at right."
            solution: |
              func subarraysWithKDistinct(nums []int, k int) int {
                  return atMost(nums, k) - atMost(nums, k-1)
              }

              func atMost(nums []int, k int) int {
                  freq := make(map[int]int)
                  count := 0
                  left := 0
                  for right := 0; right < len(nums); right++ {
                      freq[nums[right]]++
                      for len(freq) > k {
                          freq[nums[left]]--
                          if freq[nums[left]] == 0 {
                              delete(freq, nums[left])
                          }
                          left++
                      }
                      count += right - left + 1
                  }
                  return count
              }
            testCases: |
              fmt.Println(subarraysWithKDistinct([]int{1, 2, 1, 2, 3}, 2))  // 7
              fmt.Println(subarraysWithKDistinct([]int{1, 2, 1, 3, 4}, 3))  // 3
              fmt.Println(subarraysWithKDistinct([]int{1, 1, 1, 1}, 1))     // 10
          - id: v3
            title: Count Number of Nice Subarrays
            difficulty: 2
            description: "Given an array of integers nums and an integer k, return the number of subarrays that contain exactly k odd numbers."
            hints:
              - "Transform the problem: treat odd numbers as 1 and even as 0. Now find subarrays with sum exactly k."
              - "Use the same atMost technique: exactly(k) = atMost(k) - atMost(k-1)."
              - "Alternatively, use prefix sum + hash map counting how many prefix sums equal currentSum - k."
            solution: |
              func numberOfSubarrays(nums []int, k int) int {
                  return atMostOdd(nums, k) - atMostOdd(nums, k-1)
              }

              func atMostOdd(nums []int, k int) int {
                  count := 0
                  odds := 0
                  left := 0
                  for right := 0; right < len(nums); right++ {
                      if nums[right]%2 == 1 {
                          odds++
                      }
                      for odds > k {
                          if nums[left]%2 == 1 {
                              odds--
                          }
                          left++
                      }
                      count += right - left + 1
                  }
                  return count
              }
            testCases: |
              fmt.Println(numberOfSubarrays([]int{1, 1, 2, 1, 1}, 3))     // 2
              fmt.Println(numberOfSubarrays([]int{2, 4, 6}, 1))            // 0
              fmt.Println(numberOfSubarrays([]int{2, 2, 2, 1, 2, 2, 1, 2, 2, 2}, 2))  // 16
  - id: stack
    name: Stack
    icon: "â‰¡"
    order: 4
    description: "LIFO data structure for matching and ordering problems"
    problems:
      - id: valid-parentheses
        name: Valid Parentheses
        concept: "Bracket Matching"
        difficulty: 1
        docLinks:
          - url: "https://pkg.go.dev/builtin"
            title: "Go Builtin"
            note: "Slice operations for stack simulation"
        patternPrimer:
          bruteForce: "Repeatedly remove matching pairs from string until none remain - O(n^2)"
          bestApproach: "Use a stack to push opening brackets and pop/match closing brackets - O(n)"
          typical: "Stack-based matching is the standard approach for all bracket problems"
        variants:
          - id: v1
            title: "Valid Parentheses"
            difficulty: 1
            description: |
              Given a string containing just the characters '(', ')', '{', '}', '[' and ']',
              determine if the input string is valid. An input string is valid if open brackets
              are closed by the same type of brackets, and in the correct order.
            hints:
              - "Use a slice as a stack - append to push, slice to pop"
              - "Map closing brackets to their matching opening brackets"
              - "At the end, the stack should be empty for a valid string"
            solution: |
              func isValid(s string) bool {
                  stack := []rune{}
                  matching := map[rune]rune{')': '(', ']': '[', '}': '{'}
                  for _, ch := range s {
                      if ch == '(' || ch == '[' || ch == '{' {
                          stack = append(stack, ch)
                      } else {
                          if len(stack) == 0 || stack[len(stack)-1] != matching[ch] {
                              return false
                          }
                          stack = stack[:len(stack)-1]
                      }
                  }
                  return len(stack) == 0
              }
            testCases: |
              fmt.Println(isValid("()"))       // true
              fmt.Println(isValid("()[]{}"))   // true
              fmt.Println(isValid("(]"))       // false
              fmt.Println(isValid("([)]"))     // false
              fmt.Println(isValid("{[]}"))     // true
              fmt.Println(isValid(""))         // true
          - id: v2
            title: "Minimum Add to Make Parentheses Valid"
            difficulty: 2
            description: |
              Given a string of '(' and ')' parentheses, return the minimum number of
              parentheses you must add to make the string valid. A valid string has every
              open paren matched with a close paren.
            hints:
              - "Track unmatched open and unmatched close counts separately"
              - "When you see ')', it can match an unmatched '(' or become unmatched itself"
              - "Answer is the sum of unmatched opens and unmatched closes"
            solution: |
              func minAddToMakeValid(s string) int {
                  open := 0
                  close := 0
                  for _, ch := range s {
                      if ch == '(' {
                          open++
                      } else {
                          if open > 0 {
                              open--
                          } else {
                              close++
                          }
                      }
                  }
                  return open + close
              }
            testCases: |
              fmt.Println(minAddToMakeValid("())"))    // 1
              fmt.Println(minAddToMakeValid("((("))    // 3
              fmt.Println(minAddToMakeValid("()"))     // 0
              fmt.Println(minAddToMakeValid("()))((")) // 4
          - id: v3
            title: "Longest Valid Parentheses"
            difficulty: 3
            description: |
              Given a string containing just '(' and ')', return the length of the longest
              valid (well-formed) parentheses substring.
            hints:
              - "Use a stack storing indices, not characters"
              - "Push -1 as the base index, then push indices of '('"
              - "On ')', pop and compute length as current index minus new stack top"
            solution: |
              func longestValidParentheses(s string) int {
                  stack := []int{-1}
                  maxLen := 0
                  for i := 0; i < len(s); i++ {
                      if s[i] == '(' {
                          stack = append(stack, i)
                      } else {
                          stack = stack[:len(stack)-1]
                          if len(stack) == 0 {
                              stack = append(stack, i)
                          } else {
                              length := i - stack[len(stack)-1]
                              if length > maxLen {
                                  maxLen = length
                              }
                          }
                      }
                  }
                  return maxLen
              }
            testCases: |
              fmt.Println(longestValidParentheses("(()"))     // 2
              fmt.Println(longestValidParentheses(")()())"))  // 4
              fmt.Println(longestValidParentheses(""))        // 0
              fmt.Println(longestValidParentheses("()(()"))   // 2
      - id: min-stack
        name: Min Stack
        concept: "Auxiliary Stack"
        difficulty: 2
        docLinks:
          - url: "https://pkg.go.dev/builtin"
            title: "Go Builtin"
            note: "Slice append/slice for stack operations"
        patternPrimer:
          bruteForce: "Scan entire stack on each getMin call - O(n) per query"
          bestApproach: "Maintain a parallel stack tracking the minimum at each level - O(1) per operation"
          typical: "Auxiliary/parallel data structures are common for O(1) constraint problems"
        variants:
          - id: v1
            title: "Min Stack"
            difficulty: 2
            description: |
              Design a stack that supports push, pop, top, and retrieving the minimum
              element in constant time. Implement the MinStack struct with methods:
              Push(val), Pop(), Top() int, GetMin() int.
            hints:
              - "Keep a second stack that tracks the current minimum"
              - "When pushing, also push the new min onto the min stack"
              - "When popping, pop from both stacks"
            solution: |
              type MinStack struct {
                  stack    []int
                  minStack []int
              }

              func NewMinStack() MinStack {
                  return MinStack{}
              }

              func (s *MinStack) Push(val int) {
                  s.stack = append(s.stack, val)
                  if len(s.minStack) == 0 || val <= s.minStack[len(s.minStack)-1] {
                      s.minStack = append(s.minStack, val)
                  } else {
                      s.minStack = append(s.minStack, s.minStack[len(s.minStack)-1])
                  }
              }

              func (s *MinStack) Pop() {
                  s.stack = s.stack[:len(s.stack)-1]
                  s.minStack = s.minStack[:len(s.minStack)-1]
              }

              func (s *MinStack) Top() int {
                  return s.stack[len(s.stack)-1]
              }

              func (s *MinStack) GetMin() int {
                  return s.minStack[len(s.minStack)-1]
              }
            testCases: |
              ms := NewMinStack()
              ms.Push(-2)
              ms.Push(0)
              ms.Push(-3)
              fmt.Println(ms.GetMin()) // -3
              ms.Pop()
              fmt.Println(ms.Top())    // 0
              fmt.Println(ms.GetMin()) // -2
          - id: v2
            title: "Implement Queue Using Stacks"
            difficulty: 2
            description: |
              Implement a FIFO queue using only two stacks. The queue should support
              Push(x), Pop() int, Peek() int, and Empty() bool. Each operation should
              be amortized O(1).
            hints:
              - "Use two stacks: one for input, one for output"
              - "Transfer from input stack to output stack only when output is empty"
              - "This reverses the order, giving FIFO behavior"
            solution: |
              type MyQueue struct {
                  inStack  []int
                  outStack []int
              }

              func NewMyQueue() MyQueue {
                  return MyQueue{}
              }

              func (q *MyQueue) Push(x int) {
                  q.inStack = append(q.inStack, x)
              }

              func (q *MyQueue) transfer() {
                  if len(q.outStack) == 0 {
                      for len(q.inStack) > 0 {
                          val := q.inStack[len(q.inStack)-1]
                          q.inStack = q.inStack[:len(q.inStack)-1]
                          q.outStack = append(q.outStack, val)
                      }
                  }
              }

              func (q *MyQueue) Pop() int {
                  q.transfer()
                  val := q.outStack[len(q.outStack)-1]
                  q.outStack = q.outStack[:len(q.outStack)-1]
                  return val
              }

              func (q *MyQueue) Peek() int {
                  q.transfer()
                  return q.outStack[len(q.outStack)-1]
              }

              func (q *MyQueue) Empty() bool {
                  return len(q.inStack) == 0 && len(q.outStack) == 0
              }
            testCases: |
              q := NewMyQueue()
              q.Push(1)
              q.Push(2)
              fmt.Println(q.Peek()) // 1
              fmt.Println(q.Pop())  // 1
              fmt.Println(q.Empty()) // false
              fmt.Println(q.Pop())  // 2
              fmt.Println(q.Empty()) // true
          - id: v3
            title: "Maximum Frequency Stack"
            difficulty: 3
            description: |
              Design a stack-like data structure that pushes elements and pops the most
              frequent element. If there is a tie, pop the element closest to the top.
              Implement FreqStack with Push(val) and Pop() int.
            hints:
              - "Track frequency of each element and the current max frequency"
              - "Use a map from frequency to a stack of elements at that frequency"
              - "On pop, pop from the max-frequency stack and update bookkeeping"
            solution: |
              type FreqStack struct {
                  freq    map[int]int
                  group   map[int][]int
                  maxFreq int
              }

              func NewFreqStack() FreqStack {
                  return FreqStack{
                      freq:  make(map[int]int),
                      group: make(map[int][]int),
                  }
              }

              func (fs *FreqStack) Push(val int) {
                  fs.freq[val]++
                  f := fs.freq[val]
                  if f > fs.maxFreq {
                      fs.maxFreq = f
                  }
                  fs.group[f] = append(fs.group[f], val)
              }

              func (fs *FreqStack) Pop() int {
                  stack := fs.group[fs.maxFreq]
                  val := stack[len(stack)-1]
                  fs.group[fs.maxFreq] = stack[:len(stack)-1]
                  if len(fs.group[fs.maxFreq]) == 0 {
                      fs.maxFreq--
                  }
                  fs.freq[val]--
                  return val
              }
            testCases: |
              fs := NewFreqStack()
              fs.Push(5)
              fs.Push(7)
              fs.Push(5)
              fs.Push(7)
              fs.Push(4)
              fs.Push(5)
              fmt.Println(fs.Pop()) // 5
              fmt.Println(fs.Pop()) // 7
              fmt.Println(fs.Pop()) // 5
              fmt.Println(fs.Pop()) // 4
      - id: eval-reverse-polish
        name: Evaluate Reverse Polish Notation
        concept: "Expression Evaluation"
        difficulty: 2
        docLinks:
          - url: "https://pkg.go.dev/strconv"
            title: "Go strconv"
            note: "Atoi for converting string tokens to integers"
        patternPrimer:
          bruteForce: "Recursively parse expression tree - complex and error-prone"
          bestApproach: "Use a stack: push numbers, pop two operands when hitting an operator - O(n)"
          typical: "Stack-based evaluation is the standard for postfix and expression parsing"
        variants:
          - id: v1
            title: "Evaluate Reverse Polish Notation"
            difficulty: 2
            description: |
              Evaluate an arithmetic expression in Reverse Polish Notation. Valid operators
              are +, -, *, /. Each operand may be an integer or another expression. Division
              truncates toward zero.
            hints:
              - "Push numbers onto the stack"
              - "When you see an operator, pop two values, apply the operator, push the result"
              - "Use strconv.Atoi to check if a token is a number"
            solution: |
              func evalRPN(tokens []string) int {
                  stack := []int{}
                  for _, token := range tokens {
                      switch token {
                      case "+", "-", "*", "/":
                          b := stack[len(stack)-1]
                          a := stack[len(stack)-2]
                          stack = stack[:len(stack)-2]
                          var result int
                          switch token {
                          case "+":
                              result = a + b
                          case "-":
                              result = a - b
                          case "*":
                              result = a * b
                          case "/":
                              result = a / b
                          }
                          stack = append(stack, result)
                      default:
                          num, _ := strconv.Atoi(token)
                          stack = append(stack, num)
                      }
                  }
                  return stack[0]
              }
            testCases: |
              fmt.Println(evalRPN([]string{"2", "1", "+", "3", "*"}))           // 9
              fmt.Println(evalRPN([]string{"4", "13", "5", "/", "+"}))          // 6
              fmt.Println(evalRPN([]string{"10", "6", "9", "3", "+", "-11", "*", "/", "*", "17", "+", "5", "+"})) // 22
          - id: v2
            title: "Basic Calculator"
            difficulty: 3
            description: |
              Implement a basic calculator to evaluate a string expression containing
              digits, '+', '-', '(', ')', and spaces. The expression is always valid.
            hints:
              - "Use a stack to handle parentheses by saving/restoring sign and result"
              - "Track the current number, current sign (+1 or -1), and running result"
              - "When hitting '(', push result and sign; when hitting ')', pop and combine"
            solution: |
              func calculate(s string) int {
                  stack := []int{}
                  result := 0
                  num := 0
                  sign := 1
                  for i := 0; i < len(s); i++ {
                      ch := s[i]
                      if ch >= '0' && ch <= '9' {
                          num = num*10 + int(ch-'0')
                      } else if ch == '+' {
                          result += sign * num
                          num = 0
                          sign = 1
                      } else if ch == '-' {
                          result += sign * num
                          num = 0
                          sign = -1
                      } else if ch == '(' {
                          stack = append(stack, result)
                          stack = append(stack, sign)
                          result = 0
                          sign = 1
                      } else if ch == ')' {
                          result += sign * num
                          num = 0
                          prevSign := stack[len(stack)-1]
                          prevResult := stack[len(stack)-2]
                          stack = stack[:len(stack)-2]
                          result = prevResult + prevSign*result
                      }
                  }
                  result += sign * num
                  return result
              }
            testCases: |
              fmt.Println(calculate("1 + 1"))           // 2
              fmt.Println(calculate(" 2-1 + 2 "))       // 3
              fmt.Println(calculate("(1+(4+5+2)-3)+(6+8)")) // 23
              fmt.Println(calculate("-(3+2)+5"))        // 0
          - id: v3
            title: "Decode String"
            difficulty: 2
            description: |
              Given an encoded string like "3[a2[c]]", decode it. The rule is k[encoded_string]
              means the encoded_string is repeated k times. Input is always valid.
              For example: "3[a2[c]]" -> "accaccacc", "2[abc]3[cd]ef" -> "abcabccdcdcdef".
            hints:
              - "Use two stacks: one for counts and one for accumulated strings"
              - "When hitting '[', push current string and count, reset both"
              - "When hitting ']', pop and repeat the current string, append to previous"
            solution: |
              func decodeString(s string) string {
                  countStack := []int{}
                  strStack := []string{}
                  currentStr := ""
                  k := 0
                  for _, ch := range s {
                      if ch >= '0' && ch <= '9' {
                          k = k*10 + int(ch-'0')
                      } else if ch == '[' {
                          countStack = append(countStack, k)
                          strStack = append(strStack, currentStr)
                          currentStr = ""
                          k = 0
                      } else if ch == ']' {
                          count := countStack[len(countStack)-1]
                          countStack = countStack[:len(countStack)-1]
                          prev := strStack[len(strStack)-1]
                          strStack = strStack[:len(strStack)-1]
                          repeated := ""
                          for i := 0; i < count; i++ {
                              repeated += currentStr
                          }
                          currentStr = prev + repeated
                      } else {
                          currentStr += string(ch)
                      }
                  }
                  return currentStr
              }
            testCases: |
              fmt.Println(decodeString("3[a]2[bc]"))    // aaabcbc
              fmt.Println(decodeString("3[a2[c]]"))     // accaccacc
              fmt.Println(decodeString("2[abc]3[cd]ef")) // abcabccdcdcdef
              fmt.Println(decodeString("abc3[cd]xyz"))   // abccdcdcdxyz
      - id: daily-temperatures
        name: Daily Temperatures
        concept: "Monotonic Stack"
        difficulty: 2
        docLinks:
          - url: "https://pkg.go.dev/builtin"
            title: "Go Builtin"
            note: "Slice operations for stack simulation"
        patternPrimer:
          bruteForce: "For each day, scan forward to find the next warmer day - O(n^2)"
          bestApproach: "Use a monotonic decreasing stack of indices - O(n)"
          typical: "Monotonic stack is the go-to for next greater/smaller element problems"
        variants:
          - id: v1
            title: "Daily Temperatures"
            difficulty: 2
            description: |
              Given an array of daily temperatures, return an array where answer[i] is the
              number of days you have to wait after day i to get a warmer temperature. If
              there is no future day with a warmer temperature, put 0.
            hints:
              - "Use a stack to store indices of days with unresolved temperatures"
              - "When the current temperature is warmer than the stack top, pop and calculate the gap"
              - "Process elements left to right, maintaining a decreasing temperature stack"
            solution: |
              func dailyTemperatures(temperatures []int) []int {
                  n := len(temperatures)
                  result := make([]int, n)
                  stack := []int{} // indices
                  for i := 0; i < n; i++ {
                      for len(stack) > 0 && temperatures[i] > temperatures[stack[len(stack)-1]] {
                          j := stack[len(stack)-1]
                          stack = stack[:len(stack)-1]
                          result[j] = i - j
                      }
                      stack = append(stack, i)
                  }
                  return result
              }
            testCases: |
              fmt.Println(dailyTemperatures([]int{73, 74, 75, 71, 69, 72, 76, 73}))
              // [1 1 4 2 1 1 0 0]
              fmt.Println(dailyTemperatures([]int{30, 40, 50, 60}))
              // [1 1 1 0]
              fmt.Println(dailyTemperatures([]int{30, 20, 10}))
              // [0 0 0]
          - id: v2
            title: "Next Greater Element in Circular Array"
            difficulty: 2
            description: |
              Given a circular integer array nums, return the next greater number for every
              element. The next greater number of x is the first greater number traversing
              circularly. If it doesn't exist, output -1. The array is circular so the element
              after the last is the first.
            hints:
              - "Iterate through the array twice (2*n) to simulate the circular nature"
              - "Use modulo to wrap around: index % n"
              - "Maintain a monotonic decreasing stack of indices"
            solution: |
              func nextGreaterElements(nums []int) []int {
                  n := len(nums)
                  result := make([]int, n)
                  for i := range result {
                      result[i] = -1
                  }
                  stack := []int{} // indices
                  for i := 0; i < 2*n; i++ {
                      idx := i % n
                      for len(stack) > 0 && nums[idx] > nums[stack[len(stack)-1]] {
                          j := stack[len(stack)-1]
                          stack = stack[:len(stack)-1]
                          result[j] = nums[idx]
                      }
                      if i < n {
                          stack = append(stack, idx)
                      }
                  }
                  return result
              }
            testCases: |
              fmt.Println(nextGreaterElements([]int{1, 2, 1}))
              // [2 -1 2]
              fmt.Println(nextGreaterElements([]int{1, 2, 3, 4, 3}))
              // [2 3 4 -1 4]
              fmt.Println(nextGreaterElements([]int{5, 4, 3, 2, 1}))
              // [-1 5 5 5 5]
          - id: v3
            title: "Largest Rectangle in Histogram"
            difficulty: 3
            description: |
              Given an array of integers heights representing the histogram's bar heights
              where the width of each bar is 1, return the area of the largest rectangle
              in the histogram.
            hints:
              - "Use a stack of indices maintaining increasing heights"
              - "When a bar is shorter than the stack top, pop and calculate the area"
              - "The width extends from the current bar back to the new stack top"
            solution: |
              func largestRectangleArea(heights []int) int {
                  stack := []int{}
                  maxArea := 0
                  n := len(heights)
                  for i := 0; i <= n; i++ {
                      h := 0
                      if i < n {
                          h = heights[i]
                      }
                      for len(stack) > 0 && h < heights[stack[len(stack)-1]] {
                          top := stack[len(stack)-1]
                          stack = stack[:len(stack)-1]
                          width := i
                          if len(stack) > 0 {
                              width = i - stack[len(stack)-1] - 1
                          }
                          area := heights[top] * width
                          if area > maxArea {
                              maxArea = area
                          }
                      }
                      stack = append(stack, i)
                  }
                  return maxArea
              }
            testCases: |
              fmt.Println(largestRectangleArea([]int{2, 1, 5, 6, 2, 3})) // 10
              fmt.Println(largestRectangleArea([]int{2, 4}))              // 4
              fmt.Println(largestRectangleArea([]int{1}))                 // 1
              fmt.Println(largestRectangleArea([]int{1, 1, 1, 1}))       // 4
      - id: asteroid-collision
        name: Asteroid Collision
        concept: "Stack Simulation"
        difficulty: 2
        docLinks:
          - url: "https://pkg.go.dev/math"
            title: "Go math"
            note: "Abs for comparing asteroid sizes"
        patternPrimer:
          bruteForce: "Simulate collisions by scanning repeatedly until no more collisions - O(n^2)"
          bestApproach: "Use a stack to process asteroids left to right, resolving collisions on push - O(n)"
          typical: "Stack simulation handles sequential collision/cancellation problems efficiently"
        variants:
          - id: v1
            title: "Asteroid Collision"
            difficulty: 2
            description: |
              Given an array of integers representing asteroids in a row, for each asteroid
              the absolute value represents its size and the sign represents its direction
              (positive = right, negative = left). Asteroids moving the same direction never
              meet. When two asteroids meet, the smaller one explodes. If both are the same
              size, both explode. Return the state of the asteroids after all collisions.
            hints:
              - "Push positive asteroids onto the stack"
              - "For negative asteroids, resolve collisions with positive ones on the stack top"
              - "Three outcomes: negative survives, positive survives, both destroyed"
            solution: |
              func asteroidCollision(asteroids []int) []int {
                  stack := []int{}
                  for _, ast := range asteroids {
                      alive := true
                      for alive && ast < 0 && len(stack) > 0 && stack[len(stack)-1] > 0 {
                          top := stack[len(stack)-1]
                          if top < -ast {
                              stack = stack[:len(stack)-1]
                          } else if top == -ast {
                              stack = stack[:len(stack)-1]
                              alive = false
                          } else {
                              alive = false
                          }
                      }
                      if alive {
                          stack = append(stack, ast)
                      }
                  }
                  return stack
              }
            testCases: |
              fmt.Println(asteroidCollision([]int{5, 10, -5}))   // [5 10]
              fmt.Println(asteroidCollision([]int{8, -8}))       // []
              fmt.Println(asteroidCollision([]int{10, 2, -5}))   // [10]
              fmt.Println(asteroidCollision([]int{-2, -1, 1, 2})) // [-2 -1 1 2]
          - id: v2
            title: "Remove All Adjacent Duplicates in String"
            difficulty: 1
            description: |
              Given a string s, repeatedly remove adjacent duplicate characters until no
              more removals can be made. For example, "abbaca" becomes "ca" (remove "bb",
              then "aa").
            hints:
              - "Use a stack of characters"
              - "If the current char matches the stack top, pop instead of pushing"
              - "Build the result from the remaining stack contents"
            solution: |
              func removeDuplicates(s string) string {
                  stack := []byte{}
                  for i := 0; i < len(s); i++ {
                      if len(stack) > 0 && stack[len(stack)-1] == s[i] {
                          stack = stack[:len(stack)-1]
                      } else {
                          stack = append(stack, s[i])
                      }
                  }
                  return string(stack)
              }
            testCases: |
              fmt.Println(removeDuplicates("abbaca"))  // ca
              fmt.Println(removeDuplicates("azxxzy"))  // ay
              fmt.Println(removeDuplicates("aab"))     // b
              fmt.Println(removeDuplicates("aa"))      // (empty)
          - id: v3
            title: "Online Stock Span"
            difficulty: 2
            description: |
              Design a class that collects daily price quotes and returns the span of the
              stock price for the current day. The span is the number of consecutive days
              (starting from today going backward) where the price was less than or equal
              to today's price. Implement StockSpanner with Next(price int) int.
            hints:
              - "Use a stack storing (price, span) pairs"
              - "When a new price comes in, pop all smaller/equal prices and accumulate their spans"
              - "Push the new price with the accumulated span"
            solution: |
              type StockSpanner struct {
                  stack []stockEntry
              }

              type stockEntry struct {
                  price int
                  span  int
              }

              func NewStockSpanner() StockSpanner {
                  return StockSpanner{}
              }

              func (ss *StockSpanner) Next(price int) int {
                  span := 1
                  for len(ss.stack) > 0 && ss.stack[len(ss.stack)-1].price <= price {
                      span += ss.stack[len(ss.stack)-1].span
                      ss.stack = ss.stack[:len(ss.stack)-1]
                  }
                  ss.stack = append(ss.stack, stockEntry{price, span})
                  return span
              }
            testCases: |
              ss := NewStockSpanner()
              fmt.Println(ss.Next(100)) // 1
              fmt.Println(ss.Next(80))  // 1
              fmt.Println(ss.Next(60))  // 1
              fmt.Println(ss.Next(70))  // 2
              fmt.Println(ss.Next(60))  // 1
              fmt.Println(ss.Next(75))  // 4
              fmt.Println(ss.Next(85))  // 6
  - id: binary-search
    name: Binary Search
    icon: "Ã·"
    order: 5
    description: "Divide and conquer search on sorted data"
    problems:
      - id: binary-search
        name: Binary Search
        concept: "Classic Binary Search"
        difficulty: 1
        docLinks:
          - url: "https://pkg.go.dev/sort"
            title: "Go sort"
            note: "sort.Search for built-in binary search"
        patternPrimer:
          bruteForce: "Linear scan through the array - O(n)"
          bestApproach: "Binary search halving the search space each step - O(log n)"
          typical: "Binary search is fundamental; master the lo/hi pointer pattern and off-by-one handling"
        variants:
          - id: v1
            title: "Binary Search"
            difficulty: 1
            description: |
              Given a sorted array of integers nums and a target value, return the index
              of target if found, or -1 if not found. You must write an algorithm with
              O(log n) runtime complexity.
            hints:
              - "Initialize lo = 0, hi = len(nums) - 1"
              - "While lo <= hi, compute mid = lo + (hi - lo) / 2"
              - "Compare nums[mid] with target to decide which half to search"
            solution: |
              func search(nums []int, target int) int {
                  lo, hi := 0, len(nums)-1
                  for lo <= hi {
                      mid := lo + (hi-lo)/2
                      if nums[mid] == target {
                          return mid
                      } else if nums[mid] < target {
                          lo = mid + 1
                      } else {
                          hi = mid - 1
                      }
                  }
                  return -1
              }
            testCases: |
              fmt.Println(search([]int{-1, 0, 3, 5, 9, 12}, 9))  // 4
              fmt.Println(search([]int{-1, 0, 3, 5, 9, 12}, 2))  // -1
              fmt.Println(search([]int{5}, 5))                     // 0
              fmt.Println(search([]int{2, 5}, 0))                  // -1
          - id: v2
            title: "Search Insert Position"
            difficulty: 1
            description: |
              Given a sorted array of distinct integers and a target value, return the index
              where target is found or the index where it would be inserted to keep the
              array sorted.
            hints:
              - "This is finding the first index where nums[i] >= target"
              - "Use binary search; when target is not found, lo will be the insert position"
              - "After the loop, lo points to the correct insertion index"
            solution: |
              func searchInsert(nums []int, target int) int {
                  lo, hi := 0, len(nums)
                  for lo < hi {
                      mid := lo + (hi-lo)/2
                      if nums[mid] < target {
                          lo = mid + 1
                      } else {
                          hi = mid
                      }
                  }
                  return lo
              }
            testCases: |
              fmt.Println(searchInsert([]int{1, 3, 5, 6}, 5)) // 2
              fmt.Println(searchInsert([]int{1, 3, 5, 6}, 2)) // 1
              fmt.Println(searchInsert([]int{1, 3, 5, 6}, 7)) // 4
              fmt.Println(searchInsert([]int{1, 3, 5, 6}, 0)) // 0
          - id: v3
            title: "Find First and Last Position of Element"
            difficulty: 2
            description: |
              Given a sorted array of integers, find the starting and ending position of
              a given target value. If target is not found, return [-1, -1]. Must run in
              O(log n) time.
            hints:
              - "Run binary search twice: once for the leftmost occurrence, once for the rightmost"
              - "For leftmost: when nums[mid] == target, keep searching left (hi = mid)"
              - "For rightmost: when nums[mid] == target, keep searching right (lo = mid + 1)"
            solution: |
              func searchRange(nums []int, target int) []int {
                  left := findBound(nums, target, true)
                  if left == -1 {
                      return []int{-1, -1}
                  }
                  right := findBound(nums, target, false)
                  return []int{left, right}
              }

              func findBound(nums []int, target int, isLeft bool) int {
                  lo, hi := 0, len(nums)-1
                  result := -1
                  for lo <= hi {
                      mid := lo + (hi-lo)/2
                      if nums[mid] == target {
                          result = mid
                          if isLeft {
                              hi = mid - 1
                          } else {
                              lo = mid + 1
                          }
                      } else if nums[mid] < target {
                          lo = mid + 1
                      } else {
                          hi = mid - 1
                      }
                  }
                  return result
              }
            testCases: |
              fmt.Println(searchRange([]int{5, 7, 7, 8, 8, 10}, 8)) // [3 4]
              fmt.Println(searchRange([]int{5, 7, 7, 8, 8, 10}, 6)) // [-1 -1]
              fmt.Println(searchRange([]int{}, 0))                    // [-1 -1]
              fmt.Println(searchRange([]int{1}, 1))                   // [0 0]
      - id: search-rotated
        name: Search in Rotated Sorted Array
        concept: "Modified Binary Search"
        difficulty: 2
        docLinks:
          - url: "https://pkg.go.dev/sort"
            title: "Go sort"
            note: "Understanding sorted invariants for modified searches"
        patternPrimer:
          bruteForce: "Linear scan - O(n)"
          bestApproach: "Modified binary search checking which half is sorted first - O(log n)"
          typical: "Identify the sorted half, then check if target is in that range to decide direction"
        variants:
          - id: v1
            title: "Search in Rotated Sorted Array"
            difficulty: 2
            description: |
              Given a sorted array that has been rotated at some pivot (e.g., [4,5,6,7,0,1,2]),
              search for a target value. Return its index or -1 if not found. All values are
              unique. Must run in O(log n).
            hints:
              - "At each step, one half of the array is always sorted"
              - "Check if nums[lo] <= nums[mid] to determine which half is sorted"
              - "If target falls in the sorted half's range, search there; otherwise search the other half"
            solution: |
              func searchRotated(nums []int, target int) int {
                  lo, hi := 0, len(nums)-1
                  for lo <= hi {
                      mid := lo + (hi-lo)/2
                      if nums[mid] == target {
                          return mid
                      }
                      if nums[lo] <= nums[mid] {
                          if target >= nums[lo] && target < nums[mid] {
                              hi = mid - 1
                          } else {
                              lo = mid + 1
                          }
                      } else {
                          if target > nums[mid] && target <= nums[hi] {
                              lo = mid + 1
                          } else {
                              hi = mid - 1
                          }
                      }
                  }
                  return -1
              }
            testCases: |
              fmt.Println(searchRotated([]int{4, 5, 6, 7, 0, 1, 2}, 0)) // 4
              fmt.Println(searchRotated([]int{4, 5, 6, 7, 0, 1, 2}, 3)) // -1
              fmt.Println(searchRotated([]int{1}, 0))                     // -1
              fmt.Println(searchRotated([]int{3, 1}, 1))                  // 1
          - id: v2
            title: "Find Minimum in Rotated Sorted Array"
            difficulty: 2
            description: |
              Given a sorted array that has been rotated, find the minimum element.
              All elements are unique. Must run in O(log n).
            hints:
              - "Compare nums[mid] with nums[hi] to determine which half the minimum is in"
              - "If nums[mid] > nums[hi], the minimum is in the right half"
              - "Otherwise, the minimum is in the left half (including mid)"
            solution: |
              func findMin(nums []int) int {
                  lo, hi := 0, len(nums)-1
                  for lo < hi {
                      mid := lo + (hi-lo)/2
                      if nums[mid] > nums[hi] {
                          lo = mid + 1
                      } else {
                          hi = mid
                      }
                  }
                  return nums[lo]
              }
            testCases: |
              fmt.Println(findMin([]int{3, 4, 5, 1, 2}))    // 1
              fmt.Println(findMin([]int{4, 5, 6, 7, 0, 1, 2})) // 0
              fmt.Println(findMin([]int{11, 13, 15, 17}))   // 11
              fmt.Println(findMin([]int{2, 1}))              // 1
          - id: v3
            title: "Search in Rotated Array with Duplicates"
            difficulty: 3
            description: |
              Given a rotated sorted array that may contain duplicates, determine if a target
              value exists in the array. Return true or false. This is the same as search in
              rotated sorted array, but duplicates make it harder to determine the sorted half.
            hints:
              - "When nums[lo] == nums[mid] == nums[hi], you cannot determine which half is sorted"
              - "In that case, shrink both ends: lo++, hi--"
              - "This makes worst case O(n) but average case O(log n)"
            solution: |
              func searchWithDups(nums []int, target int) bool {
                  lo, hi := 0, len(nums)-1
                  for lo <= hi {
                      mid := lo + (hi-lo)/2
                      if nums[mid] == target {
                          return true
                      }
                      if nums[lo] == nums[mid] && nums[mid] == nums[hi] {
                          lo++
                          hi--
                      } else if nums[lo] <= nums[mid] {
                          if target >= nums[lo] && target < nums[mid] {
                              hi = mid - 1
                          } else {
                              lo = mid + 1
                          }
                      } else {
                          if target > nums[mid] && target <= nums[hi] {
                              lo = mid + 1
                          } else {
                              hi = mid - 1
                          }
                      }
                  }
                  return false
              }
            testCases: |
              fmt.Println(searchWithDups([]int{2, 5, 6, 0, 0, 1, 2}, 0)) // true
              fmt.Println(searchWithDups([]int{2, 5, 6, 0, 0, 1, 2}, 3)) // false
              fmt.Println(searchWithDups([]int{1, 0, 1, 1, 1}, 0))       // true
              fmt.Println(searchWithDups([]int{1, 1, 1, 1, 1}, 2))       // false
      - id: koko-bananas
        name: Koko Eating Bananas
        concept: "Binary Search on Answer"
        difficulty: 2
        docLinks:
          - url: "https://pkg.go.dev/math"
            title: "Go math"
            note: "Ceil division for calculating hours at a given speed"
        patternPrimer:
          bruteForce: "Try every possible speed from 1 to max(piles) - O(max * n)"
          bestApproach: "Binary search on the speed value, check feasibility at each mid - O(n log max)"
          typical: "Binary search on answer space when you can verify a candidate solution efficiently"
        variants:
          - id: v1
            title: "Koko Eating Bananas"
            difficulty: 2
            description: |
              Koko loves bananas. There are n piles of bananas. She can eat at speed k
              bananas per hour. Each hour she picks a pile and eats k bananas from it
              (if the pile has fewer than k, she eats all and waits). She has h hours.
              Return the minimum integer k such that she can eat all bananas within h hours.
            hints:
              - "Binary search on the answer (speed k) between 1 and max(piles)"
              - "For a given speed, calculate total hours needed using ceil(pile/k) for each pile"
              - "If total hours <= h, the speed works; try a smaller speed"
            solution: |
              func minEatingSpeed(piles []int, h int) int {
                  lo, hi := 1, 0
                  for _, p := range piles {
                      if p > hi {
                          hi = p
                      }
                  }
                  for lo < hi {
                      mid := lo + (hi-lo)/2
                      hours := 0
                      for _, p := range piles {
                          hours += (p + mid - 1) / mid
                      }
                      if hours <= h {
                          hi = mid
                      } else {
                          lo = mid + 1
                      }
                  }
                  return lo
              }
            testCases: |
              fmt.Println(minEatingSpeed([]int{3, 6, 7, 11}, 8))       // 4
              fmt.Println(minEatingSpeed([]int{30, 11, 23, 4, 20}, 5)) // 30
              fmt.Println(minEatingSpeed([]int{30, 11, 23, 4, 20}, 6)) // 23
          - id: v2
            title: "Split Array Largest Sum"
            difficulty: 3
            description: |
              Given an integer array nums and an integer k, split the array into k
              non-empty contiguous subarrays such that the largest sum among them is
              minimized. Return the minimized largest sum.
            hints:
              - "Binary search on the answer: the maximum subarray sum"
              - "Range is [max(nums), sum(nums)]"
              - "For a given max sum, greedily count how many subarrays are needed"
            solution: |
              func splitArray(nums []int, k int) int {
                  lo, hi := 0, 0
                  for _, n := range nums {
                      if n > lo {
                          lo = n
                      }
                      hi += n
                  }
                  for lo < hi {
                      mid := lo + (hi-lo)/2
                      count := 1
                      sum := 0
                      for _, n := range nums {
                          if sum+n > mid {
                              count++
                              sum = n
                          } else {
                              sum += n
                          }
                      }
                      if count <= k {
                          hi = mid
                      } else {
                          lo = mid + 1
                      }
                  }
                  return lo
              }
            testCases: |
              fmt.Println(splitArray([]int{7, 2, 5, 10, 8}, 2)) // 18
              fmt.Println(splitArray([]int{1, 2, 3, 4, 5}, 2))  // 9
              fmt.Println(splitArray([]int{1, 4, 4}, 3))         // 4
          - id: v3
            title: "Capacity to Ship Packages Within D Days"
            difficulty: 2
            description: |
              Packages on a conveyor belt must be shipped from one port to another within
              d days. The ith package has weight weights[i]. Packages must be shipped in
              order. Return the least weight capacity of the ship that will ship all
              packages within d days.
            hints:
              - "Binary search on ship capacity between max(weights) and sum(weights)"
              - "For a given capacity, simulate loading: when adding a package exceeds capacity, start a new day"
              - "Count days needed; if days <= d, try a smaller capacity"
            solution: |
              func shipWithinDays(weights []int, days int) int {
                  lo, hi := 0, 0
                  for _, w := range weights {
                      if w > lo {
                          lo = w
                      }
                      hi += w
                  }
                  for lo < hi {
                      mid := lo + (hi-lo)/2
                      d := 1
                      cur := 0
                      for _, w := range weights {
                          if cur+w > mid {
                              d++
                              cur = w
                          } else {
                              cur += w
                          }
                      }
                      if d <= days {
                          hi = mid
                      } else {
                          lo = mid + 1
                      }
                  }
                  return lo
              }
            testCases: |
              fmt.Println(shipWithinDays([]int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}, 5)) // 15
              fmt.Println(shipWithinDays([]int{3, 2, 2, 4, 1, 4}, 3))               // 6
              fmt.Println(shipWithinDays([]int{1, 2, 3, 1, 1}, 4))                   // 3
      - id: search-matrix
        name: Search a 2D Matrix
        concept: "2D Binary Search"
        difficulty: 1
        docLinks:
          - url: "https://pkg.go.dev/sort#Search"
            title: "Go sort.Search"
            note: "Built-in binary search helper"
        patternPrimer:
          bruteForce: "Scan every cell in the matrix - O(m * n)"
          bestApproach: "Treat the 2D matrix as a flat sorted array and binary search - O(log(m*n))"
          typical: "Map 1D index to 2D coordinates using row = idx/cols, col = idx%cols"
        variants:
          - id: v1
            title: "Search a 2D Matrix"
            difficulty: 1
            description: |
              Write an efficient algorithm that searches for a value in an m x n integer
              matrix. The matrix has the property that each row is sorted left to right,
              and the first integer of each row is greater than the last integer of the
              previous row.
            hints:
              - "Treat the entire matrix as a single sorted array of m*n elements"
              - "Map a 1D index to 2D: row = index / cols, col = index % cols"
              - "Standard binary search on this virtual 1D array"
            solution: |
              func searchMatrix(matrix [][]int, target int) bool {
                  if len(matrix) == 0 || len(matrix[0]) == 0 {
                      return false
                  }
                  rows, cols := len(matrix), len(matrix[0])
                  lo, hi := 0, rows*cols-1
                  for lo <= hi {
                      mid := lo + (hi-lo)/2
                      val := matrix[mid/cols][mid%cols]
                      if val == target {
                          return true
                      } else if val < target {
                          lo = mid + 1
                      } else {
                          hi = mid - 1
                      }
                  }
                  return false
              }
            testCases: |
              matrix := [][]int{{1, 3, 5, 7}, {10, 11, 16, 20}, {23, 30, 34, 60}}
              fmt.Println(searchMatrix(matrix, 3))  // true
              fmt.Println(searchMatrix(matrix, 13)) // false
              fmt.Println(searchMatrix(matrix, 60)) // true
          - id: v2
            title: "Search a 2D Matrix II"
            difficulty: 2
            description: |
              Write an efficient algorithm that searches for a target value in an m x n
              integer matrix where each row is sorted left to right AND each column is
              sorted top to bottom (but the first element of a row is NOT necessarily
              greater than the last element of the previous row).
            hints:
              - "Start from the top-right corner (or bottom-left)"
              - "If current > target, move left; if current < target, move down"
              - "This eliminates one row or column at each step - O(m + n)"
            solution: |
              func searchMatrixII(matrix [][]int, target int) bool {
                  if len(matrix) == 0 || len(matrix[0]) == 0 {
                      return false
                  }
                  row := 0
                  col := len(matrix[0]) - 1
                  for row < len(matrix) && col >= 0 {
                      if matrix[row][col] == target {
                          return true
                      } else if matrix[row][col] > target {
                          col--
                      } else {
                          row++
                      }
                  }
                  return false
              }
            testCases: |
              matrix := [][]int{
                  {1, 4, 7, 11, 15},
                  {2, 5, 8, 12, 19},
                  {3, 6, 9, 16, 22},
                  {10, 13, 14, 17, 24},
                  {18, 21, 23, 26, 30},
              }
              fmt.Println(searchMatrixII(matrix, 5))  // true
              fmt.Println(searchMatrixII(matrix, 20)) // false
          - id: v3
            title: "Kth Smallest Element in Sorted Matrix"
            difficulty: 3
            description: |
              Given an n x n matrix where each row and column is sorted in ascending order,
              return the kth smallest element. Note that it is the kth smallest in the
              sorted order, not the kth distinct element.
            hints:
              - "Binary search on the value range [matrix[0][0], matrix[n-1][n-1]]"
              - "For a given value mid, count how many elements are <= mid"
              - "Count efficiently by starting from the bottom-left of each column"
            solution: |
              func kthSmallest(matrix [][]int, k int) int {
                  n := len(matrix)
                  lo, hi := matrix[0][0], matrix[n-1][n-1]
                  for lo < hi {
                      mid := lo + (hi-lo)/2
                      count := countLessOrEqual(matrix, mid, n)
                      if count < k {
                          lo = mid + 1
                      } else {
                          hi = mid
                      }
                  }
                  return lo
              }

              func countLessOrEqual(matrix [][]int, target, n int) int {
                  count := 0
                  row := n - 1
                  col := 0
                  for row >= 0 && col < n {
                      if matrix[row][col] <= target {
                          count += row + 1
                          col++
                      } else {
                          row--
                      }
                  }
                  return count
              }
            testCases: |
              matrix := [][]int{{1, 5, 9}, {10, 11, 13}, {12, 13, 15}}
              fmt.Println(kthSmallest(matrix, 8)) // 13
              matrix2 := [][]int{{-5}}
              fmt.Println(kthSmallest(matrix2, 1)) // -5
      - id: sqrt-x
        name: Sqrt(x)
        concept: "Value Binary Search"
        difficulty: 1
        docLinks:
          - url: "https://pkg.go.dev/math"
            title: "Go math"
            note: "math.Sqrt exists but the goal is to implement binary search"
        patternPrimer:
          bruteForce: "Try every integer from 1 upward until i*i > x - O(sqrt(n))"
          bestApproach: "Binary search on the answer from 1 to x - O(log n)"
          typical: "Value binary search applies when you search for a number satisfying a monotonic condition"
        variants:
          - id: v1
            title: "Integer Square Root"
            difficulty: 1
            description: |
              Given a non-negative integer x, return the integer square root of x. The
              integer square root is the largest integer y such that y * y <= x. Do not
              use any built-in exponent function or operator.
            hints:
              - "Binary search between 0 and x"
              - "Check if mid * mid <= x and (mid+1) * (mid+1) > x"
              - "Use mid * mid <= x to avoid overflow issues (or use hi = mid vs lo = mid+1)"
            solution: |
              func mySqrt(x int) int {
                  if x < 2 {
                      return x
                  }
                  lo, hi := 1, x/2
                  for lo <= hi {
                      mid := lo + (hi-lo)/2
                      if mid <= x/mid {
                          lo = mid + 1
                      } else {
                          hi = mid - 1
                      }
                  }
                  return lo - 1
              }
            testCases: |
              fmt.Println(mySqrt(4))  // 2
              fmt.Println(mySqrt(8))  // 2
              fmt.Println(mySqrt(0))  // 0
              fmt.Println(mySqrt(1))  // 1
              fmt.Println(mySqrt(16)) // 4
          - id: v2
            title: "Find Peak Element"
            difficulty: 2
            description: |
              A peak element is strictly greater than its neighbors. Given an integer array
              nums, find a peak element and return its index. The array may contain multiple
              peaks; return the index to any one of them. You may assume nums[-1] = nums[n] = -infinity.
              Must run in O(log n).
            hints:
              - "Binary search: compare nums[mid] with nums[mid+1]"
              - "If nums[mid] < nums[mid+1], a peak exists to the right"
              - "Otherwise, a peak exists to the left (including mid)"
            solution: |
              func findPeakElement(nums []int) int {
                  lo, hi := 0, len(nums)-1
                  for lo < hi {
                      mid := lo + (hi-lo)/2
                      if nums[mid] < nums[mid+1] {
                          lo = mid + 1
                      } else {
                          hi = mid
                      }
                  }
                  return lo
              }
            testCases: |
              fmt.Println(findPeakElement([]int{1, 2, 3, 1}))       // 2
              fmt.Println(findPeakElement([]int{1, 2, 1, 3, 5, 6, 4})) // 5 (or 1)
              fmt.Println(findPeakElement([]int{1}))                 // 0
              fmt.Println(findPeakElement([]int{1, 2}))              // 1
          - id: v3
            title: "Find Minimum in Mountain Array"
            difficulty: 3
            description: |
              A mountain array is an array where values increase to a peak and then decrease.
              Given a mountain array, find the index of the peak element. You cannot access
              the array directly; you are given a MountainArray interface with Get(index) int
              and Length() int. Minimize the number of calls to Get.

              For simplicity, implement with a regular array: find the peak index in an
              array that first increases then decreases.
            hints:
              - "Binary search for the peak: compare arr[mid] with arr[mid+1]"
              - "If arr[mid] < arr[mid+1], the peak is to the right"
              - "If arr[mid] > arr[mid+1], the peak is at mid or to the left"
            solution: |
              func peakIndexInMountainArray(arr []int) int {
                  lo, hi := 0, len(arr)-1
                  for lo < hi {
                      mid := lo + (hi-lo)/2
                      if arr[mid] < arr[mid+1] {
                          lo = mid + 1
                      } else {
                          hi = mid
                      }
                  }
                  return lo
              }
            testCases: |
              fmt.Println(peakIndexInMountainArray([]int{0, 1, 0}))          // 1
              fmt.Println(peakIndexInMountainArray([]int{0, 2, 1, 0}))       // 1
              fmt.Println(peakIndexInMountainArray([]int{0, 10, 5, 2}))      // 1
              fmt.Println(peakIndexInMountainArray([]int{3, 5, 3, 2, 0}))    // 1
              fmt.Println(peakIndexInMountainArray([]int{1, 3, 5, 7, 6, 4})) // 3
  - id: linked-list
    name: Linked List
    icon: "â†’"
    order: 6
    description: "Pointer manipulation and list traversal patterns"
    problems:
      - id: reverse-list
        name: Reverse Linked List
        concept: "Pointer Reversal"
        difficulty: 1
        docLinks:
          - url: "https://pkg.go.dev/builtin"
            title: "Go Builtin"
            note: "Pointer semantics for struct manipulation"
        patternPrimer:
          bruteForce: "Collect all values into an array, build a new list in reverse - O(n) space"
          bestApproach: "Iteratively reverse pointers in-place using prev/curr/next - O(1) space"
          typical: "Pointer reversal is a fundamental building block for many linked list problems"
        variants:
          - id: v1
            title: "Reverse Linked List"
            difficulty: 1
            description: |
              Given the head of a singly linked list, reverse the list and return the
              reversed list.

              type ListNode struct {
                  Val  int
                  Next *ListNode
              }
            hints:
              - "Use three pointers: prev, curr, next"
              - "At each step, save next, point curr.Next to prev, advance prev and curr"
              - "When curr is nil, prev is the new head"
            solution: |
              type ListNode struct {
                  Val  int
                  Next *ListNode
              }

              func reverseList(head *ListNode) *ListNode {
                  var prev *ListNode
                  curr := head
                  for curr != nil {
                      next := curr.Next
                      curr.Next = prev
                      prev = curr
                      curr = next
                  }
                  return prev
              }
            testCases: |
              // Helper to build and print list
              build := func(vals []int) *ListNode {
                  dummy := &ListNode{}
                  curr := dummy
                  for _, v := range vals {
                      curr.Next = &ListNode{Val: v}
                      curr = curr.Next
                  }
                  return dummy.Next
              }
              printList := func(head *ListNode) {
                  for head != nil {
                      fmt.Print(head.Val, " ")
                      head = head.Next
                  }
                  fmt.Println()
              }
              printList(reverseList(build([]int{1, 2, 3, 4, 5}))) // 5 4 3 2 1
              printList(reverseList(build([]int{1, 2})))           // 2 1
              printList(reverseList(build([]int{})))               // (empty)
          - id: v2
            title: "Reverse Linked List II"
            difficulty: 2
            description: |
              Given the head of a singly linked list and two integers left and right where
              left <= right, reverse the nodes of the list from position left to position
              right, and return the reversed list. Positions are 1-indexed.
            hints:
              - "Use a dummy node before head to handle edge cases"
              - "Navigate to the node just before position left"
              - "Reverse the sublist from left to right, then reconnect the pointers"
            solution: |
              type ListNode struct {
                  Val  int
                  Next *ListNode
              }

              func reverseBetween(head *ListNode, left, right int) *ListNode {
                  if head == nil || left == right {
                      return head
                  }
                  dummy := &ListNode{Next: head}
                  prev := dummy
                  for i := 1; i < left; i++ {
                      prev = prev.Next
                  }
                  curr := prev.Next
                  for i := 0; i < right-left; i++ {
                      next := curr.Next
                      curr.Next = next.Next
                      next.Next = prev.Next
                      prev.Next = next
                  }
                  return dummy.Next
              }
            testCases: |
              build := func(vals []int) *ListNode {
                  dummy := &ListNode{}
                  curr := dummy
                  for _, v := range vals {
                      curr.Next = &ListNode{Val: v}
                      curr = curr.Next
                  }
                  return dummy.Next
              }
              printList := func(head *ListNode) {
                  for head != nil {
                      fmt.Print(head.Val, " ")
                      head = head.Next
                  }
                  fmt.Println()
              }
              printList(reverseBetween(build([]int{1, 2, 3, 4, 5}), 2, 4)) // 1 4 3 2 5
              printList(reverseBetween(build([]int{5}), 1, 1))              // 5
              printList(reverseBetween(build([]int{3, 5}), 1, 2))           // 5 3
          - id: v3
            title: "Reverse Nodes in k-Group"
            difficulty: 3
            description: |
              Given the head of a linked list, reverse the nodes of the list k at a time
              and return the modified list. k is a positive integer less than or equal to
              the length of the list. If the number of nodes is not a multiple of k, the
              remaining nodes at the end should stay as-is.
            hints:
              - "First count the total number of nodes"
              - "Process k nodes at a time: reverse them using the same pointer reversal technique"
              - "Use a dummy node and track the tail of the previous group for reconnection"
            solution: |
              type ListNode struct {
                  Val  int
                  Next *ListNode
              }

              func reverseKGroup(head *ListNode, k int) *ListNode {
                  count := 0
                  curr := head
                  for curr != nil {
                      count++
                      curr = curr.Next
                  }
                  dummy := &ListNode{Next: head}
                  prevGroupEnd := dummy
                  curr = head
                  for count >= k {
                      groupStart := curr
                      var prev *ListNode
                      for i := 0; i < k; i++ {
                          next := curr.Next
                          curr.Next = prev
                          prev = curr
                          curr = next
                      }
                      prevGroupEnd.Next = prev
                      groupStart.Next = curr
                      prevGroupEnd = groupStart
                      count -= k
                  }
                  return dummy.Next
              }
            testCases: |
              build := func(vals []int) *ListNode {
                  dummy := &ListNode{}
                  curr := dummy
                  for _, v := range vals {
                      curr.Next = &ListNode{Val: v}
                      curr = curr.Next
                  }
                  return dummy.Next
              }
              printList := func(head *ListNode) {
                  for head != nil {
                      fmt.Print(head.Val, " ")
                      head = head.Next
                  }
                  fmt.Println()
              }
              printList(reverseKGroup(build([]int{1, 2, 3, 4, 5}), 2)) // 2 1 4 3 5
              printList(reverseKGroup(build([]int{1, 2, 3, 4, 5}), 3)) // 3 2 1 4 5
              printList(reverseKGroup(build([]int{1, 2, 3, 4, 5}), 1)) // 1 2 3 4 5
      - id: merge-two-sorted
        name: Merge Two Sorted Lists
        concept: "Merge Pattern"
        difficulty: 1
        docLinks:
          - url: "https://pkg.go.dev/container/heap"
            title: "Go container/heap"
            note: "Min-heap for merging k sorted lists efficiently"
        patternPrimer:
          bruteForce: "Collect all nodes into an array and sort - O(n log n)"
          bestApproach: "Two-pointer merge with a dummy head node - O(n)"
          typical: "The merge pattern extends to k lists using a heap or divide-and-conquer"
        variants:
          - id: v1
            title: "Merge Two Sorted Lists"
            difficulty: 1
            description: |
              Merge two sorted linked lists and return it as a single sorted list. The list
              should be made by splicing together the nodes of the two input lists.

              type ListNode struct {
                  Val  int
                  Next *ListNode
              }
            hints:
              - "Use a dummy node as the start of the merged list"
              - "Compare the current nodes of both lists, append the smaller one"
              - "When one list is exhausted, append the remainder of the other"
            solution: |
              type ListNode struct {
                  Val  int
                  Next *ListNode
              }

              func mergeTwoLists(l1, l2 *ListNode) *ListNode {
                  dummy := &ListNode{}
                  curr := dummy
                  for l1 != nil && l2 != nil {
                      if l1.Val <= l2.Val {
                          curr.Next = l1
                          l1 = l1.Next
                      } else {
                          curr.Next = l2
                          l2 = l2.Next
                      }
                      curr = curr.Next
                  }
                  if l1 != nil {
                      curr.Next = l1
                  } else {
                      curr.Next = l2
                  }
                  return dummy.Next
              }
            testCases: |
              build := func(vals []int) *ListNode {
                  dummy := &ListNode{}
                  curr := dummy
                  for _, v := range vals {
                      curr.Next = &ListNode{Val: v}
                      curr = curr.Next
                  }
                  return dummy.Next
              }
              printList := func(head *ListNode) {
                  for head != nil {
                      fmt.Print(head.Val, " ")
                      head = head.Next
                  }
                  fmt.Println()
              }
              printList(mergeTwoLists(build([]int{1, 2, 4}), build([]int{1, 3, 4})))
              // 1 1 2 3 4 4
              printList(mergeTwoLists(build([]int{}), build([]int{0})))
              // 0
          - id: v2
            title: "Merge K Sorted Lists"
            difficulty: 3
            description: |
              Given an array of k sorted linked lists, merge them into one sorted linked
              list. Use a min-heap (priority queue) for optimal efficiency.
            hints:
              - "Use container/heap with a custom type wrapping *ListNode"
              - "Push the head of each non-nil list onto the heap"
              - "Pop the minimum, append to result, push its next node if it exists"
            solution: |
              type ListNode struct {
                  Val  int
                  Next *ListNode
              }

              type NodeHeap []*ListNode

              func (h NodeHeap) Len() int            { return len(h) }
              func (h NodeHeap) Less(i, j int) bool  { return h[i].Val < h[j].Val }
              func (h NodeHeap) Swap(i, j int)       { h[i], h[j] = h[j], h[i] }
              func (h *NodeHeap) Push(x interface{}) { *h = append(*h, x.(*ListNode)) }
              func (h *NodeHeap) Pop() interface{} {
                  old := *h
                  n := len(old)
                  x := old[n-1]
                  *h = old[:n-1]
                  return x
              }

              func mergeKLists(lists []*ListNode) *ListNode {
                  h := &NodeHeap{}
                  heap.Init(h)
                  for _, l := range lists {
                      if l != nil {
                          heap.Push(h, l)
                      }
                  }
                  dummy := &ListNode{}
                  curr := dummy
                  for h.Len() > 0 {
                      node := heap.Pop(h).(*ListNode)
                      curr.Next = node
                      curr = curr.Next
                      if node.Next != nil {
                          heap.Push(h, node.Next)
                      }
                  }
                  return dummy.Next
              }
            testCases: |
              build := func(vals []int) *ListNode {
                  dummy := &ListNode{}
                  curr := dummy
                  for _, v := range vals {
                      curr.Next = &ListNode{Val: v}
                      curr = curr.Next
                  }
                  return dummy.Next
              }
              printList := func(head *ListNode) {
                  for head != nil {
                      fmt.Print(head.Val, " ")
                      head = head.Next
                  }
                  fmt.Println()
              }
              lists := []*ListNode{
                  build([]int{1, 4, 5}),
                  build([]int{1, 3, 4}),
                  build([]int{2, 6}),
              }
              printList(mergeKLists(lists)) // 1 1 2 3 4 4 5 6
          - id: v3
            title: "Sort a Linked List"
            difficulty: 2
            description: |
              Given the head of a linked list, sort it in ascending order using merge sort
              in O(n log n) time and O(1) space (or O(log n) for recursion stack).
            hints:
              - "Use fast/slow pointers to find the middle of the list"
              - "Split the list into two halves at the middle"
              - "Recursively sort each half, then merge the two sorted halves"
            solution: |
              type ListNode struct {
                  Val  int
                  Next *ListNode
              }

              func sortList(head *ListNode) *ListNode {
                  if head == nil || head.Next == nil {
                      return head
                  }
                  slow, fast := head, head.Next
                  for fast != nil && fast.Next != nil {
                      slow = slow.Next
                      fast = fast.Next.Next
                  }
                  mid := slow.Next
                  slow.Next = nil
                  left := sortList(head)
                  right := sortList(mid)
                  return mergeSorted(left, right)
              }

              func mergeSorted(l1, l2 *ListNode) *ListNode {
                  dummy := &ListNode{}
                  curr := dummy
                  for l1 != nil && l2 != nil {
                      if l1.Val <= l2.Val {
                          curr.Next = l1
                          l1 = l1.Next
                      } else {
                          curr.Next = l2
                          l2 = l2.Next
                      }
                      curr = curr.Next
                  }
                  if l1 != nil {
                      curr.Next = l1
                  } else {
                      curr.Next = l2
                  }
                  return dummy.Next
              }
            testCases: |
              build := func(vals []int) *ListNode {
                  dummy := &ListNode{}
                  curr := dummy
                  for _, v := range vals {
                      curr.Next = &ListNode{Val: v}
                      curr = curr.Next
                  }
                  return dummy.Next
              }
              printList := func(head *ListNode) {
                  for head != nil {
                      fmt.Print(head.Val, " ")
                      head = head.Next
                  }
                  fmt.Println()
              }
              printList(sortList(build([]int{4, 2, 1, 3})))    // 1 2 3 4
              printList(sortList(build([]int{-1, 5, 3, 4, 0}))) // -1 0 3 4 5
              printList(sortList(build([]int{})))                // (empty)
      - id: detect-cycle
        name: Detect Cycle
        concept: "Floyd's Algorithm"
        difficulty: 2
        docLinks:
          - url: "https://pkg.go.dev/builtin"
            title: "Go Builtin"
            note: "Pointer comparison for cycle detection"
        patternPrimer:
          bruteForce: "Use a hash set to track visited nodes - O(n) space"
          bestApproach: "Floyd's tortoise and hare: slow moves 1 step, fast moves 2 - O(1) space"
          typical: "Floyd's algorithm detects cycles and finds cycle start with two phases"
        variants:
          - id: v1
            title: "Linked List Cycle"
            difficulty: 1
            description: |
              Given the head of a linked list, determine if the linked list has a cycle.
              A cycle exists if some node can be reached again by continuously following
              the Next pointer. Use O(1) memory.

              type ListNode struct {
                  Val  int
                  Next *ListNode
              }
            hints:
              - "Use two pointers: slow moves 1 step, fast moves 2 steps"
              - "If there is a cycle, fast will eventually meet slow"
              - "If fast reaches nil, there is no cycle"
            solution: |
              type ListNode struct {
                  Val  int
                  Next *ListNode
              }

              func hasCycle(head *ListNode) bool {
                  slow, fast := head, head
                  for fast != nil && fast.Next != nil {
                      slow = slow.Next
                      fast = fast.Next.Next
                      if slow == fast {
                          return true
                      }
                  }
                  return false
              }
            testCases: |
              // Build list with cycle
              n1 := &ListNode{Val: 3}
              n2 := &ListNode{Val: 2}
              n3 := &ListNode{Val: 0}
              n4 := &ListNode{Val: -4}
              n1.Next = n2
              n2.Next = n3
              n3.Next = n4
              n4.Next = n2 // cycle to node 2
              fmt.Println(hasCycle(n1)) // true

              a1 := &ListNode{Val: 1}
              a2 := &ListNode{Val: 2}
              a1.Next = a2
              fmt.Println(hasCycle(a1)) // false
          - id: v2
            title: "Linked List Cycle II"
            difficulty: 2
            description: |
              Given the head of a linked list, return the node where the cycle begins.
              If there is no cycle, return nil. Use O(1) extra space.
            hints:
              - "Phase 1: Detect cycle using slow/fast pointers"
              - "Phase 2: Move one pointer to head, then advance both by 1 step"
              - "They will meet at the cycle start (mathematical proof based on distances)"
            solution: |
              type ListNode struct {
                  Val  int
                  Next *ListNode
              }

              func detectCycle(head *ListNode) *ListNode {
                  slow, fast := head, head
                  for fast != nil && fast.Next != nil {
                      slow = slow.Next
                      fast = fast.Next.Next
                      if slow == fast {
                          slow = head
                          for slow != fast {
                              slow = slow.Next
                              fast = fast.Next
                          }
                          return slow
                      }
                  }
                  return nil
              }
            testCases: |
              n1 := &ListNode{Val: 3}
              n2 := &ListNode{Val: 2}
              n3 := &ListNode{Val: 0}
              n4 := &ListNode{Val: -4}
              n1.Next = n2
              n2.Next = n3
              n3.Next = n4
              n4.Next = n2 // cycle starts at n2
              result := detectCycle(n1)
              fmt.Println(result.Val) // 2

              a1 := &ListNode{Val: 1}
              a2 := &ListNode{Val: 2}
              a1.Next = a2
              fmt.Println(detectCycle(a1)) // <nil>
          - id: v3
            title: "Find the Duplicate Number"
            difficulty: 3
            description: |
              Given an array of n+1 integers where each integer is in [1, n], there is
              exactly one repeated number. Find it without modifying the array and using
              O(1) extra space. Use Floyd's cycle detection on the array (treat values as
              next pointers: index 0 -> nums[0] -> nums[nums[0]] -> ...).
            hints:
              - "Treat the array as a linked list where nums[i] is the next pointer"
              - "Start at index 0; the duplicate creates a cycle"
              - "Phase 1: Find meeting point with slow/fast. Phase 2: Find cycle entry from start"
            solution: |
              func findDuplicate(nums []int) int {
                  slow, fast := nums[0], nums[nums[0]]
                  for slow != fast {
                      slow = nums[slow]
                      fast = nums[nums[fast]]
                  }
                  slow = 0
                  for slow != fast {
                      slow = nums[slow]
                      fast = nums[fast]
                  }
                  return slow
              }
            testCases: |
              fmt.Println(findDuplicate([]int{1, 3, 4, 2, 2})) // 2
              fmt.Println(findDuplicate([]int{3, 1, 3, 4, 2})) // 3
              fmt.Println(findDuplicate([]int{1, 1}))           // 1
              fmt.Println(findDuplicate([]int{2, 5, 9, 6, 9, 3, 8, 9, 7, 1})) // 9
      - id: remove-nth-end
        name: Remove Nth From End
        concept: "Two Pointer Gap"
        difficulty: 1
        docLinks:
          - url: "https://pkg.go.dev/builtin"
            title: "Go Builtin"
            note: "Pointer operations for node removal"
        patternPrimer:
          bruteForce: "Two passes: first count length, then remove the (length-n+1)th node - O(n)"
          bestApproach: "One pass: advance first pointer n steps ahead, then move both until first reaches end - O(n)"
          typical: "The two-pointer gap technique converts 'nth from end' to a single-pass problem"
        variants:
          - id: v1
            title: "Remove Nth Node From End of List"
            difficulty: 1
            description: |
              Given the head of a linked list, remove the nth node from the end of the list
              and return its head.

              type ListNode struct {
                  Val  int
                  Next *ListNode
              }
            hints:
              - "Use a dummy node before head to handle removing the first node"
              - "Advance a fast pointer n+1 steps ahead of a slow pointer"
              - "When fast reaches nil, slow is just before the node to remove"
            solution: |
              type ListNode struct {
                  Val  int
                  Next *ListNode
              }

              func removeNthFromEnd(head *ListNode, n int) *ListNode {
                  dummy := &ListNode{Next: head}
                  fast, slow := dummy, dummy
                  for i := 0; i <= n; i++ {
                      fast = fast.Next
                  }
                  for fast != nil {
                      fast = fast.Next
                      slow = slow.Next
                  }
                  slow.Next = slow.Next.Next
                  return dummy.Next
              }
            testCases: |
              build := func(vals []int) *ListNode {
                  dummy := &ListNode{}
                  curr := dummy
                  for _, v := range vals {
                      curr.Next = &ListNode{Val: v}
                      curr = curr.Next
                  }
                  return dummy.Next
              }
              printList := func(head *ListNode) {
                  for head != nil {
                      fmt.Print(head.Val, " ")
                      head = head.Next
                  }
                  fmt.Println()
              }
              printList(removeNthFromEnd(build([]int{1, 2, 3, 4, 5}), 2)) // 1 2 3 5
              printList(removeNthFromEnd(build([]int{1}), 1))              // (empty)
              printList(removeNthFromEnd(build([]int{1, 2}), 1))           // 1
          - id: v2
            title: "Middle of the Linked List"
            difficulty: 1
            description: |
              Given the head of a singly linked list, return the middle node. If there are
              two middle nodes, return the second middle node.
            hints:
              - "Use slow and fast pointers starting at head"
              - "Slow moves 1 step, fast moves 2 steps"
              - "When fast reaches the end, slow is at the middle"
            solution: |
              type ListNode struct {
                  Val  int
                  Next *ListNode
              }

              func middleNode(head *ListNode) *ListNode {
                  slow, fast := head, head
                  for fast != nil && fast.Next != nil {
                      slow = slow.Next
                      fast = fast.Next.Next
                  }
                  return slow
              }
            testCases: |
              build := func(vals []int) *ListNode {
                  dummy := &ListNode{}
                  curr := dummy
                  for _, v := range vals {
                      curr.Next = &ListNode{Val: v}
                      curr = curr.Next
                  }
                  return dummy.Next
              }
              fmt.Println(middleNode(build([]int{1, 2, 3, 4, 5})).Val) // 3
              fmt.Println(middleNode(build([]int{1, 2, 3, 4, 5, 6})).Val) // 4
              fmt.Println(middleNode(build([]int{1})).Val) // 1
          - id: v3
            title: "Reorder List"
            difficulty: 2
            description: |
              Given the head of a singly linked list L0 -> L1 -> ... -> Ln-1 -> Ln,
              reorder it to L0 -> Ln -> L1 -> Ln-1 -> L2 -> Ln-2 -> ...
              You must do this in-place without modifying node values.
            hints:
              - "Step 1: Find the middle of the list using slow/fast pointers"
              - "Step 2: Reverse the second half of the list"
              - "Step 3: Merge the two halves by alternating nodes"
            solution: |
              type ListNode struct {
                  Val  int
                  Next *ListNode
              }

              func reorderList(head *ListNode) {
                  if head == nil || head.Next == nil {
                      return
                  }
                  // Find middle
                  slow, fast := head, head
                  for fast.Next != nil && fast.Next.Next != nil {
                      slow = slow.Next
                      fast = fast.Next.Next
                  }
                  // Reverse second half
                  var prev *ListNode
                  curr := slow.Next
                  slow.Next = nil
                  for curr != nil {
                      next := curr.Next
                      curr.Next = prev
                      prev = curr
                      curr = next
                  }
                  // Merge two halves
                  first, second := head, prev
                  for second != nil {
                      tmp1 := first.Next
                      tmp2 := second.Next
                      first.Next = second
                      second.Next = tmp1
                      first = tmp1
                      second = tmp2
                  }
              }
            testCases: |
              build := func(vals []int) *ListNode {
                  dummy := &ListNode{}
                  curr := dummy
                  for _, v := range vals {
                      curr.Next = &ListNode{Val: v}
                      curr = curr.Next
                  }
                  return dummy.Next
              }
              printList := func(head *ListNode) {
                  for head != nil {
                      fmt.Print(head.Val, " ")
                      head = head.Next
                  }
                  fmt.Println()
              }
              l1 := build([]int{1, 2, 3, 4})
              reorderList(l1)
              printList(l1) // 1 4 2 3
              l2 := build([]int{1, 2, 3, 4, 5})
              reorderList(l2)
              printList(l2) // 1 5 2 4 3
      - id: add-two-numbers
        name: Add Two Numbers
        concept: "Digit-by-digit Processing"
        difficulty: 2
        docLinks:
          - url: "https://pkg.go.dev/builtin"
            title: "Go Builtin"
            note: "Integer arithmetic for carry handling"
        patternPrimer:
          bruteForce: "Convert lists to integers, add, convert back - overflows for large numbers"
          bestApproach: "Process digit by digit with carry, building result list as you go - O(max(m,n))"
          typical: "Digit-by-digit with carry is the pattern for arbitrary-precision arithmetic"
        variants:
          - id: v1
            title: "Add Two Numbers"
            difficulty: 2
            description: |
              Given two non-empty linked lists representing two non-negative integers where
              digits are stored in reverse order, add the two numbers and return the sum as
              a linked list. Each node contains a single digit.

              type ListNode struct {
                  Val  int
                  Next *ListNode
              }
            hints:
              - "Process both lists simultaneously, tracking the carry"
              - "Create new nodes with (sum % 10), carry = sum / 10"
              - "Continue until both lists are exhausted AND carry is 0"
            solution: |
              type ListNode struct {
                  Val  int
                  Next *ListNode
              }

              func addTwoNumbers(l1, l2 *ListNode) *ListNode {
                  dummy := &ListNode{}
                  curr := dummy
                  carry := 0
                  for l1 != nil || l2 != nil || carry != 0 {
                      sum := carry
                      if l1 != nil {
                          sum += l1.Val
                          l1 = l1.Next
                      }
                      if l2 != nil {
                          sum += l2.Val
                          l2 = l2.Next
                      }
                      carry = sum / 10
                      curr.Next = &ListNode{Val: sum % 10}
                      curr = curr.Next
                  }
                  return dummy.Next
              }
            testCases: |
              build := func(vals []int) *ListNode {
                  dummy := &ListNode{}
                  curr := dummy
                  for _, v := range vals {
                      curr.Next = &ListNode{Val: v}
                      curr = curr.Next
                  }
                  return dummy.Next
              }
              printList := func(head *ListNode) {
                  for head != nil {
                      fmt.Print(head.Val, " ")
                      head = head.Next
                  }
                  fmt.Println()
              }
              // 342 + 465 = 807
              printList(addTwoNumbers(build([]int{2, 4, 3}), build([]int{5, 6, 4})))
              // 7 0 8
              // 0 + 0 = 0
              printList(addTwoNumbers(build([]int{0}), build([]int{0})))
              // 0
              // 9999999 + 9999 = 10009998
              printList(addTwoNumbers(build([]int{9, 9, 9, 9, 9, 9, 9}), build([]int{9, 9, 9, 9})))
              // 8 9 9 9 0 0 0 1
          - id: v2
            title: "Add Two Numbers II"
            difficulty: 2
            description: |
              Given two non-empty linked lists representing two non-negative integers where
              the most significant digit comes first (forward order), add them and return
              the sum as a linked list. You may not reverse the input lists.
            hints:
              - "Use two stacks to collect digits from both lists"
              - "Pop from both stacks simultaneously, adding with carry"
              - "Build the result list from least significant digit, prepending each new node"
            solution: |
              type ListNode struct {
                  Val  int
                  Next *ListNode
              }

              func addTwoNumbersII(l1, l2 *ListNode) *ListNode {
                  stack1 := []int{}
                  stack2 := []int{}
                  for l1 != nil {
                      stack1 = append(stack1, l1.Val)
                      l1 = l1.Next
                  }
                  for l2 != nil {
                      stack2 = append(stack2, l2.Val)
                      l2 = l2.Next
                  }
                  var head *ListNode
                  carry := 0
                  for len(stack1) > 0 || len(stack2) > 0 || carry != 0 {
                      sum := carry
                      if len(stack1) > 0 {
                          sum += stack1[len(stack1)-1]
                          stack1 = stack1[:len(stack1)-1]
                      }
                      if len(stack2) > 0 {
                          sum += stack2[len(stack2)-1]
                          stack2 = stack2[:len(stack2)-1]
                      }
                      carry = sum / 10
                      node := &ListNode{Val: sum % 10, Next: head}
                      head = node
                  }
                  return head
              }
            testCases: |
              build := func(vals []int) *ListNode {
                  dummy := &ListNode{}
                  curr := dummy
                  for _, v := range vals {
                      curr.Next = &ListNode{Val: v}
                      curr = curr.Next
                  }
                  return dummy.Next
              }
              printList := func(head *ListNode) {
                  for head != nil {
                      fmt.Print(head.Val, " ")
                      head = head.Next
                  }
                  fmt.Println()
              }
              // 7243 + 564 = 7807
              printList(addTwoNumbersII(build([]int{7, 2, 4, 3}), build([]int{5, 6, 4})))
              // 7 8 0 7
              // 5 + 5 = 10
              printList(addTwoNumbersII(build([]int{5}), build([]int{5})))
              // 1 0
          - id: v3
            title: "Palindrome Linked List"
            difficulty: 2
            description: |
              Given the head of a singly linked list, determine if it is a palindrome.
              Try to do it in O(n) time and O(1) space.
            hints:
              - "Find the middle using slow/fast pointers"
              - "Reverse the second half of the list in-place"
              - "Compare the first half with the reversed second half node by node"
            solution: |
              type ListNode struct {
                  Val  int
                  Next *ListNode
              }

              func isPalindrome(head *ListNode) bool {
                  if head == nil || head.Next == nil {
                      return true
                  }
                  // Find middle
                  slow, fast := head, head
                  for fast.Next != nil && fast.Next.Next != nil {
                      slow = slow.Next
                      fast = fast.Next.Next
                  }
                  // Reverse second half
                  var prev *ListNode
                  curr := slow.Next
                  for curr != nil {
                      next := curr.Next
                      curr.Next = prev
                      prev = curr
                      curr = next
                  }
                  // Compare halves
                  p1, p2 := head, prev
                  for p2 != nil {
                      if p1.Val != p2.Val {
                          return false
                      }
                      p1 = p1.Next
                      p2 = p2.Next
                  }
                  return true
              }
            testCases: |
              build := func(vals []int) *ListNode {
                  dummy := &ListNode{}
                  curr := dummy
                  for _, v := range vals {
                      curr.Next = &ListNode{Val: v}
                      curr = curr.Next
                  }
                  return dummy.Next
              }
              fmt.Println(isPalindrome(build([]int{1, 2, 2, 1})))    // true
              fmt.Println(isPalindrome(build([]int{1, 2})))           // false
              fmt.Println(isPalindrome(build([]int{1, 2, 3, 2, 1}))) // true
              fmt.Println(isPalindrome(build([]int{1})))              // true
  - id: trees
    name: Trees
    icon: "\u2295"
    order: 7
    description: "Binary tree traversal and recursive patterns"
    problems:
      - id: max-depth
        name: Maximum Depth
        concept: "Recursive Depth"
        difficulty: 1
        docLinks:
          - url: "https://pkg.go.dev/math#Max"
            title: "math.Max"
            note: "Compare two float64 values (cast int results)"
        patternPrimer:
          bruteForce: "Traverse every node, track depth manually with a counter"
          bestApproach: "Recursive DFS returning 1 + max(left, right) at each node"
          typical: "O(n) time, O(h) space where h is height"
        variants:
          - id: v1
            title: Maximum Depth of Binary Tree
            difficulty: 1
            description: "Given the root of a binary tree, return its maximum depth. The maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node."
            hints:
              - "Base case: if root is nil, return 0"
              - "Recursively find the depth of left and right subtrees, return 1 + max of both"
            solution: |
              type TreeNode struct {
                  Val   int
                  Left  *TreeNode
                  Right *TreeNode
              }

              func maxDepth(root *TreeNode) int {
                  if root == nil {
                      return 0
                  }
                  left := maxDepth(root.Left)
                  right := maxDepth(root.Right)
                  if left > right {
                      return 1 + left
                  }
                  return 1 + right
              }
            testCases: |
              // Tree:     3
              //          / \
              //         9  20
              //           /  \
              //          15   7
              root := &TreeNode{3, &TreeNode{9, nil, nil}, &TreeNode{20, &TreeNode{15, nil, nil}, &TreeNode{7, nil, nil}}}
              fmt.Println(maxDepth(root))    // 3
              fmt.Println(maxDepth(nil))     // 0
              fmt.Println(maxDepth(&TreeNode{1, nil, nil})) // 1
          - id: v2
            title: Minimum Depth of Binary Tree
            difficulty: 1
            description: "Given the root of a binary tree, find its minimum depth. The minimum depth is the number of nodes along the shortest path from the root node down to the nearest leaf node. A leaf is a node with no children."
            hints:
              - "Be careful: if one child is nil, you must go down the other side (not return 1)"
              - "A leaf node has both Left and Right as nil"
              - "Handle the case where only one subtree exists separately"
            solution: |
              type TreeNode struct {
                  Val   int
                  Left  *TreeNode
                  Right *TreeNode
              }

              func minDepth(root *TreeNode) int {
                  if root == nil {
                      return 0
                  }
                  if root.Left == nil && root.Right == nil {
                      return 1
                  }
                  if root.Left == nil {
                      return 1 + minDepth(root.Right)
                  }
                  if root.Right == nil {
                      return 1 + minDepth(root.Left)
                  }
                  left := minDepth(root.Left)
                  right := minDepth(root.Right)
                  if left < right {
                      return 1 + left
                  }
                  return 1 + right
              }
            testCases: |
              // Tree:     3
              //          / \
              //         9  20
              //           /  \
              //          15   7
              root := &TreeNode{3, &TreeNode{9, nil, nil}, &TreeNode{20, &TreeNode{15, nil, nil}, &TreeNode{7, nil, nil}}}
              fmt.Println(minDepth(root)) // 2
              // Tree:  2 -> 3 -> 4 -> 5 -> 6 (left-skewed)
              skewed := &TreeNode{2, nil, &TreeNode{3, nil, &TreeNode{4, nil, &TreeNode{5, nil, &TreeNode{6, nil, nil}}}}}
              fmt.Println(minDepth(skewed)) // 5
          - id: v3
            title: Balanced Binary Tree
            difficulty: 2
            description: "Given a binary tree, determine if it is height-balanced. A height-balanced binary tree is one in which the depth of the two subtrees of every node never differs by more than one."
            hints:
              - "A naive approach checks height at every node, leading to O(n^2). Can you check balance and compute height in one pass?"
              - "Return -1 from the helper to signal that a subtree is unbalanced"
              - "If either subtree returns -1, propagate -1 upward immediately"
            solution: |
              type TreeNode struct {
                  Val   int
                  Left  *TreeNode
                  Right *TreeNode
              }

              func isBalanced(root *TreeNode) bool {
                  return height(root) != -1
              }

              func height(node *TreeNode) int {
                  if node == nil {
                      return 0
                  }
                  left := height(node.Left)
                  if left == -1 {
                      return -1
                  }
                  right := height(node.Right)
                  if right == -1 {
                      return -1
                  }
                  diff := left - right
                  if diff < -1 || diff > 1 {
                      return -1
                  }
                  if left > right {
                      return 1 + left
                  }
                  return 1 + right
              }
            testCases: |
              // Balanced:    3
              //             / \
              //            9  20
              //              /  \
              //             15   7
              root := &TreeNode{3, &TreeNode{9, nil, nil}, &TreeNode{20, &TreeNode{15, nil, nil}, &TreeNode{7, nil, nil}}}
              fmt.Println(isBalanced(root)) // true
              // Unbalanced: 1 -> 2 -> 3 -> 4 (left-skewed depth 4, right depth 1)
              unbal := &TreeNode{1, &TreeNode{2, &TreeNode{3, &TreeNode{4, nil, nil}, nil}, nil}, nil}
              fmt.Println(isBalanced(unbal)) // false

      - id: invert-tree
        name: Invert Tree
        concept: "Tree Transformation"
        difficulty: 1
        docLinks:
          - url: "https://pkg.go.dev/fmt"
            title: "fmt package"
            note: "Print tree values for verification"
        patternPrimer:
          bruteForce: "Create a new tree with swapped children at every level"
          bestApproach: "Recursive swap: at each node, swap Left and Right, then recurse"
          typical: "O(n) time, O(h) space"
        variants:
          - id: v1
            title: Invert Binary Tree
            difficulty: 1
            description: "Given the root of a binary tree, invert the tree (mirror it) and return its root. Every left child becomes a right child and vice versa at all levels."
            hints:
              - "Base case: if root is nil, return nil"
              - "Swap root.Left and root.Right, then recursively invert both subtrees"
            solution: |
              type TreeNode struct {
                  Val   int
                  Left  *TreeNode
                  Right *TreeNode
              }

              func invertTree(root *TreeNode) *TreeNode {
                  if root == nil {
                      return nil
                  }
                  root.Left, root.Right = root.Right, root.Left
                  invertTree(root.Left)
                  invertTree(root.Right)
                  return root
              }
            testCases: |
              // Tree:     4            4
              //          / \   =>    / \
              //         2   7       7   2
              //        / \ / \    / \ / \
              //       1  3 6  9  9  6 3  1
              root := &TreeNode{4,
                  &TreeNode{2, &TreeNode{1, nil, nil}, &TreeNode{3, nil, nil}},
                  &TreeNode{7, &TreeNode{6, nil, nil}, &TreeNode{9, nil, nil}}}
              inv := invertTree(root)
              fmt.Println(inv.Val)             // 4
              fmt.Println(inv.Left.Val)        // 7
              fmt.Println(inv.Right.Val)       // 2
              fmt.Println(inv.Left.Left.Val)   // 9
          - id: v2
            title: Symmetric Tree
            difficulty: 1
            description: "Given the root of a binary tree, check whether it is a mirror of itself (symmetric around its center)."
            hints:
              - "Compare the left subtree with the right subtree using a helper that takes two nodes"
              - "Two nodes mirror each other if their values are equal, left.Left mirrors right.Right, and left.Right mirrors right.Left"
              - "Both nil is symmetric; one nil and one non-nil is not symmetric"
            solution: |
              type TreeNode struct {
                  Val   int
                  Left  *TreeNode
                  Right *TreeNode
              }

              func isSymmetric(root *TreeNode) bool {
                  if root == nil {
                      return true
                  }
                  return isMirror(root.Left, root.Right)
              }

              func isMirror(left, right *TreeNode) bool {
                  if left == nil && right == nil {
                      return true
                  }
                  if left == nil || right == nil {
                      return false
                  }
                  return left.Val == right.Val &&
                      isMirror(left.Left, right.Right) &&
                      isMirror(left.Right, right.Left)
              }
            testCases: |
              // Symmetric:     1
              //               / \
              //              2   2
              //             / \ / \
              //            3  4 4  3
              sym := &TreeNode{1,
                  &TreeNode{2, &TreeNode{3, nil, nil}, &TreeNode{4, nil, nil}},
                  &TreeNode{2, &TreeNode{4, nil, nil}, &TreeNode{3, nil, nil}}}
              fmt.Println(isSymmetric(sym)) // true
              // Not symmetric:  1
              //                / \
              //               2   2
              //                \   \
              //                 3   3
              asym := &TreeNode{1,
                  &TreeNode{2, nil, &TreeNode{3, nil, nil}},
                  &TreeNode{2, nil, &TreeNode{3, nil, nil}}}
              fmt.Println(isSymmetric(asym)) // false
          - id: v3
            title: Flatten Binary Tree to Linked List
            difficulty: 2
            description: "Given the root of a binary tree, flatten the tree into a linked list in-place. The linked list should use the same TreeNode struct where Right points to the next node and Left is always nil. The list should be in pre-order traversal order."
            hints:
              - "Process the tree in reverse post-order (right, left, root) to build the list from tail to head"
              - "Keep a variable pointing to the previously processed node"
              - "For each node, set Right to the previous node and Left to nil"
            solution: |
              type TreeNode struct {
                  Val   int
                  Left  *TreeNode
                  Right *TreeNode
              }

              func flatten(root *TreeNode) {
                  var prev *TreeNode
                  var dfs func(node *TreeNode)
                  dfs = func(node *TreeNode) {
                      if node == nil {
                          return
                      }
                      dfs(node.Right)
                      dfs(node.Left)
                      node.Right = prev
                      node.Left = nil
                      prev = node
                  }
                  dfs(root)
              }
            testCases: |
              // Tree:     1          1
              //          / \          \
              //         2   5   =>    2
              //        / \   \         \
              //       3   4   6         3
              //                          \
              //                           4
              //                            \
              //                             5
              //                              \
              //                               6
              root := &TreeNode{1,
                  &TreeNode{2, &TreeNode{3, nil, nil}, &TreeNode{4, nil, nil}},
                  &TreeNode{5, nil, &TreeNode{6, nil, nil}}}
              flatten(root)
              for n := root; n != nil; n = n.Right {
                  fmt.Print(n.Val, " ")
              }
              // 1 2 3 4 5 6

      - id: level-order
        name: Level Order Traversal
        concept: "BFS Traversal"
        difficulty: 2
        docLinks:
          - url: "https://pkg.go.dev/container/list"
            title: "container/list"
            note: "Doubly linked list usable as a queue (or use slices)"
        patternPrimer:
          bruteForce: "Use DFS with a depth parameter, append to the correct level list"
          bestApproach: "BFS with a queue, process one level at a time using the current queue size"
          typical: "O(n) time, O(w) space where w is max width"
        variants:
          - id: v1
            title: Level Order Traversal
            difficulty: 2
            description: "Given the root of a binary tree, return the level order traversal of its nodes' values as a [][]int, where each inner slice contains the values at that depth level from left to right."
            hints:
              - "Use a slice as a queue. Process nodes level by level using the queue length at the start of each level."
              - "For each level, record the current queue size, then dequeue exactly that many nodes"
              - "Enqueue children of each dequeued node for the next level"
            solution: |
              type TreeNode struct {
                  Val   int
                  Left  *TreeNode
                  Right *TreeNode
              }

              func levelOrder(root *TreeNode) [][]int {
                  if root == nil {
                      return nil
                  }
                  var result [][]int
                  queue := []*TreeNode{root}
                  for len(queue) > 0 {
                      size := len(queue)
                      level := make([]int, 0, size)
                      for i := 0; i < size; i++ {
                          node := queue[0]
                          queue = queue[1:]
                          level = append(level, node.Val)
                          if node.Left != nil {
                              queue = append(queue, node.Left)
                          }
                          if node.Right != nil {
                              queue = append(queue, node.Right)
                          }
                      }
                      result = append(result, level)
                  }
                  return result
              }
            testCases: |
              // Tree:     3
              //          / \
              //         9  20
              //           /  \
              //          15   7
              root := &TreeNode{3, &TreeNode{9, nil, nil}, &TreeNode{20, &TreeNode{15, nil, nil}, &TreeNode{7, nil, nil}}}
              fmt.Println(levelOrder(root)) // [[3] [9 20] [15 7]]
              fmt.Println(levelOrder(nil))  // []
          - id: v2
            title: Zigzag Level Order Traversal
            difficulty: 2
            description: "Given the root of a binary tree, return the zigzag level order traversal of its nodes' values. The first level is left-to-right, the second is right-to-left, the third is left-to-right, and so on alternating."
            hints:
              - "Use BFS like normal level order, but reverse every other level"
              - "Track a boolean or use the level index to decide whether to reverse"
              - "You can also use a deque and alternate the direction you add to it"
            solution: |
              type TreeNode struct {
                  Val   int
                  Left  *TreeNode
                  Right *TreeNode
              }

              func zigzagLevelOrder(root *TreeNode) [][]int {
                  if root == nil {
                      return nil
                  }
                  var result [][]int
                  queue := []*TreeNode{root}
                  leftToRight := true
                  for len(queue) > 0 {
                      size := len(queue)
                      level := make([]int, size)
                      for i := 0; i < size; i++ {
                          node := queue[0]
                          queue = queue[1:]
                          idx := i
                          if !leftToRight {
                              idx = size - 1 - i
                          }
                          level[idx] = node.Val
                          if node.Left != nil {
                              queue = append(queue, node.Left)
                          }
                          if node.Right != nil {
                              queue = append(queue, node.Right)
                          }
                      }
                      result = append(result, level)
                      leftToRight = !leftToRight
                  }
                  return result
              }
            testCases: |
              // Tree:     3
              //          / \
              //         9  20
              //           /  \
              //          15   7
              root := &TreeNode{3, &TreeNode{9, nil, nil}, &TreeNode{20, &TreeNode{15, nil, nil}, &TreeNode{7, nil, nil}}}
              fmt.Println(zigzagLevelOrder(root)) // [[3] [20 9] [15 7]]
          - id: v3
            title: Binary Tree Right Side View
            difficulty: 2
            description: "Given the root of a binary tree, return the values of the nodes you can see when looking at the tree from the right side, ordered from top to bottom."
            hints:
              - "Use BFS level by level; the last node in each level is visible from the right"
              - "Alternatively, use DFS visiting right child first and picking the first node at each new depth"
            solution: |
              type TreeNode struct {
                  Val   int
                  Left  *TreeNode
                  Right *TreeNode
              }

              func rightSideView(root *TreeNode) []int {
                  if root == nil {
                      return nil
                  }
                  var result []int
                  queue := []*TreeNode{root}
                  for len(queue) > 0 {
                      size := len(queue)
                      for i := 0; i < size; i++ {
                          node := queue[0]
                          queue = queue[1:]
                          if i == size-1 {
                              result = append(result, node.Val)
                          }
                          if node.Left != nil {
                              queue = append(queue, node.Left)
                          }
                          if node.Right != nil {
                              queue = append(queue, node.Right)
                          }
                      }
                  }
                  return result
              }
            testCases: |
              // Tree:     1
              //          / \
              //         2   3
              //          \   \
              //           5   4
              root := &TreeNode{1,
                  &TreeNode{2, nil, &TreeNode{5, nil, nil}},
                  &TreeNode{3, nil, &TreeNode{4, nil, nil}}}
              fmt.Println(rightSideView(root)) // [1 3 4]

      - id: validate-bst
        name: Validate BST
        concept: "BST Properties"
        difficulty: 2
        docLinks:
          - url: "https://pkg.go.dev/math"
            title: "math package"
            note: "math.MinInt64 and math.MaxInt64 for initial bounds"
        patternPrimer:
          bruteForce: "In-order traversal, check if result is sorted"
          bestApproach: "Recursive validation with min/max bounds passed down"
          typical: "O(n) time, O(h) space"
        variants:
          - id: v1
            title: Validate Binary Search Tree
            difficulty: 2
            description: "Given the root of a binary tree, determine if it is a valid binary search tree (BST). A valid BST has the property that for every node, all values in the left subtree are strictly less than the node's value, and all values in the right subtree are strictly greater."
            hints:
              - "Checking only immediate children is not enough. Use min/max bounds."
              - "Pass a lower and upper bound to each recursive call. Left child gets upper bound = parent value, right child gets lower bound = parent value."
              - "Use math.MinInt64 and math.MaxInt64 as initial bounds"
            solution: |
              type TreeNode struct {
                  Val   int
                  Left  *TreeNode
                  Right *TreeNode
              }

              import "math"

              func isValidBST(root *TreeNode) bool {
                  return validate(root, math.MinInt64, math.MaxInt64)
              }

              func validate(node *TreeNode, min, max int) bool {
                  if node == nil {
                      return true
                  }
                  if node.Val <= min || node.Val >= max {
                      return false
                  }
                  return validate(node.Left, min, node.Val) &&
                      validate(node.Right, node.Val, max)
              }
            testCases: |
              // Valid BST:    2
              //              / \
              //             1   3
              valid := &TreeNode{2, &TreeNode{1, nil, nil}, &TreeNode{3, nil, nil}}
              fmt.Println(isValidBST(valid)) // true
              // Invalid BST:  5
              //              / \
              //             1   4
              //                / \
              //               3   6
              invalid := &TreeNode{5, &TreeNode{1, nil, nil}, &TreeNode{4, &TreeNode{3, nil, nil}, &TreeNode{6, nil, nil}}}
              fmt.Println(isValidBST(invalid)) // false
          - id: v2
            title: Kth Smallest Element in BST
            difficulty: 2
            description: "Given the root of a BST and an integer k, return the kth smallest value (1-indexed) among all node values in the tree."
            hints:
              - "In-order traversal of a BST visits nodes in ascending order"
              - "Count nodes during in-order traversal and stop when you reach the kth"
              - "Use a closure variable to track the count and result"
            solution: |
              type TreeNode struct {
                  Val   int
                  Left  *TreeNode
                  Right *TreeNode
              }

              func kthSmallest(root *TreeNode, k int) int {
                  count := 0
                  result := 0
                  var inorder func(node *TreeNode)
                  inorder = func(node *TreeNode) {
                      if node == nil || count >= k {
                          return
                      }
                      inorder(node.Left)
                      count++
                      if count == k {
                          result = node.Val
                          return
                      }
                      inorder(node.Right)
                  }
                  inorder(root)
                  return result
              }
            testCases: |
              // BST:     3
              //         / \
              //        1   4
              //         \
              //          2
              root := &TreeNode{3, &TreeNode{1, nil, &TreeNode{2, nil, nil}}, &TreeNode{4, nil, nil}}
              fmt.Println(kthSmallest(root, 1)) // 1
              fmt.Println(kthSmallest(root, 2)) // 2
              fmt.Println(kthSmallest(root, 3)) // 3
          - id: v3
            title: Lowest Common Ancestor of BST
            difficulty: 2
            description: "Given a BST and two nodes p and q, find their lowest common ancestor (LCA). The LCA is the deepest node that is an ancestor of both p and q (a node can be an ancestor of itself)."
            hints:
              - "Use BST properties: if both p and q are less than current node, LCA is in the left subtree"
              - "If both are greater, LCA is in the right subtree"
              - "If they split (one left, one right), current node is the LCA"
            solution: |
              type TreeNode struct {
                  Val   int
                  Left  *TreeNode
                  Right *TreeNode
              }

              func lowestCommonAncestor(root, p, q *TreeNode) *TreeNode {
                  node := root
                  for node != nil {
                      if p.Val < node.Val && q.Val < node.Val {
                          node = node.Left
                      } else if p.Val > node.Val && q.Val > node.Val {
                          node = node.Right
                      } else {
                          return node
                      }
                  }
                  return nil
              }
            testCases: |
              // BST:       6
              //           / \
              //          2   8
              //         / \ / \
              //        0  4 7  9
              //          / \
              //         3   5
              n0 := &TreeNode{Val: 0}
              n3 := &TreeNode{Val: 3}
              n5 := &TreeNode{Val: 5}
              n4 := &TreeNode{4, n3, n5}
              n2 := &TreeNode{2, n0, n4}
              n7 := &TreeNode{Val: 7}
              n9 := &TreeNode{Val: 9}
              n8 := &TreeNode{8, n7, n9}
              root := &TreeNode{6, n2, n8}
              fmt.Println(lowestCommonAncestor(root, n2, n8).Val) // 6
              fmt.Println(lowestCommonAncestor(root, n2, n4).Val) // 2

      - id: path-sum
        name: Path Sum
        concept: "Path Tracking"
        difficulty: 2
        docLinks:
          - url: "https://pkg.go.dev/math"
            title: "math package"
            note: "math.MinInt64 for tracking maximum values"
        patternPrimer:
          bruteForce: "Enumerate all root-to-leaf paths, check each sum"
          bestApproach: "DFS with running sum passed as parameter; for any-path problems, use prefix sums"
          typical: "O(n) time for single path, O(n) with hash map for arbitrary paths"
        variants:
          - id: v1
            title: Path Sum (Root to Leaf)
            difficulty: 1
            description: "Given the root of a binary tree and an integer targetSum, return true if the tree has a root-to-leaf path such that adding up all the values along the path equals targetSum. A leaf is a node with no children."
            hints:
              - "Subtract the current node value from targetSum as you recurse down"
              - "At a leaf node, check if the remaining targetSum equals the leaf value"
              - "Both children must be nil for a node to be a leaf"
            solution: |
              type TreeNode struct {
                  Val   int
                  Left  *TreeNode
                  Right *TreeNode
              }

              func hasPathSum(root *TreeNode, targetSum int) bool {
                  if root == nil {
                      return false
                  }
                  if root.Left == nil && root.Right == nil {
                      return root.Val == targetSum
                  }
                  remaining := targetSum - root.Val
                  return hasPathSum(root.Left, remaining) || hasPathSum(root.Right, remaining)
              }
            testCases: |
              // Tree:       5
              //            / \
              //           4   8
              //          /   / \
              //         11  13  4
              //        /  \      \
              //       7    2      1
              n7 := &TreeNode{Val: 7}
              n2 := &TreeNode{Val: 2}
              n11 := &TreeNode{11, n7, n2}
              n4l := &TreeNode{4, n11, nil}
              n13 := &TreeNode{Val: 13}
              n1 := &TreeNode{Val: 1}
              n4r := &TreeNode{4, nil, n1}
              n8 := &TreeNode{8, n13, n4r}
              root := &TreeNode{5, n4l, n8}
              fmt.Println(hasPathSum(root, 22)) // true (5->4->11->2)
              fmt.Println(hasPathSum(root, 26)) // true (5->8->13)
              fmt.Println(hasPathSum(root, 100)) // false
          - id: v2
            title: Path Sum III (Any Start/End)
            difficulty: 2
            description: "Given the root of a binary tree and an integer targetSum, return the number of paths where the values along the path sum to targetSum. The path does not need to start at the root or end at a leaf, but it must go downwards (from parent to child)."
            hints:
              - "Use a prefix sum approach similar to subarray sum equals k"
              - "Maintain a map of prefix sums seen so far on the current path"
              - "At each node, check if (currentSum - targetSum) exists in the prefix map"
            solution: |
              type TreeNode struct {
                  Val   int
                  Left  *TreeNode
                  Right *TreeNode
              }

              func pathSum(root *TreeNode, targetSum int) int {
                  prefixSums := map[int]int{0: 1}
                  return dfs(root, 0, targetSum, prefixSums)
              }

              func dfs(node *TreeNode, currentSum, target int, prefixSums map[int]int) int {
                  if node == nil {
                      return 0
                  }
                  currentSum += node.Val
                  count := prefixSums[currentSum-target]
                  prefixSums[currentSum]++
                  count += dfs(node.Left, currentSum, target, prefixSums)
                  count += dfs(node.Right, currentSum, target, prefixSums)
                  prefixSums[currentSum]--
                  return count
              }
            testCases: |
              // Tree:      10
              //           /  \
              //          5   -3
              //         / \    \
              //        3   2   11
              //       / \   \
              //      3  -2   1
              n3a := &TreeNode{Val: 3}
              nm2 := &TreeNode{Val: -2}
              n3b := &TreeNode{3, n3a, nm2}
              n1 := &TreeNode{Val: 1}
              n2 := &TreeNode{2, nil, n1}
              n5 := &TreeNode{5, n3b, n2}
              n11 := &TreeNode{Val: 11}
              nm3 := &TreeNode{-3, nil, n11}
              root := &TreeNode{10, n5, nm3}
              fmt.Println(pathSum(root, 8)) // 3 (paths: 5->3, 5->2->1, -3->11)
          - id: v3
            title: Binary Tree Maximum Path Sum
            difficulty: 3
            description: "Given the root of a binary tree, return the maximum path sum of any non-empty path. A path is a sequence of nodes where each pair of adjacent nodes has an edge. A node can only appear at most once in the path. The path does not need to pass through the root."
            hints:
              - "At each node, compute the max gain from left and right subtrees (clamped to 0 to ignore negative paths)"
              - "The path through the current node = node.Val + leftGain + rightGain; update global max"
              - "Return node.Val + max(leftGain, rightGain) to the parent (can only extend one side)"
            solution: |
              type TreeNode struct {
                  Val   int
                  Left  *TreeNode
                  Right *TreeNode
              }

              import "math"

              func maxPathSum(root *TreeNode) int {
                  maxSum := math.MinInt64
                  var gain func(node *TreeNode) int
                  gain = func(node *TreeNode) int {
                      if node == nil {
                          return 0
                      }
                      leftGain := gain(node.Left)
                      if leftGain < 0 {
                          leftGain = 0
                      }
                      rightGain := gain(node.Right)
                      if rightGain < 0 {
                          rightGain = 0
                      }
                      pathSum := node.Val + leftGain + rightGain
                      if pathSum > maxSum {
                          maxSum = pathSum
                      }
                      if leftGain > rightGain {
                          return node.Val + leftGain
                      }
                      return node.Val + rightGain
                  }
                  gain(root)
                  return maxSum
              }
            testCases: |
              // Tree:    -10
              //          /  \
              //         9   20
              //            /  \
              //           15   7
              root := &TreeNode{-10,
                  &TreeNode{9, nil, nil},
                  &TreeNode{20, &TreeNode{15, nil, nil}, &TreeNode{7, nil, nil}}}
              fmt.Println(maxPathSum(root)) // 42 (15 + 20 + 7)
              single := &TreeNode{Val: -3}
              fmt.Println(maxPathSum(single)) // -3

      - id: serialize-tree
        name: Serialize Tree
        concept: "Tree Encoding"
        difficulty: 3
        docLinks:
          - url: "https://pkg.go.dev/strconv"
            title: "strconv package"
            note: "Itoa/Atoi for int-string conversions"
          - url: "https://pkg.go.dev/strings"
            title: "strings package"
            note: "Join/Split for building serialized representations"
        patternPrimer:
          bruteForce: "Convert tree to a string with special markers, parse it back"
          bestApproach: "Pre-order traversal with nil markers for serialization; rebuild using a queue/index for deserialization"
          typical: "O(n) time and space for both serialize and deserialize"
        variants:
          - id: v1
            title: Same Tree
            difficulty: 1
            description: "Given the roots of two binary trees p and q, check if they are structurally identical and have the same node values."
            hints:
              - "If both are nil, they are the same. If one is nil, they are not."
              - "Compare values, then recursively check left and right subtrees"
            solution: |
              type TreeNode struct {
                  Val   int
                  Left  *TreeNode
                  Right *TreeNode
              }

              func isSameTree(p, q *TreeNode) bool {
                  if p == nil && q == nil {
                      return true
                  }
                  if p == nil || q == nil {
                      return false
                  }
                  return p.Val == q.Val &&
                      isSameTree(p.Left, q.Left) &&
                      isSameTree(p.Right, q.Right)
              }
            testCases: |
              p := &TreeNode{1, &TreeNode{2, nil, nil}, &TreeNode{3, nil, nil}}
              q := &TreeNode{1, &TreeNode{2, nil, nil}, &TreeNode{3, nil, nil}}
              fmt.Println(isSameTree(p, q)) // true
              r := &TreeNode{1, &TreeNode{2, nil, nil}, nil}
              fmt.Println(isSameTree(p, r)) // false
          - id: v2
            title: Subtree of Another Tree
            difficulty: 2
            description: "Given the roots of two binary trees root and subRoot, return true if there is a subtree of root with the same structure and node values as subRoot."
            hints:
              - "At each node of root, check if the subtree rooted there is identical to subRoot"
              - "Reuse the isSameTree function as a helper"
              - "If root is nil, subRoot cannot be a subtree"
            solution: |
              type TreeNode struct {
                  Val   int
                  Left  *TreeNode
                  Right *TreeNode
              }

              func isSubtree(root, subRoot *TreeNode) bool {
                  if root == nil {
                      return subRoot == nil
                  }
                  if isSameTree(root, subRoot) {
                      return true
                  }
                  return isSubtree(root.Left, subRoot) || isSubtree(root.Right, subRoot)
              }

              func isSameTree(p, q *TreeNode) bool {
                  if p == nil && q == nil {
                      return true
                  }
                  if p == nil || q == nil {
                      return false
                  }
                  return p.Val == q.Val &&
                      isSameTree(p.Left, q.Left) &&
                      isSameTree(p.Right, q.Right)
              }
            testCases: |
              // root:     3         subRoot:  4
              //          / \                 / \
              //         4   5               1   2
              //        / \
              //       1   2
              sub := &TreeNode{4, &TreeNode{1, nil, nil}, &TreeNode{2, nil, nil}}
              root := &TreeNode{3, &TreeNode{4, &TreeNode{1, nil, nil}, &TreeNode{2, nil, nil}}, &TreeNode{5, nil, nil}}
              fmt.Println(isSubtree(root, sub)) // true
              notSub := &TreeNode{4, &TreeNode{1, nil, nil}, &TreeNode{2, &TreeNode{0, nil, nil}, nil}}
              fmt.Println(isSubtree(root, notSub)) // false
          - id: v3
            title: Serialize and Deserialize Binary Tree
            difficulty: 3
            description: "Design an algorithm to serialize a binary tree to a string and deserialize that string back to the original tree. The encoded string should be as compact as possible."
            hints:
              - "Use pre-order traversal for serialization, with a special marker like 'N' for nil nodes"
              - "For deserialization, split the string and use an index pointer to rebuild the tree"
              - "A closure or pointer to an index variable avoids passing the index through recursion"
            solution: |
              type TreeNode struct {
                  Val   int
                  Left  *TreeNode
                  Right *TreeNode
              }

              import (
                  "strconv"
                  "strings"
              )

              type Codec struct{}

              func (c *Codec) serialize(root *TreeNode) string {
                  var parts []string
                  var build func(node *TreeNode)
                  build = func(node *TreeNode) {
                      if node == nil {
                          parts = append(parts, "N")
                          return
                      }
                      parts = append(parts, strconv.Itoa(node.Val))
                      build(node.Left)
                      build(node.Right)
                  }
                  build(root)
                  return strings.Join(parts, ",")
              }

              func (c *Codec) deserialize(data string) *TreeNode {
                  parts := strings.Split(data, ",")
                  idx := 0
                  var build func() *TreeNode
                  build = func() *TreeNode {
                      if idx >= len(parts) || parts[idx] == "N" {
                          idx++
                          return nil
                      }
                      val, _ := strconv.Atoi(parts[idx])
                      idx++
                      node := &TreeNode{Val: val}
                      node.Left = build()
                      node.Right = build()
                      return node
                  }
                  return build()
              }
            testCases: |
              // Tree:     1
              //          / \
              //         2   3
              //            / \
              //           4   5
              root := &TreeNode{1,
                  &TreeNode{2, nil, nil},
                  &TreeNode{3, &TreeNode{4, nil, nil}, &TreeNode{5, nil, nil}}}
              c := &Codec{}
              s := c.serialize(root)
              fmt.Println(s) // "1,2,N,N,3,4,N,N,5,N,N"
              rebuilt := c.deserialize(s)
              fmt.Println(rebuilt.Val)             // 1
              fmt.Println(rebuilt.Right.Left.Val)  // 4

  - id: dynamic-programming
    name: Dynamic Programming
    icon: "\u2207"
    order: 8
    description: "Optimal substructure and overlapping subproblems"
    problems:
      - id: climbing-stairs
        name: Climbing Stairs
        concept: "1D DP Base Case"
        difficulty: 1
        docLinks:
          - url: "https://pkg.go.dev/builtin"
            title: "Go builtins"
            note: "make, len, append for working with slices"
        patternPrimer:
          bruteForce: "Recursive enumeration of all step combinations, exponential time"
          bestApproach: "Bottom-up DP: dp[i] = dp[i-1] + dp[i-2], or just two variables"
          typical: "O(n) time, O(1) space with variable optimization"
        variants:
          - id: v1
            title: Climbing Stairs
            difficulty: 1
            description: "You are climbing a staircase. It takes n steps to reach the top. Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?"
            hints:
              - "This is the Fibonacci sequence: ways(n) = ways(n-1) + ways(n-2)"
              - "Base cases: 1 step = 1 way, 2 steps = 2 ways"
              - "You only need two variables, no need for an array"
            solution: |
              func climbStairs(n int) int {
                  if n <= 2 {
                      return n
                  }
                  prev, curr := 1, 2
                  for i := 3; i <= n; i++ {
                      prev, curr = curr, prev+curr
                  }
                  return curr
              }
            testCases: |
              fmt.Println(climbStairs(2))  // 2
              fmt.Println(climbStairs(3))  // 3
              fmt.Println(climbStairs(5))  // 8
              fmt.Println(climbStairs(10)) // 89
          - id: v2
            title: Min Cost Climbing Stairs
            difficulty: 1
            description: "You are given an integer array cost where cost[i] is the cost of stepping on the ith stair. You can start from step 0 or step 1. Return the minimum cost to reach the top of the floor (past the last step)."
            hints:
              - "dp[i] = cost[i] + min(dp[i-1], dp[i-2])"
              - "You can modify the cost array in-place or use two variables"
              - "The answer is min(dp[n-1], dp[n-2]) since you can step over the top from either"
            solution: |
              func minCostClimbingStairs(cost []int) int {
                  n := len(cost)
                  for i := 2; i < n; i++ {
                      cost[i] += min(cost[i-1], cost[i-2])
                  }
                  return min(cost[n-1], cost[n-2])
              }

              func min(a, b int) int {
                  if a < b {
                      return a
                  }
                  return b
              }
            testCases: |
              fmt.Println(minCostClimbingStairs([]int{10, 15, 20}))       // 15
              fmt.Println(minCostClimbingStairs([]int{1, 100, 1, 1, 1, 100, 1, 1, 100, 1})) // 6
          - id: v3
            title: Decode Ways
            difficulty: 2
            description: "A message containing letters A-Z can be encoded as numbers 1-26. Given a string s containing only digits, return the number of ways to decode it. For example, '226' can be decoded as 'BZ' (2,26), 'VF' (22,6), or 'BBF' (2,2,6)."
            hints:
              - "dp[i] = number of ways to decode s[0..i-1]"
              - "If s[i-1] != '0', dp[i] += dp[i-1] (single digit decode)"
              - "If s[i-2..i-1] forms 10-26, dp[i] += dp[i-2] (two digit decode)"
            solution: |
              func numDecodings(s string) int {
                  n := len(s)
                  if n == 0 || s[0] == '0' {
                      return 0
                  }
                  prev2, prev1 := 1, 1
                  for i := 1; i < n; i++ {
                      curr := 0
                      if s[i] != '0' {
                          curr += prev1
                      }
                      twoDigit := (s[i-1]-'0')*10 + (s[i] - '0')
                      if twoDigit >= 10 && twoDigit <= 26 {
                          curr += prev2
                      }
                      prev2, prev1 = prev1, curr
                  }
                  return prev1
              }
            testCases: |
              fmt.Println(numDecodings("12"))   // 2 ("AB" or "L")
              fmt.Println(numDecodings("226"))  // 3 ("BZ", "VF", "BBF")
              fmt.Println(numDecodings("06"))   // 0 (leading zero invalid)
              fmt.Println(numDecodings("11106")) // 2

      - id: house-robber
        name: House Robber
        concept: "Include/Exclude DP"
        difficulty: 2
        docLinks:
          - url: "https://pkg.go.dev/builtin"
            title: "Go builtins"
            note: "len for array/slice length"
        patternPrimer:
          bruteForce: "Try all subsets of non-adjacent houses, track maximum"
          bestApproach: "DP: at each house, choose max(rob it + dp[i-2], skip it = dp[i-1])"
          typical: "O(n) time, O(1) space with two variables"
        variants:
          - id: v1
            title: House Robber
            difficulty: 1
            description: "You are a robber planning to rob houses along a street. Each house has a certain amount of money. Adjacent houses have connected alarms, so you cannot rob two adjacent houses. Return the maximum amount you can rob."
            hints:
              - "At each house i, choose: rob it (nums[i] + best from i-2) or skip it (best from i-1)"
              - "dp[i] = max(nums[i] + dp[i-2], dp[i-1])"
              - "Only need two variables: the best totals for i-1 and i-2"
            solution: |
              func rob(nums []int) int {
                  if len(nums) == 0 {
                      return 0
                  }
                  if len(nums) == 1 {
                      return nums[0]
                  }
                  prev2, prev1 := 0, 0
                  for _, n := range nums {
                      curr := prev1
                      if n+prev2 > curr {
                          curr = n + prev2
                      }
                      prev2, prev1 = prev1, curr
                  }
                  return prev1
              }
            testCases: |
              fmt.Println(rob([]int{1, 2, 3, 1}))       // 4 (rob house 0 and 2)
              fmt.Println(rob([]int{2, 7, 9, 3, 1}))    // 12 (rob house 0, 2, 4)
              fmt.Println(rob([]int{2, 1, 1, 2}))        // 4 (rob house 0 and 3)
          - id: v2
            title: House Robber II (Circular)
            difficulty: 2
            description: "All houses are arranged in a circle, meaning the first and last houses are adjacent. You cannot rob both of them. Return the maximum amount you can rob."
            hints:
              - "Since first and last are adjacent, solve two subproblems: houses[0..n-2] and houses[1..n-1]"
              - "Return the max of both subproblem results"
              - "Reuse the linear house robber as a helper"
            solution: |
              func rob(nums []int) int {
                  n := len(nums)
                  if n == 0 {
                      return 0
                  }
                  if n == 1 {
                      return nums[0]
                  }
                  a := robLinear(nums[:n-1])
                  b := robLinear(nums[1:])
                  if a > b {
                      return a
                  }
                  return b
              }

              func robLinear(nums []int) int {
                  prev2, prev1 := 0, 0
                  for _, n := range nums {
                      curr := prev1
                      if n+prev2 > curr {
                          curr = n + prev2
                      }
                      prev2, prev1 = prev1, curr
                  }
                  return prev1
              }
            testCases: |
              fmt.Println(rob([]int{2, 3, 2}))     // 3 (rob house 1)
              fmt.Println(rob([]int{1, 2, 3, 1}))  // 4 (rob house 1 and 3)
              fmt.Println(rob([]int{1, 2, 3}))      // 3 (rob house 2)
          - id: v3
            title: Delete and Earn
            difficulty: 2
            description: "Given an integer array nums, you can perform operations where you pick nums[i], earn nums[i] points, and delete every element equal to nums[i]-1 and nums[i]+1. Return the maximum points you can earn."
            hints:
              - "This reduces to house robber: group by value, sum each group, then you can't pick adjacent values"
              - "Create a frequency sum array where sums[v] = v * count(v)"
              - "Apply house robber DP on this sums array"
            solution: |
              func deleteAndEarn(nums []int) int {
                  if len(nums) == 0 {
                      return 0
                  }
                  maxVal := 0
                  for _, n := range nums {
                      if n > maxVal {
                          maxVal = n
                      }
                  }
                  sums := make([]int, maxVal+1)
                  for _, n := range nums {
                      sums[n] += n
                  }
                  prev2, prev1 := 0, 0
                  for i := 0; i <= maxVal; i++ {
                      curr := prev1
                      if sums[i]+prev2 > curr {
                          curr = sums[i] + prev2
                      }
                      prev2, prev1 = prev1, curr
                  }
                  return prev1
              }
            testCases: |
              fmt.Println(deleteAndEarn([]int{3, 4, 2}))        // 6 (delete 4, earn 3+3... actually earn 3+2=? No: delete 4, earn 4, then 2 is ok, earn 2. Or delete 3 earn 3, delete... Best: earn 3+2=5 or earn 4. Actually 6: earn 2 then 4? No adjacents removed. Correct: 6 -> earn 3 then 3)
              fmt.Println(deleteAndEarn([]int{2, 2, 3, 3, 3, 4})) // 9 (earn all 3s: 3*3=9)

      - id: coin-change
        name: Coin Change
        concept: "Unbounded Knapsack"
        difficulty: 2
        docLinks:
          - url: "https://pkg.go.dev/math"
            title: "math package"
            note: "math.MaxInt32 as infinity sentinel"
        patternPrimer:
          bruteForce: "Try all combinations of coins recursively, exponential time"
          bestApproach: "Bottom-up DP: dp[amount] = min coins needed; for each coin, dp[a] = min(dp[a], dp[a-coin]+1)"
          typical: "O(amount * numCoins) time, O(amount) space"
        variants:
          - id: v1
            title: Coin Change (Minimum Coins)
            difficulty: 2
            description: "Given an array of coin denominations and a target amount, return the fewest number of coins needed to make that amount. If it cannot be made, return -1. You have infinite coins of each denomination."
            hints:
              - "Create dp array of size amount+1, initialize to amount+1 (impossible sentinel)"
              - "dp[0] = 0 (zero coins for amount zero)"
              - "For each amount a from 1 to target, try each coin: dp[a] = min(dp[a], dp[a-coin]+1)"
            solution: |
              func coinChange(coins []int, amount int) int {
                  dp := make([]int, amount+1)
                  for i := range dp {
                      dp[i] = amount + 1
                  }
                  dp[0] = 0
                  for a := 1; a <= amount; a++ {
                      for _, coin := range coins {
                          if coin <= a && dp[a-coin]+1 < dp[a] {
                              dp[a] = dp[a-coin] + 1
                          }
                      }
                  }
                  if dp[amount] > amount {
                      return -1
                  }
                  return dp[amount]
              }
            testCases: |
              fmt.Println(coinChange([]int{1, 5, 10, 25}, 30))  // 2 (25+5)
              fmt.Println(coinChange([]int{2}, 3))               // -1
              fmt.Println(coinChange([]int{1}, 0))               // 0
              fmt.Println(coinChange([]int{1, 2, 5}, 11))        // 3 (5+5+1)
          - id: v2
            title: Coin Change II (Count Combinations)
            difficulty: 2
            description: "Given an array of coin denominations and an amount, return the number of combinations that make up that amount. You have infinite coins of each denomination. Order does not matter (1+2 and 2+1 are the same combination)."
            hints:
              - "Iterate coins in the outer loop to avoid counting permutations"
              - "dp[a] += dp[a - coin] for each coin"
              - "dp[0] = 1 (one way to make amount 0: use no coins)"
            solution: |
              func change(amount int, coins []int) int {
                  dp := make([]int, amount+1)
                  dp[0] = 1
                  for _, coin := range coins {
                      for a := coin; a <= amount; a++ {
                          dp[a] += dp[a-coin]
                      }
                  }
                  return dp[amount]
              }
            testCases: |
              fmt.Println(change(5, []int{1, 2, 5}))  // 4 (5, 2+2+1, 2+1+1+1, 1+1+1+1+1)
              fmt.Println(change(3, []int{2}))          // 0
              fmt.Println(change(10, []int{10}))        // 1
          - id: v3
            title: Perfect Squares
            difficulty: 2
            description: "Given an integer n, return the least number of perfect square numbers (1, 4, 9, 16, ...) that sum to n."
            hints:
              - "This is like coin change where the coins are 1, 4, 9, 16, ..."
              - "dp[i] = min(dp[i], dp[i - j*j] + 1) for all j where j*j <= i"
              - "dp[0] = 0, initialize all others to n+1"
            solution: |
              func numSquares(n int) int {
                  dp := make([]int, n+1)
                  for i := range dp {
                      dp[i] = n + 1
                  }
                  dp[0] = 0
                  for i := 1; i <= n; i++ {
                      for j := 1; j*j <= i; j++ {
                          if dp[i-j*j]+1 < dp[i] {
                              dp[i] = dp[i-j*j] + 1
                          }
                      }
                  }
                  return dp[n]
              }
            testCases: |
              fmt.Println(numSquares(12))  // 3 (4+4+4)
              fmt.Println(numSquares(13))  // 2 (4+9)
              fmt.Println(numSquares(1))   // 1
              fmt.Println(numSquares(7))   // 4 (4+1+1+1)

      - id: longest-common-subseq
        name: Longest Common Subsequence
        concept: "2D DP"
        difficulty: 2
        docLinks:
          - url: "https://pkg.go.dev/builtin"
            title: "Go builtins"
            note: "make for 2D slice allocation"
        patternPrimer:
          bruteForce: "Generate all subsequences of both strings and find longest common one"
          bestApproach: "2D DP table: if chars match, dp[i][j] = dp[i-1][j-1]+1; else max(dp[i-1][j], dp[i][j-1])"
          typical: "O(m*n) time and space, reducible to O(min(m,n)) space"
        variants:
          - id: v1
            title: Longest Common Subsequence
            difficulty: 2
            description: "Given two strings text1 and text2, return the length of their longest common subsequence. A subsequence is a sequence that can be derived by deleting some or no characters without changing the order of remaining characters."
            hints:
              - "Build a 2D dp table of size (len(text1)+1) x (len(text2)+1)"
              - "If text1[i-1] == text2[j-1], dp[i][j] = dp[i-1][j-1] + 1"
              - "Otherwise dp[i][j] = max(dp[i-1][j], dp[i][j-1])"
            solution: |
              func longestCommonSubsequence(text1, text2 string) int {
                  m, n := len(text1), len(text2)
                  dp := make([][]int, m+1)
                  for i := range dp {
                      dp[i] = make([]int, n+1)
                  }
                  for i := 1; i <= m; i++ {
                      for j := 1; j <= n; j++ {
                          if text1[i-1] == text2[j-1] {
                              dp[i][j] = dp[i-1][j-1] + 1
                          } else {
                              dp[i][j] = dp[i-1][j]
                              if dp[i][j-1] > dp[i][j] {
                                  dp[i][j] = dp[i][j-1]
                              }
                          }
                      }
                  }
                  return dp[m][n]
              }
            testCases: |
              fmt.Println(longestCommonSubsequence("abcde", "ace"))   // 3 ("ace")
              fmt.Println(longestCommonSubsequence("abc", "abc"))     // 3
              fmt.Println(longestCommonSubsequence("abc", "def"))     // 0
          - id: v2
            title: Edit Distance
            difficulty: 2
            description: "Given two strings word1 and word2, return the minimum number of operations (insert, delete, replace a character) required to convert word1 into word2."
            hints:
              - "dp[i][j] = min edit distance between word1[0..i-1] and word2[0..j-1]"
              - "If characters match, dp[i][j] = dp[i-1][j-1] (no operation needed)"
              - "Otherwise, dp[i][j] = 1 + min(dp[i-1][j-1], dp[i-1][j], dp[i][j-1]) for replace/delete/insert"
            solution: |
              func minDistance(word1, word2 string) int {
                  m, n := len(word1), len(word2)
                  dp := make([][]int, m+1)
                  for i := range dp {
                      dp[i] = make([]int, n+1)
                      dp[i][0] = i
                  }
                  for j := 0; j <= n; j++ {
                      dp[0][j] = j
                  }
                  for i := 1; i <= m; i++ {
                      for j := 1; j <= n; j++ {
                          if word1[i-1] == word2[j-1] {
                              dp[i][j] = dp[i-1][j-1]
                          } else {
                              dp[i][j] = 1 + min3(dp[i-1][j-1], dp[i-1][j], dp[i][j-1])
                          }
                      }
                  }
                  return dp[m][n]
              }

              func min3(a, b, c int) int {
                  if a <= b && a <= c {
                      return a
                  }
                  if b <= c {
                      return b
                  }
                  return c
              }
            testCases: |
              fmt.Println(minDistance("horse", "ros"))      // 3
              fmt.Println(minDistance("intention", "execution")) // 5
              fmt.Println(minDistance("", "abc"))           // 3
          - id: v3
            title: Longest Increasing Subsequence
            difficulty: 2
            description: "Given an integer array nums, return the length of the longest strictly increasing subsequence."
            hints:
              - "O(n^2) DP: dp[i] = length of LIS ending at index i. For each j < i, if nums[j] < nums[i], dp[i] = max(dp[i], dp[j]+1)"
              - "O(n log n) optimization: maintain a tails array where tails[k] is the smallest tail element for increasing subsequence of length k+1"
              - "Use binary search to find the position to update in the tails array"
            solution: |
              import "sort"

              func lengthOfLIS(nums []int) int {
                  tails := []int{}
                  for _, num := range nums {
                      pos := sort.SearchInts(tails, num)
                      if pos == len(tails) {
                          tails = append(tails, num)
                      } else {
                          tails[pos] = num
                      }
                  }
                  return len(tails)
              }
            testCases: |
              fmt.Println(lengthOfLIS([]int{10, 9, 2, 5, 3, 7, 101, 18})) // 4 ([2,3,7,101])
              fmt.Println(lengthOfLIS([]int{0, 1, 0, 3, 2, 3}))           // 4
              fmt.Println(lengthOfLIS([]int{7, 7, 7, 7, 7}))              // 1

      - id: max-subarray
        name: Maximum Subarray
        concept: "Kadane's Algorithm"
        difficulty: 1
        docLinks:
          - url: "https://pkg.go.dev/math"
            title: "math package"
            note: "math.MinInt64 for initializing maximum trackers"
        patternPrimer:
          bruteForce: "Check all O(n^2) subarrays, track maximum sum"
          bestApproach: "Kadane's algorithm: maintain running sum, reset to current element when sum goes negative"
          typical: "O(n) time, O(1) space"
        variants:
          - id: v1
            title: Maximum Subarray Sum
            difficulty: 1
            description: "Given an integer array nums, find the subarray with the largest sum and return its sum."
            hints:
              - "At each element, decide: extend the previous subarray or start a new one"
              - "currentSum = max(nums[i], currentSum + nums[i])"
              - "Track the overall maximum sum seen so far"
            solution: |
              func maxSubArray(nums []int) int {
                  maxSum := nums[0]
                  currentSum := nums[0]
                  for i := 1; i < len(nums); i++ {
                      if currentSum+nums[i] > nums[i] {
                          currentSum = currentSum + nums[i]
                      } else {
                          currentSum = nums[i]
                      }
                      if currentSum > maxSum {
                          maxSum = currentSum
                      }
                  }
                  return maxSum
              }
            testCases: |
              fmt.Println(maxSubArray([]int{-2, 1, -3, 4, -1, 2, 1, -5, 4})) // 6 ([4,-1,2,1])
              fmt.Println(maxSubArray([]int{1}))                              // 1
              fmt.Println(maxSubArray([]int{5, 4, -1, 7, 8}))                 // 23
          - id: v2
            title: Maximum Product Subarray
            difficulty: 2
            description: "Given an integer array nums, find the subarray that has the largest product and return the product. The array may contain negative numbers and zeros."
            hints:
              - "Track both the current maximum and current minimum product (negatives can flip)"
              - "At each element, the new max is max(nums[i], maxSoFar*nums[i], minSoFar*nums[i])"
              - "Similarly update the minimum, then update the global max"
            solution: |
              func maxProduct(nums []int) int {
                  maxProd := nums[0]
                  curMax, curMin := nums[0], nums[0]
                  for i := 1; i < len(nums); i++ {
                      if nums[i] < 0 {
                          curMax, curMin = curMin, curMax
                      }
                      if nums[i] > curMax*nums[i] {
                          curMax = nums[i]
                      } else {
                          curMax = curMax * nums[i]
                      }
                      if nums[i] < curMin*nums[i] {
                          curMin = nums[i]
                      } else {
                          curMin = curMin * nums[i]
                      }
                      if curMax > maxProd {
                          maxProd = curMax
                      }
                  }
                  return maxProd
              }
            testCases: |
              fmt.Println(maxProduct([]int{2, 3, -2, 4}))   // 6 ([2,3])
              fmt.Println(maxProduct([]int{-2, 0, -1}))      // 0
              fmt.Println(maxProduct([]int{-2, 3, -4}))      // 24 ([-2,3,-4])
          - id: v3
            title: Best Time to Buy and Sell Stock with Cooldown
            difficulty: 2
            description: "You are given an array prices where prices[i] is the price of a stock on day i. You may complete as many transactions as you like, but after selling you must wait one day before buying again (cooldown). Return the maximum profit."
            hints:
              - "Use state machine DP: hold (holding stock), sold (just sold), rest (cooldown/no stock)"
              - "hold[i] = max(hold[i-1], rest[i-1] - prices[i])"
              - "sold[i] = hold[i-1] + prices[i], rest[i] = max(rest[i-1], sold[i-1])"
            solution: |
              func maxProfit(prices []int) int {
                  if len(prices) < 2 {
                      return 0
                  }
                  hold := -prices[0]
                  sold := 0
                  rest := 0
                  for i := 1; i < len(prices); i++ {
                      prevHold := hold
                      prevSold := sold
                      if rest-prices[i] > hold {
                          hold = rest - prices[i]
                      }
                      sold = prevHold + prices[i]
                      if prevSold > rest {
                          rest = prevSold
                      }
                  }
                  if sold > rest {
                      return sold
                  }
                  return rest
              }
            testCases: |
              fmt.Println(maxProfit([]int{1, 2, 3, 0, 2})) // 3 (buy@1, sell@3, cool, buy@0, sell@2)
              fmt.Println(maxProfit([]int{1}))              // 0
              fmt.Println(maxProfit([]int{1, 2, 4}))        // 3

      - id: knapsack
        name: 0/1 Knapsack
        concept: "0/1 Knapsack"
        difficulty: 2
        docLinks:
          - url: "https://pkg.go.dev/builtin"
            title: "Go builtins"
            note: "make for allocating DP arrays"
        patternPrimer:
          bruteForce: "Try all 2^n subsets, check which ones fit within weight capacity"
          bestApproach: "2D DP: dp[i][w] = max value using first i items within weight w. Optimize to 1D by iterating weights in reverse."
          typical: "O(n*W) time and space, or O(W) space with 1D optimization"
        variants:
          - id: v1
            title: 0/1 Knapsack
            difficulty: 2
            description: "Given n items with weights and values, and a knapsack capacity W, find the maximum value you can carry. Each item can be used at most once."
            hints:
              - "dp[i][w] = max value considering items 0..i-1 with capacity w"
              - "For each item, either include it (if it fits) or exclude it"
              - "Optimize to 1D: iterate capacity from W down to weight[i] to avoid reusing items"
            solution: |
              func knapsack(weights, values []int, capacity int) int {
                  dp := make([]int, capacity+1)
                  for i := 0; i < len(weights); i++ {
                      for w := capacity; w >= weights[i]; w-- {
                          withItem := dp[w-weights[i]] + values[i]
                          if withItem > dp[w] {
                              dp[w] = withItem
                          }
                      }
                  }
                  return dp[capacity]
              }
            testCases: |
              weights := []int{1, 3, 4, 5}
              values := []int{1, 4, 5, 7}
              fmt.Println(knapsack(weights, values, 7)) // 9 (items with weight 3+4, value 4+5)
              fmt.Println(knapsack([]int{2, 3, 4}, []int{3, 4, 5}, 5)) // 7 (weight 2+3, value 3+4)
          - id: v2
            title: Partition Equal Subset Sum
            difficulty: 2
            description: "Given an integer array nums, return true if you can partition the array into two subsets such that the sum of elements in both subsets is equal."
            hints:
              - "If total sum is odd, return false immediately"
              - "This reduces to: can we find a subset that sums to totalSum/2?"
              - "Use a boolean DP array: dp[s] = can we make sum s? It is a 0/1 knapsack variant."
            solution: |
              func canPartition(nums []int) bool {
                  total := 0
                  for _, n := range nums {
                      total += n
                  }
                  if total%2 != 0 {
                      return false
                  }
                  target := total / 2
                  dp := make([]bool, target+1)
                  dp[0] = true
                  for _, n := range nums {
                      for s := target; s >= n; s-- {
                          if dp[s-n] {
                              dp[s] = true
                          }
                      }
                  }
                  return dp[target]
              }
            testCases: |
              fmt.Println(canPartition([]int{1, 5, 11, 5}))   // true ([1,5,5] and [11])
              fmt.Println(canPartition([]int{1, 2, 3, 5}))    // false
              fmt.Println(canPartition([]int{1, 2, 3, 4, 5, 6, 7})) // true
          - id: v3
            title: Target Sum
            difficulty: 2
            description: "Given an integer array nums and a target, assign a + or - sign to each number so that the sum equals target. Return the number of different ways to achieve this."
            hints:
              - "If we split nums into P (positive) and N (negative) subsets, P - N = target and P + N = sum, so P = (sum + target) / 2"
              - "This reduces to counting subsets that sum to (sum + target) / 2"
              - "Use 0/1 knapsack counting: dp[s] = number of subsets summing to s"
            solution: |
              func findTargetSumWays(nums []int, target int) int {
                  total := 0
                  for _, n := range nums {
                      total += n
                  }
                  if (total+target)%2 != 0 || total+target < 0 {
                      return 0
                  }
                  subsetSum := (total + target) / 2
                  dp := make([]int, subsetSum+1)
                  dp[0] = 1
                  for _, n := range nums {
                      for s := subsetSum; s >= n; s-- {
                          dp[s] += dp[s-n]
                      }
                  }
                  return dp[subsetSum]
              }
            testCases: |
              fmt.Println(findTargetSumWays([]int{1, 1, 1, 1, 1}, 3)) // 5
              fmt.Println(findTargetSumWays([]int{1}, 1))              // 1
              fmt.Println(findTargetSumWays([]int{1, 0}, 1))           // 2
  - id: greedy
    name: Greedy
    icon: "â–¸"
    order: 9
    description: "Locally optimal choices leading to global solutions"
    problems:
      - id: jump-game
        name: Jump Game
        concept: "Reachability"
        difficulty: 2
        docLinks:
          - url: "https://pkg.go.dev/builtin"
            title: "Go Built-in Functions"
            note: "max, len, append"
        patternPrimer:
          bruteForce: "Recursively try all jumps from each position - O(2^n)"
          bestApproach: "Greedy tracking of farthest reachable index - O(n)"
          typical: "Single pass maintaining max reach"
        variants:
          - id: v1
            title: Can Jump to Last Index
            difficulty: 1
            description: "Given an array of non-negative integers where each element represents the maximum jump length from that position, determine if you can reach the last index starting from index 0."
            hints:
              - "Track the farthest index you can reach so far"
              - "At each position, update maxReach = max(maxReach, i + nums[i])"
              - "If i ever exceeds maxReach, you are stuck"
            solution: |
              func canJump(nums []int) bool {
                  maxReach := 0
                  for i := 0; i < len(nums); i++ {
                      if i > maxReach {
                          return false
                      }
                      if i+nums[i] > maxReach {
                          maxReach = i + nums[i]
                      }
                  }
                  return true
              }
            testCases: |
              fmt.Println(canJump([]int{2, 3, 1, 1, 4})) // true
              fmt.Println(canJump([]int{3, 2, 1, 0, 4})) // false
              fmt.Println(canJump([]int{0}))              // true
              fmt.Println(canJump([]int{2, 0, 0}))        // true
          - id: v2
            title: Minimum Jumps to Reach End
            difficulty: 2
            description: "Given an array of non-negative integers where each element represents the maximum jump length, return the minimum number of jumps needed to reach the last index. You can assume you can always reach the last index."
            hints:
              - "Use a greedy BFS-like approach: track the current jump boundary and the farthest you can reach"
              - "When you hit the current boundary, increment jumps and extend the boundary to farthest"
            solution: |
              func jump(nums []int) int {
                  jumps := 0
                  curEnd := 0
                  farthest := 0
                  for i := 0; i < len(nums)-1; i++ {
                      if i+nums[i] > farthest {
                          farthest = i + nums[i]
                      }
                      if i == curEnd {
                          jumps++
                          curEnd = farthest
                      }
                  }
                  return jumps
              }
            testCases: |
              fmt.Println(jump([]int{2, 3, 1, 1, 4})) // 2
              fmt.Println(jump([]int{2, 3, 0, 1, 4})) // 2
              fmt.Println(jump([]int{1, 1, 1, 1}))    // 3
          - id: v3
            title: Jump Game with Cost
            difficulty: 3
            description: "Given an array of integers representing the cost at each position and a maximum jump length k, find the minimum total cost to reach the last index from index 0. You must land on (and pay) the cost of each position you visit, including the start and end."
            hints:
              - "Use dynamic programming: dp[i] = minimum cost to reach position i"
              - "For each position i, check all positions j in range [max(0, i-k), i-1]"
              - "Optimize with a sliding window minimum using a deque for O(n) time"
            solution: |
              func minCostJump(cost []int, k int) int {
                  n := len(cost)
                  if n == 0 {
                      return 0
                  }
                  dp := make([]int, n)
                  dp[0] = cost[0]
                  for i := 1; i < n; i++ {
                      dp[i] = 1<<31 - 1
                      start := i - k
                      if start < 0 {
                          start = 0
                      }
                      for j := start; j < i; j++ {
                          if dp[j]+cost[i] < dp[i] {
                              dp[i] = dp[j] + cost[i]
                          }
                      }
                  }
                  return dp[n-1]
              }
            testCases: |
              fmt.Println(minCostJump([]int{1, 3, 2, 4, 1}, 2)) // 4  (0->2->4: 1+2+1)
              fmt.Println(minCostJump([]int{10, 1, 1, 1, 10}, 3)) // 12 (0->1->3->4 or similar)
              fmt.Println(minCostJump([]int{5}, 1))               // 5

      - id: merge-intervals
        name: Merge Intervals
        concept: "Interval Scheduling"
        difficulty: 2
        docLinks:
          - url: "https://pkg.go.dev/sort"
            title: "sort package"
            note: "sort.Slice for custom sorting"
        patternPrimer:
          bruteForce: "Compare every pair of intervals for overlap - O(n^2)"
          bestApproach: "Sort by start time, merge greedily - O(n log n)"
          typical: "Sort then single-pass merge"
        variants:
          - id: v1
            title: Merge Overlapping Intervals
            difficulty: 1
            description: "Given an array of intervals where intervals[i] = [start, end], merge all overlapping intervals and return an array of the non-overlapping intervals that cover all the input intervals."
            hints:
              - "Sort intervals by start time first"
              - "If the current interval overlaps with the last merged one, extend the end"
              - "Two intervals overlap when the start of one is <= the end of the other"
            solution: |
              func merge(intervals [][]int) [][]int {
                  sort.Slice(intervals, func(i, j int) bool {
                      return intervals[i][0] < intervals[j][0]
                  })
                  merged := [][]int{intervals[0]}
                  for i := 1; i < len(intervals); i++ {
                      last := merged[len(merged)-1]
                      if intervals[i][0] <= last[1] {
                          if intervals[i][1] > last[1] {
                              last[1] = intervals[i][1]
                          }
                      } else {
                          merged = append(merged, intervals[i])
                      }
                  }
                  return merged
              }
            testCases: |
              fmt.Println(merge([][]int{{1,3},{2,6},{8,10},{15,18}})) // [[1,6],[8,10],[15,18]]
              fmt.Println(merge([][]int{{1,4},{4,5}}))                // [[1,5]]
              fmt.Println(merge([][]int{{1,4},{0,4}}))                // [[0,4]]
          - id: v2
            title: Insert Interval
            difficulty: 2
            description: "Given a sorted list of non-overlapping intervals and a new interval, insert the new interval and merge if necessary. Return the resulting list of non-overlapping intervals."
            hints:
              - "Add all intervals that end before the new one starts"
              - "Merge all intervals that overlap with the new interval"
              - "Add all remaining intervals that start after the new one ends"
            solution: |
              func insert(intervals [][]int, newInterval []int) [][]int {
                  result := [][]int{}
                  i := 0
                  n := len(intervals)
                  // Add all intervals ending before new interval starts
                  for i < n && intervals[i][1] < newInterval[0] {
                      result = append(result, intervals[i])
                      i++
                  }
                  // Merge overlapping intervals
                  for i < n && intervals[i][0] <= newInterval[1] {
                      if intervals[i][0] < newInterval[0] {
                          newInterval[0] = intervals[i][0]
                      }
                      if intervals[i][1] > newInterval[1] {
                          newInterval[1] = intervals[i][1]
                      }
                      i++
                  }
                  result = append(result, newInterval)
                  // Add remaining intervals
                  for i < n {
                      result = append(result, intervals[i])
                      i++
                  }
                  return result
              }
            testCases: |
              fmt.Println(insert([][]int{{1,3},{6,9}}, []int{2,5}))           // [[1,5],[6,9]]
              fmt.Println(insert([][]int{{1,2},{3,5},{6,7},{8,10},{12,16}}, []int{4,8})) // [[1,2],[3,10],[12,16]]
              fmt.Println(insert([][]int{}, []int{5,7}))                       // [[5,7]]
          - id: v3
            title: Non-Overlapping Intervals
            difficulty: 2
            description: "Given an array of intervals, return the minimum number of intervals you need to remove to make the rest non-overlapping."
            hints:
              - "Sort by end time - this is the key greedy choice"
              - "Greedily keep the interval that ends earliest when there is overlap"
              - "Count intervals that overlap with the previously kept interval"
            solution: |
              func eraseOverlapIntervals(intervals [][]int) int {
                  sort.Slice(intervals, func(i, j int) bool {
                      return intervals[i][1] < intervals[j][1]
                  })
                  count := 0
                  end := intervals[0][1]
                  for i := 1; i < len(intervals); i++ {
                      if intervals[i][0] < end {
                          count++
                      } else {
                          end = intervals[i][1]
                      }
                  }
                  return count
              }
            testCases: |
              fmt.Println(eraseOverlapIntervals([][]int{{1,2},{2,3},{3,4},{1,3}})) // 1
              fmt.Println(eraseOverlapIntervals([][]int{{1,2},{1,2},{1,2}}))       // 2
              fmt.Println(eraseOverlapIntervals([][]int{{1,2},{2,3}}))             // 0

      - id: meeting-rooms
        name: Meeting Rooms
        concept: "Interval Sorting"
        difficulty: 1
        docLinks:
          - url: "https://pkg.go.dev/sort"
            title: "sort package"
            note: "sort.Slice for interval sorting"
          - url: "https://pkg.go.dev/container/heap"
            title: "container/heap"
            note: "Min-heap for meeting rooms II"
        patternPrimer:
          bruteForce: "Check every pair of meetings for conflicts - O(n^2)"
          bestApproach: "Sort by start time and check adjacent pairs - O(n log n)"
          typical: "Sort intervals then linear scan"
        variants:
          - id: v1
            title: Can Attend All Meetings
            difficulty: 1
            description: "Given an array of meeting time intervals where intervals[i] = [start, end], determine if a person could attend all meetings (i.e., no two meetings overlap)."
            hints:
              - "Sort meetings by start time"
              - "Check if any meeting starts before the previous one ends"
            solution: |
              func canAttendMeetings(intervals [][]int) bool {
                  sort.Slice(intervals, func(i, j int) bool {
                      return intervals[i][0] < intervals[j][0]
                  })
                  for i := 1; i < len(intervals); i++ {
                      if intervals[i][0] < intervals[i-1][1] {
                          return false
                      }
                  }
                  return true
              }
            testCases: |
              fmt.Println(canAttendMeetings([][]int{{0,30},{5,10},{15,20}})) // false
              fmt.Println(canAttendMeetings([][]int{{7,10},{2,4}}))          // true
              fmt.Println(canAttendMeetings([][]int{{1,5},{5,10}}))          // true
          - id: v2
            title: Minimum Meeting Rooms
            difficulty: 2
            description: "Given an array of meeting time intervals, find the minimum number of conference rooms required so that all meetings can be held."
            hints:
              - "Separate start and end times into two sorted arrays"
              - "Use a two-pointer approach: when a meeting starts, add a room; when one ends, free a room"
              - "The maximum concurrent meetings is the answer"
            solution: |
              func minMeetingRooms(intervals [][]int) int {
                  n := len(intervals)
                  starts := make([]int, n)
                  ends := make([]int, n)
                  for i, interval := range intervals {
                      starts[i] = interval[0]
                      ends[i] = interval[1]
                  }
                  sort.Ints(starts)
                  sort.Ints(ends)
                  rooms := 0
                  maxRooms := 0
                  si, ei := 0, 0
                  for si < n {
                      if starts[si] < ends[ei] {
                          rooms++
                          si++
                      } else {
                          rooms--
                          ei++
                      }
                      if rooms > maxRooms {
                          maxRooms = rooms
                      }
                  }
                  return maxRooms
              }
            testCases: |
              fmt.Println(minMeetingRooms([][]int{{0,30},{5,10},{15,20}})) // 2
              fmt.Println(minMeetingRooms([][]int{{7,10},{2,4}}))          // 1
              fmt.Println(minMeetingRooms([][]int{{1,5},{2,6},{3,7}}))     // 3
          - id: v3
            title: Employee Free Time
            difficulty: 3
            description: "Given a list of schedules for multiple employees, where each schedule is a list of non-overlapping intervals sorted by start time, return a list of finite free time intervals common to all employees, sorted by start time."
            hints:
              - "Flatten all intervals into one list and sort by start time"
              - "Merge overlapping intervals, then find gaps between merged intervals"
              - "A gap exists when the start of the next merged interval is after the end of the previous"
            solution: |
              func employeeFreeTime(schedules [][][]int) [][]int {
                  // Flatten all intervals
                  all := [][]int{}
                  for _, schedule := range schedules {
                      all = append(all, schedule...)
                  }
                  sort.Slice(all, func(i, j int) bool {
                      return all[i][0] < all[j][0]
                  })
                  // Merge intervals
                  merged := [][]int{all[0]}
                  for i := 1; i < len(all); i++ {
                      last := merged[len(merged)-1]
                      if all[i][0] <= last[1] {
                          if all[i][1] > last[1] {
                              last[1] = all[i][1]
                          }
                      } else {
                          merged = append(merged, all[i])
                      }
                  }
                  // Find gaps
                  free := [][]int{}
                  for i := 1; i < len(merged); i++ {
                      free = append(free, []int{merged[i-1][1], merged[i][0]})
                  }
                  return free
              }
            testCases: |
              fmt.Println(employeeFreeTime([][][]int{{{1,2},{5,6}}, {{1,3}}, {{4,10}}})) // [[3,4]]
              fmt.Println(employeeFreeTime([][][]int{{{1,3},{6,7}}, {{2,4}}, {{2,5},{9,12}}})) // [[5,6],[7,9]]

      - id: gas-station
        name: Gas Station
        concept: "Circular Greedy"
        difficulty: 2
        docLinks:
          - url: "https://pkg.go.dev/builtin"
            title: "Go Built-in Functions"
            note: "len, max"
        patternPrimer:
          bruteForce: "Try starting from each station and simulate the trip - O(n^2)"
          bestApproach: "Single pass tracking surplus/deficit - O(n)"
          typical: "Greedy with running tank balance"
        variants:
          - id: v1
            title: Gas Station Circuit
            difficulty: 2
            description: "There are n gas stations along a circular route. You are given gas[i] (fuel at station i) and cost[i] (fuel needed to reach station i+1). Starting with an empty tank, return the starting station index if you can complete the circuit, or -1 if impossible."
            hints:
              - "If total gas >= total cost, a solution must exist"
              - "Track a running tank; if it goes negative, the next station is a candidate start"
              - "You only need one pass through the array"
            solution: |
              func canCompleteCircuit(gas []int, cost []int) int {
                  totalSurplus := 0
                  currentTank := 0
                  start := 0
                  for i := 0; i < len(gas); i++ {
                      totalSurplus += gas[i] - cost[i]
                      currentTank += gas[i] - cost[i]
                      if currentTank < 0 {
                          start = i + 1
                          currentTank = 0
                      }
                  }
                  if totalSurplus < 0 {
                      return -1
                  }
                  return start
              }
            testCases: |
              fmt.Println(canCompleteCircuit([]int{1,2,3,4,5}, []int{3,4,5,1,2})) // 3
              fmt.Println(canCompleteCircuit([]int{2,3,4}, []int{3,4,3}))          // -1
              fmt.Println(canCompleteCircuit([]int{5,1,2,3,4}, []int{4,4,1,5,1}))  // 4
          - id: v2
            title: Candy Distribution
            difficulty: 2
            description: "There are n children standing in a line, each with a rating. Give candies such that: each child gets at least 1, and children with a higher rating than a neighbor get more candies than that neighbor. Return the minimum total candies needed."
            hints:
              - "Do two passes: left-to-right and right-to-left"
              - "First pass: if rating[i] > rating[i-1], give more than left neighbor"
              - "Second pass: if rating[i] > rating[i+1], ensure more than right neighbor"
            solution: |
              func candy(ratings []int) int {
                  n := len(ratings)
                  candies := make([]int, n)
                  for i := range candies {
                      candies[i] = 1
                  }
                  // Left to right
                  for i := 1; i < n; i++ {
                      if ratings[i] > ratings[i-1] {
                          candies[i] = candies[i-1] + 1
                      }
                  }
                  // Right to left
                  for i := n - 2; i >= 0; i-- {
                      if ratings[i] > ratings[i+1] && candies[i] <= candies[i+1] {
                          candies[i] = candies[i+1] + 1
                      }
                  }
                  total := 0
                  for _, c := range candies {
                      total += c
                  }
                  return total
              }
            testCases: |
              fmt.Println(candy([]int{1, 0, 2}))    // 5
              fmt.Println(candy([]int{1, 2, 2}))    // 4
              fmt.Println(candy([]int{1, 3, 2, 1})) // 7
          - id: v3
            title: Task Scheduler
            difficulty: 3
            description: "Given a list of tasks represented by characters and a cooldown interval n, find the minimum number of intervals the CPU needs to complete all tasks. The CPU can either execute a task or be idle. The same task must have at least n intervals between executions."
            hints:
              - "The most frequent task determines the structure of the schedule"
              - "Calculate idle slots based on the most frequent task, then fill them with other tasks"
              - "Result is max(len(tasks), (maxFreq-1)*(n+1) + countOfMaxFreq)"
            solution: |
              func leastInterval(tasks []byte, n int) int {
                  freq := make([]int, 26)
                  for _, t := range tasks {
                      freq[t-'A']++
                  }
                  sort.Sort(sort.Reverse(sort.IntSlice(freq)))
                  maxFreq := freq[0]
                  maxCount := 0
                  for _, f := range freq {
                      if f == maxFreq {
                          maxCount++
                      }
                  }
                  intervals := (maxFreq-1)*(n+1) + maxCount
                  if len(tasks) > intervals {
                      return len(tasks)
                  }
                  return intervals
              }
            testCases: |
              fmt.Println(leastInterval([]byte{'A','A','A','B','B','B'}, 2))             // 8
              fmt.Println(leastInterval([]byte{'A','A','A','B','B','B'}, 0))             // 6
              fmt.Println(leastInterval([]byte{'A','A','A','A','B','B','B','C','C'}, 2)) // 10

      - id: assign-cookies
        name: Assign Cookies
        concept: "Greedy Matching"
        difficulty: 1
        docLinks:
          - url: "https://pkg.go.dev/sort"
            title: "sort package"
            note: "sort.Ints for sorting"
        patternPrimer:
          bruteForce: "Try all possible assignments - O(n! or 2^n)"
          bestApproach: "Sort both arrays and use two pointers - O(n log n)"
          typical: "Sort + greedy matching"
        variants:
          - id: v1
            title: Assign Cookies to Children
            difficulty: 1
            description: "Each child i has a greed factor g[i] (minimum cookie size they accept). Each cookie j has size s[j]. Assign cookies to maximize the number of satisfied children. Each child gets at most one cookie."
            hints:
              - "Sort both the greed factors and cookie sizes"
              - "Use two pointers: try to satisfy the least greedy child first"
              - "If the current cookie satisfies the current child, move both pointers; otherwise move only the cookie pointer"
            solution: |
              func findContentChildren(g []int, s []int) int {
                  sort.Ints(g)
                  sort.Ints(s)
                  child := 0
                  cookie := 0
                  for child < len(g) && cookie < len(s) {
                      if s[cookie] >= g[child] {
                          child++
                      }
                      cookie++
                  }
                  return child
              }
            testCases: |
              fmt.Println(findContentChildren([]int{1, 2, 3}, []int{1, 1}))    // 1
              fmt.Println(findContentChildren([]int{1, 2}, []int{1, 2, 3}))    // 2
              fmt.Println(findContentChildren([]int{10, 9, 8}, []int{5, 6, 7})) // 0
          - id: v2
            title: Boats to Save People
            difficulty: 2
            description: "Given an array of people's weights and a weight limit for each boat, find the minimum number of boats needed. Each boat can carry at most 2 people, and their total weight must not exceed the limit."
            hints:
              - "Sort people by weight"
              - "Try to pair the heaviest person with the lightest person"
              - "If they fit together, pair them; otherwise the heavy person goes alone"
            solution: |
              func numRescueBoats(people []int, limit int) int {
                  sort.Ints(people)
                  boats := 0
                  lo, hi := 0, len(people)-1
                  for lo <= hi {
                      if people[lo]+people[hi] <= limit {
                          lo++
                      }
                      hi--
                      boats++
                  }
                  return boats
              }
            testCases: |
              fmt.Println(numRescueBoats([]int{1, 2}, 3))       // 1
              fmt.Println(numRescueBoats([]int{3, 2, 2, 1}, 3)) // 3
              fmt.Println(numRescueBoats([]int{3, 5, 3, 4}, 5)) // 4
          - id: v3
            title: Partition Labels
            difficulty: 2
            description: "Given a string s, partition it into as many parts as possible so that each letter appears in at most one part. Return a list of the sizes of these parts."
            hints:
              - "First find the last occurrence of each character"
              - "Iterate through the string, expanding the current partition to include the last occurrence of each character seen"
              - "When i reaches the partition end, close the partition"
            solution: |
              func partitionLabels(s string) []int {
                  last := make(map[byte]int)
                  for i := 0; i < len(s); i++ {
                      last[s[i]] = i
                  }
                  result := []int{}
                  start := 0
                  end := 0
                  for i := 0; i < len(s); i++ {
                      if last[s[i]] > end {
                          end = last[s[i]]
                      }
                      if i == end {
                          result = append(result, end-start+1)
                          start = end + 1
                      }
                  }
                  return result
              }
            testCases: |
              fmt.Println(partitionLabels("ababcbacadefegdehijhklij")) // [9 7 8]
              fmt.Println(partitionLabels("eccbbbbdec"))               // [10]
              fmt.Println(partitionLabels("abc"))                      // [1 1 1]

  - id: backtracking
    name: Backtracking
    icon: "â†º"
    order: 10
    description: "Systematic exploration with pruning"
    problems:
      - id: subsets
        name: Subsets
        concept: "Power Set"
        difficulty: 2
        docLinks:
          - url: "https://pkg.go.dev/builtin"
            title: "Go Built-in Functions"
            note: "append, len, copy"
          - url: "https://pkg.go.dev/sort"
            title: "sort package"
            note: "sort.Ints for dedup approach"
        patternPrimer:
          bruteForce: "Use bitmask to enumerate all 2^n subsets iteratively"
          bestApproach: "Backtracking with include/exclude decision at each element - O(2^n)"
          typical: "Recursive backtracking building subsets incrementally"
        variants:
          - id: v1
            title: Generate All Subsets
            difficulty: 1
            description: "Given an array of distinct integers, return all possible subsets (the power set). The solution set must not contain duplicate subsets."
            hints:
              - "Use backtracking: at each index decide to include or exclude the element"
              - "Build the current subset incrementally, backtrack by removing the last element"
              - "Start from index 0 and recurse to index+1 after each inclusion"
            solution: |
              func subsets(nums []int) [][]int {
                  result := [][]int{}
                  current := []int{}
                  var backtrack func(start int)
                  backtrack = func(start int) {
                      // Make a copy of current and add to result
                      tmp := make([]int, len(current))
                      copy(tmp, current)
                      result = append(result, tmp)
                      for i := start; i < len(nums); i++ {
                          current = append(current, nums[i])
                          backtrack(i + 1)
                          current = current[:len(current)-1]
                      }
                  }
                  backtrack(0)
                  return result
              }
            testCases: |
              fmt.Println(subsets([]int{1, 2, 3})) // [[] [1] [1 2] [1 2 3] [1 3] [2] [2 3] [3]]
              fmt.Println(subsets([]int{0}))        // [[] [0]]
              fmt.Println(subsets([]int{}))          // [[]]
          - id: v2
            title: Subsets with Duplicates
            difficulty: 2
            description: "Given an integer array that may contain duplicates, return all possible subsets. The solution set must not contain duplicate subsets."
            hints:
              - "Sort the array first so duplicates are adjacent"
              - "When iterating choices at a level, skip nums[i] if nums[i] == nums[i-1] and i > start"
              - "This pruning prevents generating duplicate subsets"
            solution: |
              func subsetsWithDup(nums []int) [][]int {
                  sort.Ints(nums)
                  result := [][]int{}
                  current := []int{}
                  var backtrack func(start int)
                  backtrack = func(start int) {
                      tmp := make([]int, len(current))
                      copy(tmp, current)
                      result = append(result, tmp)
                      for i := start; i < len(nums); i++ {
                          if i > start && nums[i] == nums[i-1] {
                              continue
                          }
                          current = append(current, nums[i])
                          backtrack(i + 1)
                          current = current[:len(current)-1]
                      }
                  }
                  backtrack(0)
                  return result
              }
            testCases: |
              fmt.Println(subsetsWithDup([]int{1, 2, 2})) // [[] [1] [1 2] [1 2 2] [2] [2 2]]
              fmt.Println(subsetsWithDup([]int{0}))        // [[] [0]]
              fmt.Println(subsetsWithDup([]int{4, 4, 4}))  // [[] [4] [4 4] [4 4 4]]
          - id: v3
            title: Combinations of K Elements
            difficulty: 2
            description: "Given two integers n and k, return all possible combinations of k numbers chosen from the range [1, n]."
            hints:
              - "Backtrack with a start parameter to avoid duplicates"
              - "Add the current combination to results when its length equals k"
              - "Prune: if remaining elements are not enough to fill k slots, return early"
            solution: |
              func combine(n int, k int) [][]int {
                  result := [][]int{}
                  current := []int{}
                  var backtrack func(start int)
                  backtrack = func(start int) {
                      if len(current) == k {
                          tmp := make([]int, k)
                          copy(tmp, current)
                          result = append(result, tmp)
                          return
                      }
                      // Prune: need k-len(current) more elements
                      for i := start; i <= n-(k-len(current))+1; i++ {
                          current = append(current, i)
                          backtrack(i + 1)
                          current = current[:len(current)-1]
                      }
                  }
                  backtrack(1)
                  return result
              }
            testCases: |
              fmt.Println(combine(4, 2)) // [[1 2] [1 3] [1 4] [2 3] [2 4] [3 4]]
              fmt.Println(combine(1, 1)) // [[1]]
              fmt.Println(combine(5, 3)) // [[1 2 3] [1 2 4] [1 2 5] [1 3 4] [1 3 5] [1 4 5] [2 3 4] [2 3 5] [2 4 5] [3 4 5]]

      - id: combination-sum
        name: Combination Sum
        concept: "Target Sum Search"
        difficulty: 2
        docLinks:
          - url: "https://pkg.go.dev/sort"
            title: "sort package"
            note: "sort.Ints for early termination"
        patternPrimer:
          bruteForce: "Try all possible combinations recursively without pruning"
          bestApproach: "Backtracking with sorting for early termination - O(n^(t/min))"
          typical: "Recursive backtracking with target reduction"
        variants:
          - id: v1
            title: Combination Sum (Reuse Allowed)
            difficulty: 2
            description: "Given an array of distinct integers (candidates) and a target integer, return all unique combinations of candidates where the chosen numbers sum to target. The same number may be chosen an unlimited number of times."
            hints:
              - "Backtrack with the remaining target as a parameter"
              - "Allow reuse by passing the same start index (not i+1) in recursion"
              - "If remaining target becomes 0, add current combination to results"
            solution: |
              func combinationSum(candidates []int, target int) [][]int {
                  result := [][]int{}
                  current := []int{}
                  sort.Ints(candidates)
                  var backtrack func(start, remaining int)
                  backtrack = func(start, remaining int) {
                      if remaining == 0 {
                          tmp := make([]int, len(current))
                          copy(tmp, current)
                          result = append(result, tmp)
                          return
                      }
                      for i := start; i < len(candidates); i++ {
                          if candidates[i] > remaining {
                              break
                          }
                          current = append(current, candidates[i])
                          backtrack(i, remaining-candidates[i])
                          current = current[:len(current)-1]
                      }
                  }
                  backtrack(0, target)
                  return result
              }
            testCases: |
              fmt.Println(combinationSum([]int{2, 3, 6, 7}, 7)) // [[2 2 3] [7]]
              fmt.Println(combinationSum([]int{2, 3, 5}, 8))    // [[2 2 2 2] [2 3 3] [3 5]]
              fmt.Println(combinationSum([]int{2}, 1))           // []
          - id: v2
            title: Combination Sum II (Each Number Once)
            difficulty: 2
            description: "Given a collection of candidate numbers (may contain duplicates) and a target, find all unique combinations where each number is used at most once and the sum equals the target."
            hints:
              - "Sort candidates first to handle duplicates"
              - "Skip duplicates at the same recursion level: if i > start and candidates[i] == candidates[i-1], skip"
              - "Pass i+1 as start (no reuse allowed)"
            solution: |
              func combinationSum2(candidates []int, target int) [][]int {
                  sort.Ints(candidates)
                  result := [][]int{}
                  current := []int{}
                  var backtrack func(start, remaining int)
                  backtrack = func(start, remaining int) {
                      if remaining == 0 {
                          tmp := make([]int, len(current))
                          copy(tmp, current)
                          result = append(result, tmp)
                          return
                      }
                      for i := start; i < len(candidates); i++ {
                          if candidates[i] > remaining {
                              break
                          }
                          if i > start && candidates[i] == candidates[i-1] {
                              continue
                          }
                          current = append(current, candidates[i])
                          backtrack(i+1, remaining-candidates[i])
                          current = current[:len(current)-1]
                      }
                  }
                  backtrack(0, target)
                  return result
              }
            testCases: |
              fmt.Println(combinationSum2([]int{10,1,2,7,6,1,5}, 8)) // [[1 1 6] [1 2 5] [1 7] [2 6]]
              fmt.Println(combinationSum2([]int{2,5,2,1,2}, 5))      // [[1 2 2] [5]]
          - id: v3
            title: Combination Sum III (K Numbers from 1-9)
            difficulty: 2
            description: "Find all valid combinations of k numbers that sum up to n, using only numbers 1 through 9. Each number is used at most once."
            hints:
              - "Backtrack with numbers 1-9 as candidates"
              - "Stop when current combination has k elements"
              - "Prune when remaining sum is negative or not enough numbers left"
            solution: |
              func combinationSum3(k int, n int) [][]int {
                  result := [][]int{}
                  current := []int{}
                  var backtrack func(start, remaining int)
                  backtrack = func(start, remaining int) {
                      if len(current) == k {
                          if remaining == 0 {
                              tmp := make([]int, k)
                              copy(tmp, current)
                              result = append(result, tmp)
                          }
                          return
                      }
                      for i := start; i <= 9; i++ {
                          if i > remaining {
                              break
                          }
                          current = append(current, i)
                          backtrack(i+1, remaining-i)
                          current = current[:len(current)-1]
                      }
                  }
                  backtrack(1, n)
                  return result
              }
            testCases: |
              fmt.Println(combinationSum3(3, 7))  // [[1 2 4]]
              fmt.Println(combinationSum3(3, 9))  // [[1 2 6] [1 3 5] [2 3 4]]
              fmt.Println(combinationSum3(4, 1))  // []
              fmt.Println(combinationSum3(2, 18)) // []

      - id: permutations
        name: Permutations
        concept: "Arrangement Generation"
        difficulty: 2
        docLinks:
          - url: "https://pkg.go.dev/builtin"
            title: "Go Built-in Functions"
            note: "append, copy, len"
          - url: "https://pkg.go.dev/sort"
            title: "sort package"
            note: "sort.Ints for next permutation"
        patternPrimer:
          bruteForce: "Generate all n! arrangements, filter valid ones"
          bestApproach: "Backtracking with swap or used-array - O(n!)"
          typical: "Recursive backtracking with visited tracking"
        variants:
          - id: v1
            title: All Permutations of Distinct Integers
            difficulty: 1
            description: "Given an array of distinct integers, return all possible permutations in any order."
            hints:
              - "Use a boolean used array to track which elements are in the current permutation"
              - "At each step, try adding each unused element"
              - "When the permutation length equals n, add a copy to results"
            solution: |
              func permute(nums []int) [][]int {
                  result := [][]int{}
                  current := []int{}
                  used := make([]bool, len(nums))
                  var backtrack func()
                  backtrack = func() {
                      if len(current) == len(nums) {
                          tmp := make([]int, len(nums))
                          copy(tmp, current)
                          result = append(result, tmp)
                          return
                      }
                      for i := 0; i < len(nums); i++ {
                          if used[i] {
                              continue
                          }
                          used[i] = true
                          current = append(current, nums[i])
                          backtrack()
                          current = current[:len(current)-1]
                          used[i] = false
                      }
                  }
                  backtrack()
                  return result
              }
            testCases: |
              fmt.Println(permute([]int{1, 2, 3})) // [[1 2 3] [1 3 2] [2 1 3] [2 3 1] [3 1 2] [3 2 1]]
              fmt.Println(permute([]int{0, 1}))     // [[0 1] [1 0]]
              fmt.Println(permute([]int{1}))         // [[1]]
          - id: v2
            title: Permutations with Duplicates
            difficulty: 2
            description: "Given a collection of numbers that might contain duplicates, return all possible unique permutations in any order."
            hints:
              - "Sort the array first so duplicates are adjacent"
              - "Skip used[i] or when nums[i] == nums[i-1] and !used[i-1] (same level duplicate)"
              - "The !used[i-1] check ensures we only use duplicates in order"
            solution: |
              func permuteUnique(nums []int) [][]int {
                  sort.Ints(nums)
                  result := [][]int{}
                  current := []int{}
                  used := make([]bool, len(nums))
                  var backtrack func()
                  backtrack = func() {
                      if len(current) == len(nums) {
                          tmp := make([]int, len(nums))
                          copy(tmp, current)
                          result = append(result, tmp)
                          return
                      }
                      for i := 0; i < len(nums); i++ {
                          if used[i] {
                              continue
                          }
                          if i > 0 && nums[i] == nums[i-1] && !used[i-1] {
                              continue
                          }
                          used[i] = true
                          current = append(current, nums[i])
                          backtrack()
                          current = current[:len(current)-1]
                          used[i] = false
                      }
                  }
                  backtrack()
                  return result
              }
            testCases: |
              fmt.Println(permuteUnique([]int{1, 1, 2})) // [[1 1 2] [1 2 1] [2 1 1]]
              fmt.Println(permuteUnique([]int{1, 2, 3})) // [[1 2 3] [1 3 2] [2 1 3] [2 3 1] [3 1 2] [3 2 1]]
          - id: v3
            title: Next Permutation
            difficulty: 3
            description: "Given an array of integers, rearrange it into the lexicographically next greater permutation. If no such arrangement exists (the array is in descending order), rearrange it as the lowest possible order (ascending). Modify the array in-place."
            hints:
              - "Find the first index i from the right where nums[i] < nums[i+1]"
              - "Find the smallest number greater than nums[i] to its right, swap them"
              - "Reverse the suffix after index i to get the smallest possible tail"
            solution: |
              func nextPermutation(nums []int) {
                  n := len(nums)
                  // Step 1: find first decreasing element from right
                  i := n - 2
                  for i >= 0 && nums[i] >= nums[i+1] {
                      i--
                  }
                  if i >= 0 {
                      // Step 2: find smallest element larger than nums[i] from right
                      j := n - 1
                      for nums[j] <= nums[i] {
                          j--
                      }
                      nums[i], nums[j] = nums[j], nums[i]
                  }
                  // Step 3: reverse suffix starting at i+1
                  lo, hi := i+1, n-1
                  for lo < hi {
                      nums[lo], nums[hi] = nums[hi], nums[lo]
                      lo++
                      hi--
                  }
              }
            testCases: |
              a := []int{1, 2, 3}
              nextPermutation(a)
              fmt.Println(a) // [1 3 2]
              b := []int{3, 2, 1}
              nextPermutation(b)
              fmt.Println(b) // [1 2 3]
              c := []int{1, 1, 5}
              nextPermutation(c)
              fmt.Println(c) // [1 5 1]

      - id: word-search
        name: Word Search
        concept: "Grid Backtracking"
        difficulty: 2
        docLinks:
          - url: "https://pkg.go.dev/builtin"
            title: "Go Built-in Functions"
            note: "len, byte, make"
        patternPrimer:
          bruteForce: "Try all possible paths in the grid - exponential"
          bestApproach: "DFS backtracking with visited marking - O(m*n*4^L)"
          typical: "Recursive DFS from each cell, marking visited cells"
        variants:
          - id: v1
            title: Word Search in 2D Grid
            difficulty: 2
            description: "Given an m x n grid of characters and a string word, return true if the word exists in the grid. The word can be constructed from sequentially adjacent cells (horizontally or vertically). Each cell may be used only once."
            hints:
              - "Try starting DFS from every cell in the grid"
              - "Mark cells as visited by temporarily changing their value"
              - "Restore the cell value when backtracking"
            solution: |
              func exist(board [][]byte, word string) bool {
                  rows, cols := len(board), len(board[0])
                  var dfs func(r, c, idx int) bool
                  dfs = func(r, c, idx int) bool {
                      if idx == len(word) {
                          return true
                      }
                      if r < 0 || r >= rows || c < 0 || c >= cols || board[r][c] != word[idx] {
                          return false
                      }
                      tmp := board[r][c]
                      board[r][c] = '#'
                      found := dfs(r+1, c, idx+1) || dfs(r-1, c, idx+1) ||
                          dfs(r, c+1, idx+1) || dfs(r, c-1, idx+1)
                      board[r][c] = tmp
                      return found
                  }
                  for r := 0; r < rows; r++ {
                      for c := 0; c < cols; c++ {
                          if dfs(r, c, 0) {
                              return true
                          }
                      }
                  }
                  return false
              }
            testCases: |
              board := [][]byte{{'A','B','C','E'},{'S','F','C','S'},{'A','D','E','E'}}
              fmt.Println(exist(board, "ABCCED")) // true
              fmt.Println(exist(board, "SEE"))     // true
              fmt.Println(exist(board, "ABCB"))    // false
          - id: v2
            title: N-Queens
            difficulty: 3
            description: "Place n queens on an n x n chessboard such that no two queens attack each other. Return all distinct solutions. Each solution is a board configuration where 'Q' and '.' indicate a queen and an empty space."
            hints:
              - "Place queens row by row, backtrack when a conflict is found"
              - "Track which columns and diagonals are under attack using sets"
              - "Diagonals: row-col identifies one direction, row+col the other"
            solution: |
              func solveNQueens(n int) [][]string {
                  result := [][]string{}
                  cols := make(map[int]bool)
                  diag1 := make(map[int]bool) // row - col
                  diag2 := make(map[int]bool) // row + col
                  board := make([][]byte, n)
                  for i := range board {
                      board[i] = make([]byte, n)
                      for j := range board[i] {
                          board[i][j] = '.'
                      }
                  }
                  var backtrack func(row int)
                  backtrack = func(row int) {
                      if row == n {
                          solution := make([]string, n)
                          for i := range board {
                              solution[i] = string(board[i])
                          }
                          result = append(result, solution)
                          return
                      }
                      for col := 0; col < n; col++ {
                          if cols[col] || diag1[row-col] || diag2[row+col] {
                              continue
                          }
                          board[row][col] = 'Q'
                          cols[col] = true
                          diag1[row-col] = true
                          diag2[row+col] = true
                          backtrack(row + 1)
                          board[row][col] = '.'
                          delete(cols, col)
                          delete(diag1, row-col)
                          delete(diag2, row+col)
                      }
                  }
                  backtrack(0)
                  return result
              }
            testCases: |
              solutions := solveNQueens(4)
              fmt.Println(len(solutions)) // 2
              for _, s := range solutions {
                  for _, row := range s {
                      fmt.Println(row)
                  }
                  fmt.Println()
              }
              // .Q..  ..Q.
              // ...Q  Q...
              // Q...  ...Q
              // ..Q.  .Q..
          - id: v3
            title: Sudoku Solver
            difficulty: 3
            description: "Write a program to solve a 9x9 Sudoku puzzle by filling empty cells (represented by '.'). Each row, column, and 3x3 sub-box must contain digits 1-9 without repetition."
            hints:
              - "Find the next empty cell, try digits 1-9"
              - "Validate by checking the row, column, and 3x3 box"
              - "Backtrack if no digit is valid for the current cell"
            solution: |
              func solveSudoku(board [][]byte) {
                  solve(board)
              }

              func solve(board [][]byte) bool {
                  for r := 0; r < 9; r++ {
                      for c := 0; c < 9; c++ {
                          if board[r][c] == '.' {
                              for d := byte('1'); d <= '9'; d++ {
                                  if isValid(board, r, c, d) {
                                      board[r][c] = d
                                      if solve(board) {
                                          return true
                                      }
                                      board[r][c] = '.'
                                  }
                              }
                              return false
                          }
                      }
                  }
                  return true
              }

              func isValid(board [][]byte, row, col int, d byte) bool {
                  for i := 0; i < 9; i++ {
                      if board[row][i] == d {
                          return false
                      }
                      if board[i][col] == d {
                          return false
                      }
                      br := 3*(row/3) + i/3
                      bc := 3*(col/3) + i%3
                      if board[br][bc] == d {
                          return false
                      }
                  }
                  return true
              }
            testCases: |
              board := [][]byte{
                  {'5','3','.','.','7','.','.','.','.'},
                  {'6','.','.','1','9','5','.','.','.'},
                  {'.','9','8','.','.','.','.','6','.'},
                  {'8','.','.','.','6','.','.','.','3'},
                  {'4','.','.','8','.','3','.','.','1'},
                  {'7','.','.','.','2','.','.','.','6'},
                  {'.','6','.','.','.','.','2','8','.'},
                  {'.','.','.','4','1','9','.','.','5'},
                  {'.','.','.','.','8','.','.','7','9'},
              }
              solveSudoku(board)
              for _, row := range board {
                  fmt.Println(string(row))
              }
              // 534678912
              // 672195348
              // 198342567
              // 859761423
              // 426853791
              // 713924856
              // 961537284
              // 287419635
              // 345286179

      - id: generate-parentheses
        name: Generate Parentheses
        concept: "Constrained Generation"
        difficulty: 2
        docLinks:
          - url: "https://pkg.go.dev/strings"
            title: "strings package"
            note: "String building utilities"
        patternPrimer:
          bruteForce: "Generate all 2^(2n) bracket sequences and filter valid ones"
          bestApproach: "Backtracking with open/close count constraints - O(4^n/sqrt(n))"
          typical: "Recursive generation tracking open and close counts"
        variants:
          - id: v1
            title: Generate Valid Parentheses
            difficulty: 1
            description: "Given n pairs of parentheses, write a function to generate all combinations of well-formed parentheses."
            hints:
              - "Track the count of open and close parentheses used so far"
              - "You can add '(' if open count < n"
              - "You can add ')' if close count < open count"
            solution: |
              func generateParenthesis(n int) []string {
                  result := []string{}
                  var backtrack func(current string, open, close int)
                  backtrack = func(current string, open, close int) {
                      if len(current) == 2*n {
                          result = append(result, current)
                          return
                      }
                      if open < n {
                          backtrack(current+"(", open+1, close)
                      }
                      if close < open {
                          backtrack(current+")", open, close+1)
                      }
                  }
                  backtrack("", 0, 0)
                  return result
              }
            testCases: |
              fmt.Println(generateParenthesis(3)) // [((())) (()()) (())() ()(()) ()()()]
              fmt.Println(generateParenthesis(1)) // [()]
              fmt.Println(generateParenthesis(2)) // [(()) ()()]
          - id: v2
            title: Letter Combinations of Phone Number
            difficulty: 2
            description: "Given a string containing digits from 2-9, return all possible letter combinations that the number could represent (like on a phone keypad). Return the answer in any order."
            hints:
              - "Create a mapping from digit to letters (2->abc, 3->def, etc.)"
              - "Backtrack through each digit, appending each possible letter"
              - "When the combination length equals the input length, add to results"
            solution: |
              func letterCombinations(digits string) []string {
                  if len(digits) == 0 {
                      return []string{}
                  }
                  phone := map[byte]string{
                      '2': "abc", '3': "def", '4': "ghi", '5': "jkl",
                      '6': "mno", '7': "pqrs", '8': "tuv", '9': "wxyz",
                  }
                  result := []string{}
                  var backtrack func(idx int, current string)
                  backtrack = func(idx int, current string) {
                      if idx == len(digits) {
                          result = append(result, current)
                          return
                      }
                      letters := phone[digits[idx]]
                      for i := 0; i < len(letters); i++ {
                          backtrack(idx+1, current+string(letters[i]))
                      }
                  }
                  backtrack(0, "")
                  return result
              }
            testCases: |
              fmt.Println(letterCombinations("23")) // [ad ae af bd be bf cd ce cf]
              fmt.Println(letterCombinations(""))   // []
              fmt.Println(letterCombinations("2"))  // [a b c]
          - id: v3
            title: Palindrome Partitioning
            difficulty: 3
            description: "Given a string s, partition it such that every substring in the partition is a palindrome. Return all possible palindrome partitionings."
            hints:
              - "Backtrack by trying every possible prefix that is a palindrome"
              - "Write a helper function to check if a substring is a palindrome"
              - "When the start index reaches the end of the string, add the current partition to results"
            solution: |
              func partition(s string) [][]string {
                  result := [][]string{}
                  current := []string{}
                  var backtrack func(start int)
                  backtrack = func(start int) {
                      if start == len(s) {
                          tmp := make([]string, len(current))
                          copy(tmp, current)
                          result = append(result, tmp)
                          return
                      }
                      for end := start + 1; end <= len(s); end++ {
                          sub := s[start:end]
                          if isPalindrome(sub) {
                              current = append(current, sub)
                              backtrack(end)
                              current = current[:len(current)-1]
                          }
                      }
                  }
                  backtrack(0)
                  return result
              }

              func isPalindrome(s string) bool {
                  lo, hi := 0, len(s)-1
                  for lo < hi {
                      if s[lo] != s[hi] {
                          return false
                      }
                      lo++
                      hi--
                  }
                  return true
              }
            testCases: |
              fmt.Println(partition("aab")) // [[a a b] [aa b]]
              fmt.Println(partition("a"))   // [[a]]
              fmt.Println(partition("aba")) // [[a b a] [aba]]
