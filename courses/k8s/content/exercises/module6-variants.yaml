conceptLinks:
  ClusterIP Services: "#lesson-service-types"
  NodePort Services: "#lesson-service-types"
  Service Commands: "#lesson-services"
  Port Mapping: "#lesson-port-mapping"
  Service Types: "#lesson-service-types"
  Service + Deployment Wiring: "#lesson-services"
  Service Debugging: "#lesson-endpoints-and-endpointslices"

variants:
  warmups:
    - id: warmup_1
      concept: ClusterIP Services
      variants:
        - id: v1
          title: Basic Web Service
          description: >-
            Write a ClusterIP Service YAML named <code>web</code> that selects Pods with label <code>app: web</code>
            and maps port 80 to targetPort 8080.
          hints:
            - "Use <code>apiVersion: v1</code> and <code>kind: Service</code>."
            - "The <code>selector</code> field goes under <code>spec</code> and matches Pod labels."
            - "<code>port</code> is what clients connect to, <code>targetPort</code> is the container port."
          solution: |-
            apiVersion: v1
            kind: Service
            metadata:
              name: web
            spec:
              type: ClusterIP
              selector:
                app: web
              ports:
              - port: 80
                targetPort: 8080
        - id: v2
          title: API Backend Service
          description: >-
            Write a ClusterIP Service YAML named <code>api</code> that selects Pods with label <code>app: api</code>
            and maps port 3000 to targetPort 3000.
          hints:
            - "When port and targetPort are the same, you can omit <code>targetPort</code> — but being explicit is clearer."
            - "ClusterIP is the default type, so <code>type: ClusterIP</code> is optional."
          solution: |-
            apiVersion: v1
            kind: Service
            metadata:
              name: api
            spec:
              selector:
                app: api
              ports:
              - port: 3000
                targetPort: 3000
        - id: v3
          title: Redis Cache Service
          description: >-
            Write a ClusterIP Service YAML named <code>redis</code> that selects Pods with label <code>app: redis</code>
            and maps port 6379 to targetPort 6379.
          hints:
            - "Redis uses port 6379 by default."
            - "Internal-only services like caches should always use ClusterIP."
          solution: |-
            apiVersion: v1
            kind: Service
            metadata:
              name: redis
            spec:
              selector:
                app: redis
              ports:
              - port: 6379
                targetPort: 6379
        - id: v4
          title: PostgreSQL Database Service
          description: >-
            Write a ClusterIP Service YAML named <code>postgres</code> that selects Pods with labels
            <code>app: postgres</code> and <code>tier: database</code>, mapping port 5432 to targetPort 5432.
          hints:
            - "Selectors can match multiple labels — all must match for a Pod to be selected."
            - "PostgreSQL uses port 5432 by default."
          solution: |-
            apiVersion: v1
            kind: Service
            metadata:
              name: postgres
            spec:
              selector:
                app: postgres
                tier: database
              ports:
              - port: 5432
                targetPort: 5432
        - id: v5
          title: Multi-Port Service
          description: >-
            Write a ClusterIP Service YAML named <code>app</code> that selects Pods with label <code>app: myapp</code>
            and exposes two ports: HTTP on port 80 (targetPort 8080) and metrics on port 9090 (targetPort 9090).
          hints:
            - "When a Service has multiple ports, each port entry must have a <code>name</code> field."
            - "Use descriptive names like <code>http</code> and <code>metrics</code>."
          solution: |-
            apiVersion: v1
            kind: Service
            metadata:
              name: app
            spec:
              selector:
                app: myapp
              ports:
              - name: http
                port: 80
                targetPort: 8080
              - name: metrics
                port: 9090
                targetPort: 9090
        - id: v6
          title: gRPC Service
          description: >-
            Write a ClusterIP Service YAML named <code>grpc-api</code> that selects Pods with label
            <code>app: grpc-api</code> and maps port 50051 to targetPort 50051.
          hints:
            - "gRPC typically uses port 50051."
            - "The protocol defaults to TCP, which is correct for gRPC."
          solution: |-
            apiVersion: v1
            kind: Service
            metadata:
              name: grpc-api
            spec:
              selector:
                app: grpc-api
              ports:
              - port: 50051
                targetPort: 50051
        - id: v7
          title: Frontend Service with Named Port
          description: >-
            Write a ClusterIP Service YAML named <code>frontend</code> that selects Pods with label
            <code>app: frontend</code> and maps port 80 to a named targetPort called <code>http</code>.
          hints:
            - "<code>targetPort</code> can be a string referencing a named <code>containerPort</code> in the Pod spec."
            - "Named ports make it easier to change port numbers without updating the Service."
          solution: |-
            apiVersion: v1
            kind: Service
            metadata:
              name: frontend
            spec:
              selector:
                app: frontend
              ports:
              - port: 80
                targetPort: http
        - id: v8
          title: Elasticsearch Service
          description: >-
            Write a ClusterIP Service YAML named <code>elasticsearch</code> that selects Pods with label
            <code>app: elasticsearch</code> and exposes two ports: REST API on port 9200 (targetPort 9200)
            and inter-node transport on port 9300 (targetPort 9300).
          hints:
            - "Elasticsearch uses 9200 for the REST API and 9300 for inter-node communication."
            - "Name the ports <code>rest</code> and <code>transport</code>."
          solution: |-
            apiVersion: v1
            kind: Service
            metadata:
              name: elasticsearch
            spec:
              selector:
                app: elasticsearch
              ports:
              - name: rest
                port: 9200
                targetPort: 9200
              - name: transport
                port: 9300
                targetPort: 9300
        - id: v9
          title: Service with Session Affinity
          description: >-
            Write a ClusterIP Service YAML named <code>web</code> that selects Pods with label <code>app: web</code>,
            maps port 80 to targetPort 8080, and enables <code>ClientIP</code> session affinity with a timeout of
            3600 seconds.
          hints:
            - "Add <code>sessionAffinity: ClientIP</code> under <code>spec</code>."
            - "Configure the timeout under <code>sessionAffinityConfig.clientIP.timeoutSeconds</code>."
          solution: |-
            apiVersion: v1
            kind: Service
            metadata:
              name: web
            spec:
              selector:
                app: web
              sessionAffinity: ClientIP
              sessionAffinityConfig:
                clientIP:
                  timeoutSeconds: 3600
              ports:
              - port: 80
                targetPort: 8080
        - id: v10
          title: MongoDB Service
          description: >-
            Write a ClusterIP Service YAML named <code>mongo</code> that selects Pods with labels
            <code>app: mongo</code> and <code>role: primary</code>, mapping port 27017 to targetPort 27017.
          hints:
            - "MongoDB uses port 27017 by default."
            - "Using a <code>role: primary</code> label lets you target only the primary node in a replica set."
          solution: |-
            apiVersion: v1
            kind: Service
            metadata:
              name: mongo
            spec:
              selector:
                app: mongo
                role: primary
              ports:
              - port: 27017
                targetPort: 27017
        - id: v11
          title: RabbitMQ Service
          description: >-
            Write a ClusterIP Service YAML named <code>rabbitmq</code> that selects Pods with label
            <code>app: rabbitmq</code> and exposes two ports: AMQP on port 5672 (targetPort 5672) and
            management UI on port 15672 (targetPort 15672).
          hints:
            - "RabbitMQ uses 5672 for AMQP messaging and 15672 for the management web UI."
            - "Name the ports <code>amqp</code> and <code>management</code>."
          solution: |-
            apiVersion: v1
            kind: Service
            metadata:
              name: rabbitmq
            spec:
              selector:
                app: rabbitmq
              ports:
              - name: amqp
                port: 5672
                targetPort: 5672
              - name: management
                port: 15672
                targetPort: 15672
        - id: v12
          title: Remapped Port Service
          description: >-
            Write a ClusterIP Service YAML named <code>backend</code> that selects Pods with label
            <code>app: backend</code> and maps Service port 443 to targetPort 8443 with protocol TCP.
          hints:
            - "Remapping ports lets you expose a standard port while the container uses a non-privileged port."
            - "Protocol defaults to TCP, but being explicit is good practice for clarity."
          solution: |-
            apiVersion: v1
            kind: Service
            metadata:
              name: backend
            spec:
              selector:
                app: backend
              ports:
              - port: 443
                targetPort: 8443
                protocol: TCP

    - id: warmup_2
      concept: NodePort Services
      variants:
        - id: v1
          title: Basic NodePort Service
          description: >-
            Write a NodePort Service YAML named <code>web</code> that selects Pods with label <code>app: web</code>,
            maps port 80 to targetPort 80, and uses nodePort 30080.
          hints:
            - "Set <code>type: NodePort</code> under <code>spec</code>."
            - "NodePort must be in the range 30000-32767."
          solution: |-
            apiVersion: v1
            kind: Service
            metadata:
              name: web
            spec:
              type: NodePort
              selector:
                app: web
              ports:
              - port: 80
                targetPort: 80
                nodePort: 30080
        - id: v2
          title: NodePort with Port Remapping
          description: >-
            Write a NodePort Service YAML named <code>api</code> that selects Pods with label <code>app: api</code>,
            maps Service port 80 to targetPort 3000, and uses nodePort 30300.
          hints:
            - "The three ports are independent: nodePort (external), port (ClusterIP), targetPort (Pod)."
            - "Traffic flows: Node:30300 -> Service:80 -> Pod:3000."
          solution: |-
            apiVersion: v1
            kind: Service
            metadata:
              name: api
            spec:
              type: NodePort
              selector:
                app: api
              ports:
              - port: 80
                targetPort: 3000
                nodePort: 30300
        - id: v3
          title: NodePort Auto-Assigned
          description: >-
            Write a NodePort Service YAML named <code>dashboard</code> that selects Pods with label
            <code>app: dashboard</code> and maps port 443 to targetPort 8443. Let Kubernetes auto-assign the nodePort.
          hints:
            - "Omit the <code>nodePort</code> field to let Kubernetes pick a port in the 30000-32767 range."
            - "Auto-assignment avoids port conflicts when you do not need a specific nodePort."
          solution: |-
            apiVersion: v1
            kind: Service
            metadata:
              name: dashboard
            spec:
              type: NodePort
              selector:
                app: dashboard
              ports:
              - port: 443
                targetPort: 8443
        - id: v4
          title: NodePort for Dev Server
          description: >-
            Write a NodePort Service YAML named <code>dev-server</code> that selects Pods with label
            <code>app: dev-server</code>, maps port 3000 to targetPort 3000, and uses nodePort 31000.
          hints:
            - "Development servers often run on port 3000."
            - "NodePort gives you external access without needing a cloud load balancer."
          solution: |-
            apiVersion: v1
            kind: Service
            metadata:
              name: dev-server
            spec:
              type: NodePort
              selector:
                app: dev-server
              ports:
              - port: 3000
                targetPort: 3000
                nodePort: 31000
        - id: v5
          title: Multi-Port NodePort Service
          description: >-
            Write a NodePort Service YAML named <code>app</code> that selects Pods with label <code>app: myapp</code>
            and exposes HTTP on port 80 (targetPort 8080, nodePort 30080) and HTTPS on port 443 (targetPort 8443,
            nodePort 30443).
          hints:
            - "Each port entry needs a <code>name</code> when there are multiple ports."
            - "Each port can have its own nodePort value."
          solution: |-
            apiVersion: v1
            kind: Service
            metadata:
              name: app
            spec:
              type: NodePort
              selector:
                app: myapp
              ports:
              - name: http
                port: 80
                targetPort: 8080
                nodePort: 30080
              - name: https
                port: 443
                targetPort: 8443
                nodePort: 30443
        - id: v6
          title: Grafana NodePort Service
          description: >-
            Write a NodePort Service YAML named <code>grafana</code> that selects Pods with label
            <code>app: grafana</code>, maps port 3000 to targetPort 3000, and uses nodePort 30300.
          hints:
            - "Grafana serves its web UI on port 3000 by default."
            - "A NodePort makes it accessible from your browser during development."
          solution: |-
            apiVersion: v1
            kind: Service
            metadata:
              name: grafana
            spec:
              type: NodePort
              selector:
                app: grafana
              ports:
              - port: 3000
                targetPort: 3000
                nodePort: 30300
        - id: v7
          title: Jenkins NodePort Service
          description: >-
            Write a NodePort Service YAML named <code>jenkins</code> that selects Pods with label
            <code>app: jenkins</code> and exposes two ports: web UI on port 8080 (targetPort 8080,
            nodePort 30808) and agent on port 50000 (targetPort 50000, nodePort 30500).
          hints:
            - "Jenkins uses 8080 for the web UI and 50000 for agent communication."
            - "Name the ports <code>web</code> and <code>agent</code>."
          solution: |-
            apiVersion: v1
            kind: Service
            metadata:
              name: jenkins
            spec:
              type: NodePort
              selector:
                app: jenkins
              ports:
              - name: web
                port: 8080
                targetPort: 8080
                nodePort: 30808
              - name: agent
                port: 50000
                targetPort: 50000
                nodePort: 30500
        - id: v8
          title: Game Server NodePort
          description: >-
            Write a NodePort Service YAML named <code>game-server</code> that selects Pods with label
            <code>app: game</code>, maps port 7777 to targetPort 7777 using UDP protocol, and uses nodePort 30777.
          hints:
            - "Set <code>protocol: UDP</code> on the port entry for UDP-based game servers."
            - "The default protocol is TCP, so you must explicitly specify UDP."
          solution: |-
            apiVersion: v1
            kind: Service
            metadata:
              name: game-server
            spec:
              type: NodePort
              selector:
                app: game
              ports:
              - port: 7777
                targetPort: 7777
                nodePort: 30777
                protocol: UDP
        - id: v9
          title: Prometheus NodePort
          description: >-
            Write a NodePort Service YAML named <code>prometheus</code> that selects Pods with label
            <code>app: prometheus</code>, maps port 9090 to targetPort 9090, and uses nodePort 30909.
          hints:
            - "Prometheus serves its web UI on port 9090."
            - "NodePort is useful for accessing monitoring dashboards during development."
          solution: |-
            apiVersion: v1
            kind: Service
            metadata:
              name: prometheus
            spec:
              type: NodePort
              selector:
                app: prometheus
              ports:
              - port: 9090
                targetPort: 9090
                nodePort: 30909
        - id: v10
          title: Kibana NodePort
          description: >-
            Write a NodePort Service YAML named <code>kibana</code> that selects Pods with label
            <code>app: kibana</code>, maps port 5601 to targetPort 5601, and uses nodePort 30561.
          hints:
            - "Kibana serves its UI on port 5601 by default."
            - "NodePort makes it accessible without setting up an Ingress or load balancer."
          solution: |-
            apiVersion: v1
            kind: Service
            metadata:
              name: kibana
            spec:
              type: NodePort
              selector:
                app: kibana
              ports:
              - port: 5601
                targetPort: 5601
                nodePort: 30561
        - id: v11
          title: Argo CD NodePort
          description: >-
            Write a NodePort Service YAML named <code>argocd-server</code> that selects Pods with label
            <code>app.kubernetes.io/name: argocd-server</code>, maps port 443 to targetPort 8080,
            and uses nodePort 30443.
          hints:
            - "Argo CD uses Kubernetes-style labels with the <code>app.kubernetes.io/name</code> convention."
            - "The server listens on 8080 internally but is exposed as 443."
          solution: |-
            apiVersion: v1
            kind: Service
            metadata:
              name: argocd-server
            spec:
              type: NodePort
              selector:
                app.kubernetes.io/name: argocd-server
              ports:
              - port: 443
                targetPort: 8080
                nodePort: 30443
        - id: v12
          title: MinIO NodePort
          description: >-
            Write a NodePort Service YAML named <code>minio</code> that selects Pods with label
            <code>app: minio</code> and exposes the API on port 9000 (targetPort 9000, nodePort 30900)
            and the console on port 9001 (targetPort 9001, nodePort 30901).
          hints:
            - "MinIO uses 9000 for S3 API and 9001 for the web console."
            - "Name the ports <code>api</code> and <code>console</code>."
          solution: |-
            apiVersion: v1
            kind: Service
            metadata:
              name: minio
            spec:
              type: NodePort
              selector:
                app: minio
              ports:
              - name: api
                port: 9000
                targetPort: 9000
                nodePort: 30900
              - name: console
                port: 9001
                targetPort: 9001
                nodePort: 30901

    - id: warmup_3
      concept: Service Commands
      variants:
        - id: v1
          title: Expose a Deployment
          description: >-
            Write the <code>kubectl</code> command to expose a Deployment named <code>web</code> as a ClusterIP
            Service on port 80 with targetPort 8080.
          hints:
            - "Use <code>kubectl expose deployment</code>."
            - "Use <code>--port</code> and <code>--target-port</code> flags."
          solution: |-
            kubectl expose deployment web --port=80 --target-port=8080
        - id: v2
          title: Expose as NodePort
          description: >-
            Write the <code>kubectl</code> command to expose a Deployment named <code>api</code> as a NodePort
            Service on port 3000.
          hints:
            - "Use <code>--type=NodePort</code> to override the default ClusterIP."
            - "Kubernetes will auto-assign a nodePort in the 30000-32767 range."
          solution: |-
            kubectl expose deployment api --port=3000 --type=NodePort
        - id: v3
          title: List All Services
          description: >-
            Write the <code>kubectl</code> command to list all Services in the current namespace, showing
            wide output with cluster IPs and ports.
          hints:
            - "Use <code>kubectl get svc</code> or <code>kubectl get services</code>."
            - "Add <code>-o wide</code> for additional columns like selectors."
          solution: |-
            kubectl get svc -o wide
        - id: v4
          title: Get Endpoints for a Service
          description: >-
            Write the <code>kubectl</code> command to view the endpoints for a Service named <code>web</code>.
          hints:
            - "Use <code>kubectl get endpoints</code> (or <code>ep</code> for short)."
            - "This shows the Pod IPs and ports that back the Service."
          solution: |-
            kubectl get endpoints web
        - id: v5
          title: Describe a Service
          description: >-
            Write the <code>kubectl</code> command to show detailed information about a Service named
            <code>api</code>, including its endpoints, selector, and events.
          hints:
            - "Use <code>kubectl describe svc</code>."
            - "The output includes Endpoints, Selector, Type, and Port information."
          solution: |-
            kubectl describe svc api
        - id: v6
          title: Delete a Service
          description: >-
            Write the <code>kubectl</code> command to delete a Service named <code>old-api</code> without
            deleting the Pods behind it.
          hints:
            - "Use <code>kubectl delete svc</code>."
            - "Deleting a Service only removes the network endpoint — Pods are unaffected."
          solution: |-
            kubectl delete svc old-api
        - id: v7
          title: List Services in All Namespaces
          description: >-
            Write the <code>kubectl</code> command to list Services across all namespaces.
          hints:
            - "Use the <code>--all-namespaces</code> flag (or <code>-A</code> for short)."
          solution: |-
            kubectl get svc --all-namespaces
        - id: v8
          title: Get Service YAML
          description: >-
            Write the <code>kubectl</code> command to output the full YAML definition of an existing Service
            named <code>web</code>.
          hints:
            - "Use <code>-o yaml</code> to get the full resource definition."
            - "This is useful for inspecting auto-generated fields like ClusterIP."
          solution: |-
            kubectl get svc web -o yaml
        - id: v9
          title: Test Service Connectivity
          description: >-
            Write the <code>kubectl</code> command to run a temporary Pod that tests connectivity to a
            Service named <code>api</code> on port 80 using <code>wget</code>.
          hints:
            - "Use <code>kubectl run</code> with <code>--rm -it</code> for a temporary interactive Pod."
            - "Use the <code>busybox</code> image which includes <code>wget</code>."
          solution: |-
            kubectl run test --image=busybox --rm -it -- wget -qO- http://api:80
        - id: v10
          title: Get EndpointSlices
          description: >-
            Write the <code>kubectl</code> command to list EndpointSlices for a Service named <code>web</code>.
          hints:
            - "EndpointSlices are labeled with <code>kubernetes.io/service-name</code>."
            - "Use <code>kubectl get endpointslices</code> with a label selector."
          solution: |-
            kubectl get endpointslices -l kubernetes.io/service-name=web
        - id: v11
          title: Expose Pod Directly
          description: >-
            Write the <code>kubectl</code> command to expose a single Pod named <code>nginx</code> as a
            ClusterIP Service named <code>nginx-svc</code> on port 80.
          hints:
            - "Use <code>kubectl expose pod</code> instead of <code>kubectl expose deployment</code>."
            - "Use the <code>--name</code> flag to specify the Service name."
          solution: |-
            kubectl expose pod nginx --port=80 --name=nginx-svc
        - id: v12
          title: Patch Service Type
          description: >-
            Write the <code>kubectl</code> command to change an existing ClusterIP Service named <code>web</code>
            to a NodePort Service.
          hints:
            - "Use <code>kubectl patch svc</code> to modify an existing resource."
            - "Use a JSON patch to set <code>spec.type</code>."
          solution: |-
            kubectl patch svc web -p '{"spec": {"type": "NodePort"}}'
        - id: v13
          title: Create Service with Dry Run
          description: >-
            Write the <code>kubectl</code> command to generate a ClusterIP Service YAML for a Deployment named
            <code>api</code> on port 80 without actually creating it (dry-run client output).
          hints:
            - "Use <code>--dry-run=client -o yaml</code> to generate YAML without creating the resource."
            - "This is useful for generating a starting template to customize."
          solution: |-
            kubectl expose deployment api --port=80 --dry-run=client -o yaml

    - id: warmup_4
      concept: Port Mapping
      variants:
        - id: v1
          title: Match the Port Fields
          description: >-
            A container listens on port 3000. Write a Service YAML snippet (just the <code>spec.ports</code>
            section) that exposes it as port 80 on the ClusterIP.
          hints:
            - "<code>port</code> is what clients connect to (80), <code>targetPort</code> is the container port (3000)."
          solution: |-
            ports:
            - port: 80
              targetPort: 3000
        - id: v2
          title: NodePort Chain
          description: >-
            A container listens on port 8080. Write a Service YAML snippet (just the <code>spec.ports</code>
            section) for a NodePort Service that maps nodePort 30080 to Service port 80 to container port 8080.
          hints:
            - "Traffic flows: Node:30080 -> Service:80 -> Pod:8080."
            - "All three port fields go in the same port entry."
          solution: |-
            ports:
            - port: 80
              targetPort: 8080
              nodePort: 30080
        - id: v3
          title: Same Port Everywhere
          description: >-
            A container listens on port 80. Write a Service YAML snippet (just the <code>spec.ports</code> section)
            where port and targetPort are both 80.
          hints:
            - "When the container port matches the Service port, the mapping is one-to-one."
            - "You can omit <code>targetPort</code> when it equals <code>port</code>, but explicit is clearer."
          solution: |-
            ports:
            - port: 80
              targetPort: 80
        - id: v4
          title: Named Target Port
          description: >-
            Write a Pod <code>containerPort</code> snippet with name <code>http</code> and port 8080, then
            write the matching Service <code>ports</code> snippet using the named targetPort.
          hints:
            - "In the container spec, use <code>name: http</code> under <code>containerPort</code>."
            - "In the Service, set <code>targetPort: http</code> instead of a number."
          solution: |-
            # Container spec:
            ports:
            - name: http
              containerPort: 8080

            # Service spec:
            ports:
            - port: 80
              targetPort: http
        - id: v5
          title: UDP Port Mapping
          description: >-
            A DNS container listens on UDP port 53. Write a Service YAML snippet (just the <code>spec.ports</code>
            section) that maps port 53 to targetPort 53 using UDP protocol.
          hints:
            - "Set <code>protocol: UDP</code> on the port entry."
            - "The default protocol is TCP, so UDP must be specified explicitly."
          solution: |-
            ports:
            - port: 53
              targetPort: 53
              protocol: UDP
        - id: v6
          title: Mixed Protocol Ports
          description: >-
            A container handles both TCP and UDP on port 53. Write a Service YAML snippet (just the
            <code>spec.ports</code> section) that exposes both protocols on port 53.
          hints:
            - "You need two separate port entries, each with a <code>name</code> since there are multiple ports."
            - "Name them something like <code>dns-tcp</code> and <code>dns-udp</code>."
          solution: |-
            ports:
            - name: dns-tcp
              port: 53
              targetPort: 53
              protocol: TCP
            - name: dns-udp
              port: 53
              targetPort: 53
              protocol: UDP
        - id: v7
          title: Remap High Port to Standard Port
          description: >-
            A container runs on non-privileged port 8443. Write a Service YAML snippet (just the
            <code>spec.ports</code> section) that exposes it as standard HTTPS port 443.
          hints:
            - "Non-privileged containers use high ports (above 1024) because they do not run as root."
            - "The Service can remap to standard ports like 443."
          solution: |-
            ports:
            - port: 443
              targetPort: 8443
        - id: v8
          title: Three Services, One Container Port
          description: >-
            Given a container on port 8080, write three separate Service YAML <code>spec.ports</code> snippets:
            one ClusterIP on port 80, one NodePort on port 80 with nodePort 30080, and one LoadBalancer on port 80.
          hints:
            - "All three Service types can forward to the same container targetPort."
            - "The only difference is the Service type and whether nodePort is specified."
          solution: |-
            # ClusterIP:
            ports:
            - port: 80
              targetPort: 8080

            # NodePort:
            ports:
            - port: 80
              targetPort: 8080
              nodePort: 30080

            # LoadBalancer:
            ports:
            - port: 80
              targetPort: 8080
        - id: v9
          title: Multiple Container Ports
          description: >-
            A container exposes port 8080 for HTTP and port 8443 for HTTPS. Write a Service YAML snippet
            (just the <code>spec.ports</code> section) that maps 80 to 8080 and 443 to 8443.
          hints:
            - "Each port entry must have a <code>name</code> when there are multiple ports."
            - "Use clear names like <code>http</code> and <code>https</code>."
          solution: |-
            ports:
            - name: http
              port: 80
              targetPort: 8080
            - name: https
              port: 443
              targetPort: 8443
        - id: v10
          title: NodePort with Full Port Chain
          description: >-
            Write a complete NodePort Service YAML named <code>web</code> that demonstrates the full port
            chain: nodePort 30080 -> Service port 80 -> Pod targetPort 8080. Include the selector
            <code>app: web</code>.
          hints:
            - "This is the full flow: external traffic hits Node:30080, kube-proxy forwards to Service:80, which forwards to Pod:8080."
          solution: |-
            apiVersion: v1
            kind: Service
            metadata:
              name: web
            spec:
              type: NodePort
              selector:
                app: web
              ports:
              - port: 80
                targetPort: 8080
                nodePort: 30080

  challenges:
    - id: challenge_1
      block: 1
      difficulty: 2
      concept: Service Types
      variants:
        - id: v1
          title: Internal Microservice
          description: >-
            Your team is deploying a user authentication service. It will only be called by other services
            within the cluster. The service runs on port 4000. Write the complete Service YAML.
          functionSignature: "kind: Service"
          testCases:
            - input: "Internal-only service, port 4000, app=auth-service"
              output: "ClusterIP Service on port 4000"
          hints:
            - title: "Think about it"
              content: "Which Service type is used for internal-only communication? What is the default type?"
            - title: "Hint"
              content: "ClusterIP is the default Service type and is only reachable from within the cluster. Perfect for internal microservices."
            - title: "Pattern"
              content: |-
                <pre>1. Use ClusterIP (default type)
                2. Selector matches Pod labels
                3. port = what clients connect to
                4. targetPort = container port</pre>
          solution: |-
            apiVersion: v1
            kind: Service
            metadata:
              name: auth-service
            spec:
              type: ClusterIP
              selector:
                app: auth-service
              ports:
              - port: 4000
                targetPort: 4000
          difficulty: 1
        - id: v2
          title: Development Web App
          description: >-
            You are testing a web app locally on minikube. The container listens on port 3000. You need to
            access it from your browser at a fixed port. Write the Service YAML that makes this possible.
          functionSignature: "kind: Service"
          testCases:
            - input: "External access on minikube, port 3000, app=webapp, fixed external port"
              output: "NodePort Service on port 3000, nodePort in 30000-32767"
          hints:
            - title: "Think about it"
              content: "You need external access without a cloud load balancer. Which Service type exposes on every node's IP?"
            - title: "Hint"
              content: "NodePort exposes the Service on a static port (30000-32767) on every node. On minikube, access via <code>$(minikube ip):nodePort</code>."
            - title: "Pattern"
              content: |-
                <pre>1. type: NodePort for external access
                2. nodePort in 30000-32767 range
                3. port = ClusterIP port
                4. targetPort = container port</pre>
          solution: |-
            apiVersion: v1
            kind: Service
            metadata:
              name: webapp
            spec:
              type: NodePort
              selector:
                app: webapp
              ports:
              - port: 3000
                targetPort: 3000
                nodePort: 30030
          difficulty: 1
        - id: v3
          title: Production API on AWS
          description: >-
            Your production API needs a public-facing endpoint on AWS EKS. The API container listens on port
            8080 and should be exposed as standard HTTP port 80 with a real external IP. Write the Service YAML.
          functionSignature: "kind: Service"
          testCases:
            - input: "Cloud production, external IP, port 80 -> 8080, app=api"
              output: "LoadBalancer Service mapping 80 to 8080"
          hints:
            - title: "Think about it"
              content: "Which Service type provisions a cloud load balancer with a real external IP?"
            - title: "Hint"
              content: "LoadBalancer type requests an external load balancer from the cloud provider. On AWS, this creates an ELB/NLB. The Service gets an EXTERNAL-IP."
            - title: "Pattern"
              content: |-
                <pre>1. type: LoadBalancer for cloud external access
                2. port: 80 (standard HTTP)
                3. targetPort: 8080 (container port)
                4. Cloud auto-provisions the LB</pre>
          solution: |-
            apiVersion: v1
            kind: Service
            metadata:
              name: api
            spec:
              type: LoadBalancer
              selector:
                app: api
              ports:
              - port: 80
                targetPort: 8080
          difficulty: 2
        - id: v4
          title: External Database Alias
          description: >-
            Your app connects to a managed PostgreSQL database at <code>db.prod.example.com</code>. You want
            Pods to reference it as a Kubernetes Service name <code>database</code> so you can swap to an
            in-cluster database later without changing app code. Write the Service YAML.
          functionSignature: "kind: Service"
          testCases:
            - input: "DNS alias to db.prod.example.com, name=database"
              output: "ExternalName Service with CNAME"
          hints:
            - title: "Think about it"
              content: "Which Service type creates a DNS alias (CNAME) to an external hostname without any proxying?"
            - title: "Hint"
              content: "ExternalName creates a CNAME DNS record. No selector, no ClusterIP — just a DNS redirect. Pods connect to <code>database.default.svc.cluster.local</code> and DNS resolves to the external hostname."
            - title: "Pattern"
              content: |-
                <pre>1. type: ExternalName
                2. externalName: the real hostname
                3. No selector needed
                4. No ports needed (DNS only)</pre>
          solution: |-
            apiVersion: v1
            kind: Service
            metadata:
              name: database
            spec:
              type: ExternalName
              externalName: db.prod.example.com
          difficulty: 2
        - id: v5
          title: Staging vs Production Decision
          description: >-
            You have two environments. In staging, your team accesses the app on their laptops via a local
            kind cluster. In production on GKE, the app needs a real external IP. The container runs on port
            8080. Write both Service YAMLs: one for staging, one for production.
          functionSignature: "kind: Service"
          testCases:
            - input: "Staging: local access via kind, Production: GKE external IP, port 8080, app=frontend"
              output: "NodePort for staging, LoadBalancer for production"
          hints:
            - title: "Think about it"
              content: "What type gives external access on a local cluster? What type gives a real external IP on a cloud provider?"
            - title: "Hint"
              content: "Use NodePort for staging (local clusters like kind/minikube) and LoadBalancer for production (cloud providers). The selector and targetPort stay the same."
            - title: "Pattern"
              content: |-
                <pre>Staging:
                  type: NodePort
                  nodePort: fixed port for testing
                Production:
                  type: LoadBalancer
                  gets real external IP from GKE</pre>
          solution: |-
            # Staging (kind cluster):
            apiVersion: v1
            kind: Service
            metadata:
              name: frontend
            spec:
              type: NodePort
              selector:
                app: frontend
              ports:
              - port: 80
                targetPort: 8080
                nodePort: 30080
            ---
            # Production (GKE):
            apiVersion: v1
            kind: Service
            metadata:
              name: frontend
            spec:
              type: LoadBalancer
              selector:
                app: frontend
              ports:
              - port: 80
                targetPort: 8080
          difficulty: 3
        - id: v6
          title: Service Without Selector
          description: >-
            Your team has a legacy database at IP <code>192.168.1.50</code> on port 3306 that is not running
            in Kubernetes. You want in-cluster Pods to access it via the Service name <code>legacy-db</code>.
            Write the Service and Endpoints YAML (no selector, manual endpoints).
          functionSignature: "kind: Service + kind: Endpoints"
          testCases:
            - input: "External IP 192.168.1.50, port 3306, name=legacy-db"
              output: "Service without selector + Endpoints with manual IP"
          hints:
            - title: "Think about it"
              content: "How do you create a Service that points to an IP address outside the cluster? What do you use when there is no label selector?"
            - title: "Hint"
              content: "Create a Service without a <code>selector</code>, then create an Endpoints resource with the same name. The Endpoints resource lists the external IP and port."
            - title: "Pattern"
              content: |-
                <pre>1. Service with no selector (just ports)
                2. Endpoints resource with same name
                3. Endpoints lists the external IP
                4. Pods connect to service-name:port</pre>
          solution: |-
            apiVersion: v1
            kind: Service
            metadata:
              name: legacy-db
            spec:
              ports:
              - port: 3306
            ---
            apiVersion: v1
            kind: Endpoints
            metadata:
              name: legacy-db
            subsets:
            - addresses:
              - ip: 192.168.1.50
              ports:
              - port: 3306
          difficulty: 3
        - id: v7
          title: HTTPS LoadBalancer
          description: >-
            Your API needs to serve HTTPS traffic in production on GKE. The container handles TLS termination
            internally on port 8443. Expose it on standard port 443 with a cloud load balancer. Write the
            Service YAML.
          functionSignature: "kind: Service"
          testCases:
            - input: "Cloud HTTPS, port 443 -> 8443, app=secure-api, LoadBalancer"
              output: "LoadBalancer Service mapping 443 to 8443"
          hints:
            - title: "Think about it"
              content: "The container does its own TLS termination on port 8443. The Service needs to expose standard HTTPS port 443."
            - title: "Hint"
              content: "Use LoadBalancer type with port 443 mapping to targetPort 8443. The Service remaps the port so external clients connect on the standard HTTPS port."
            - title: "Pattern"
              content: |-
                <pre>1. type: LoadBalancer
                2. port: 443 (standard HTTPS)
                3. targetPort: 8443 (container TLS port)
                4. Cloud LB forwards to node, kube-proxy forwards to Pod</pre>
          solution: |-
            apiVersion: v1
            kind: Service
            metadata:
              name: secure-api
            spec:
              type: LoadBalancer
              selector:
                app: secure-api
              ports:
              - port: 443
                targetPort: 8443
          difficulty: 2

    - id: challenge_2
      block: 1
      difficulty: 3
      concept: Service + Deployment Wiring
      variants:
        - id: v1
          title: Web App Deployment + Service
          description: >-
            Write a Deployment and ClusterIP Service for a web app. The Deployment should have 3 replicas of
            <code>nginx:1.25</code> on port 80. The Service should expose port 80. Ensure labels and selectors
            match correctly.
          functionSignature: "kind: Deployment + kind: Service"
          testCases:
            - input: "3 replicas nginx:1.25, port 80, app=web"
              output: "Deployment labels match Service selector, endpoints populated"
          hints:
            - title: "Think about it"
              content: "Which labels must match? The Service selector must match the Pod template labels, not the Deployment labels. The Deployment selector must also match the Pod template."
            - title: "Hint"
              content: "Three labels must align: the Deployment's <code>spec.selector.matchLabels</code>, the Pod template's <code>metadata.labels</code>, and the Service's <code>spec.selector</code>. All three should use the same label (e.g., <code>app: web</code>)."
            - title: "Pattern"
              content: |-
                <pre>1. Deployment:
                   spec.selector.matchLabels: {app: web}
                   spec.template.metadata.labels: {app: web}
                   spec.template.spec.containers[0].ports[0].containerPort: 80
                2. Service:
                   spec.selector: {app: web}
                   spec.ports[0].port: 80, targetPort: 80</pre>
          solution: |-
            apiVersion: apps/v1
            kind: Deployment
            metadata:
              name: web
            spec:
              replicas: 3
              selector:
                matchLabels:
                  app: web
              template:
                metadata:
                  labels:
                    app: web
                spec:
                  containers:
                  - name: web
                    image: nginx:1.25
                    ports:
                    - containerPort: 80
            ---
            apiVersion: v1
            kind: Service
            metadata:
              name: web
            spec:
              selector:
                app: web
              ports:
              - port: 80
                targetPort: 80
          difficulty: 2
        - id: v2
          title: API + Redis Backend
          description: >-
            Write a Deployment and ClusterIP Service for an API (<code>myapi:v2</code>, port 3000, 2 replicas)
            and a separate Deployment and ClusterIP Service for Redis (<code>redis:7</code>, port 6379,
            1 replica). The API connects to Redis at <code>redis:6379</code>.
          functionSignature: "kind: Deployment + kind: Service (x2)"
          testCases:
            - input: "API: myapi:v2 port 3000, Redis: redis:7 port 6379"
              output: "Two Deployments + two Services, API can reach redis:6379"
          hints:
            - title: "Think about it"
              content: "Each Deployment needs its own labels, and each Service selector must match the right Deployment's Pod labels. The API uses the Redis Service DNS name."
            - title: "Hint"
              content: "Use different label values: <code>app: api</code> for the API and <code>app: redis</code> for Redis. The API Pod can connect to <code>redis:6379</code> because Kubernetes DNS resolves the Service name."
            - title: "Pattern"
              content: |-
                <pre>1. API Deployment: app=api, image myapi:v2, containerPort 3000
                2. API Service: selector app=api, port 3000
                3. Redis Deployment: app=redis, image redis:7, containerPort 6379
                4. Redis Service: selector app=redis, port 6379
                   API connects to redis:6379 via DNS</pre>
          solution: |-
            apiVersion: apps/v1
            kind: Deployment
            metadata:
              name: api
            spec:
              replicas: 2
              selector:
                matchLabels:
                  app: api
              template:
                metadata:
                  labels:
                    app: api
                spec:
                  containers:
                  - name: api
                    image: myapi:v2
                    ports:
                    - containerPort: 3000
            ---
            apiVersion: v1
            kind: Service
            metadata:
              name: api
            spec:
              selector:
                app: api
              ports:
              - port: 3000
                targetPort: 3000
            ---
            apiVersion: apps/v1
            kind: Deployment
            metadata:
              name: redis
            spec:
              replicas: 1
              selector:
                matchLabels:
                  app: redis
              template:
                metadata:
                  labels:
                    app: redis
                spec:
                  containers:
                  - name: redis
                    image: redis:7
                    ports:
                    - containerPort: 6379
            ---
            apiVersion: v1
            kind: Service
            metadata:
              name: redis
            spec:
              selector:
                app: redis
              ports:
              - port: 6379
                targetPort: 6379
          difficulty: 2
        - id: v3
          title: Frontend + Backend with NodePort
          description: >-
            Write a Deployment and NodePort Service for a frontend (<code>frontend:v1</code>, port 80,
            2 replicas, nodePort 30080) and a Deployment and ClusterIP Service for a backend
            (<code>backend:v1</code>, port 8080, 3 replicas). The frontend calls the backend at
            <code>http://backend:8080</code>.
          functionSignature: "kind: Deployment + kind: Service (x2)"
          testCases:
            - input: "Frontend: NodePort 30080, Backend: ClusterIP 8080"
              output: "Frontend externally accessible, backend internal only"
          hints:
            - title: "Think about it"
              content: "The frontend needs external access (NodePort) while the backend should be internal-only (ClusterIP). Both need Deployments with matching label selectors."
            - title: "Hint"
              content: "Use <code>app: frontend</code> and <code>app: backend</code> labels. The frontend Service is NodePort with nodePort 30080. The backend Service is ClusterIP. The frontend Pods reach the backend via DNS name <code>backend</code>."
            - title: "Pattern"
              content: |-
                <pre>1. Frontend Deployment: app=frontend, port 80
                2. Frontend Service: NodePort, nodePort 30080
                3. Backend Deployment: app=backend, port 8080
                4. Backend Service: ClusterIP, port 8080
                   Frontend -> http://backend:8080</pre>
          solution: |-
            apiVersion: apps/v1
            kind: Deployment
            metadata:
              name: frontend
            spec:
              replicas: 2
              selector:
                matchLabels:
                  app: frontend
              template:
                metadata:
                  labels:
                    app: frontend
                spec:
                  containers:
                  - name: frontend
                    image: frontend:v1
                    ports:
                    - containerPort: 80
            ---
            apiVersion: v1
            kind: Service
            metadata:
              name: frontend
            spec:
              type: NodePort
              selector:
                app: frontend
              ports:
              - port: 80
                targetPort: 80
                nodePort: 30080
            ---
            apiVersion: apps/v1
            kind: Deployment
            metadata:
              name: backend
            spec:
              replicas: 3
              selector:
                matchLabels:
                  app: backend
              template:
                metadata:
                  labels:
                    app: backend
                spec:
                  containers:
                  - name: backend
                    image: backend:v1
                    ports:
                    - containerPort: 8080
            ---
            apiVersion: v1
            kind: Service
            metadata:
              name: backend
            spec:
              selector:
                app: backend
              ports:
              - port: 8080
                targetPort: 8080
          difficulty: 3
        - id: v4
          title: Microservices with Port Remapping
          description: >-
            Write a Deployment and Service for a payment service (<code>payment:v3</code>, runs on port 9090,
            2 replicas). The Service should expose it on port 80 so callers use
            <code>http://payment:80</code>. Use labels <code>app: payment</code> and <code>tier: backend</code>.
          functionSignature: "kind: Deployment + kind: Service"
          testCases:
            - input: "payment:v3 on 9090, Service port 80, labels app=payment tier=backend"
              output: "Service port 80 -> targetPort 9090, multi-label selector"
          hints:
            - title: "Think about it"
              content: "The Service port and targetPort differ — clients connect to port 80 but traffic forwards to port 9090. The selector uses two labels."
            - title: "Hint"
              content: "Set <code>port: 80</code> and <code>targetPort: 9090</code> in the Service. Both labels (<code>app: payment</code> and <code>tier: backend</code>) must appear in the Pod template labels AND the Service selector."
            - title: "Pattern"
              content: |-
                <pre>1. Deployment Pod labels: {app: payment, tier: backend}
                2. Service selector: {app: payment, tier: backend}
                3. Service port: 80 -> targetPort: 9090
                4. Callers use http://payment:80</pre>
          solution: |-
            apiVersion: apps/v1
            kind: Deployment
            metadata:
              name: payment
            spec:
              replicas: 2
              selector:
                matchLabels:
                  app: payment
                  tier: backend
              template:
                metadata:
                  labels:
                    app: payment
                    tier: backend
                spec:
                  containers:
                  - name: payment
                    image: payment:v3
                    ports:
                    - containerPort: 9090
            ---
            apiVersion: v1
            kind: Service
            metadata:
              name: payment
            spec:
              selector:
                app: payment
                tier: backend
              ports:
              - port: 80
                targetPort: 9090
          difficulty: 2
        - id: v5
          title: Three-Tier Application
          description: >-
            Write Deployments and Services for a 3-tier app: a frontend (<code>web:v1</code>, port 80,
            NodePort 30080), an API (<code>api:v2</code>, port 3000, ClusterIP), and a database
            (<code>postgres:15</code>, port 5432, ClusterIP). Each tier gets its own label. The
            frontend calls <code>http://api:3000</code> and the API calls <code>postgres:5432</code>.
          functionSignature: "kind: Deployment + kind: Service (x3)"
          testCases:
            - input: "3 tiers: web(NodePort), api(ClusterIP), postgres(ClusterIP)"
              output: "Three Deployment+Service pairs with correct wiring"
          hints:
            - title: "Think about it"
              content: "Only the frontend needs external access (NodePort). The API and database are internal (ClusterIP). Each tier has distinct labels."
            - title: "Hint"
              content: "Use labels <code>app: web</code>, <code>app: api</code>, and <code>app: postgres</code>. Only the web Service is NodePort. The API uses ClusterIP on port 3000. PostgreSQL uses ClusterIP on port 5432."
            - title: "Pattern"
              content: |-
                <pre>Frontend: NodePort 30080, port 80, app=web
                API: ClusterIP, port 3000, app=api
                Database: ClusterIP, port 5432, app=postgres
                web -> http://api:3000 -> postgres:5432</pre>
          solution: |-
            apiVersion: apps/v1
            kind: Deployment
            metadata:
              name: web
            spec:
              replicas: 2
              selector:
                matchLabels:
                  app: web
              template:
                metadata:
                  labels:
                    app: web
                spec:
                  containers:
                  - name: web
                    image: web:v1
                    ports:
                    - containerPort: 80
            ---
            apiVersion: v1
            kind: Service
            metadata:
              name: web
            spec:
              type: NodePort
              selector:
                app: web
              ports:
              - port: 80
                targetPort: 80
                nodePort: 30080
            ---
            apiVersion: apps/v1
            kind: Deployment
            metadata:
              name: api
            spec:
              replicas: 2
              selector:
                matchLabels:
                  app: api
              template:
                metadata:
                  labels:
                    app: api
                spec:
                  containers:
                  - name: api
                    image: api:v2
                    ports:
                    - containerPort: 3000
            ---
            apiVersion: v1
            kind: Service
            metadata:
              name: api
            spec:
              selector:
                app: api
              ports:
              - port: 3000
                targetPort: 3000
            ---
            apiVersion: apps/v1
            kind: Deployment
            metadata:
              name: postgres
            spec:
              replicas: 1
              selector:
                matchLabels:
                  app: postgres
              template:
                metadata:
                  labels:
                    app: postgres
                spec:
                  containers:
                  - name: postgres
                    image: postgres:15
                    ports:
                    - containerPort: 5432
            ---
            apiVersion: v1
            kind: Service
            metadata:
              name: postgres
            spec:
              selector:
                app: postgres
              ports:
              - port: 5432
                targetPort: 5432
          difficulty: 4
        - id: v6
          title: LoadBalancer Frontend with Internal Backend
          description: >-
            Write a Deployment and LoadBalancer Service for a frontend (<code>nginx:1.25</code>, port 80,
            3 replicas, exposed on port 80) and a Deployment and ClusterIP Service for a backend echo
            server (<code>hashicorp/http-echo</code> with args <code>["-text=hello"]</code>, port 5678,
            exposed as port 80). The frontend proxies to <code>http://echo:80</code>.
          functionSignature: "kind: Deployment + kind: Service (x2)"
          testCases:
            - input: "Frontend: LoadBalancer port 80, Backend: ClusterIP echo on 5678 exposed as 80"
              output: "External LB + internal ClusterIP with port remapping"
          hints:
            - title: "Think about it"
              content: "The frontend needs a cloud load balancer (LoadBalancer). The backend uses port remapping: Service port 80 forwards to container port 5678."
            - title: "Hint"
              content: "The echo container listens on 5678, but its Service exposes port 80. This way, the frontend just calls <code>http://echo:80</code> without knowing the internal port."
            - title: "Pattern"
              content: |-
                <pre>Frontend: LoadBalancer, port 80, app=frontend
                Backend: ClusterIP, port 80 -> targetPort 5678, app=echo
                Container args: ["-text=hello"]</pre>
          solution: |-
            apiVersion: apps/v1
            kind: Deployment
            metadata:
              name: frontend
            spec:
              replicas: 3
              selector:
                matchLabels:
                  app: frontend
              template:
                metadata:
                  labels:
                    app: frontend
                spec:
                  containers:
                  - name: nginx
                    image: nginx:1.25
                    ports:
                    - containerPort: 80
            ---
            apiVersion: v1
            kind: Service
            metadata:
              name: frontend
            spec:
              type: LoadBalancer
              selector:
                app: frontend
              ports:
              - port: 80
                targetPort: 80
            ---
            apiVersion: apps/v1
            kind: Deployment
            metadata:
              name: echo
            spec:
              replicas: 2
              selector:
                matchLabels:
                  app: echo
              template:
                metadata:
                  labels:
                    app: echo
                spec:
                  containers:
                  - name: echo
                    image: hashicorp/http-echo
                    args: ["-text=hello"]
                    ports:
                    - containerPort: 5678
            ---
            apiVersion: v1
            kind: Service
            metadata:
              name: echo
            spec:
              selector:
                app: echo
              ports:
              - port: 80
                targetPort: 5678
          difficulty: 3
        - id: v7
          title: Multi-Port Deployment + Service
          description: >-
            Write a Deployment and Service for an application (<code>myapp:v1</code>, 2 replicas) that
            serves HTTP on container port 8080 and exposes a Prometheus metrics endpoint on container port
            9090. The Service should map port 80 to 8080 (named <code>http</code>) and port 9090 to 9090
            (named <code>metrics</code>).
          functionSignature: "kind: Deployment + kind: Service"
          testCases:
            - input: "myapp:v1, HTTP 8080->80, metrics 9090->9090, named ports"
              output: "Multi-port Deployment + Service with named ports"
          hints:
            - title: "Think about it"
              content: "The container exposes two ports. The Service must list both with names (required when multiple ports exist)."
            - title: "Hint"
              content: "List both <code>containerPort</code> entries in the Deployment and both <code>port</code>/<code>targetPort</code> entries in the Service. Give each a <code>name</code>."
            - title: "Pattern"
              content: |-
                <pre>Container ports: 8080 (http), 9090 (metrics)
                Service ports:
                  http: 80 -> 8080
                  metrics: 9090 -> 9090</pre>
          solution: |-
            apiVersion: apps/v1
            kind: Deployment
            metadata:
              name: myapp
            spec:
              replicas: 2
              selector:
                matchLabels:
                  app: myapp
              template:
                metadata:
                  labels:
                    app: myapp
                spec:
                  containers:
                  - name: myapp
                    image: myapp:v1
                    ports:
                    - name: http
                      containerPort: 8080
                    - name: metrics
                      containerPort: 9090
            ---
            apiVersion: v1
            kind: Service
            metadata:
              name: myapp
            spec:
              selector:
                app: myapp
              ports:
              - name: http
                port: 80
                targetPort: 8080
              - name: metrics
                port: 9090
                targetPort: 9090
          difficulty: 3
        - id: v8
          title: Named TargetPort Wiring
          description: >-
            Write a Deployment for <code>api:v4</code> (2 replicas) that declares a named container port
            called <code>api-port</code> on port 9090. Then write a Service that references this named
            port in <code>targetPort</code> instead of using the port number.
          functionSignature: "kind: Deployment + kind: Service"
          testCases:
            - input: "Named containerPort 'api-port' at 9090, Service references by name"
              output: "Service targetPort uses string 'api-port' instead of 9090"
          hints:
            - title: "Think about it"
              content: "Named ports decouple the Service from the container's actual port number. If the container port changes, only the Deployment needs updating."
            - title: "Hint"
              content: "In the container spec, set <code>name: api-port</code> alongside <code>containerPort: 9090</code>. In the Service, use <code>targetPort: api-port</code> (a string, not a number)."
            - title: "Pattern"
              content: |-
                <pre>Deployment container:
                  ports:
                  - name: api-port
                    containerPort: 9090
                Service:
                  ports:
                  - port: 80
                    targetPort: api-port  # string reference</pre>
          solution: |-
            apiVersion: apps/v1
            kind: Deployment
            metadata:
              name: api
            spec:
              replicas: 2
              selector:
                matchLabels:
                  app: api
              template:
                metadata:
                  labels:
                    app: api
                spec:
                  containers:
                  - name: api
                    image: api:v4
                    ports:
                    - name: api-port
                      containerPort: 9090
            ---
            apiVersion: v1
            kind: Service
            metadata:
              name: api
            spec:
              selector:
                app: api
              ports:
              - port: 80
                targetPort: api-port
          difficulty: 2

    - id: challenge_3
      block: 2
      difficulty: 3
      concept: Service Debugging
      variants:
        - id: v1
          title: Label Mismatch
          description: >-
            A Service has no endpoints. Here is the Service and Deployment YAML. Find the bug and write
            the corrected YAML.<br><br>
            <pre>apiVersion: v1
            kind: Service
            metadata:
              name: api
            spec:
              selector:
                app: api-server
              ports:
              - port: 80
                targetPort: 3000
            ---
            apiVersion: apps/v1
            kind: Deployment
            metadata:
              name: api
            spec:
              replicas: 2
              selector:
                matchLabels:
                  app: api
              template:
                metadata:
                  labels:
                    app: api
                spec:
                  containers:
                  - name: api
                    image: api:v1
                    ports:
                    - containerPort: 3000</pre>
          functionSignature: "kubectl get endpoints api"
          testCases:
            - input: "kubectl get endpoints api shows <none>"
              output: "Service selector app:api-server does not match Pod label app:api"
          hints:
            - title: "Think about it"
              content: "The Service has no endpoints. This means the selector is not matching any Pods. Compare the Service selector with the Pod template labels."
            - title: "Hint"
              content: "The Service selector says <code>app: api-server</code> but the Pod labels say <code>app: api</code>. They must match exactly."
            - title: "Pattern"
              content: |-
                <pre>Debug steps:
                1. kubectl get endpoints api → shows <none>
                2. kubectl describe svc api → check Selector
                3. kubectl get pods --show-labels → check Pod labels
                4. Fix: make selector match Pod labels</pre>
          solution: |-
            # Fix: Change Service selector from "api-server" to "api"
            apiVersion: v1
            kind: Service
            metadata:
              name: api
            spec:
              selector:
                app: api
              ports:
              - port: 80
                targetPort: 3000
          difficulty: 2
        - id: v2
          title: Wrong TargetPort
          description: >-
            The Service endpoints are populated but requests hang and time out. Here is the YAML. Find the bug
            and write the corrected YAML.<br><br>
            <pre>apiVersion: v1
            kind: Service
            metadata:
              name: web
            spec:
              selector:
                app: web
              ports:
              - port: 80
                targetPort: 8080
            ---
            apiVersion: apps/v1
            kind: Deployment
            metadata:
              name: web
            spec:
              replicas: 3
              selector:
                matchLabels:
                  app: web
              template:
                metadata:
                  labels:
                    app: web
                spec:
                  containers:
                  - name: web
                    image: nginx:1.25
                    ports:
                    - containerPort: 80</pre>
          functionSignature: "kubectl describe svc web"
          testCases:
            - input: "curl http://web:80 times out, but endpoints exist"
              output: "Service targetPort 8080 does not match container port 80"
          hints:
            - title: "Think about it"
              content: "Endpoints exist (labels match), but connections fail. The issue is at the port level. What port is the container actually listening on?"
            - title: "Hint"
              content: "The Service <code>targetPort: 8080</code> sends traffic to port 8080 on the Pod, but nginx listens on port 80 (<code>containerPort: 80</code>). The targetPort must match the container's actual listening port."
            - title: "Pattern"
              content: |-
                <pre>Debug steps:
                1. kubectl get endpoints web → IPs exist (labels match)
                2. kubectl exec into a Pod → curl localhost:80 works
                3. targetPort 8080 != containerPort 80
                4. Fix: change targetPort to 80</pre>
          solution: |-
            # Fix: Change targetPort from 8080 to 80 (matching containerPort)
            apiVersion: v1
            kind: Service
            metadata:
              name: web
            spec:
              selector:
                app: web
              ports:
              - port: 80
                targetPort: 80
          difficulty: 2
        - id: v3
          title: Missing Label in Selector
          description: >-
            The Service has no endpoints. The Deployment Pods are Running. Find the bug and write the
            corrected YAML.<br><br>
            <pre>apiVersion: v1
            kind: Service
            metadata:
              name: backend
            spec:
              selector:
                app: backend
                version: v2
              ports:
              - port: 80
                targetPort: 8080
            ---
            apiVersion: apps/v1
            kind: Deployment
            metadata:
              name: backend
            spec:
              replicas: 2
              selector:
                matchLabels:
                  app: backend
              template:
                metadata:
                  labels:
                    app: backend
                spec:
                  containers:
                  - name: backend
                    image: backend:v2
                    ports:
                    - containerPort: 8080</pre>
          functionSignature: "kubectl get endpoints backend"
          testCases:
            - input: "kubectl get endpoints backend shows <none>"
              output: "Service requires label version:v2 but Pods only have app:backend"
          hints:
            - title: "Think about it"
              content: "The Service selector requires ALL listed labels to match. The Pods must have every label the Service selector specifies."
            - title: "Hint"
              content: "The Service selector requires <code>app: backend</code> AND <code>version: v2</code>. The Pods only have <code>app: backend</code>. Fix by either adding the label to Pods or removing it from the Service selector."
            - title: "Pattern"
              content: |-
                <pre>Debug steps:
                1. kubectl describe svc backend → Selector: app=backend,version=v2
                2. kubectl get pods --show-labels → Labels: app=backend (no version!)
                3. Fix option A: Add version:v2 label to Pod template
                4. Fix option B: Remove version:v2 from Service selector</pre>
          solution: |-
            # Fix: Add the missing version label to the Pod template
            apiVersion: apps/v1
            kind: Deployment
            metadata:
              name: backend
            spec:
              replicas: 2
              selector:
                matchLabels:
                  app: backend
                  version: v2
              template:
                metadata:
                  labels:
                    app: backend
                    version: v2
                spec:
                  containers:
                  - name: backend
                    image: backend:v2
                    ports:
                    - containerPort: 8080
          difficulty: 3
        - id: v4
          title: Wrong Service Name for DNS
          description: >-
            The frontend Pod tries to connect to <code>http://api-service:80</code> but gets a DNS
            resolution error. The backend Service and Deployment are running. Find the problem and write
            the fix.<br><br>
            <pre>apiVersion: v1
            kind: Service
            metadata:
              name: api
            spec:
              selector:
                app: api
              ports:
              - port: 80
                targetPort: 3000
            ---
            # Frontend code connects to: http://api-service:80</pre>
          functionSignature: "kubectl exec frontend-pod -- nslookup api-service"
          testCases:
            - input: "nslookup api-service fails, nslookup api succeeds"
              output: "Service name is 'api' but code uses 'api-service'"
          hints:
            - title: "Think about it"
              content: "Kubernetes DNS creates records based on the Service <code>metadata.name</code>. What name did we give the Service?"
            - title: "Hint"
              content: "The Service is named <code>api</code> but the frontend code tries to connect to <code>api-service</code>. Either rename the Service or update the application config to use <code>api</code>."
            - title: "Pattern"
              content: |-
                <pre>Debug steps:
                1. kubectl exec frontend -- nslookup api-service → NXDOMAIN
                2. kubectl exec frontend -- nslookup api → resolves!
                3. Fix: rename Service to match what the app expects
                   OR update app config to use correct Service name</pre>
          solution: |-
            # Fix: Rename the Service to match what the frontend expects
            apiVersion: v1
            kind: Service
            metadata:
              name: api-service
            spec:
              selector:
                app: api
              ports:
              - port: 80
                targetPort: 3000
          difficulty: 2
        - id: v5
          title: NodePort Out of Range
          description: >-
            Applying this Service YAML fails with an error. Find the problem and write the corrected
            YAML.<br><br>
            <pre>apiVersion: v1
            kind: Service
            metadata:
              name: web
            spec:
              type: NodePort
              selector:
                app: web
              ports:
              - port: 80
                targetPort: 80
                nodePort: 8080</pre>
          functionSignature: "kubectl apply -f svc.yaml"
          testCases:
            - input: "kubectl apply fails: 'provided port is not in the valid range'"
              output: "nodePort 8080 is outside 30000-32767 range"
          hints:
            - title: "Think about it"
              content: "NodePort values have a restricted range. What is the valid range for nodePort?"
            - title: "Hint"
              content: "NodePorts must be in the range 30000-32767. The value 8080 is outside this range. Change it to a value like 30080."
            - title: "Pattern"
              content: |-
                <pre>Valid nodePort range: 30000-32767
                Common mapping: 80 → 30080, 443 → 30443
                Fix: change nodePort to valid range</pre>
          solution: |-
            # Fix: Change nodePort from 8080 to 30080 (within valid range)
            apiVersion: v1
            kind: Service
            metadata:
              name: web
            spec:
              type: NodePort
              selector:
                app: web
              ports:
              - port: 80
                targetPort: 80
                nodePort: 30080
          difficulty: 2
        - id: v6
          title: Selector Typo
          description: >-
            A Service shows no endpoints. The Pods are Running with labels <code>app: payment-svc</code>.
            Find the bug and write the corrected Service YAML.<br><br>
            <pre>apiVersion: v1
            kind: Service
            metadata:
              name: payment
            spec:
              selector:
                app: payment-sv
              ports:
              - port: 80
                targetPort: 8080</pre>
          functionSignature: "kubectl get endpoints payment"
          testCases:
            - input: "kubectl get endpoints payment shows <none>"
              output: "Selector 'payment-sv' is a typo for 'payment-svc'"
          hints:
            - title: "Think about it"
              content: "Label selectors must match exactly. Even one character difference means no match."
            - title: "Hint"
              content: "The selector says <code>payment-sv</code> but Pods have <code>payment-svc</code>. A simple typo — the trailing 'c' is missing."
            - title: "Pattern"
              content: |-
                <pre>Debug steps:
                1. kubectl get endpoints payment → <none>
                2. kubectl get pods --show-labels → app=payment-svc
                3. kubectl describe svc payment → Selector: app=payment-sv
                4. Fix: correct the typo in the selector</pre>
          solution: |-
            # Fix: Correct the typo from "payment-sv" to "payment-svc"
            apiVersion: v1
            kind: Service
            metadata:
              name: payment
            spec:
              selector:
                app: payment-svc
              ports:
              - port: 80
                targetPort: 8080
          difficulty: 2
        - id: v7
          title: Protocol Mismatch
          description: >-
            A DNS Service is not working. The CoreDNS Pod listens on UDP port 53, but queries time out.
            Find the bug and write the corrected Service YAML.<br><br>
            <pre>apiVersion: v1
            kind: Service
            metadata:
              name: custom-dns
            spec:
              selector:
                app: custom-dns
              ports:
              - port: 53
                targetPort: 53</pre>
          functionSignature: "nslookup example.com custom-dns"
          testCases:
            - input: "DNS queries to custom-dns:53 time out"
              output: "Service defaults to TCP but DNS uses UDP"
          hints:
            - title: "Think about it"
              content: "DNS primarily uses UDP, not TCP. What is the default protocol for a Kubernetes Service port?"
            - title: "Hint"
              content: "The default protocol is TCP. DNS queries use UDP. Add <code>protocol: UDP</code> to the port entry. For full DNS support, expose both TCP and UDP on port 53."
            - title: "Pattern"
              content: |-
                <pre>Debug steps:
                1. DNS queries time out (UDP traffic)
                2. Service defaults to TCP protocol
                3. Fix: add protocol: UDP
                4. For full DNS: expose both TCP and UDP ports</pre>
          solution: |-
            # Fix: Add protocol: UDP (and optionally TCP for zone transfers)
            apiVersion: v1
            kind: Service
            metadata:
              name: custom-dns
            spec:
              selector:
                app: custom-dns
              ports:
              - name: dns-udp
                port: 53
                targetPort: 53
                protocol: UDP
              - name: dns-tcp
                port: 53
                targetPort: 53
                protocol: TCP
          difficulty: 3
        - id: v8
          title: Cross-Namespace Service Access
          description: >-
            Team A's frontend (in namespace <code>frontend</code>) cannot reach Team B's API Service
            (named <code>api</code> in namespace <code>backend</code>) using <code>http://api:80</code>.
            The Service and Pods are healthy. What is the problem and how do you fix the connection URL?
          functionSignature: "kubectl exec -n frontend deploy/web -- curl http://api:80"
          testCases:
            - input: "curl http://api:80 from namespace 'frontend' fails"
              output: "Must use FQDN: http://api.backend.svc.cluster.local:80"
          hints:
            - title: "Think about it"
              content: "Short DNS names like <code>api</code> only resolve within the same namespace. How do you reach a Service in a different namespace?"
            - title: "Hint"
              content: "Use the fully-qualified DNS name: <code>api.backend.svc.cluster.local</code> or the shorter form <code>api.backend</code>. The format is <code>&lt;service&gt;.&lt;namespace&gt;.svc.cluster.local</code>."
            - title: "Pattern"
              content: |-
                <pre>DNS resolution:
                  Same namespace: http://api:80
                  Cross namespace: http://api.backend:80
                  Full FQDN: http://api.backend.svc.cluster.local:80

                Fix the application config to use the cross-namespace name.</pre>
          solution: |-
            # Fix: Use the cross-namespace DNS name
            kubectl exec -n frontend deploy/web -- curl http://api.backend.svc.cluster.local:80

            # Or the shorter cross-namespace form:
            kubectl exec -n frontend deploy/web -- curl http://api.backend:80
          difficulty: 3
