categories:
  - id: arrays-searching
    name: Arrays & Searching
    icon: "#"
    order: 1
    description: "Hash maps, linear search, and binary search"
    problems:
      - id: two-sum
        name: Two Sum
        concept: "Hash Map Complement"
        difficulty: 1
        docLinks:
          - url: https://en.wikipedia.org/wiki/Hash_table
            title: "Hash Table"
            note: "How hash-based lookups achieve O(1) average time"
        patternPrimer:
          bruteForce: "Nested loops checking all pairs - O(n^2)"
          bestApproach: "Single pass with hash map storing complement - O(n)"
          typical: "Build map of value->index, check if complement exists"
        variants:
          - id: v1
            title: Two Sum
            difficulty: 1
            description: "Given an array of integers and a target, return the indices of the two numbers that add up to target. Each input has exactly one solution and you may not use the same element twice."
            hints:
              - "For each number, its complement is target - num."
              - "Use a dictionary/map to store each number's index as you go."
              - "One pass: for each num, check if target-num is in the map. If yes, return both indices."
            solution: |
              def two_sum(nums, target):
                  seen = {}
                  for i, num in enumerate(nums):
                      complement = target - num
                      if complement in seen:
                          return [seen[complement], i]
                      seen[num] = i
                  return []
            testCases: |
              print(two_sum([2, 7, 11, 15], 9))  # [0, 1]
              print(two_sum([3, 2, 4], 6))        # [1, 2]
              print(two_sum([3, 3], 6))            # [0, 1]
          - id: v2
            title: Contains Duplicate
            difficulty: 1
            description: "Given an integer array, return true if any value appears at least twice, and false if every element is distinct."
            hints:
              - "A set stores unique values. What happens when you try to add a duplicate?"
              - "Iterate through the array, adding each element to a set. If it's already there, return true."
            solution: |
              def contains_duplicate(nums):
                  seen = set()
                  for num in nums:
                      if num in seen:
                          return True
                      seen.add(num)
                  return False
            testCases: |
              print(contains_duplicate([1, 2, 3, 1]))     # True
              print(contains_duplicate([1, 2, 3, 4]))     # False
              print(contains_duplicate([1, 1, 1, 3, 3]))  # True

      - id: binary-search
        name: Binary Search
        concept: "Divide and Conquer Lookup"
        difficulty: 1
        docLinks:
          - url: https://en.wikipedia.org/wiki/Binary_search_algorithm
            title: "Binary Search"
            note: "How halving the search space gives O(log n)"
        patternPrimer:
          bruteForce: "Linear scan through the entire array - O(n)"
          bestApproach: "Binary search on sorted array - O(log n)"
          typical: "Maintain lo/hi pointers, check midpoint, halve search space"
        variants:
          - id: v1
            title: Binary Search
            difficulty: 1
            description: "Given a sorted array of integers and a target value, return the index of the target if it exists, otherwise return -1."
            hints:
              - "The array is sorted. You can eliminate half the remaining elements with each comparison."
              - "Use two pointers (lo and hi). Compute mid = (lo + hi) // 2 and compare."
              - "If nums[mid] == target, return mid. If less, move lo up. If greater, move hi down."
            solution: |
              def binary_search(nums, target):
                  lo, hi = 0, len(nums) - 1
                  while lo <= hi:
                      mid = (lo + hi) // 2
                      if nums[mid] == target:
                          return mid
                      elif nums[mid] < target:
                          lo = mid + 1
                      else:
                          hi = mid - 1
                  return -1
            testCases: |
              print(binary_search([1, 3, 5, 7, 9], 5))   # 2
              print(binary_search([1, 3, 5, 7, 9], 4))   # -1
              print(binary_search([2, 4, 6, 8, 10], 10))  # 4
          - id: v2
            title: First Bad Version
            difficulty: 1
            description: "You have n versions [1, 2, ..., n] and a function is_bad(version) that returns whether a version is bad. All bad versions come after good ones. Find the first bad version using the minimum number of calls to is_bad."
            hints:
              - "This is binary search — you're looking for the boundary between good and bad."
              - "If mid is bad, the first bad is at mid or earlier (hi = mid). If mid is good, first bad is after mid (lo = mid + 1)."
            solution: |
              def first_bad_version(n, is_bad):
                  lo, hi = 1, n
                  while lo < hi:
                      mid = (lo + hi) // 2
                      if is_bad(mid):
                          hi = mid
                      else:
                          lo = mid + 1
                  return lo
            testCases: |
              is_bad = lambda v: v >= 4
              print(first_bad_version(5, is_bad))  # 4
              is_bad = lambda v: v >= 1
              print(first_bad_version(1, is_bad))  # 1

  - id: stacks-strings
    name: Stacks & Strings
    icon: "[]"
    order: 2
    description: "Stack-based problems and string manipulation"
    problems:
      - id: valid-parentheses
        name: Valid Parentheses
        concept: "Stack Matching"
        difficulty: 1
        docLinks:
          - url: https://en.wikipedia.org/wiki/Stack_(abstract_data_type)
            title: "Stack Data Structure"
            note: "LIFO structure for matching nested elements"
        patternPrimer:
          bruteForce: "Repeatedly remove innermost pairs until empty - O(n^2)"
          bestApproach: "Single pass with a stack - O(n)"
          typical: "Push openers, pop and match on closers"
        variants:
          - id: v1
            title: Valid Parentheses
            difficulty: 1
            description: "Given a string containing just the characters '(', ')', '{', '}', '[' and ']', determine if the input string is valid. An input is valid if open brackets are closed by the same type in the correct order."
            hints:
              - "Use a stack. Push opening brackets, and when you see a closing bracket, check if it matches the top of the stack."
              - "If the stack is empty when you see a closer, or the types don't match, return false."
              - "At the end, the stack should be empty for a valid string."
            solution: |
              def is_valid(s):
                  stack = []
                  pairs = {')': '(', '}': '{', ']': '['}
                  for ch in s:
                      if ch in pairs:
                          if not stack or stack[-1] != pairs[ch]:
                              return False
                          stack.pop()
                      else:
                          stack.append(ch)
                  return len(stack) == 0
            testCases: |
              print(is_valid("()"))        # True
              print(is_valid("()[]{}"))    # True
              print(is_valid("(]"))        # False
              print(is_valid("([)]"))      # False
              print(is_valid("{[]}"))      # True
          - id: v2
            title: Reverse String
            difficulty: 1
            description: "Write a function that reverses a string. The input is given as a list of characters. Modify the list in-place with O(1) extra memory."
            hints:
              - "Use two pointers — one at the start, one at the end."
              - "Swap the characters at both pointers and move them toward the center."
            solution: |
              def reverse_string(s):
                  lo, hi = 0, len(s) - 1
                  while lo < hi:
                      s[lo], s[hi] = s[hi], s[lo]
                      lo += 1
                      hi -= 1
            testCases: |
              s = list("hello")
              reverse_string(s)
              print("".join(s))  # "olleh"
              s = list("ab")
              reverse_string(s)
              print("".join(s))  # "ba"
