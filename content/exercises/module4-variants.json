{
  "conceptLinks": {
    "Interface Basics": "#lesson-interfaces",
    "fmt.Stringer": "#lesson-stringer",
    "io.Writer": "#lesson-writer",
    "io.Reader": "#lesson-reader",
    "Type Assertions": "#lesson-type-assertions",
    "Type Switches": "#lesson-type-switch",
    "Implicit Satisfaction": "#lesson-implicit",
    "Empty Interface": "#lesson-empty-interface"
  },
  "sharedContent": {},
  "variants": {
    "warmups": [
      {
        "id": "warmup_1",
        "concept": "fmt.Stringer",
        "variants": [
          {
            "id": "v1",
            "title": "Person Stringer",
            "description": "Create a <code>Person</code> struct with <code>Name string</code> and <code>Age int</code>. Implement <code>fmt.Stringer</code> so that printing a Person outputs a nice format.",
            "hints": [
              "Implement <code>String() string</code> method",
              "Use <code>fmt.Sprintf</code> to format the output",
              "The Stringer interface has just one method: <code>String() string</code>"
            ],
            "solution": "type Person struct {\n    Name string\n    Age  int\n}\n\nfunc (p Person) String() string {\n    return fmt.Sprintf(\"%s (%d years old)\", p.Name, p.Age)\n}",
            "annotations": [
              { "type": "idiom", "label": "Implicit Interfaces", "text": "Go interfaces are satisfied implicitly. Simply defining <code>String() string</code> makes <code>Person</code> satisfy <code>fmt.Stringer</code> -- no <code>implements</code> keyword needed." },
              { "type": "stdlib", "label": "fmt.Stringer", "text": "The <code>fmt</code> package checks for the <code>Stringer</code> interface when printing values. Implementing it controls how your type appears in <code>fmt.Println</code> and <code>%v</code>." }
            ]
          },
          {
            "id": "v2",
            "title": "Color Stringer",
            "description": "Create a <code>Color</code> struct with <code>R, G, B uint8</code> fields. Implement <code>String() string</code> to return the hex format like <code>#FF8800</code>.",
            "hints": [
              "Use <code>fmt.Sprintf(\"#%02X%02X%02X\", c.R, c.G, c.B)</code>",
              "<code>%02X</code> formats as uppercase hex with zero-padding"
            ],
            "solution": "type Color struct {\n    R, G, B uint8\n}\n\nfunc (c Color) String() string {\n    return fmt.Sprintf(\"#%02X%02X%02X\", c.R, c.G, c.B)\n}",
            "annotations": [
              { "type": "idiom", "label": "Format Verbs", "text": "<code>%02X</code> means: uppercase hex, at least 2 digits, zero-padded. This is the standard way to format colors in Go." }
            ]
          },
          {
            "id": "v3",
            "title": "Coordinate Stringer",
            "description": "Create a <code>Coordinate</code> struct with <code>Lat, Lon float64</code>. Implement <code>String() string</code> to return a format like <code>(40.7128, -74.0060)</code>.",
            "hints": [
              "Use <code>fmt.Sprintf(\"(%.4f, %.4f)\", c.Lat, c.Lon)</code>",
              "<code>%.4f</code> formats a float with 4 decimal places"
            ],
            "solution": "type Coordinate struct {\n    Lat, Lon float64\n}\n\nfunc (c Coordinate) String() string {\n    return fmt.Sprintf(\"(%.4f, %.4f)\", c.Lat, c.Lon)\n}",
            "annotations": [
              { "type": "idiom", "label": "Float Precision", "text": "Use <code>%.Nf</code> to control decimal places in output. This is important for coordinates, currency, and scientific values." }
            ]
          },
          {
            "id": "v4",
            "title": "Duration Stringer",
            "description": "Create a <code>Duration</code> struct with <code>Hours, Minutes, Seconds int</code>. Implement <code>String() string</code> to return a format like <code>02:30:05</code>.",
            "hints": [
              "Use <code>fmt.Sprintf(\"%02d:%02d:%02d\", d.Hours, d.Minutes, d.Seconds)</code>",
              "<code>%02d</code> zero-pads to 2 digits"
            ],
            "solution": "type Duration struct {\n    Hours, Minutes, Seconds int\n}\n\nfunc (d Duration) String() string {\n    return fmt.Sprintf(\"%02d:%02d:%02d\", d.Hours, d.Minutes, d.Seconds)\n}",
            "annotations": [
              { "type": "stdlib", "label": "time.Duration", "text": "Go's standard library has <code>time.Duration</code> for real use. This exercise teaches the Stringer pattern with a familiar concept." },
              { "type": "gotcha", "label": "Value vs Pointer Receiver", "text": "Using a value receiver for <code>String()</code> ensures it works on both values and pointers. A pointer receiver would not be called on values." }
            ]
          }
        ]
      },
      {
        "id": "warmup_2",
        "concept": "Interface Basics",
        "variants": [
          {
            "id": "v1",
            "title": "Shape Interface",
            "description": "Define a <code>Shape</code> interface with <code>Area() float64</code>. Implement it for <code>Circle</code> and <code>Rectangle</code>. Write <code>func TotalArea(shapes []Shape) float64</code>.",
            "hints": [
              "Circle area = math.Pi * r * r",
              "Rectangle area = width * height",
              "Loop through shapes and sum their areas"
            ],
            "solution": "type Shape interface {\n    Area() float64\n}\n\ntype Circle struct{ Radius float64 }\nfunc (c Circle) Area() float64 { return math.Pi * c.Radius * c.Radius }\n\ntype Rectangle struct{ Width, Height float64 }\nfunc (r Rectangle) Area() float64 { return r.Width * r.Height }\n\nfunc TotalArea(shapes []Shape) float64 {\n    var total float64\n    for _, s := range shapes {\n        total += s.Area()\n    }\n    return total\n}",
            "annotations": [
              { "type": "idiom", "label": "Small Interfaces", "text": "Go favors small interfaces with 1-2 methods. The <code>Shape</code> interface with a single <code>Area()</code> method is a good example." },
              { "type": "pattern", "label": "Interface Slice", "text": "Using <code>[]Shape</code> lets you store any type that satisfies <code>Shape</code>. This is Go's polymorphism: different types, same behavior." }
            ]
          },
          {
            "id": "v2",
            "title": "Measurable Interface",
            "description": "Define a <code>Measurable</code> interface with <code>Length() int</code>. Implement it for <code>Word</code> (a string wrapper) and <code>Sentence</code> (word count). Write <code>func Longest(items []Measurable) Measurable</code>.",
            "hints": [
              "Word's Length returns <code>len(string)</code>",
              "Sentence's Length returns the number of words",
              "Loop through items tracking the one with max Length"
            ],
            "solution": "type Measurable interface {\n    Length() int\n}\n\ntype Word string\nfunc (w Word) Length() int { return len(string(w)) }\n\ntype Sentence struct{ Words []string }\nfunc (s Sentence) Length() int { return len(s.Words) }\n\nfunc Longest(items []Measurable) Measurable {\n    var longest Measurable\n    maxLen := -1\n    for _, item := range items {\n        if item.Length() > maxLen {\n            maxLen = item.Length()\n            longest = item\n        }\n    }\n    return longest\n}",
            "annotations": [
              { "type": "idiom", "label": "Named Type", "text": "<code>type Word string</code> creates a new named type based on string. It can have its own methods, unlike a plain string." },
              { "type": "gotcha", "label": "Nil Interface Return", "text": "If <code>items</code> is empty, <code>longest</code> will be nil. Callers should check the return value." }
            ]
          },
          {
            "id": "v3",
            "title": "Sortable Interface",
            "description": "Define a <code>Sortable</code> interface with <code>CompareTo(other Sortable) int</code>. Implement it for <code>Age int</code> that returns -1, 0, or 1. Write <code>func Max(items []Sortable) Sortable</code>.",
            "hints": [
              "CompareTo returns -1 if less, 0 if equal, 1 if greater",
              "Use a type assertion in CompareTo to get the underlying Age",
              "Track the maximum while iterating"
            ],
            "solution": "type Sortable interface {\n    CompareTo(other Sortable) int\n}\n\ntype Age int\n\nfunc (a Age) CompareTo(other Sortable) int {\n    b := other.(Age)\n    if a < b {\n        return -1\n    } else if a > b {\n        return 1\n    }\n    return 0\n}\n\nfunc Max(items []Sortable) Sortable {\n    if len(items) == 0 {\n        return nil\n    }\n    max := items[0]\n    for _, item := range items[1:] {\n        if item.CompareTo(max) > 0 {\n            max = item\n        }\n    }\n    return max\n}",
            "annotations": [
              { "type": "gotcha", "label": "Type Assertion Panic", "text": "The assertion <code>other.(Age)</code> will panic if other is not an <code>Age</code>. Use the comma-ok form <code>b, ok := other.(Age)</code> for safety." },
              { "type": "alternative", "label": "sort.Interface", "text": "Go's standard library uses <code>sort.Interface</code> with <code>Len</code>, <code>Less</code>, and <code>Swap</code> methods. This approach is more idiomatic than CompareTo." }
            ]
          },
          {
            "id": "v4",
            "title": "Greeter Interface",
            "description": "Define a <code>Greeter</code> interface with <code>Greet() string</code>. Implement it for <code>EnglishGreeter</code>, <code>SpanishGreeter</code>, and <code>FormalGreeter</code> (which wraps a name). Write <code>func GreetAll(greeters []Greeter) []string</code>.",
            "hints": [
              "Each greeter returns a different greeting string",
              "FormalGreeter uses its Name field in the greeting",
              "GreetAll collects all greetings into a slice"
            ],
            "solution": "type Greeter interface {\n    Greet() string\n}\n\ntype EnglishGreeter struct{}\nfunc (e EnglishGreeter) Greet() string { return \"Hello!\" }\n\ntype SpanishGreeter struct{}\nfunc (s SpanishGreeter) Greet() string { return \"Hola!\" }\n\ntype FormalGreeter struct{ Name string }\nfunc (f FormalGreeter) Greet() string {\n    return fmt.Sprintf(\"Good day, %s.\", f.Name)\n}\n\nfunc GreetAll(greeters []Greeter) []string {\n    var greetings []string\n    for _, g := range greeters {\n        greetings = append(greetings, g.Greet())\n    }\n    return greetings\n}",
            "annotations": [
              { "type": "idiom", "label": "Accept Interfaces", "text": "Go proverb: 'Accept interfaces, return structs.' <code>GreetAll</code> accepts <code>[]Greeter</code> (interface), making it work with any Greeter implementation." },
              { "type": "pattern", "label": "Stateless vs Stateful", "text": "EnglishGreeter is stateless (empty struct), while FormalGreeter is stateful (carries a Name). Both satisfy the same interface." }
            ]
          }
        ]
      }
    ],
    "challenges": [
      {
        "id": "challenge_1",
        "block": 1,
        "difficulty": 2,
        "concept": "io.Writer",
        "variants": [
          {
            "id": "v1",
            "title": "UpperWriter",
            "description": "Create an <code>UpperWriter</code> struct that wraps an <code>io.Writer</code> and converts all bytes to uppercase before writing to the inner writer.",
            "functionSignature": "func (u *UpperWriter) Write(p []byte) (int, error)",
            "testCases": [
              { "input": "var buf bytes.Buffer; uw := &UpperWriter{&buf}; uw.Write([]byte(\"hello\"))", "output": "buf.String() == \"HELLO\"" },
              { "input": "var buf bytes.Buffer; uw := &UpperWriter{&buf}; fmt.Fprintln(uw, \"go is fun\")", "output": "buf.String() == \"GO IS FUN\\n\"" }
            ],
            "hints": [
              { "title": "\ud83e\udd14 Think about it", "content": "The <code>io.Writer</code> interface has one method: <code>Write(p []byte) (n int, err error)</code>. You need to transform the bytes before passing them along." },
              { "title": "\ud83d\udca1 Hint", "content": "Use <code>bytes.ToUpper(p)</code> to convert the byte slice, then write the result to the inner writer." },
              { "title": "\ud83d\udd27 Pattern", "content": "<pre>type UpperWriter struct { w io.Writer }\nfunc (u *UpperWriter) Write(p []byte) (int, error) {\n    return u.w.Write(bytes.ToUpper(p))\n}</pre>" }
            ],
            "solution": "type UpperWriter struct {\n    w io.Writer\n}\n\nfunc (u *UpperWriter) Write(p []byte) (int, error) {\n    return u.w.Write(bytes.ToUpper(p))\n}",
            "difficulty": 2,
            "annotations": [
              { "type": "idiom", "label": "Writer Wrapper", "text": "Wrapping an <code>io.Writer</code> to transform output is a classic Go pattern. It's used in compression, encryption, and logging." },
              { "type": "pattern", "label": "Decorator Pattern", "text": "This is the decorator pattern: <code>UpperWriter</code> adds behavior (uppercasing) to any existing Writer without modifying it." }
            ]
          },
          {
            "id": "v2",
            "title": "PrefixWriter",
            "description": "Create a <code>PrefixWriter</code> that prepends a prefix string to every <code>Write</code> call before passing data to the inner <code>io.Writer</code>.",
            "functionSignature": "func (pw *PrefixWriter) Write(p []byte) (int, error)",
            "testCases": [
              { "input": "var buf bytes.Buffer; pw := &PrefixWriter{\"[LOG] \", &buf}; pw.Write([]byte(\"hello\"))", "output": "buf.String() == \"[LOG] hello\"" },
              { "input": "var buf bytes.Buffer; pw := &PrefixWriter{\">> \", &buf}; pw.Write([]byte(\"test\"))", "output": "buf.String() == \">> test\"" }
            ],
            "hints": [
              { "title": "\ud83e\udd14 Think about it", "content": "You need to write the prefix bytes first, then the original data." },
              { "title": "\ud83d\udca1 Hint", "content": "Concatenate prefix + data into a single byte slice, or write the prefix first then the data." },
              { "title": "\ud83d\udd27 Pattern", "content": "<pre>type PrefixWriter struct {\n    Prefix string\n    w      io.Writer\n}\nfunc (pw *PrefixWriter) Write(p []byte) (int, error) {\n    data := append([]byte(pw.Prefix), p...)\n    return pw.w.Write(data)\n}</pre>" }
            ],
            "solution": "type PrefixWriter struct {\n    Prefix string\n    w      io.Writer\n}\n\nfunc (pw *PrefixWriter) Write(p []byte) (int, error) {\n    data := append([]byte(pw.Prefix), p...)\n    return pw.w.Write(data)\n}",
            "difficulty": 2,
            "annotations": [
              { "type": "gotcha", "label": "Byte Count Mismatch", "text": "The returned byte count includes the prefix bytes, which is more than what the caller wrote. Some callers may check this. A production version should handle this carefully." },
              { "type": "idiom", "label": "Composable Writers", "text": "Writer wrappers can be stacked: <code>PrefixWriter</code> wrapping an <code>UpperWriter</code> wrapping <code>os.Stdout</code>." }
            ]
          },
          {
            "id": "v3",
            "title": "CountWriter",
            "description": "Create a <code>CountWriter</code> that wraps an <code>io.Writer</code> and tracks the total number of bytes written. Add a <code>BytesWritten() int</code> method.",
            "functionSignature": "func (cw *CountWriter) Write(p []byte) (int, error)\nfunc (cw *CountWriter) BytesWritten() int",
            "testCases": [
              { "input": "var buf bytes.Buffer; cw := &CountWriter{w: &buf}; cw.Write([]byte(\"hello\")); cw.BytesWritten()", "output": "5" },
              { "input": "cw.Write([]byte(\" world\")); cw.BytesWritten()", "output": "11" }
            ],
            "hints": [
              { "title": "\ud83e\udd14 Think about it", "content": "You need to track cumulative bytes. Where does the actual byte count come from?" },
              { "title": "\ud83d\udca1 Hint", "content": "The inner writer's Write returns the number of bytes written. Add that to your running total." },
              { "title": "\ud83d\udd27 Pattern", "content": "<pre>type CountWriter struct {\n    w     io.Writer\n    count int\n}\nfunc (cw *CountWriter) Write(p []byte) (int, error) {\n    n, err := cw.w.Write(p)\n    cw.count += n\n    return n, err\n}</pre>" }
            ],
            "solution": "type CountWriter struct {\n    w     io.Writer\n    count int\n}\n\nfunc (cw *CountWriter) Write(p []byte) (int, error) {\n    n, err := cw.w.Write(p)\n    cw.count += n\n    return n, err\n}\n\nfunc (cw *CountWriter) BytesWritten() int {\n    return cw.count\n}",
            "difficulty": 2,
            "annotations": [
              { "type": "idiom", "label": "Passthrough with Side Effect", "text": "CountWriter delegates to the inner writer but adds counting as a side effect. The caller's data flows through unchanged." },
              { "type": "complexity", "label": "O(1) per Write", "text": "Counting adds constant overhead per Write call. No additional memory beyond the counter." }
            ]
          },
          {
            "id": "v4",
            "title": "TeeWriter",
            "description": "Create a <code>TeeWriter</code> that writes to two <code>io.Writer</code>s simultaneously. If either write fails, return the error.",
            "functionSignature": "func (tw *TeeWriter) Write(p []byte) (int, error)",
            "testCases": [
              { "input": "var b1, b2 bytes.Buffer; tw := &TeeWriter{&b1, &b2}; tw.Write([]byte(\"hello\"))", "output": "b1.String() == \"hello\" && b2.String() == \"hello\"" },
              { "input": "n, err from above", "output": "n == 5, err == nil" }
            ],
            "hints": [
              { "title": "\ud83e\udd14 Think about it", "content": "You need to write to both writers. What if the first succeeds but the second fails?" },
              { "title": "\ud83d\udca1 Hint", "content": "Write to the first writer, check for errors. Then write to the second. Return the first error encountered." },
              { "title": "\ud83d\udd27 Pattern", "content": "<pre>type TeeWriter struct { w1, w2 io.Writer }\nfunc (tw *TeeWriter) Write(p []byte) (int, error) {\n    n, err := tw.w1.Write(p)\n    if err != nil { return n, err }\n    return tw.w2.Write(p)\n}</pre>" }
            ],
            "solution": "type TeeWriter struct {\n    w1, w2 io.Writer\n}\n\nfunc (tw *TeeWriter) Write(p []byte) (int, error) {\n    n, err := tw.w1.Write(p)\n    if err != nil {\n        return n, err\n    }\n    return tw.w2.Write(p)\n}",
            "difficulty": 3,
            "annotations": [
              { "type": "stdlib", "label": "io.MultiWriter", "text": "Go's standard library provides <code>io.MultiWriter(writers ...io.Writer)</code> which does this for any number of writers." },
              { "type": "gotcha", "label": "Partial Writes", "text": "If w1 succeeds but w2 fails, data is partially written. Production code should consider whether this inconsistency is acceptable." },
              { "type": "pattern", "label": "Fan-out Pattern", "text": "Writing to multiple destinations is the fan-out pattern. Useful for logging to both file and stdout simultaneously." }
            ]
          }
        ]
      },
      {
        "id": "challenge_2",
        "block": 1,
        "difficulty": 2,
        "concept": "Type Switches",
        "variants": [
          {
            "id": "v1",
            "title": "Describe Any Value",
            "description": "Write <code>func describe(i any) string</code> that returns type-specific descriptions for <code>int</code>, <code>string</code>, <code>bool</code>, <code>float64</code>, and <code>\"unknown\"</code> for other types.",
            "functionSignature": "func describe(i any) string",
            "testCases": [
              { "input": "describe(42)", "output": "\"integer: 42\"" },
              { "input": "describe(\"hello\")", "output": "\"text: hello\"" },
              { "input": "describe(true)", "output": "\"boolean: true\"" },
              { "input": "describe(3.14)", "output": "\"float: 3.14\"" },
              { "input": "describe([]int{1})", "output": "\"unknown\"" }
            ],
            "hints": [
              { "title": "\ud83e\udd14 Think about it", "content": "Go's type switch lets you branch based on the dynamic type of an interface value." },
              { "title": "\ud83d\udca1 Hint", "content": "Use <code>switch v := i.(type)</code>. The variable <code>v</code> has the concrete type in each case branch." },
              { "title": "\ud83d\udd27 Pattern", "content": "<pre>switch v := i.(type) {\ncase int:\n    return fmt.Sprintf(\"integer: %d\", v)\ncase string:\n    return fmt.Sprintf(\"text: %s\", v)\n// ... more cases\ndefault:\n    return \"unknown\"\n}</pre>" }
            ],
            "solution": "func describe(i any) string {\n    switch v := i.(type) {\n    case int:\n        return fmt.Sprintf(\"integer: %d\", v)\n    case string:\n        return fmt.Sprintf(\"text: %s\", v)\n    case bool:\n        return fmt.Sprintf(\"boolean: %t\", v)\n    case float64:\n        return fmt.Sprintf(\"float: %g\", v)\n    default:\n        return \"unknown\"\n    }\n}",
            "difficulty": 1,
            "annotations": [
              { "type": "idiom", "label": "Type Switch", "text": "Type switches are Go's primary mechanism for handling values of unknown type. The <code>v</code> variable is automatically narrowed to the matched type." },
              { "type": "gotcha", "label": "any vs interface{}", "text": "<code>any</code> is an alias for <code>interface{}</code> introduced in Go 1.18. They are interchangeable, but <code>any</code> is preferred in modern Go." }
            ]
          },
          {
            "id": "v2",
            "title": "Stringify Anything",
            "description": "Write <code>func stringify(i any) string</code> that converts values to strings: numbers to their string form, bools to \"yes\"/\"no\", strings returned as-is, <code>fmt.Stringer</code> types call <code>String()</code>, and anything else returns \"?\".",
            "functionSignature": "func stringify(i any) string",
            "testCases": [
              { "input": "stringify(42)", "output": "\"42\"" },
              { "input": "stringify(true)", "output": "\"yes\"" },
              { "input": "stringify(false)", "output": "\"no\"" },
              { "input": "stringify(\"hi\")", "output": "\"hi\"" }
            ],
            "hints": [
              { "title": "\ud83e\udd14 Think about it", "content": "Order matters in a type switch. Check concrete types before interfaces." },
              { "title": "\ud83d\udca1 Hint", "content": "Check <code>string</code> before <code>fmt.Stringer</code>, since strings also satisfy Stringer. Use <code>strconv.Itoa</code> for int-to-string." },
              { "title": "\ud83d\udd27 Pattern", "content": "<pre>switch v := i.(type) {\ncase string:\n    return v\ncase int:\n    return strconv.Itoa(v)\ncase bool:\n    if v { return \"yes\" }\n    return \"no\"\ncase fmt.Stringer:\n    return v.String()\ndefault:\n    return \"?\"\n}</pre>" }
            ],
            "solution": "func stringify(i any) string {\n    switch v := i.(type) {\n    case string:\n        return v\n    case int:\n        return strconv.Itoa(v)\n    case bool:\n        if v {\n            return \"yes\"\n        }\n        return \"no\"\n    case fmt.Stringer:\n        return v.String()\n    default:\n        return \"?\"\n    }\n}",
            "difficulty": 2,
            "annotations": [
              { "type": "gotcha", "label": "Case Order Matters", "text": "In a type switch, the first matching case wins. Put concrete types before interfaces, or a <code>fmt.Stringer</code> case could match before <code>string</code>." },
              { "type": "idiom", "label": "Interface Case", "text": "Type switches can match interfaces, not just concrete types. <code>case fmt.Stringer</code> matches any type with a <code>String()</code> method." }
            ]
          },
          {
            "id": "v3",
            "title": "Sum Mixed Slice",
            "description": "Write <code>func sumAny(items []any) float64</code> that sums numeric values in the slice, skipping non-numeric types. Handle <code>int</code>, <code>float64</code>, and <code>string</code> (parse with <code>strconv.ParseFloat</code>, skip on error).",
            "functionSignature": "func sumAny(items []any) float64",
            "testCases": [
              { "input": "sumAny([]any{1, 2.5, \"3.5\"})", "output": "7.0" },
              { "input": "sumAny([]any{10, \"abc\", true})", "output": "10.0" },
              { "input": "sumAny([]any{})", "output": "0.0" }
            ],
            "hints": [
              { "title": "\ud83e\udd14 Think about it", "content": "Loop through items, type-switch each one, and add numeric values to a running sum." },
              { "title": "\ud83d\udca1 Hint", "content": "For <code>int</code>, convert to <code>float64</code>. For <code>string</code>, try <code>strconv.ParseFloat(v, 64)</code> and skip on error." },
              { "title": "\ud83d\udd27 Pattern", "content": "<pre>var sum float64\nfor _, item := range items {\n    switch v := item.(type) {\n    case int:\n        sum += float64(v)\n    case float64:\n        sum += v\n    case string:\n        if f, err := strconv.ParseFloat(v, 64); err == nil {\n            sum += f\n        }\n    }\n}\nreturn sum</pre>" }
            ],
            "solution": "func sumAny(items []any) float64 {\n    var sum float64\n    for _, item := range items {\n        switch v := item.(type) {\n        case int:\n            sum += float64(v)\n        case float64:\n            sum += v\n        case string:\n            if f, err := strconv.ParseFloat(v, 64); err == nil {\n                sum += f\n            }\n        }\n    }\n    return sum\n}",
            "difficulty": 2,
            "annotations": [
              { "type": "gotcha", "label": "int vs float64", "text": "JSON numbers unmarshaled into <code>any</code> become <code>float64</code>, not <code>int</code>. Always handle both numeric types when working with <code>any</code>." },
              { "type": "idiom", "label": "Silent Skip", "text": "Not handling a type in a type switch silently skips it (no default needed). This is intentional for filtering by type." }
            ]
          },
          {
            "id": "v4",
            "title": "Format for Logging",
            "description": "Write <code>func formatLog(level string, value any) string</code> that formats log entries differently based on the value type: <code>error</code> types include <code>[ERROR]</code> prefix, <code>fmt.Stringer</code> types use <code>String()</code>, and others use <code>fmt.Sprintf(\"%v\")</code>.",
            "functionSignature": "func formatLog(level string, value any) string",
            "testCases": [
              { "input": "formatLog(\"INFO\", \"server started\")", "output": "\"[INFO] server started\"" },
              { "input": "formatLog(\"WARN\", fmt.Errorf(\"disk full\"))", "output": "\"[WARN][ERROR] disk full\"" },
              { "input": "formatLog(\"DEBUG\", 42)", "output": "\"[DEBUG] 42\"" }
            ],
            "hints": [
              { "title": "\ud83e\udd14 Think about it", "content": "The <code>error</code> interface has an <code>Error() string</code> method. Check for <code>error</code> before <code>fmt.Stringer</code> since errors also satisfy Stringer." },
              { "title": "\ud83d\udca1 Hint", "content": "Use <code>case error</code> to match error types. Then <code>case fmt.Stringer</code> for other Stringer types. Default uses <code>%v</code>." },
              { "title": "\ud83d\udd27 Pattern", "content": "<pre>func formatLog(level string, value any) string {\n    prefix := fmt.Sprintf(\"[%s]\", level)\n    switch v := value.(type) {\n    case error:\n        return fmt.Sprintf(\"%s[ERROR] %s\", prefix, v.Error())\n    case fmt.Stringer:\n        return fmt.Sprintf(\"%s %s\", prefix, v.String())\n    default:\n        return fmt.Sprintf(\"%s %v\", prefix, v)\n    }\n}</pre>" }
            ],
            "solution": "func formatLog(level string, value any) string {\n    prefix := fmt.Sprintf(\"[%s]\", level)\n    switch v := value.(type) {\n    case error:\n        return fmt.Sprintf(\"%s[ERROR] %s\", prefix, v.Error())\n    case fmt.Stringer:\n        return fmt.Sprintf(\"%s %s\", prefix, v.String())\n    default:\n        return fmt.Sprintf(\"%s %v\", prefix, v)\n    }\n}",
            "difficulty": 3,
            "annotations": [
              { "type": "gotcha", "label": "error vs Stringer Order", "text": "The <code>error</code> interface defines <code>Error() string</code>, and many errors also implement <code>Stringer</code>. Check <code>error</code> first to avoid treating errors as generic Stringers." },
              { "type": "pattern", "label": "Structured Logging", "text": "This pattern is foundational for logging libraries. Real loggers like <code>slog</code> use similar type-based formatting internally." },
              { "type": "stdlib", "label": "log/slog", "text": "Go 1.21 introduced <code>log/slog</code> for structured logging. For production code, prefer <code>slog</code> over manual formatting." }
            ]
          }
        ]
      }
    ]
  }
}