{
  "conceptLinks": {
    "For Loops": "#lesson-loops",
    "If/Else": "#lesson-if",
    "Slices & Range": "#lesson-slices",
    "Maps": "#lesson-maps",
    "make() Function": "#lesson-slices",
    "Comma-Ok Pattern": "#lesson-comma-ok",
    "Range with Index": "#lesson-loops",
    "Building Slices": "#lesson-slices"
  },
  "sharedContent": {
    "advanced_1": {
      "preReading": {
        "title": "\ud83d\udcd6 Pre-reading: The \"Have I Seen This?\" Pattern",
        "content": "<strong>The Problem:</strong> How do you know if you've seen something before?<br><br>\n                <strong>Naive approach (slow):</strong><br>\n                For each element, check every other element to see if it matches \u2192 O(n\u00b2)<br>\n                For 1000 elements, that's 1,000,000 comparisons! \ud83d\udc0c<br><br>\n                <strong>Smart approach (fast):</strong><br>\n                Use a map to remember what you've seen \u2192 O(n)<br>\n                For 1000 elements, that's just 1000 operations! \ud83d\ude80<br><br>\n                <strong>The Pattern:</strong><br>\n                1. Create an empty map to track what you've seen<br>\n                2. For each element, check: \"Have I seen this before?\"<br>\n                3. If yes \u2192 found a duplicate!<br>\n                4. If no \u2192 remember it and continue"
      },
      "hints": [
        {
          "title": "\ud83e\udd14 Think about it",
          "content": "As you go through the elements, how would you remember which ones you've already seen? What data structure gives you fast lookup to check \"have I seen this before?\""
        },
        {
          "title": "\ud83d\udca1 Hint",
          "content": "Use a map as your \"memory\" - the key is the element, and you just need to know it exists (what simple type represents yes/no?). For each element: first check if it's in your memory, then add it if not. If you make it through all elements without finding a duplicate, they must all be unique."
        },
        {
          "title": "\ud83d\udd27 Pattern",
          "content": "<pre>1. Create empty \"seen\" tracker\n2. For each element:\n   - Already in tracker? \u2192 found duplicate!\n   - Not seen? \u2192 add to tracker\n3. Finished loop? \u2192 all unique</pre>"
        }
      ],
      "docLinks": [
        {
          "url": "https://go.dev/blog/maps",
          "title": "Go Blog: Go maps in action",
          "note": "comprehensive guide to maps"
        },
        {
          "url": "https://go.dev/ref/spec#Map_types",
          "title": "Go Spec: Map types",
          "note": "official language specification"
        },
        {
          "url": "https://go.dev/ref/spec#Making_slices_maps_and_channels",
          "title": "Go Spec: make()",
          "note": "how make() initializes maps"
        }
      ]
    },
    "advanced_2": {
      "preReading": {
        "title": "\ud83d\udcd6 Pre-reading: The Slow/Fast Pointer Pattern",
        "content": "<strong>The Problem:</strong> Remove duplicates from a sorted collection in-place<br><br>\n                <strong>Key insight:</strong> The collection is <strong>sorted</strong>, so duplicates are next to each other!<br><br>\n                <strong>The Slow/Fast Pattern:</strong><br>\n                \u2022 <strong>Both pointers start at different positions</strong> (unlike i/j starting at opposite ends)<br>\n                \u2022 <strong>They move at different speeds</strong> (unlike i/j both moving every iteration)<br>\n                \u2022 One pointer <strong>reads</strong>, the other <strong>writes</strong><br><br>\n                <strong>Code structure pattern:</strong><br>\n<pre>slow := 0  // Initialize OUTSIDE loop (write position)\n\nfor fast := 1; fast < len(items); fast++ {  // Initialize IN loop (read position)\n    // Compare items[fast] with items[slow]\n    // If different: move slow, write value\n    // If same: do nothing\n    // fast moves automatically every iteration\n}</pre>"
      },
      "hints": [
        {
          "title": "\ud83e\udd14 Think about it",
          "content": "If the array is already sorted, where will duplicates be? If you're keeping track of the 'last unique' position, what do you do when you find a new unique value?"
        },
        {
          "title": "\ud83d\udca1 Hint",
          "content": "Use two pointers: 'slow' marks where to write the next unique value, 'fast' scans ahead. When fast finds something different from what slow points to, you've found a new unique value - increment slow and copy it there."
        },
        {
          "title": "\ud83d\udd27 Pattern",
          "content": "<pre>1. slow = first position (write pointer)\n2. fast scans from second position (read pointer)\n3. For each fast position:\n   - Different from slow? \u2192 advance slow, copy value\n   - Same? \u2192 skip (fast moves on)\n4. Return slow + 1 (new length)</pre>"
        }
      ],
      "docLinks": [
        {
          "url": "https://go.dev/ref/spec#For_statements",
          "title": "Go Spec: For statements",
          "note": "loop syntax and semantics"
        },
        {
          "url": "https://go.dev/ref/spec#Slice_types",
          "title": "Go Spec: Slice types",
          "note": "understanding slices"
        },
        {
          "url": "https://go.dev/blog/slices-intro",
          "title": "Go Blog: Arrays, slices, and strings",
          "note": "in-depth slice mechanics"
        }
      ]
    },
    "advanced_3": {
      "preReading": {
        "title": "\ud83d\udcd6 Pre-reading: Strings vs Runes in Go",
        "content": "<strong>The Problem:</strong> In Go, a <code>string</code> is a sequence of <strong>bytes</strong>, not characters!<br><br>\n                For ASCII (a-z, 0-9), one character = one byte. Easy!<br>\n                But for Unicode (emoji \ud83c\udf89, Chinese \u4e16\u754c, etc.), one character can be 2-4 bytes.<br><br>\n                <strong>Example:</strong><br>\n                <code>\"Hello\"</code> = 5 bytes = 5 characters \u2705<br>\n                <code>\"\u4e16\u754c\"</code> = 6 bytes but only 2 characters! \u26a0\ufe0f<br>\n                <code>\"\ud83c\udf89\"</code> = 4 bytes but only 1 character! \u26a0\ufe0f<br><br>\n                <strong>The Solution: Runes</strong><br>\n                A <code>rune</code> is Go's type for a Unicode character (actually an <code>int32</code>).<br>\n                Converting to <code>[]rune</code> splits the string into actual characters, not bytes."
      },
      "hints": [
        {
          "title": "\ud83e\udd14 Think about it",
          "content": "Why can't you just index a string directly with [i]? What's special about strings in Go when dealing with non-ASCII characters?"
        },
        {
          "title": "\ud83d\udca1 Hint",
          "content": "Convert to []rune to handle Unicode properly. Then use the two-pointer swap pattern you learned - swap from both ends working inward."
        },
        {
          "title": "\ud83d\udd27 Pattern",
          "content": "<pre>1. Convert string to character array (runes)\n2. Two pointers: left at start, right at end\n3. While left < right:\n   - Swap characters at left and right\n   - Move pointers inward\n4. Convert back to string</pre>"
        }
      ],
      "docLinks": [
        {
          "url": "https://go.dev/blog/strings",
          "title": "Go Blog: Strings, bytes, runes and characters",
          "note": "essential reading for Go strings"
        },
        {
          "url": "https://go.dev/ref/spec#Rune_literals",
          "title": "Go Spec: Rune literals",
          "note": "what runes are"
        },
        {
          "url": "https://pkg.go.dev/unicode",
          "title": "Package unicode",
          "note": "unicode classification functions"
        }
      ]
    },
    "advanced_4": {
      "hints": [
        {
          "title": "\ud83e\udd14 Think about it",
          "content": "What's the pattern for counting things? What data structure lets you track 'how many of each thing' efficiently?"
        },
        {
          "title": "\ud83d\udca1 Hint",
          "content": "First split the string into words (check the strings package for a function that splits on whitespace). Then use a map where keys are words and values are counts - what operation increases a map value?"
        },
        {
          "title": "\ud83d\udd27 Pattern",
          "content": "<pre>1. Split string into words\n2. Create empty count tracker (map)\n3. For each word:\n   - Increment its count\n4. Return the counts</pre>"
        }
      ],
      "docLinks": [
        {
          "url": "https://pkg.go.dev/strings",
          "title": "Package strings",
          "note": "Fields, Split, Join and more"
        },
        {
          "url": "https://go.dev/blog/maps",
          "title": "Go Blog: Go maps in action",
          "note": "map operations including increment"
        },
        {
          "url": "https://pkg.go.dev/fmt",
          "title": "Package fmt",
          "note": "printing maps and formatted output"
        }
      ]
    },
    "advanced_5": {
      "preReading": {
        "title": "\ud83d\udcd6 Pre-reading: The Hash Map Complement Pattern",
        "content": "<strong>The Naive Approach (slow):</strong><br>\n                Check every pair of numbers - requires nested loops O(n\u00b2)<br><br>\n                <strong>The Smart Approach (fast):</strong><br>\n                Use a map to remember what you've seen - only one loop O(n)<br><br>\n                <strong>The Key Insight:</strong><br>\n                If target = 9 and current number = 2, we need to find 7.<br>\n                Instead of searching the whole array for 7, just check: \"Have I seen 7 before?\"<br>\n                Maps make this lookup instant!"
      },
      "hints": [
        {
          "title": "\ud83e\udd14 Think about it",
          "content": "For each number, what other number would you need to find to reach the target? Instead of searching the whole array for it, how could you instantly check if you've seen it?"
        },
        {
          "title": "\ud83d\udca1 Hint",
          "content": "The complement is <code>target - current</code>. Use a map to remember numbers you've seen AND their indices (since you need to return indices). Check for the complement before adding the current number to your map."
        },
        {
          "title": "\ud83d\udd27 Pattern",
          "content": "<pre>1. Create tracker: number \u2192 its index\n2. For each number at position i:\n   - Calculate: complement = target - number\n   - Complement in tracker? \u2192 return [tracker[complement], i]\n   - Not found? \u2192 add number:i to tracker</pre>"
        }
      ],
      "docLinks": [
        {
          "url": "https://go.dev/blog/maps",
          "title": "Go Blog: Go maps in action",
          "note": "storing values (indices) in maps"
        },
        {
          "url": "https://go.dev/ref/spec#Index_expressions",
          "title": "Go Spec: Index expressions",
          "note": "the comma-ok idiom for map access"
        },
        {
          "url": "https://pkg.go.dev/sort",
          "title": "Package sort",
          "note": "for sorted-input variants"
        }
      ]
    },
    "advanced_6": {
      "preReading": {
        "title": "\ud83d\udcd6 Pre-reading: The Sliding Window Pattern",
        "content": "<strong>The Problem:</strong> Find something optimal in a contiguous subarray<br><br>\n                <strong>Naive approach (slow):</strong><br>\n                Check every possible subarray - O(n\u00b2) or worse \ud83d\udc0c<br><br>\n                <strong>Smart approach (fast):</strong><br>\n                Use a \"window\" that slides through the array - O(n) \ud83d\ude80<br><br>\n                <strong>Two Types of Sliding Windows:</strong><br>\n                <strong>1. Fixed-size window:</strong> Window size k stays constant<br>\n                \u2022 Add the new element entering on the right<br>\n                \u2022 Subtract the element leaving on the left<br><br>\n                <strong>2. Variable-size window:</strong> Window grows and shrinks<br>\n                \u2022 Expand (move right pointer) to include more elements<br>\n                \u2022 Shrink (move left pointer) when condition is violated or met"
      },
      "hints": [
        {
          "title": "\ud83e\udd14 Think about it",
          "content": "If you've already calculated the sum for elements 0-3, do you really need to recalculate everything for elements 1-4? What operation can give you the new sum efficiently?"
        },
        {
          "title": "\ud83d\udca1 Hint",
          "content": "For fixed windows: add the new element entering, subtract the element leaving. Think of it as the window 'sliding' right - one element comes in, one goes out. Track your max/min as you slide."
        },
        {
          "title": "\ud83d\udd27 Pattern",
          "content": "<pre>1. Calculate sum of first k elements\n2. Track this as current max\n3. Slide window: for each new position:\n   - Add new element (entering window)\n   - Subtract old element (leaving window)\n   - Update max if current sum is larger</pre>"
        }
      ],
      "docLinks": [
        {
          "url": "https://go.dev/ref/spec#For_statements",
          "title": "Go Spec: For statements",
          "note": "loop constructs"
        },
        {
          "url": "https://go.dev/blog/slices-intro",
          "title": "Go Blog: Slices introduction",
          "note": "slice indexing and sub-slicing"
        },
        {
          "url": "https://pkg.go.dev/builtin#len",
          "title": "Builtin len()",
          "note": "getting slice length"
        }
      ]
    },
    "advanced_7": {
      "preReading": {
        "title": "\ud83d\udcd6 Pre-reading: The \"Best So Far\" Pattern",
        "content": "<strong>The Problem:</strong> Find the optimal result that depends on pairs of elements where order matters<br><br>\n                <strong>Example:</strong> Best Time to Buy/Sell Stock - you must buy BEFORE you sell<br><br>\n                <strong>Naive approach (slow):</strong><br>\n                Check every pair (i, j) where i < j - O(n\u00b2) \ud83d\udc0c<br><br>\n                <strong>Smart approach (fast):</strong><br>\n                Track the \"best so far\" as you scan - O(n) \ud83d\ude80<br><br>\n                <strong>The Pattern:</strong><br>\n                \u2022 Track the minimum (or maximum) seen so far<br>\n                \u2022 At each position, calculate the best result using that tracked value<br>\n                \u2022 Update your overall best if this result is better<br><br>\n                <strong>Key insight:</strong> You don't need to remember ALL previous values - just the one that matters (min or max)!"
      },
      "hints": [
        {
          "title": "\ud83e\udd14 Think about it",
          "content": "To maximize profit, you want to buy low and sell high. As you scan through prices, what single value from the past do you need to remember to calculate the best possible profit at each day?"
        },
        {
          "title": "\ud83d\udca1 Hint",
          "content": "Track the minimum price seen so far. At each day, the best profit you could make is: today's price - minimum so far. Keep track of the maximum profit across all days."
        },
        {
          "title": "\ud83d\udd27 Pattern",
          "content": "<pre>1. Initialize: minSoFar = first element, bestResult = 0\n2. For each element:\n   - Calculate result using minSoFar\n   - Update bestResult if this is better\n   - Update minSoFar if current element is smaller\n3. Return bestResult</pre>"
        }
      ],
      "docLinks": [
        {
          "url": "https://go.dev/ref/spec#Comparison_operators",
          "title": "Go Spec: Comparison operators",
          "note": "< > comparisons"
        },
        {
          "url": "https://go.dev/ref/spec#Arithmetic_operators",
          "title": "Go Spec: Arithmetic operators",
          "note": "subtraction for differences"
        },
        {
          "url": "https://go.dev/ref/spec#If_statements",
          "title": "Go Spec: If statements",
          "note": "conditional updates"
        }
      ]
    }
  },
  "variants": {
    "warmups": [
      {
        "id": "warmup_1",
        "concept": "For Loops",
        "variants": [
          {
            "id": "v1",
            "title": "Print 1 to 10",
            "description": "Write a program that prints the numbers 1 to 10, one per line.",
            "hints": [
              "Use <code>for i := 1; i <= 10; i++</code>"
            ],
            "solution": "for i := 1; i <= 10; i++ {\n    fmt.Println(i)\n}"
          },
          {
            "id": "v2",
            "title": "Countdown from 5",
            "description": "Write a program that counts down from 5 to 1, then prints \"Go!\"",
            "hints": [
              "Use <code>for i := 5; i >= 1; i--</code>",
              "Print \"Go!\" after the loop"
            ],
            "solution": "for i := 5; i >= 1; i-- {\n    fmt.Println(i)\n}\nfmt.Println(\"Go!\")"
          },
          {
            "id": "v3",
            "title": "Print Even Numbers",
            "description": "Write a program that prints even numbers from 2 to 10.",
            "hints": [
              "Use <code>for i := 2; i <= 10; i += 2</code>"
            ],
            "solution": "for i := 2; i <= 10; i += 2 {\n    fmt.Println(i)\n}"
          },
          {
            "id": "v4",
            "title": "Count by Twos",
            "description": "Write a program that prints odd numbers from 1 to 9.",
            "hints": [
              "Use <code>for i := 1; i <= 9; i += 2</code>"
            ],
            "solution": "for i := 1; i <= 9; i += 2 {\n    fmt.Println(i)\n}"
          },
          {
            "id": "v5",
            "title": "Sum First N Numbers",
            "description": "Write a program that calculates and prints the sum of numbers from 1 to 5.",
            "hints": [
              "Create a <code>sum</code> variable",
              "Add each number: <code>sum += i</code>"
            ],
            "solution": "sum := 0\nfor i := 1; i <= 5; i++ {\n    sum += i\n}\nfmt.Println(sum)  // 15"
          },
          {
            "id": "v6",
            "title": "Multiplication Table Row",
            "description": "Write a program that prints the 3 times table from 3x1 to 3x5.",
            "hints": [
              "Loop from 1 to 5",
              "Print <code>3 * i</code> each time"
            ],
            "solution": "for i := 1; i <= 5; i++ {\n    fmt.Printf(\"3 x %d = %d\\n\", i, 3*i)\n}"
          },
          {
            "id": "v7",
            "title": "Print Squares",
            "description": "Write a program that prints the square of numbers from 1 to 4.",
            "hints": [
              "Square is <code>i * i</code>"
            ],
            "solution": "for i := 1; i <= 4; i++ {\n    fmt.Println(i * i)\n}"
          },
          {
            "id": "v8",
            "title": "Count Down by Threes",
            "description": "Write a program that counts down from 15 to 0 by threes (15, 12, 9, 6, 3, 0).",
            "hints": [
              "Start at 15, use <code>i -= 3</code>"
            ],
            "solution": "for i := 15; i >= 0; i -= 3 {\n    fmt.Println(i)\n}"
          },
          {
            "id": "v9",
            "title": "Fibonacci First N",
            "description": "Write a program that prints the first 7 Fibonacci numbers (1, 1, 2, 3, 5, 8, 13).",
            "hints": [
              "Start with <code>a, b := 1, 1</code>",
              "Each new number is the sum of the previous two"
            ],
            "solution": "a, b := 1, 1\nfor i := 0; i < 7; i++ {\n    fmt.Println(a)\n    a, b = b, a+b\n}"
          },
          {
            "id": "v10",
            "title": "Factorial",
            "description": "Write a program that calculates and prints 5! (5 factorial = 5 \u00d7 4 \u00d7 3 \u00d7 2 \u00d7 1 = 120).",
            "hints": [
              "Start with <code>result := 1</code>",
              "Multiply by each number: <code>result *= i</code>"
            ],
            "solution": "result := 1\nfor i := 1; i <= 5; i++ {\n    result *= i\n}\nfmt.Println(result)  // 120"
          },
          {
            "id": "v11",
            "title": "Skip Count by Fives",
            "description": "Write a program that counts from 0 to 25 by fives (0, 5, 10, 15, 20, 25).",
            "hints": [
              "Use <code>for i := 0; i <= 25; i += 5</code>"
            ],
            "solution": "for i := 0; i <= 25; i += 5 {\n    fmt.Println(i)\n}"
          },
          {
            "id": "v12",
            "title": "Print Star Pattern",
            "description": "Write a program that prints a triangle pattern of stars (1 star, then 2 stars, then 3 stars).",
            "hints": [
              "Outer loop controls rows",
              "Inner loop prints stars: <code>for j := 0; j < i; j++</code>"
            ],
            "solution": "for i := 1; i <= 3; i++ {\n    for j := 0; j < i; j++ {\n        fmt.Print(\"*\")\n    }\n    fmt.Println()\n}"
          },
          {
            "id": "v13",
            "title": "Power of Two",
            "description": "Write a program that prints powers of 2 from 2^0 to 2^5 (1, 2, 4, 8, 16, 32).",
            "hints": [
              "Start with <code>power := 1</code>",
              "Double each time: <code>power *= 2</code>"
            ],
            "solution": "power := 1\nfor i := 0; i <= 5; i++ {\n    fmt.Println(power)\n    power *= 2\n}"
          }
        ]
      },
      {
        "id": "warmup_2",
        "concept": "If/Else",
        "variants": [
          {
            "id": "v1",
            "title": "Odd or Even",
            "description": "Write <code>func oddOrEven(n int) string</code> that returns \"even\" if n is divisible by 2, else \"odd\".",
            "hints": [
              "Use modulo: <code>if n % 2 == 0</code> means even"
            ],
            "solution": "func oddOrEven(n int) string {\n    if n % 2 == 0 {\n        return \"even\"\n    }\n    return \"odd\"\n}"
          },
          {
            "id": "v2",
            "title": "Pass or Fail",
            "description": "Write <code>func passOrFail(score int) string</code> that returns \"pass\" if score >= 60, else \"fail\".",
            "hints": [
              "Simple if/else: <code>if score >= 60 { return \"pass\" }</code>"
            ],
            "solution": "func passOrFail(score int) string {\n    if score >= 60 {\n        return \"pass\"\n    }\n    return \"fail\"\n}"
          },
          {
            "id": "v3",
            "title": "Temperature Feel",
            "description": "Write <code>func tempFeel(celsius int) string</code> that returns \"freezing\" (< 0), \"cold\" (0-15), \"warm\" (16-25), or \"hot\" (> 25).",
            "hints": [
              "Chain if/else if based on temperature thresholds"
            ],
            "solution": "func tempFeel(celsius int) string {\n    if celsius < 0 {\n        return \"freezing\"\n    } else if celsius <= 15 {\n        return \"cold\"\n    } else if celsius <= 25 {\n        return \"warm\"\n    }\n    return \"hot\"\n}"
          },
          {
            "id": "v4",
            "title": "Grade Letter",
            "description": "Write <code>func gradeLetter(score int) string</code> that returns \"A\" (>=90), \"B\" (>=80), \"C\" (>=70), \"D\" (>=60), or \"F\" (<60).",
            "hints": [
              "Use chained if/else if statements",
              "Check highest grade first"
            ],
            "solution": "func gradeLetter(score int) string {\n    if score >= 90 {\n        return \"A\"\n    } else if score >= 80 {\n        return \"B\"\n    } else if score >= 70 {\n        return \"C\"\n    } else if score >= 60 {\n        return \"D\"\n    }\n    return \"F\"\n}"
          },
          {
            "id": "v5",
            "title": "Voting Eligibility",
            "description": "Write <code>func canVote(age int) string</code> that returns \"can vote\" if age >= 18, else \"too young\".",
            "hints": [
              "Simple comparison with 18"
            ],
            "solution": "func canVote(age int) string {\n    if age >= 18 {\n        return \"can vote\"\n    }\n    return \"too young\"\n}"
          },
          {
            "id": "v6",
            "title": "Discount Eligibility",
            "description": "Write <code>func getDiscount(age int) string</code> that returns \"senior discount\" (>=65), \"student discount\" (<=25), or \"no discount\".",
            "hints": [
              "Check senior first, then student, then default"
            ],
            "solution": "func getDiscount(age int) string {\n    if age >= 65 {\n        return \"senior discount\"\n    } else if age <= 25 {\n        return \"student discount\"\n    }\n    return \"no discount\"\n}"
          },
          {
            "id": "v7",
            "title": "Positive or Negative",
            "description": "Write <code>func posNegZero(n int) string</code> that returns \"positive\", \"negative\", or \"zero\".",
            "hints": [
              "Check if n > 0, n < 0, or else it's zero"
            ],
            "solution": "func posNegZero(n int) string {\n    if n > 0 {\n        return \"positive\"\n    } else if n < 0 {\n        return \"negative\"\n    }\n    return \"zero\"\n}"
          },
          {
            "id": "v8",
            "title": "Speed Limit",
            "description": "Write <code>func speedCheck(speed int) string</code> that returns \"safe\" (<=60), \"warning\" (61-80), or \"ticket\" (>80).",
            "hints": [
              "Use ranges for different categories"
            ],
            "solution": "func speedCheck(speed int) string {\n    if speed <= 60 {\n        return \"safe\"\n    } else if speed <= 80 {\n        return \"warning\"\n    }\n    return \"ticket\"\n}"
          },
          {
            "id": "v9",
            "title": "Age Category",
            "description": "Write <code>func ageCategory(age int) string</code> that returns \"child\" if age < 13, \"teen\" if age < 20, else \"adult\".",
            "hints": [
              "Use multiple if/else if statements",
              "Check conditions from smallest to largest"
            ],
            "solution": "func ageCategory(age int) string {\n    if age < 13 {\n        return \"child\"\n    } else if age < 20 {\n        return \"teen\"\n    }\n    return \"adult\"\n}"
          },
          {
            "id": "v10",
            "title": "BMI Category",
            "description": "Write <code>func bmiCategory(bmi float64) string</code> that returns \"underweight\" if bmi < 18.5, \"normal\" if bmi < 25, else \"overweight\".",
            "hints": [
              "Use <code>else if</code> for the middle condition"
            ],
            "solution": "func bmiCategory(bmi float64) string {\n    if bmi < 18.5 {\n        return \"underweight\"\n    } else if bmi < 25 {\n        return \"normal\"\n    }\n    return \"overweight\"\n}"
          },
          {
            "id": "v11",
            "title": "Season from Month",
            "description": "Write <code>func season(month int) string</code> that returns \"winter\" for 12-2, \"spring\" for 3-5, \"summer\" for 6-8, \"fall\" for 9-11.",
            "hints": [
              "Use multiple if/else if conditions",
              "Check ranges like <code>month >= 3 && month <= 5</code>"
            ],
            "solution": "func season(month int) string {\n    if month == 12 || month <= 2 {\n        return \"winter\"\n    } else if month <= 5 {\n        return \"spring\"\n    } else if month <= 8 {\n        return \"summer\"\n    }\n    return \"fall\"\n}"
          },
          {
            "id": "v12",
            "title": "Weekend or Weekday",
            "description": "Write <code>func dayType(day string) string</code> that returns \"weekend\" if day is \"Saturday\" or \"Sunday\", else \"weekday\".",
            "hints": [
              "Use <code>||</code> (OR) operator",
              "Check: <code>if day == \"Saturday\" || day == \"Sunday\"</code>"
            ],
            "solution": "func dayType(day string) string {\n    if day == \"Saturday\" || day == \"Sunday\" {\n        return \"weekend\"\n    }\n    return \"weekday\"\n}"
          },
          {
            "id": "v13",
            "title": "Password Strength",
            "description": "Write <code>func passwordStrength(length int) string</code> that returns \"weak\" if length < 8, \"medium\" if length < 12, else \"strong\".",
            "hints": [
              "Simple if/else if chain based on length thresholds"
            ],
            "solution": "func passwordStrength(length int) string {\n    if length < 8 {\n        return \"weak\"\n    } else if length < 12 {\n        return \"medium\"\n    }\n    return \"strong\"\n}"
          }
        ]
      },
      {
        "id": "warmup_3",
        "concept": "Slices & Range",
        "variants": [
          {
            "id": "v1",
            "title": "Iterate Numbers",
            "description": "Create a slice with three numbers, then print each using <code>for range</code>.",
            "hints": [
              "Create: <code>nums := []int{7, 42, 99}</code>",
              "Loop: <code>for _, num := range nums</code>"
            ],
            "solution": "nums := []int{7, 42, 99}\nfor _, num := range nums {\n    fmt.Println(num)\n}"
          },
          {
            "id": "v2",
            "title": "Iterate with Index",
            "description": "Create a slice of colors, then print each with its index: \"0: red\", \"1: blue\", etc.",
            "hints": [
              "Loop with index: <code>for i, color := range colors</code>",
              "Use <code>fmt.Printf(\"%d: %s\\n\", i, color)</code>"
            ],
            "solution": "colors := []string{\"red\", \"blue\", \"green\"}\nfor i, color := range colors {\n    fmt.Printf(\"%d: %s\\n\", i, color)\n}"
          },
          {
            "id": "v3",
            "title": "Iterate Strings",
            "description": "Create a slice of your favorite foods, print each on its own line.",
            "hints": [
              "Create: <code>foods := []string{\"pizza\", \"sushi\", \"tacos\"}</code>"
            ],
            "solution": "foods := []string{\"pizza\", \"sushi\", \"tacos\"}\nfor _, food := range foods {\n    fmt.Println(food)\n}"
          },
          {
            "id": "v4",
            "title": "Sum Slice",
            "description": "Create a slice of numbers, then calculate and print their sum.",
            "hints": [
              "Create a sum variable before the loop",
              "Add each number: <code>sum += num</code>"
            ],
            "solution": "nums := []int{10, 20, 30}\nsum := 0\nfor _, num := range nums {\n    sum += num\n}\nfmt.Println(sum)  // 60"
          },
          {
            "id": "v5",
            "title": "Count Items",
            "description": "Create a slice of fruits and print how many items are in it.",
            "hints": [
              "Use <code>len(fruits)</code> to get the count"
            ],
            "solution": "fruits := []string{\"apple\", \"banana\", \"orange\", \"grape\"}\nfmt.Println(len(fruits))  // 4"
          },
          {
            "id": "v6",
            "title": "Names List",
            "description": "Create a slice of names and print each with a greeting: \"Hello, Alice!\"",
            "hints": [
              "Use <code>fmt.Printf(\"Hello, %s!\\n\", name)</code>"
            ],
            "solution": "names := []string{\"Alice\", \"Bob\", \"Charlie\"}\nfor _, name := range names {\n    fmt.Printf(\"Hello, %s!\\n\", name)\n}"
          },
          {
            "id": "v7",
            "title": "Test Scores",
            "description": "Create a slice of test scores and print each one with its position: \"Test 1: 85\"",
            "hints": [
              "Use the index in the range loop",
              "Add 1 to the index for human-readable numbering"
            ],
            "solution": "scores := []int{85, 92, 78, 95}\nfor i, score := range scores {\n    fmt.Printf(\"Test %d: %d\\n\", i+1, score)\n}"
          },
          {
            "id": "v8",
            "title": "Reverse Print",
            "description": "Create a slice of 3 animals and print them in reverse order using a regular for loop.",
            "hints": [
              "Start from <code>len(animals)-1</code>",
              "Count down: <code>i--</code>"
            ],
            "solution": "animals := []string{\"cat\", \"dog\", \"bird\"}\nfor i := len(animals) - 1; i >= 0; i-- {\n    fmt.Println(animals[i])\n}"
          },
          {
            "id": "v9",
            "title": "Find Maximum",
            "description": "Write <code>func findMax(nums []int) int</code> that returns the largest number in the slice.",
            "hints": [
              "Start with <code>max := nums[0]</code>",
              "Use range to compare each number"
            ],
            "solution": "func findMax(nums []int) int {\n    max := nums[0]\n    for _, n := range nums {\n        if n > max {\n            max = n\n        }\n    }\n    return max\n}"
          },
          {
            "id": "v10",
            "title": "Find Minimum",
            "description": "Write <code>func findMin(nums []int) int</code> that returns the smallest number in the slice.",
            "hints": [
              "Start with <code>min := nums[0]</code>",
              "Compare each number: <code>if n < min</code>"
            ],
            "solution": "func findMin(nums []int) int {\n    min := nums[0]\n    for _, n := range nums {\n        if n < min {\n            min = n\n        }\n    }\n    return min\n}"
          },
          {
            "id": "v11",
            "title": "Calculate Average",
            "description": "Write <code>func average(nums []float64) float64</code> that returns the average of all numbers.",
            "hints": [
              "Sum all numbers first",
              "Divide by length: <code>sum / float64(len(nums))</code>"
            ],
            "solution": "func average(nums []float64) float64 {\n    sum := 0.0\n    for _, n := range nums {\n        sum += n\n    }\n    return sum / float64(len(nums))\n}"
          },
          {
            "id": "v12",
            "title": "Contains Check",
            "description": "Write <code>func contains(items []string, target string) bool</code> that returns true if target is in items.",
            "hints": [
              "Use range to check each item",
              "Return true immediately when found"
            ],
            "solution": "func contains(items []string, target string) bool {\n    for _, item := range items {\n        if item == target {\n            return true\n        }\n    }\n    return false\n}"
          },
          {
            "id": "v13",
            "title": "First N Elements",
            "description": "Write <code>func firstN(items []string, n int) []string</code> that returns the first n elements of the slice.",
            "hints": [
              "Use slice syntax: <code>items[:n]</code>"
            ],
            "solution": "func firstN(items []string, n int) []string {\n    return items[:n]\n}"
          }
        ]
      },
      {
        "id": "warmup_4",
        "concept": "Maps",
        "variants": [
          {
            "id": "v1",
            "title": "Ages Map",
            "description": "Create a map of names to ages, then print each person's name and age.",
            "hints": [
              "Map syntax: <code>map[string]int{\"alice\": 30}</code>",
              "Loop: <code>for name, age := range ages</code>"
            ],
            "solution": "ages := map[string]int{\n    \"alice\": 30,\n    \"bob\":   25,\n}\nfor name, age := range ages {\n    fmt.Printf(\"%s is %d\\n\", name, age)\n}"
          },
          {
            "id": "v2",
            "title": "Prices Map",
            "description": "Create a map of items to prices (float64), then print each item and price.",
            "hints": [
              "Map syntax: <code>map[string]float64{\"apple\": 1.50}</code>"
            ],
            "solution": "prices := map[string]float64{\n    \"apple\":  1.50,\n    \"banana\": 0.75,\n}\nfor item, price := range prices {\n    fmt.Printf(\"%s: $%.2f\\n\", item, price)\n}"
          },
          {
            "id": "v3",
            "title": "Capitals Map",
            "description": "Create a map of countries to their capitals, then print each pair.",
            "hints": [
              "Map syntax: <code>map[string]string{\"France\": \"Paris\"}</code>"
            ],
            "solution": "capitals := map[string]string{\n    \"France\": \"Paris\",\n    \"Japan\":  \"Tokyo\",\n}\nfor country, capital := range capitals {\n    fmt.Printf(\"%s: %s\\n\", country, capital)\n}"
          },
          {
            "id": "v4",
            "title": "Inventory Count",
            "description": "Create a map of product names to quantities in stock, then print each item and count.",
            "hints": [
              "Map syntax: <code>map[string]int{\"shirt\": 15}</code>"
            ],
            "solution": "inventory := map[string]int{\n    \"shirt\": 15,\n    \"pants\": 8,\n    \"hat\":   20,\n}\nfor item, count := range inventory {\n    fmt.Printf(\"%s: %d in stock\\n\", item, count)\n}"
          },
          {
            "id": "v5",
            "title": "Student Grades",
            "description": "Create a map of student names to their letter grades, then print each student and grade.",
            "hints": [
              "Map syntax: <code>map[string]string{\"Alice\": \"A\"}</code>"
            ],
            "solution": "grades := map[string]string{\n    \"Alice\": \"A\",\n    \"Bob\":   \"B\",\n    \"Carol\": \"A\",\n}\nfor student, grade := range grades {\n    fmt.Printf(\"%s: %s\\n\", student, grade)\n}"
          },
          {
            "id": "v6",
            "title": "Phone Book",
            "description": "Create a map of names to phone numbers, then print each entry.",
            "hints": [
              "Phone numbers can be strings: <code>\"555-1234\"</code>"
            ],
            "solution": "phonebook := map[string]string{\n    \"Alice\": \"555-1234\",\n    \"Bob\":   \"555-5678\",\n}\nfor name, phone := range phonebook {\n    fmt.Printf(\"%s: %s\\n\", name, phone)\n}"
          },
          {
            "id": "v7",
            "title": "Menu Prices",
            "description": "Create a map of menu items to their prices (use integers for cents), then print the menu.",
            "hints": [
              "Store cents as int: 250 for $2.50",
              "Divide by 100.0 when printing"
            ],
            "solution": "menu := map[string]int{\n    \"burger\": 850,\n    \"fries\":  350,\n    \"soda\":   200,\n}\nfor item, cents := range menu {\n    fmt.Printf(\"%s: $%.2f\\n\", item, float64(cents)/100.0)\n}"
          },
          {
            "id": "v8",
            "title": "Room Numbers",
            "description": "Create a map of employee names to their office room numbers, then print the directory.",
            "hints": [
              "Map syntax: <code>map[string]int{\"Alice\": 101}</code>"
            ],
            "solution": "offices := map[string]int{\n    \"Alice\": 101,\n    \"Bob\":   102,\n    \"Carol\": 105,\n}\nfor name, room := range offices {\n    fmt.Printf(\"%s - Room %d\\n\", name, room)\n}"
          },
          {
            "id": "v9",
            "title": "Most Common Value",
            "description": "Write <code>func mostCommon(counts map[string]int) string</code> that returns the key with the highest value.",
            "hints": [
              "Track max value and corresponding key",
              "Loop through map with range"
            ],
            "solution": "func mostCommon(counts map[string]int) string {\n    maxKey := \"\"\n    maxVal := 0\n    for k, v := range counts {\n        if v > maxVal {\n            maxVal = v\n            maxKey = k\n        }\n    }\n    return maxKey\n}"
          },
          {
            "id": "v10",
            "title": "Merge Maps",
            "description": "Write <code>func mergeMaps(m1, m2 map[string]int) map[string]int</code> that combines both maps (m2 overwrites m1 on conflicts).",
            "hints": [
              "Create new result map",
              "Copy all from m1, then all from m2"
            ],
            "solution": "func mergeMaps(m1, m2 map[string]int) map[string]int {\n    result := make(map[string]int)\n    for k, v := range m1 {\n        result[k] = v\n    }\n    for k, v := range m2 {\n        result[k] = v\n    }\n    return result\n}"
          },
          {
            "id": "v11",
            "title": "Filter by Value",
            "description": "Write <code>func filterByValue(m map[string]int, threshold int) map[string]int</code> that returns only entries where value >= threshold.",
            "hints": [
              "Create new map for results",
              "Only add entries that meet the condition"
            ],
            "solution": "func filterByValue(m map[string]int, threshold int) map[string]int {\n    result := make(map[string]int)\n    for k, v := range m {\n        if v >= threshold {\n            result[k] = v\n        }\n    }\n    return result\n}"
          },
          {
            "id": "v12",
            "title": "Key Exists Multiple",
            "description": "Write <code>func hasAllKeys(m map[string]int, keys []string) bool</code> that returns true if all keys exist in the map.",
            "hints": [
              "Loop through keys slice",
              "Use comma-ok idiom: <code>_, ok := m[key]</code>"
            ],
            "solution": "func hasAllKeys(m map[string]int, keys []string) bool {\n    for _, key := range keys {\n        if _, ok := m[key]; !ok {\n            return false\n        }\n    }\n    return true\n}"
          },
          {
            "id": "v13",
            "title": "Invert Map",
            "description": "Write <code>func invertMap(m map[string]string) map[string]string</code> that swaps keys and values.",
            "hints": [
              "Create new map where values become keys",
              "Loop: <code>result[v] = k</code>"
            ],
            "solution": "func invertMap(m map[string]string) map[string]string {\n    result := make(map[string]string)\n    for k, v := range m {\n        result[v] = k\n    }\n    return result\n}"
          }
        ]
      },
      {
        "id": "warmup_5",
        "concept": "Variables & Assignment",
        "variants": [
          {
            "id": "v1",
            "title": "Declare and Print",
            "description": "Declare a variable <code>name</code> with value \"Go\", and an integer <code>year</code> with value 2009. Print both.",
            "hints": [
              "Use short declaration: <code>name := \"Go\"</code>",
              "Use <code>fmt.Println(name, year)</code>"
            ],
            "solution": "name := \"Go\"\nyear := 2009\nfmt.Println(name, year)"
          },
          {
            "id": "v2",
            "title": "Swap Two Variables",
            "description": "Create two variables <code>a := 10</code> and <code>b := 20</code>. Swap their values, then print them.",
            "hints": [
              "Go allows simultaneous assignment: <code>a, b = b, a</code>"
            ],
            "solution": "a := 10\nb := 20\na, b = b, a\nfmt.Println(a, b)  // 20 10"
          },
          {
            "id": "v3",
            "title": "Type Inference",
            "description": "Create variables for your age (int), height (float64), and name (string) using short declaration. Print their values and types.",
            "hints": [
              "Go infers types: <code>age := 25</code> is int",
              "Use <code>fmt.Printf(\"%T\", age)</code> to print type"
            ],
            "solution": "age := 25\nheight := 5.9\nname := \"Alice\"\nfmt.Printf(\"age: %d (%T)\\n\", age, age)\nfmt.Printf(\"height: %.1f (%T)\\n\", height, height)\nfmt.Printf(\"name: %s (%T)\\n\", name, name)"
          },
          {
            "id": "v4",
            "title": "Calculate Area",
            "description": "Create variables for width (5.0) and height (3.0), calculate the area, and print it.",
            "hints": [
              "Area is width * height",
              "Use <code>:=</code> for short declaration"
            ],
            "solution": "width := 5.0\nheight := 3.0\narea := width * height\nfmt.Println(area)  // 15"
          },
          {
            "id": "v5",
            "title": "String Concatenation",
            "description": "Create variables for first name and last name, then create and print a full name.",
            "hints": [
              "Concatenate with <code>+</code>",
              "Don't forget the space between names"
            ],
            "solution": "firstName := \"John\"\nlastName := \"Doe\"\nfullName := firstName + \" \" + lastName\nfmt.Println(fullName)  // John Doe"
          },
          {
            "id": "v6",
            "title": "Boolean Logic",
            "description": "Create two boolean variables, then print their AND and OR results.",
            "hints": [
              "AND: <code>a && b</code>",
              "OR: <code>a || b</code>"
            ],
            "solution": "a := true\nb := false\nfmt.Println(a && b)  // false\nfmt.Println(a || b)  // true"
          },
          {
            "id": "v7",
            "title": "Temperature Conversion",
            "description": "Create a celsius variable (25), convert it to Fahrenheit (F = C * 9/5 + 32), and print both.",
            "hints": [
              "Formula: <code>fahrenheit := celsius * 9 / 5 + 32</code>",
              "Use float64 for decimal precision"
            ],
            "solution": "celsius := 25.0\nfahrenheit := celsius * 9 / 5 + 32\nfmt.Printf(\"%.1fC = %.1fF\\n\", celsius, fahrenheit)  // 25.0C = 77.0F"
          },
          {
            "id": "v8",
            "title": "Shopping Total",
            "description": "Create variables for three item prices, calculate the total, then apply a 10% discount and print the final price.",
            "hints": [
              "Total: <code>price1 + price2 + price3</code>",
              "Discount: <code>total * 0.9</code>"
            ],
            "solution": "item1 := 10.0\nitem2 := 25.5\nitem3 := 8.75\ntotal := item1 + item2 + item3\nfinal := total * 0.9\nfmt.Printf(\"Total: $%.2f, After discount: $%.2f\\n\", total, final)"
          },
          {
            "id": "v9",
            "title": "Pythagorean Theorem",
            "description": "Write a program that calculates the hypotenuse c given sides a=3 and b=4 using c = sqrt(a\u00b2 + b\u00b2). Print the result.",
            "hints": [
              "Use <code>math.Sqrt()</code> function",
              "Formula: <code>c := math.Sqrt(a*a + b*b)</code>"
            ],
            "solution": "import \"math\"\n\na := 3.0\nb := 4.0\nc := math.Sqrt(a*a + b*b)\nfmt.Println(c)  // 5"
          },
          {
            "id": "v10",
            "title": "Compound Interest",
            "description": "Write a program that calculates compound interest. Given principal=1000, rate=0.05, time=2, calculate amount = principal * (1 + rate)^time. Print result.",
            "hints": [
              "Use <code>math.Pow()</code> for exponentiation",
              "Formula: <code>amount := principal * math.Pow(1+rate, time)</code>"
            ],
            "solution": "import \"math\"\n\nprincipal := 1000.0\nrate := 0.05\ntime := 2.0\namount := principal * math.Pow(1+rate, time)\nfmt.Println(amount)  // 1102.5"
          },
          {
            "id": "v11",
            "title": "Temperature Conversion",
            "description": "Write a program that converts 100\u00b0F to Celsius using the formula C = (F - 32) * 5/9. Print the result.",
            "hints": [
              "Use parentheses for correct order of operations",
              "Formula: <code>celsius := (fahrenheit - 32) * 5 / 9</code>"
            ],
            "solution": "fahrenheit := 100.0\ncelsius := (fahrenheit - 32) * 5 / 9\nfmt.Println(celsius)  // 37.777..."
          },
          {
            "id": "v12",
            "title": "Circle Circumference",
            "description": "Write a program that calculates the circumference of a circle with radius 7 using C = 2\u03c0r. Print the result.",
            "hints": [
              "Use <code>math.Pi</code> constant",
              "Formula: <code>circumference := 2 * math.Pi * radius</code>"
            ],
            "solution": "import \"math\"\n\nradius := 7.0\ncircumference := 2 * math.Pi * radius\nfmt.Println(circumference)  // 43.98..."
          },
          {
            "id": "v13",
            "title": "Distance Formula",
            "description": "Write a program that calculates distance between points (1,2) and (4,6) using d = sqrt((x2-x1)\u00b2 + (y2-y1)\u00b2). Print result.",
            "hints": [
              "Calculate differences first: <code>dx := x2 - x1</code>",
              "Use <code>math.Sqrt(dx*dx + dy*dy)</code>"
            ],
            "solution": "import \"math\"\n\nx1, y1 := 1.0, 2.0\nx2, y2 := 4.0, 6.0\ndx := x2 - x1\ndy := y2 - y1\ndist := math.Sqrt(dx*dx + dy*dy)\nfmt.Println(dist)  // 5"
          }
        ]
      },
      {
        "id": "warmup_6",
        "concept": "Multiple Returns",
        "variants": [
          {
            "id": "v1",
            "title": "Divide with Remainder",
            "description": "Write <code>func divMod(a, b int) (int, int)</code> that returns both quotient and remainder.",
            "hints": [
              "Return two values: <code>return a / b, a % b</code>",
              "Call with: <code>q, r := divMod(10, 3)</code>"
            ],
            "solution": "func divMod(a, b int) (int, int) {\n    return a / b, a % b\n}\n\n// Usage:\nq, r := divMod(10, 3)\nfmt.Println(q, r)  // 3 1"
          },
          {
            "id": "v2",
            "title": "Min and Max",
            "description": "Write <code>func minMax(a, b int) (int, int)</code> that returns the smaller value first, then the larger.",
            "hints": [
              "Use if to compare, then return in order"
            ],
            "solution": "func minMax(a, b int) (int, int) {\n    if a < b {\n        return a, b\n    }\n    return b, a\n}\n\n// Usage:\nsmall, big := minMax(5, 3)\nfmt.Println(small, big)  // 3 5"
          },
          {
            "id": "v3",
            "title": "First and Last",
            "description": "Write <code>func firstLast(s string) (string, string)</code> that returns the first and last character of a string.",
            "hints": [
              "First char: <code>string(s[0])</code>",
              "Last char: <code>string(s[len(s)-1])</code>"
            ],
            "solution": "func firstLast(s string) (string, string) {\n    return string(s[0]), string(s[len(s)-1])\n}\n\n// Usage:\nf, l := firstLast(\"hello\")\nfmt.Println(f, l)  // h o"
          },
          {
            "id": "v4",
            "title": "Split Name",
            "description": "Write <code>func splitName(fullName string) (string, string)</code> that splits \"John Doe\" into first and last name (assume one space).",
            "hints": [
              "Find the space with a simple loop or assume fixed position",
              "For warmup, you can hardcode the split at index 4 for \"John Doe\""
            ],
            "solution": "func splitName(fullName string) (string, string) {\n    // Simple version: find space\n    for i, ch := range fullName {\n        if ch == ' ' {\n            return fullName[:i], fullName[i+1:]\n        }\n    }\n    return fullName, \"\"\n}\n\n// Usage:\nfirst, last := splitName(\"John Doe\")\nfmt.Println(first, last)  // John Doe"
          },
          {
            "id": "v5",
            "title": "Circle Properties",
            "description": "Write <code>func circleProps(radius float64) (float64, float64)</code> that returns circumference and area (use 3.14 for pi).",
            "hints": [
              "Circumference: <code>2 * pi * radius</code>",
              "Area: <code>pi * radius * radius</code>"
            ],
            "solution": "func circleProps(radius float64) (float64, float64) {\n    pi := 3.14\n    circumference := 2 * pi * radius\n    area := pi * radius * radius\n    return circumference, area\n}\n\n// Usage:\nc, a := circleProps(5.0)\nfmt.Printf(\"Circumference: %.2f, Area: %.2f\\n\", c, a)"
          },
          {
            "id": "v6",
            "title": "Bounds Check",
            "description": "Write <code>func inRange(n, min, max int) (bool, string)</code> that returns true/\"in range\" if n is between min and max, else false/\"out of range\".",
            "hints": [
              "Check if <code>n >= min && n <= max</code>",
              "Return both the boolean and a message"
            ],
            "solution": "func inRange(n, min, max int) (bool, string) {\n    if n >= min && n <= max {\n        return true, \"in range\"\n    }\n    return false, \"out of range\"\n}\n\n// Usage:\nok, msg := inRange(15, 10, 20)\nfmt.Println(ok, msg)  // true in range"
          },
          {
            "id": "v7",
            "title": "Quotient and Remainder",
            "description": "Write <code>func divide(dividend, divisor int) (int, int)</code> that returns quotient and remainder.",
            "hints": [
              "Quotient: <code>dividend / divisor</code>",
              "Remainder: <code>dividend % divisor</code>"
            ],
            "solution": "func divide(dividend, divisor int) (int, int) {\n    quotient := dividend / divisor\n    remainder := dividend % divisor\n    return quotient, remainder\n}\n\n// Usage:\nq, r := divide(17, 5)\nfmt.Println(q, r)  // 3 2"
          },
          {
            "id": "v8",
            "title": "String Info",
            "description": "Write <code>func stringInfo(s string) (int, string)</code> that returns the length and the first character as a string.",
            "hints": [
              "Length: <code>len(s)</code>",
              "First char: <code>string(s[0])</code>"
            ],
            "solution": "func stringInfo(s string) (int, string) {\n    length := len(s)\n    firstChar := string(s[0])\n    return length, firstChar\n}\n\n// Usage:\nlen, first := stringInfo(\"hello\")\nfmt.Println(len, first)  // 5 h"
          },
          {
            "id": "v9",
            "title": "Parse Int with Error",
            "description": "Write <code>func parsePositive(s string) (int, error)</code> that converts string to int. Return error if conversion fails or number is negative.",
            "hints": [
              "Use <code>strconv.Atoi(s)</code> to convert",
              "Check if result < 0 and return custom error"
            ],
            "solution": "import (\n    \"errors\"\n    \"strconv\"\n)\n\nfunc parsePositive(s string) (int, error) {\n    n, err := strconv.Atoi(s)\n    if err != nil {\n        return 0, err\n    }\n    if n < 0 {\n        return 0, errors.New(\"negative number\")\n    }\n    return n, nil\n}"
          },
          {
            "id": "v10",
            "title": "Validate Range",
            "description": "Write <code>func validateRange(n, min, max int) (int, bool)</code> that returns (n, true) if n is in [min,max], else (0, false).",
            "hints": [
              "Check condition: <code>n >= min && n <= max</code>",
              "Return the value with a boolean flag"
            ],
            "solution": "func validateRange(n, min, max int) (int, bool) {\n    if n >= min && n <= max {\n        return n, true\n    }\n    return 0, false\n}"
          },
          {
            "id": "v11",
            "title": "String Split at Position",
            "description": "Write <code>func splitAt(s string, pos int) (string, string, bool)</code> that splits string at position. Return false if pos is out of bounds.",
            "hints": [
              "Check if <code>pos >= 0 && pos <= len(s)</code>",
              "Use slice notation: <code>s[:pos]</code> and <code>s[pos:]</code>"
            ],
            "solution": "func splitAt(s string, pos int) (string, string, bool) {\n    if pos < 0 || pos > len(s) {\n        return \"\", \"\", false\n    }\n    return s[:pos], s[pos:], true\n}"
          },
          {
            "id": "v12",
            "title": "Find First Occurrence",
            "description": "Write <code>func findFirst(items []string, target string) (int, bool)</code> that returns (index, true) if found, else (-1, false).",
            "hints": [
              "Use range to get both index and value",
              "Return immediately when target is found"
            ],
            "solution": "func findFirst(items []string, target string) (int, bool) {\n    for i, item := range items {\n        if item == target {\n            return i, true\n        }\n    }\n    return -1, false\n}"
          },
          {
            "id": "v13",
            "title": "Min and Max",
            "description": "Write <code>func minMax(nums []int) (int, int)</code> that returns both the minimum and maximum values in one call.",
            "hints": [
              "Initialize both to first element",
              "Update both in one loop using range"
            ],
            "solution": "func minMax(nums []int) (int, int) {\n    min, max := nums[0], nums[0]\n    for _, n := range nums {\n        if n < min {\n            min = n\n        }\n        if n > max {\n            max = n\n        }\n    }\n    return min, max\n}"
          }
        ]
      }
    ],
    "challenges": [
      {
        "id": "challenge_1",
        "block": 1,
        "difficulty": 1,
        "concept": "Accumulator Pattern",
        "docLinks": [
          {
            "url": "https://go.dev/ref/spec#For_statements",
            "title": "Go Spec: For statements",
            "note": "range loops"
          },
          {
            "url": "https://go.dev/ref/spec#Arithmetic_operators",
            "title": "Go Spec: Arithmetic operators",
            "note": "+= syntax"
          }
        ],
        "patternPrimer": {
          "bruteForce": "Loop and update a running result (sum/product/string).",
          "bestApproach": "Initialize the identity value once, then update per element; sometimes early-return is possible.",
          "typical": "Typically O(n) time, O(1) extra space"
        },
        "variants": [
          {
            "id": "v1",
            "title": "Sum of Slice",
            "description": "Write <code>func sum(numbers []int) int</code> that returns the sum of all numbers.",
            "functionSignature": "func sum(numbers []int) int",
            "testCases": [
              {
                "input": "[]int{1, 2, 3, 4, 5}",
                "output": "15"
              }
            ],
            "hints": [
              {
                "title": "\ud83e\udd14 Think about it",
                "content": "As you process each element, you need to build up a result. What variable do you need to track this running total?"
              },
              {
                "title": "\ud83d\udca1 Hint",
                "content": "Create an accumulator variable (number for sums, string for joining). Loop through and combine each element with your accumulator."
              },
              {
                "title": "\ud83d\udd27 Pattern",
                "content": "<pre>1. Start with initial value (0 for sums, \"\" for strings)\n2. For each element:\n   - Combine element with accumulator\n3. Return accumulator</pre>"
              }
            ],
            "solution": "func sum(numbers []int) int {\n    total := 0\n    for _, num := range numbers {\n        total += num\n    }\n    return total\n}",
            "difficulty": 1
          },
          {
            "id": "v2",
            "title": "Join Words",
            "description": "Write <code>func joinWords(words []string) string</code> that joins all words with spaces.",
            "functionSignature": "func joinWords(words []string) string",
            "testCases": [
              {
                "input": "[]string{\"go\", \"is\", \"fun\"}",
                "output": "\"go is fun\""
              }
            ],
            "hints": [
              {
                "title": "\ud83e\udd14 Think about it",
                "content": "As you process each element, you need to build up a result. What variable do you need to track this running total?"
              },
              {
                "title": "\ud83d\udca1 Hint",
                "content": "Create an accumulator variable (number for sums, string for joining). Loop through and combine each element with your accumulator."
              },
              {
                "title": "\ud83d\udd27 Pattern",
                "content": "<pre>1. Start with initial value (0 for sums, \"\" for strings)\n2. For each element:\n   - Combine element with accumulator\n3. Return accumulator</pre>"
              }
            ],
            "solution": "func joinWords(words []string) string {\n    result := \"\"\n    for i, word := range words {\n        if i > 0 {\n            result += \" \"\n        }\n        result += word\n    }\n    return result\n}",
            "difficulty": 2
          },
          {
            "id": "v3",
            "title": "Total String Length",
            "description": "Write <code>func totalLength(words []string) int</code> that returns total length of all strings.",
            "functionSignature": "func totalLength(words []string) int",
            "testCases": [
              {
                "input": "[]string{\"go\", \"is\", \"fun\"}",
                "output": "7"
              }
            ],
            "hints": [
              {
                "title": "\ud83e\udd14 Think about it",
                "content": "As you process each element, you need to build up a result. What variable do you need to track this running total?"
              },
              {
                "title": "\ud83d\udca1 Hint",
                "content": "Create an accumulator variable (number for sums, string for joining). Loop through and combine each element with your accumulator."
              },
              {
                "title": "\ud83d\udd27 Pattern",
                "content": "<pre>1. Start with initial value (0 for sums, \"\" for strings)\n2. For each element:\n   - Combine element with accumulator\n3. Return accumulator</pre>"
              }
            ],
            "solution": "func totalLength(words []string) int {\n    total := 0\n    for _, word := range words {\n        total += len(word)\n    }\n    return total\n}",
            "difficulty": 1
          },
          {
            "id": "v4",
            "title": "Product of Slice",
            "description": "Write <code>func product(nums []int) int</code> that returns the product of all numbers (multiply them together).",
            "functionSignature": "func product(nums []int) int",
            "testCases": [
              {
                "input": "[]int{2, 3, 4}",
                "output": "24"
              },
              {
                "input": "[]int{5, 2, 1}",
                "output": "10"
              }
            ],
            "hints": [
              {
                "title": "\ud83e\udd14 Think about it",
                "content": "Like sum, but multiply. What should your starting value be? (Hint: not 0!)"
              },
              {
                "title": "\ud83d\udca1 Hint",
                "content": "Start with result := 1 (identity for multiplication). Multiply each element into the accumulator."
              },
              {
                "title": "\ud83d\udd27 Pattern",
                "content": "<pre>1. Start with result := 1\n2. For each element:\n   - result *= element\n3. Return result</pre>"
              }
            ],
            "solution": "func product(nums []int) int {\n    result := 1\n    for _, n := range nums {\n        result *= n\n    }\n    return result\n}",
            "difficulty": 2
          },
          {
            "id": "v5",
            "title": "Running Balance",
            "description": "Write <code>func balance(transactions []int) int</code> where positive numbers are deposits, negative are withdrawals. Return final balance.",
            "functionSignature": "func balance(transactions []int) int",
            "testCases": [
              {
                "input": "[]int{100, -30, 50, -20}",
                "output": "100",
                "note": "100 - 30 + 50 - 20 = 100"
              },
              {
                "input": "[]int{-10, 20, -5}",
                "output": "5"
              }
            ],
            "hints": [
              {
                "title": "\ud83e\udd14 Think about it",
                "content": "This is just a sum! Positive and negative numbers handle themselves."
              },
              {
                "title": "\ud83d\udca1 Hint",
                "content": "Start with balance := 0. Add each transaction (negatives will subtract automatically)."
              },
              {
                "title": "\ud83d\udd27 Pattern",
                "content": "<pre>1. Start with balance := 0\n2. For each transaction:\n   - balance += transaction\n3. Return balance</pre>"
              }
            ],
            "solution": "func balance(transactions []int) int {\n    bal := 0\n    for _, t := range transactions {\n        bal += t\n    }\n    return bal\n}",
            "difficulty": 1
          },
          {
            "id": "v6",
            "title": "Concat All",
            "description": "Write <code>func concatAll(words []string) string</code> that concatenates all strings with no separator.",
            "functionSignature": "func concatAll(words []string) string",
            "testCases": [
              {
                "input": "[]string{\"a\", \"b\", \"c\"}",
                "output": "\"abc\""
              },
              {
                "input": "[]string{\"Go\", \"Lang\"}",
                "output": "\"GoLang\""
              }
            ],
            "hints": [
              {
                "title": "\ud83e\udd14 Think about it",
                "content": "Build up a string by adding each word to the end."
              },
              {
                "title": "\ud83d\udca1 Hint",
                "content": "Start with result := \"\". For each word, result += word."
              },
              {
                "title": "\ud83d\udd27 Pattern",
                "content": "<pre>1. Start with result := \"\"\n2. For each word:\n   - result += word\n3. Return result</pre>"
              }
            ],
            "solution": "func concatAll(words []string) string {\n    result := \"\"\n    for _, w := range words {\n        result += w\n    }\n    return result\n}",
            "difficulty": 1
          },
          {
            "id": "v7",
            "title": "Sum of Squares",
            "difficulty": 2,
            "description": "Write <code>func sumOfSquares(nums []int) int</code> that returns the sum of the squares of all numbers. For example, [1, 2, 3] \u2192 1\u00b2 + 2\u00b2 + 3\u00b2 = 14.",
            "functionSignature": "func sumOfSquares(nums []int) int",
            "testCases": [
              {
                "input": "[]int{1, 2, 3}",
                "output": "14",
                "note": "1\u00b2 + 2\u00b2 + 3\u00b2 = 1 + 4 + 9 = 14"
              },
              {
                "input": "[]int{2, 4}",
                "output": "20",
                "note": "2\u00b2 + 4\u00b2 = 4 + 16 = 20"
              }
            ],
            "hints": [
              {
                "title": "\ud83e\udd14 Think about it",
                "content": "This is accumulator pattern, but you need to transform each element before adding it. How do you square a number in Go?"
              },
              {
                "title": "\ud83d\udca1 Hint",
                "content": "Start with sum := 0. For each number, calculate its square (n * n) and add that to the sum."
              },
              {
                "title": "\ud83d\udd27 Pattern",
                "content": "<pre>1. sum := 0\n2. For each num:\n   - square := num * num\n   - sum += square\n3. Return sum</pre>"
              }
            ],
            "solution": "func sumOfSquares(nums []int) int {\n    sum := 0\n    for _, n := range nums {\n        sum += n * n\n    }\n    return sum\n}"
          },
          {
            "id": "v8",
            "title": "Weighted Sum",
            "difficulty": 3,
            "description": "Write <code>func weightedSum(values []int, weights []int) int</code> that returns the sum of values[i] \u00d7 weights[i]. Assume both slices have the same length.",
            "functionSignature": "func weightedSum(values []int, weights []int) int",
            "testCases": [
              {
                "input": "[]int{10, 20, 30}, []int{1, 2, 3}",
                "output": "140",
                "note": "10\u00d71 + 20\u00d72 + 30\u00d73 = 10 + 40 + 90 = 140"
              },
              {
                "input": "[]int{5, 5, 5}, []int{1, 2, 3}",
                "output": "30",
                "note": "5\u00d71 + 5\u00d72 + 5\u00d73 = 5 + 10 + 15 = 30"
              }
            ],
            "hints": [
              {
                "title": "\ud83e\udd14 Think about it",
                "content": "You're working with TWO slices, but they have the same length. How do you access corresponding elements from both?"
              },
              {
                "title": "\ud83d\udca1 Hint",
                "content": "You can use range with index: for i := range values. Then access values[i] and weights[i] to multiply them together."
              },
              {
                "title": "\ud83d\udd27 Pattern",
                "content": "<pre>1. sum := 0\n2. For i from 0 to len(values):\n   - sum += values[i] * weights[i]\n3. Return sum</pre>"
              }
            ],
            "solution": "func weightedSum(values []int, weights []int) int {\n    sum := 0\n    for i := range values {\n        sum += values[i] * weights[i]\n    }\n    return sum\n}"
          },
          {
            "id": "v9",
            "title": "Alternating Sum",
            "difficulty": 2,
            "description": "Write <code>func alternatingSum(nums []int) int</code> that returns nums[0] - nums[1] + nums[2] - nums[3] + ... (alternate adding and subtracting).",
            "functionSignature": "func alternatingSum(nums []int) int",
            "testCases": [
              {
                "input": "[]int{10, 5, 3, 2}",
                "output": "6",
                "note": "10 - 5 + 3 - 2 = 6"
              },
              {
                "input": "[]int{1, 2, 3}",
                "output": "2",
                "note": "1 - 2 + 3 = 2"
              }
            ],
            "hints": [
              {
                "title": "\ud83e\udd14 Think about it",
                "content": "The operation alternates based on position. How can you tell if an index is even or odd?"
              },
              {
                "title": "\ud83d\udca1 Hint",
                "content": "Use the index! Even indices (0, 2, 4...) are added, odd indices (1, 3, 5...) are subtracted. Check i % 2 == 0."
              },
              {
                "title": "\ud83d\udd27 Pattern",
                "content": "<pre>1. sum := 0\n2. For i, num in enumerate:\n   - If i is even: sum += num\n   - If i is odd: sum -= num\n3. Return sum</pre>"
              }
            ],
            "solution": "func alternatingSum(nums []int) int {\n    sum := 0\n    for i, n := range nums {\n        if i%2 == 0 {\n            sum += n\n        } else {\n            sum -= n\n        }\n    }\n    return sum\n}"
          },
          {
            "id": "v10",
            "title": "Total Revenue",
            "description": "Write <code>func totalRevenue(sales []float64, taxRate float64) float64</code> that sums all sales including tax.",
            "functionSignature": "func totalRevenue(sales []float64, taxRate float64) float64",
            "testCases": [
              {
                "input": "[]float64{100.0, 200.0, 50.0}, 0.08",
                "output": "378.0",
                "note": "350 * 1.08"
              },
              {
                "input": "[]float64{25.0, 75.0}, 0.10",
                "output": "110.0"
              }
            ],
            "hints": [
              {
                "title": "\ud83e\udd14 Think about it",
                "content": "First sum all sales, then add tax to the total: total * (1 + taxRate)."
              },
              {
                "title": "\ud83d\udca1 Hint",
                "content": "Accumulate sum, then multiply by (1 + taxRate) at the end."
              },
              {
                "title": "\ud83d\udd27 Pattern",
                "content": "<pre>1. sum := 0.0\n2. For each sale:\n   - sum += sale\n3. Return sum * (1 + taxRate)</pre>"
              }
            ],
            "solution": "func totalRevenue(sales []float64, taxRate float64) float64 {\n    sum := 0.0\n    for _, sale := range sales {\n        sum += sale\n    }\n    return sum * (1 + taxRate)\n}",
            "difficulty": 2
          },
          {
            "id": "v11",
            "title": "Dice Total",
            "description": "Write <code>func diceTotal(rolls []int) int</code> that sums dice rolls and returns -1 if any roll is invalid (not 1-6).",
            "functionSignature": "func diceTotal(rolls []int) int",
            "testCases": [
              {
                "input": "[]int{6, 3, 4, 2}",
                "output": "15"
              },
              {
                "input": "[]int{6, 7, 4}",
                "output": "-1",
                "note": "7 is invalid"
              }
            ],
            "hints": [
              {
                "title": "\ud83e\udd14 Think about it",
                "content": "Check validity while accumulating. If any roll is outside 1-6, return -1 immediately."
              },
              {
                "title": "\ud83d\udca1 Hint",
                "content": "As you sum, check each roll. Use early return for invalid rolls."
              },
              {
                "title": "\ud83d\udd27 Pattern",
                "content": "<pre>1. sum := 0\n2. For each roll:\n   - roll < 1 OR roll > 6? \u2192 return -1\n   - sum += roll\n3. Return sum</pre>"
              }
            ],
            "solution": "func diceTotal(rolls []int) int {\n    sum := 0\n    for _, roll := range rolls {\n        if roll < 1 || roll > 6 { return -1 }\n        sum += roll\n    }\n    return sum\n}",
            "difficulty": 2
          },
          {
            "id": "v12",
            "title": "Compound Interest",
            "description": "Write <code>func compoundInterest(deposits []float64, rate float64) float64</code> that calculates compound interest where each deposit earns interest at rate (as decimal) per period. Process deposits in order, adding interest to running balance before adding next deposit.",
            "functionSignature": "func compoundInterest(deposits []float64, rate float64) float64",
            "testCases": [
              {
                "input": "[]float64{100.0, 100.0}, 0.10",
                "output": "221.0",
                "note": "Period 1: 100. Period 2: 100*1.1 + 100 = 210. Final: 210*1.1 = 231 (approx)"
              },
              {
                "input": "[]float64{1000.0}, 0.05",
                "output": "1050.0"
              }
            ],
            "hints": [
              {
                "title": "\ud83e\udd14 Think about it",
                "content": "Each period, you apply interest to the current balance, then add the new deposit."
              },
              {
                "title": "\ud83d\udca1 Hint",
                "content": "Keep a running balance. For each deposit: balance = balance * (1 + rate), then balance += deposit."
              },
              {
                "title": "\ud83d\udd27 Pattern",
                "content": "<pre>1. balance := 0.0\n2. For each deposit:\n   - balance *= (1 + rate)\n   - balance += deposit\n3. Return balance</pre>"
              }
            ],
            "solution": "func compoundInterest(deposits []float64, rate float64) float64 {\n    balance := 0.0\n    for _, deposit := range deposits {\n        balance = balance * (1 + rate)\n        balance += deposit\n    }\n    return balance\n}",
            "difficulty": 3
          },
          {
            "id": "v13",
            "title": "Running Max Product",
            "description": "Write <code>func runningMaxProduct(nums []int) []int</code> that returns a slice where each element is the maximum product of any two consecutive elements seen so far (including current position).",
            "functionSignature": "func runningMaxProduct(nums []int) []int",
            "testCases": [
              {
                "input": "[]int{1, 2, 3, 4}",
                "output": "[]int{0, 2, 6, 12}",
                "note": "Position 0: no pair (0), Pos 1: max(1*2)=2, Pos 2: max(1*2, 2*3)=6, Pos 3: max(1*2, 2*3, 3*4)=12"
              },
              {
                "input": "[]int{5, 1, 3, 2}",
                "output": "[]int{0, 5, 5, 6}"
              }
            ],
            "hints": [
              {
                "title": "\ud83e\udd14 Think about it",
                "content": "At each position, you need to track the maximum product of consecutive pairs seen up to that point."
              },
              {
                "title": "\ud83d\udca1 Hint",
                "content": "Keep track of maxProduct as you go. At position i, calculate nums[i-1]*nums[i] and update maxProduct if it's larger."
              },
              {
                "title": "\ud83d\udd27 Pattern",
                "content": "<pre>1. result := []int{0}, maxProduct := 0\n2. For i from 1 to len:\n   - product := nums[i-1] * nums[i]\n   - if product > maxProduct: maxProduct = product\n   - append maxProduct to result\n3. Return result</pre>"
              }
            ],
            "solution": "func runningMaxProduct(nums []int) []int {\n    result := []int{0}\n    maxProduct := 0\n    for i := 1; i < len(nums); i++ {\n        product := nums[i-1] * nums[i]\n        if product > maxProduct {\n            maxProduct = product\n        }\n        result = append(result, maxProduct)\n    }\n    return result\n}",
            "difficulty": 3
          }
        ]
      },
      {
        "id": "challenge_2",
        "block": 1,
        "difficulty": 1,
        "concept": "Conditional Counter",
        "docLinks": [
          {
            "url": "https://go.dev/ref/spec#If_statements",
            "title": "Go Spec: If statements",
            "note": "conditionals"
          },
          {
            "url": "https://go.dev/ref/spec#Arithmetic_operators",
            "title": "Go Spec: Arithmetic operators",
            "note": "% modulo operator"
          }
        ],
        "patternPrimer": {
          "bruteForce": "Loop through, check condition for each element, increment counter.",
          "bestApproach": "Same approach - this is already optimal! Just loop once and count matches.",
          "typical": "Typically O(n) time, O(1) extra space"
        },
        "variants": [
          {
            "id": "v1",
            "title": "Count Evens",
            "description": "Write <code>func countEvens(nums []int) int</code> that counts even numbers.",
            "functionSignature": "func countEvens(nums []int) int",
            "testCases": [
              {
                "input": "[]int{1, 2, 3, 4, 5, 6}",
                "output": "3"
              }
            ],
            "hints": [
              {
                "title": "\ud83e\udd14 Think about it",
                "content": "You need to count things that meet a condition. What two pieces do you need: one to track the count, and one to check each element?"
              },
              {
                "title": "\ud83d\udca1 Hint",
                "content": "Start a counter at 0. For each element, check your condition - if true, increment the counter."
              },
              {
                "title": "\ud83d\udd27 Pattern",
                "content": "<pre>1. Start counter at 0\n2. For each element:\n   - Meets condition? \u2192 increment counter\n3. Return counter</pre>"
              }
            ],
            "solution": "func countEvens(nums []int) int {\n    count := 0\n    for _, num := range nums {\n        if num%2 == 0 {\n            count++\n        }\n    }\n    return count\n}",
            "difficulty": 1
          },
          {
            "id": "v2",
            "title": "Count Negatives",
            "description": "Write <code>func countNegatives(nums []int) int</code> that counts negative numbers.",
            "functionSignature": "func countNegatives(nums []int) int",
            "testCases": [
              {
                "input": "[]int{-1, 2, -3, 4}",
                "output": "2"
              }
            ],
            "hints": [
              {
                "title": "\ud83e\udd14 Think about it",
                "content": "You need to count things that meet a condition. What two pieces do you need: one to track the count, and one to check each element?"
              },
              {
                "title": "\ud83d\udca1 Hint",
                "content": "Start a counter at 0. For each element, check your condition - if true, increment the counter."
              },
              {
                "title": "\ud83d\udd27 Pattern",
                "content": "<pre>1. Start counter at 0\n2. For each element:\n   - Meets condition? \u2192 increment counter\n3. Return counter</pre>"
              }
            ],
            "solution": "func countNegatives(nums []int) int {\n    count := 0\n    for _, num := range nums {\n        if num < 0 {\n            count++\n        }\n    }\n    return count\n}",
            "difficulty": 1
          },
          {
            "id": "v3",
            "title": "Count Passing Scores",
            "description": "Write <code>func countPassing(scores []int, threshold int) int</code> that counts scores >= threshold.",
            "functionSignature": "func countPassing(scores []int, threshold int) int",
            "testCases": [
              {
                "input": "[]int{55, 72, 68, 90, 45}, 60",
                "output": "3"
              }
            ],
            "hints": [
              {
                "title": "\ud83e\udd14 Think about it",
                "content": "You need to count things that meet a condition. What two pieces do you need: one to track the count, and one to check each element?"
              },
              {
                "title": "\ud83d\udca1 Hint",
                "content": "Start a counter at 0. For each element, check your condition - if true, increment the counter."
              },
              {
                "title": "\ud83d\udd27 Pattern",
                "content": "<pre>1. Start counter at 0\n2. For each element:\n   - Meets condition? \u2192 increment counter\n3. Return counter</pre>"
              }
            ],
            "solution": "func countPassing(scores []int, threshold int) int {\n    count := 0\n    for _, score := range scores {\n        if score >= threshold {\n            count++\n        }\n    }\n    return count\n}",
            "difficulty": 1
          },
          {
            "id": "v4",
            "title": "Count Divisible By",
            "description": "Write <code>func countDivisible(nums []int, d int) int</code> that counts numbers divisible by d.",
            "functionSignature": "func countDivisible(nums []int, d int) int",
            "testCases": [
              {
                "input": "[]int{3, 6, 7, 9, 12}, 3",
                "output": "4",
                "note": "3, 6, 9, 12 are divisible by 3"
              },
              {
                "input": "[]int{1, 2, 3, 4, 5}, 2",
                "output": "2"
              }
            ],
            "hints": [
              {
                "title": "\ud83e\udd14 Think about it",
                "content": "How do you check if a number is divisible by another? What operation gives you the remainder?"
              },
              {
                "title": "\ud83d\udca1 Hint",
                "content": "Use the modulo operator: num % d == 0 means num is divisible by d."
              },
              {
                "title": "\ud83d\udd27 Pattern",
                "content": "<pre>1. count := 0\n2. For each num:\n   - num % d == 0? \u2192 count++\n3. Return count</pre>"
              }
            ],
            "solution": "func countDivisible(nums []int, d int) int {\n    count := 0\n    for _, n := range nums {\n        if n % d == 0 { count++ }\n    }\n    return count\n}",
            "difficulty": 1
          },
          {
            "id": "v5",
            "title": "Count Long Words",
            "description": "Write <code>func countLongWords(words []string, minLen int) int</code> that counts words with length >= minLen.",
            "functionSignature": "func countLongWords(words []string, minLen int) int",
            "testCases": [
              {
                "input": "[]string{\"go\", \"python\", \"rust\", \"c\"}, 4",
                "output": "2",
                "note": "python and rust have len >= 4"
              },
              {
                "input": "[]string{\"a\", \"ab\", \"abc\"}, 2",
                "output": "2"
              }
            ],
            "hints": [
              {
                "title": "\ud83e\udd14 Think about it",
                "content": "Same counting pattern, just checking string length instead of numeric value."
              },
              {
                "title": "\ud83d\udca1 Hint",
                "content": "Use len(word) >= minLen as your condition."
              },
              {
                "title": "\ud83d\udd27 Pattern",
                "content": "<pre>1. count := 0\n2. For each word:\n   - len(word) >= minLen? \u2192 count++\n3. Return count</pre>"
              }
            ],
            "solution": "func countLongWords(words []string, minLen int) int {\n    count := 0\n    for _, w := range words {\n        if len(w) >= minLen { count++ }\n    }\n    return count\n}",
            "difficulty": 1
          },
          {
            "id": "v6",
            "title": "Count In Range",
            "description": "Write <code>func countInRange(nums []int, min, max int) int</code> that counts numbers where min <= num <= max.",
            "functionSignature": "func countInRange(nums []int, min, max int) int",
            "testCases": [
              {
                "input": "[]int{1, 5, 10, 15, 20}, 5, 15",
                "output": "3",
                "note": "5, 10, 15 are in range"
              },
              {
                "input": "[]int{1, 2, 3, 4, 5}, 2, 4",
                "output": "3"
              }
            ],
            "hints": [
              {
                "title": "\ud83e\udd14 Think about it",
                "content": "You need to check TWO conditions: num >= min AND num <= max."
              },
              {
                "title": "\ud83d\udca1 Hint",
                "content": "Combine conditions with &&: if num >= min && num <= max."
              },
              {
                "title": "\ud83d\udd27 Pattern",
                "content": "<pre>1. count := 0\n2. For each num:\n   - num >= min && num <= max? \u2192 count++\n3. Return count</pre>"
              }
            ],
            "solution": "func countInRange(nums []int, min, max int) int {\n    count := 0\n    for _, n := range nums {\n        if n >= min && n <= max { count++ }\n    }\n    return count\n}",
            "difficulty": 2
          },
          {
            "id": "v7",
            "title": "Count Prime Numbers",
            "difficulty": 3,
            "description": "Write <code>func countPrimes(nums []int) int</code> that counts how many prime numbers are in the slice. A prime number is greater than 1 and only divisible by 1 and itself.",
            "functionSignature": "func countPrimes(nums []int) int",
            "testCases": [
              {
                "input": "[]int{2, 3, 4, 5, 6, 7}",
                "output": "4",
                "note": "2, 3, 5, 7 are prime"
              },
              {
                "input": "[]int{1, 4, 6, 8, 9}",
                "output": "0",
                "note": "No primes"
              }
            ],
            "hints": [
              {
                "title": "\ud83e\udd14 Think about it",
                "content": "Checking if a number is prime requires nested logic. For each number, you need to check if any number from 2 to n-1 divides it evenly."
              },
              {
                "title": "\ud83d\udca1 Hint",
                "content": "Create a helper function isPrime(n int) bool. A number is prime if it's > 1 and no number from 2 to sqrt(n) divides it evenly. Then count how many numbers pass the isPrime test."
              },
              {
                "title": "\ud83d\udd27 Pattern",
                "content": "<pre>1. count := 0\n2. For each num:\n   - If isPrime(num): count++\n3. Return count\n\nisPrime(n):\n  - If n <= 1: return false\n  - For i from 2 to sqrt(n):\n    - If n % i == 0: return false\n  - return true</pre>"
              }
            ],
            "solution": "func countPrimes(nums []int) int {\n    count := 0\n    for _, n := range nums {\n        if isPrime(n) {\n            count++\n        }\n    }\n    return count\n}\n\nfunc isPrime(n int) bool {\n    if n <= 1 {\n        return false\n    }\n    for i := 2; i*i <= n; i++ {\n        if n%i == 0 {\n            return false\n        }\n    }\n    return true\n}"
          },
          {
            "id": "v8",
            "title": "Count Words Starting With Vowel",
            "difficulty": 2,
            "description": "Write <code>func countVowelStart(words []string) int</code> that counts how many words start with a vowel (a, e, i, o, u). Use lowercase comparison.",
            "functionSignature": "func countVowelStart(words []string) int",
            "testCases": [
              {
                "input": "[]string{\"apple\", \"banana\", \"orange\", \"grape\"}",
                "output": "2",
                "note": "apple and orange start with vowels"
              },
              {
                "input": "[]string{\"Go\", \"is\", \"awesome\"}",
                "output": "2",
                "note": "is and awesome start with vowels"
              }
            ],
            "hints": [
              {
                "title": "\ud83e\udd14 Think about it",
                "content": "You need to check the first character of each word. How do you get the first character, and how do you check if it's in the set {a, e, i, o, u}?"
              },
              {
                "title": "\ud83d\udca1 Hint",
                "content": "Use strings.ToLower() to convert to lowercase, then check if word[0] is one of the vowel bytes. You can use multiple OR conditions, or create a helper function."
              },
              {
                "title": "\ud83d\udd27 Pattern",
                "content": "<pre>1. count := 0\n2. For each word:\n   - Get first character (lowercase)\n   - If it's a, e, i, o, or u: count++\n3. Return count</pre>"
              }
            ],
            "solution": "func countVowelStart(words []string) int {\n    count := 0\n    for _, word := range words {\n        if len(word) > 0 {\n            first := strings.ToLower(string(word[0]))\n            if first == \"a\" || first == \"e\" || first == \"i\" || first == \"o\" || first == \"u\" {\n                count++\n            }\n        }\n    }\n    return count\n}"
          },
          {
            "id": "v9",
            "title": "Three Letter Words",
            "description": "Write <code>func threeLetterWords(words []string) int</code> that counts words with exactly 3 letters.",
            "functionSignature": "func threeLetterWords(words []string) int",
            "testCases": [
              {
                "input": "[]string{\"cat\", \"dog\", \"elephant\", \"bat\"}",
                "output": "3"
              },
              {
                "input": "[]string{\"hello\", \"world\"}",
                "output": "0"
              }
            ],
            "hints": [
              {
                "title": "\ud83e\udd14 Think about it",
                "content": "Count words where len(word) == 3."
              },
              {
                "title": "\ud83d\udca1 Hint",
                "content": "Simple counter with condition: if len(word) == 3, count++"
              },
              {
                "title": "\ud83d\udd27 Pattern",
                "content": "<pre>1. count := 0\n2. For each word:\n   - len(word) == 3? \u2192 count++\n3. Return count</pre>"
              }
            ],
            "solution": "func threeLetterWords(words []string) int {\n    count := 0\n    for _, word := range words {\n        if len(word) == 3 { count++ }\n    }\n    return count\n}",
            "difficulty": 1
          },
          {
            "id": "v10",
            "title": "Temperature Extremes",
            "description": "Write <code>func tempExtremes(temps []int) int</code> that counts how many temps are below 0 or above 100.",
            "functionSignature": "func tempExtremes(temps []int) int",
            "testCases": [
              {
                "input": "[]int{-5, 50, 105, 25, -10}",
                "output": "3"
              },
              {
                "input": "[]int{20, 30, 40}",
                "output": "0"
              }
            ],
            "hints": [
              {
                "title": "\ud83e\udd14 Think about it",
                "content": "Count temperatures that are < 0 OR > 100."
              },
              {
                "title": "\ud83d\udca1 Hint",
                "content": "if temp < 0 || temp > 100, increment count."
              },
              {
                "title": "\ud83d\udd27 Pattern",
                "content": "<pre>1. count := 0\n2. For each temp:\n   - temp < 0 OR temp > 100? \u2192 count++\n3. Return count</pre>"
              }
            ],
            "solution": "func tempExtremes(temps []int) int {\n    count := 0\n    for _, temp := range temps {\n        if temp < 0 || temp > 100 { count++ }\n    }\n    return count\n}",
            "difficulty": 1
          },
          {
            "id": "v11",
            "title": "Count By Multiple Criteria",
            "description": "Write <code>func countByCriteria(words []string, minLen, maxLen int, mustContain string) int</code> that counts words where length is between minLen and maxLen (inclusive) AND the word contains the substring mustContain.",
            "functionSignature": "func countByCriteria(words []string, minLen, maxLen int, mustContain string) int",
            "testCases": [
              {
                "input": "[\"hello\", \"world\", \"hi\", \"help\"], 4, 6, \"el\"",
                "output": "2",
                "note": "hello and help both have length 4-5 and contain 'el'"
              },
              {
                "input": "[\"go\", \"gopher\", \"golang\", \"rust\"], 2, 6, \"go\"",
                "output": "3",
                "note": "go, gopher, golang all contain 'go' and fit length constraint"
              }
            ],
            "hints": [
              {
                "title": "\ud83e\udd14 Think about it",
                "content": "You need to check THREE conditions for each word: minimum length, maximum length, and contains substring. Use strings.Contains() to check for substring."
              },
              {
                "title": "\ud83d\udca1 Hint",
                "content": "Import strings package. For each word, check: len(word) >= minLen AND len(word) <= maxLen AND strings.Contains(word, mustContain). Only count if all three are true."
              },
              {
                "title": "\ud83d\udd27 Pattern",
                "content": "<pre>1. count := 0\n2. For each word:\n   - length in range? AND\n   - contains substring?\n   - Both true? \u2192 count++\n3. Return count</pre>"
              }
            ],
            "solution": "import \"strings\"\n\nfunc countByCriteria(words []string, minLen, maxLen int, mustContain string) int {\n    count := 0\n    for _, word := range words {\n        if len(word) >= minLen && len(word) <= maxLen && strings.Contains(word, mustContain) {\n            count++\n        }\n    }\n    return count\n}",
            "difficulty": 3
          },
          {
            "id": "v12",
            "title": "Count Valid Pairs",
            "description": "Write <code>func countValidPairs(nums []int, targetSum int) int</code> that counts how many pairs of adjacent elements sum to targetSum.",
            "functionSignature": "func countValidPairs(nums []int, targetSum int) int",
            "testCases": [
              {
                "input": "[]int{1, 4, 3, 2, 5}, 5",
                "output": "2",
                "note": "pairs (1,4) and (3,2) both sum to 5"
              },
              {
                "input": "[]int{2, 3, 2, 3}, 5",
                "output": "3",
                "note": "all three adjacent pairs (2,3), (3,2), (2,3) sum to 5"
              }
            ],
            "hints": [
              {
                "title": "\ud83e\udd14 Think about it",
                "content": "You need to look at each pair of consecutive elements. For position i, check if nums[i] + nums[i+1] equals targetSum."
              },
              {
                "title": "\ud83d\udca1 Hint",
                "content": "Loop from i=0 to len(nums)-2 (so i+1 is valid). For each i, check if nums[i] + nums[i+1] == targetSum."
              },
              {
                "title": "\ud83d\udd27 Pattern",
                "content": "<pre>1. count := 0\n2. For i from 0 to len-2:\n   - nums[i] + nums[i+1] == target?\n   - Yes \u2192 count++\n3. Return count</pre>"
              }
            ],
            "solution": "func countValidPairs(nums []int, targetSum int) int {\n    count := 0\n    for i := 0; i < len(nums)-1; i++ {\n        if nums[i] + nums[i+1] == targetSum {\n            count++\n        }\n    }\n    return count\n}",
            "difficulty": 3
          },
          {
            "id": "v13",
            "title": "Count Pattern Match",
            "description": "Write <code>func countPatternMatch(words []string, prefix, suffix string) int</code> that counts words that start with prefix AND end with suffix.",
            "functionSignature": "func countPatternMatch(words []string, prefix, suffix string) int",
            "testCases": [
              {
                "input": "[\"hello\", \"hero\", \"hermit\", \"world\"], \"he\", \"o\"",
                "output": "2",
                "note": "hello and hero both start with 'he' and end with 'o'"
              },
              {
                "input": "[\"testing\", \"resting\", \"test\", \"ing\"], \"test\", \"ing\"",
                "output": "1",
                "note": "only 'testing' starts with 'test' and ends with 'ing'"
              }
            ],
            "hints": [
              {
                "title": "\ud83e\udd14 Think about it",
                "content": "Use strings.HasPrefix() and strings.HasSuffix() to check both ends of each word. Count only if both conditions are true."
              },
              {
                "title": "\ud83d\udca1 Hint",
                "content": "Import strings package. For each word: if strings.HasPrefix(word, prefix) && strings.HasSuffix(word, suffix), increment count."
              },
              {
                "title": "\ud83d\udd27 Pattern",
                "content": "<pre>1. count := 0\n2. For each word:\n   - starts with prefix? AND\n   - ends with suffix?\n   - Both true? \u2192 count++\n3. Return count</pre>"
              }
            ],
            "solution": "import \"strings\"\n\nfunc countPatternMatch(words []string, prefix, suffix string) int {\n    count := 0\n    for _, word := range words {\n        if strings.HasPrefix(word, prefix) && strings.HasSuffix(word, suffix) {\n            count++\n        }\n    }\n    return count\n}",
            "difficulty": 3
          },
          {
            "id": "v14",
            "title": "Count Words Starting With Letter",
            "description": "Write <code>func countStartsWith(words []string, letter rune) int</code> that counts words starting with the given letter (case-insensitive).",
            "functionSignature": "func countStartsWith(words []string, letter rune) int",
            "testCases": [
              {
                "input": "[\"Hello\", \"world\", \"Hi\"], 'h'",
                "output": "2",
                "note": "Hello and Hi start with h (case-insensitive)"
              },
              {
                "input": "[\"Go\", \"Python\", \"Rust\", \"Go\"], 'g'",
                "output": "2"
              }
            ],
            "hints": [
              {
                "title": "\ud83e\udd14 Think about it",
                "content": "Check the first character of each word. Convert both to lowercase for case-insensitive comparison."
              },
              {
                "title": "\ud83d\udca1 Hint",
                "content": "Use strings.ToLower() on the first character. Get first rune with rune(word[0]) if word is non-empty."
              },
              {
                "title": "\ud83d\udd27 Pattern",
                "content": "<pre>1. count := 0\n2. For each word:\n   - Get first letter (lowercase)\n   - Matches target letter? \u2192 count++\n3. Return count</pre>"
              }
            ],
            "solution": "import \"strings\"\n\nfunc countStartsWith(words []string, letter rune) int {\n    count := 0\n    targetLower := strings.ToLower(string(letter))\n    \n    for _, word := range words {\n        if len(word) > 0 {\n            firstLetter := strings.ToLower(string(word[0]))\n            if firstLetter == targetLower {\n                count++\n            }\n        }\n    }\n    \n    return count\n}",
            "difficulty": 2
          },
          {
            "id": "v15",
            "title": "Count Between (Exclusive)",
            "description": "Write <code>func countBetween(nums []int, low, high int) int</code> that counts numbers strictly between low and high (exclusive on both ends: low < num < high).",
            "functionSignature": "func countBetween(nums []int, low, high int) int",
            "testCases": [
              {
                "input": "[]int{1, 5, 10, 15, 20}, 5, 15",
                "output": "1",
                "note": "only 10 is strictly between 5 and 15"
              },
              {
                "input": "[]int{1, 2, 3, 4, 5}, 1, 5",
                "output": "3",
                "note": "2, 3, 4 are between 1 and 5 (exclusive)"
              }
            ],
            "hints": [
              {
                "title": "\ud83e\udd14 Think about it",
                "content": "Exclusive means not including the boundaries. Check num > low AND num < high (not >= or <=)."
              },
              {
                "title": "\ud83d\udca1 Hint",
                "content": "Use strict inequality: if num > low && num < high, count it."
              },
              {
                "title": "\ud83d\udd27 Pattern",
                "content": "<pre>1. count := 0\n2. For each num:\n   - num > low AND num < high? \u2192 count++\n3. Return count</pre>"
              }
            ],
            "solution": "func countBetween(nums []int, low, high int) int {\n    count := 0\n    for _, num := range nums {\n        if num > low && num < high {\n            count++\n        }\n    }\n    return count\n}",
            "difficulty": 2
          }
        ]
      },
      {
        "id": "challenge_3",
        "block": 1,
        "difficulty": 1,
        "concept": "Branching Logic",
        "docLinks": [
          {
            "url": "https://go.dev/ref/spec#If_statements",
            "title": "Go Spec: If statements",
            "note": "else-if chains"
          },
          {
            "url": "https://go.dev/ref/spec#Comparison_operators",
            "title": "Go Spec: Comparison operators",
            "note": ">=, <, == etc."
          }
        ],
        "variants": [
          {
            "id": "v1",
            "title": "FizzBuzz",
            "description": "Print 1-20. Multiples of 3: \"Fizz\", 5: \"Buzz\", both: \"FizzBuzz\".",
            "functionSignature": "// loop",
            "testCases": [
              {
                "input": "15",
                "output": "FizzBuzz"
              }
            ],
            "hints": [
              {
                "title": "\ud83e\udd14 Think about it",
                "content": "When you have overlapping conditions (like a number divisible by both 3 AND 5), which case should you check first?"
              },
              {
                "title": "\ud83d\udca1 Hint",
                "content": "Check the most specific condition first! For FizzBuzz, 15 is divisible by both 3 and 5, so check for 15 before checking 3 or 5 individually."
              },
              {
                "title": "\ud83d\udd27 Pattern",
                "content": "<pre>1. Check most specific condition first\n2. Then check less specific conditions\n3. Default case last\n(Order matters: check \"both 3 AND 5\" before \"just 3\" or \"just 5\")</pre>"
              }
            ],
            "solution": "for i := 1; i <= 20; i++ {\n    if i%15 == 0 {\n        fmt.Println(\"FizzBuzz\")\n    } else if i%3 == 0 {\n        fmt.Println(\"Fizz\")\n    } else if i%5 == 0 {\n        fmt.Println(\"Buzz\")\n    } else {\n        fmt.Println(i)\n    }\n}",
            "difficulty": 2
          },
          {
            "id": "v2",
            "title": "Grade Classifier",
            "description": "Write <code>func grade(score int) string</code> returning A/B/C/D/F.",
            "functionSignature": "func grade(score int) string",
            "testCases": [
              {
                "input": "85",
                "output": "\"B\""
              }
            ],
            "hints": [
              {
                "title": "\ud83e\udd14 Think about it",
                "content": "When you have overlapping conditions (like a number divisible by both 3 AND 5), which case should you check first?"
              },
              {
                "title": "\ud83d\udca1 Hint",
                "content": "Check the most specific condition first! For FizzBuzz, 15 is divisible by both 3 and 5, so check for 15 before checking 3 or 5 individually."
              },
              {
                "title": "\ud83d\udd27 Pattern",
                "content": "<pre>1. Check most specific condition first\n2. Then check less specific conditions\n3. Default case last\n(Order matters: check \"both 3 AND 5\" before \"just 3\" or \"just 5\")</pre>"
              }
            ],
            "solution": "func grade(score int) string {\n    if score >= 90 { return \"A\" }\n    if score >= 80 { return \"B\" }\n    if score >= 70 { return \"C\" }\n    if score >= 60 { return \"D\" }\n    return \"F\"\n}",
            "difficulty": 1
          },
          {
            "id": "v3",
            "title": "Age Category",
            "description": "Write <code>func ageCategory(age int) string</code> returning \"infant\" (0-1), \"toddler\" (2-3), \"child\" (4-12), \"teen\" (13-19), or \"adult\" (20+).",
            "functionSignature": "func ageCategory(age int) string",
            "testCases": [
              {
                "input": "15",
                "output": "\"teen\""
              },
              {
                "input": "2",
                "output": "\"toddler\""
              }
            ],
            "hints": [
              {
                "title": "\ud83e\udd14 Think about it",
                "content": "When you have multiple age ranges to check, what order should you check them in to avoid incorrect matches?"
              },
              {
                "title": "\ud83d\udca1 Hint",
                "content": "Check ranges in ascending order using upper bounds. If age <= 1, it's infant. If age <= 3, it's toddler. And so on."
              },
              {
                "title": "\ud83d\udd27 Pattern",
                "content": "<pre>1. Check ranges in order from youngest to oldest\n2. Use upper bounds (<=) for each category\n3. Default to \"adult\" for 20+</pre>"
              }
            ],
            "solution": "func ageCategory(age int) string {\n    if age <= 1 { return \"infant\" }\n    if age <= 3 { return \"toddler\" }\n    if age <= 12 { return \"child\" }\n    if age <= 19 { return \"teen\" }\n    return \"adult\"\n}",
            "difficulty": 2
          },
          {
            "id": "v4",
            "title": "Number Sign",
            "description": "Write <code>func sign(n int) string</code> returning \"positive\", \"negative\", or \"zero\".",
            "functionSignature": "func sign(n int) string",
            "testCases": [
              {
                "input": "5",
                "output": "\"positive\""
              },
              {
                "input": "-3",
                "output": "\"negative\""
              },
              {
                "input": "0",
                "output": "\"zero\""
              }
            ],
            "hints": [
              {
                "title": "\ud83e\udd14 Think about it",
                "content": "Three cases: greater than 0, less than 0, or equal to 0."
              },
              {
                "title": "\ud83d\udca1 Hint",
                "content": "Check n > 0, then n < 0, else it's zero."
              },
              {
                "title": "\ud83d\udd27 Pattern",
                "content": "<pre>if n > 0 { return \"positive\" }\nif n < 0 { return \"negative\" }\nreturn \"zero\"</pre>"
              }
            ],
            "solution": "func sign(n int) string {\n    if n > 0 { return \"positive\" }\n    if n < 0 { return \"negative\" }\n    return \"zero\"\n}",
            "difficulty": 1
          },
          {
            "id": "v5",
            "title": "Ticket Price",
            "description": "Write <code>func ticketPrice(age int) int</code>: children (0-12) pay 5, teens (13-17) pay 8, adults (18-64) pay 12, seniors (65+) pay 7.",
            "functionSignature": "func ticketPrice(age int) int",
            "testCases": [
              {
                "input": "10",
                "output": "5"
              },
              {
                "input": "15",
                "output": "8"
              },
              {
                "input": "30",
                "output": "12"
              },
              {
                "input": "70",
                "output": "7"
              }
            ],
            "hints": [
              {
                "title": "\ud83e\udd14 Think about it",
                "content": "Multiple age ranges with different prices. Check from youngest to oldest."
              },
              {
                "title": "\ud83d\udca1 Hint",
                "content": "Use if-else chain checking upper bounds: <= 12, <= 17, <= 64, else senior."
              },
              {
                "title": "\ud83d\udd27 Pattern",
                "content": "<pre>if age <= 12 { return 5 }\nif age <= 17 { return 8 }\nif age <= 64 { return 12 }\nreturn 7</pre>"
              }
            ],
            "solution": "func ticketPrice(age int) int {\n    if age <= 12 { return 5 }\n    if age <= 17 { return 8 }\n    if age <= 64 { return 12 }\n    return 7\n}",
            "difficulty": 2
          },
          {
            "id": "v6",
            "title": "Shipping Cost",
            "description": "Write <code>func shippingCost(weight int) int</code>: 0-1kg costs 5, 2-5kg costs 10, 6-10kg costs 20, over 10kg costs 50.",
            "functionSignature": "func shippingCost(weight int) int",
            "testCases": [
              {
                "input": "1",
                "output": "5"
              },
              {
                "input": "3",
                "output": "10"
              },
              {
                "input": "8",
                "output": "20"
              },
              {
                "input": "15",
                "output": "50"
              }
            ],
            "hints": [
              {
                "title": "\ud83e\udd14 Think about it",
                "content": "Multiple weight brackets. Check from lightest to heaviest."
              },
              {
                "title": "\ud83d\udca1 Hint",
                "content": "Check upper bounds: <= 1, <= 5, <= 10, else heavy."
              },
              {
                "title": "\ud83d\udd27 Pattern",
                "content": "<pre>if weight <= 1 { return 5 }\nif weight <= 5 { return 10 }\nif weight <= 10 { return 20 }\nreturn 50</pre>"
              }
            ],
            "solution": "func shippingCost(weight int) int {\n    if weight <= 1 { return 5 }\n    if weight <= 5 { return 10 }\n    if weight <= 10 { return 20 }\n    return 50\n}",
            "difficulty": 2
          },
          {
            "id": "v7",
            "title": "Tax Bracket Calculator",
            "difficulty": 3,
            "description": "Write <code>func calculateTax(income int) int</code>. Tax brackets: 0-10k: 0%, 10k-50k: 10%, 50k-100k: 20%, 100k+: 30%. Calculate progressive tax (each bracket taxed at its rate).",
            "functionSignature": "func calculateTax(income int) int",
            "testCases": [
              {
                "input": "15000",
                "output": "500",
                "note": "First 10k: 0, next 5k at 10% = 500"
              },
              {
                "input": "60000",
                "output": "6000",
                "note": "10k@0% + 40k@10% + 10k@20% = 0 + 4000 + 2000 = 6000"
              },
              {
                "input": "5000",
                "output": "0",
                "note": "All in 0% bracket"
              }
            ],
            "hints": [
              {
                "title": "\ud83e\udd14 Think about it",
                "content": "This is NOT a simple if-else! Each bracket taxes only the portion of income in that range. Someone earning 60k pays 10% on the middle 40k, not on all 60k."
              },
              {
                "title": "\ud83d\udca1 Hint",
                "content": "Calculate tax bracket by bracket. For each bracket, determine how much income falls in it (min of remaining income and bracket size), multiply by rate, add to total tax."
              },
              {
                "title": "\ud83d\udd27 Pattern",
                "content": "<pre>1. tax := 0, remaining := income\n2. First bracket (0-10k at 0%):\n   - amount = min(remaining, 10000)\n   - tax += amount * 0.0\n   - remaining -= amount\n3. Repeat for each bracket\n4. Return tax</pre>"
              }
            ],
            "solution": "func calculateTax(income int) int {\n    if income <= 10000 {\n        return 0\n    }\n    tax := 0\n    if income > 10000 {\n        taxable := income - 10000\n        if taxable > 40000 {\n            taxable = 40000\n        }\n        tax += taxable * 10 / 100\n    }\n    if income > 50000 {\n        taxable := income - 50000\n        if taxable > 50000 {\n            taxable = 50000\n        }\n        tax += taxable * 20 / 100\n    }\n    if income > 100000 {\n        tax += (income - 100000) * 30 / 100\n    }\n    return tax\n}"
          },
          {
            "id": "v8",
            "title": "Rock Paper Scissors",
            "difficulty": 2,
            "description": "Write <code>func rps(p1, p2 string) string</code> that takes \"rock\", \"paper\", or \"scissors\" and returns \"p1\", \"p2\", or \"tie\".",
            "functionSignature": "func rps(p1, p2 string) string",
            "testCases": [
              {
                "input": "\"rock\", \"scissors\"",
                "output": "\"p1\"",
                "note": "Rock beats scissors"
              },
              {
                "input": "\"paper\", \"rock\"",
                "output": "\"p1\"",
                "note": "Paper beats rock"
              },
              {
                "input": "\"rock\", \"rock\"",
                "output": "\"tie\""
              },
              {
                "input": "\"scissors\", \"paper\"",
                "output": "\"p1\""
              }
            ],
            "hints": [
              {
                "title": "\ud83e\udd14 Think about it",
                "content": "There are 9 possible combinations (3\u00d73), but some simplify. Check for tie first, then you have 6 win cases to check."
              },
              {
                "title": "\ud83d\udca1 Hint",
                "content": "First check if p1 == p2 (tie). Then check the three cases where p1 wins: (rock, scissors), (paper, rock), (scissors, paper). Otherwise p2 wins."
              },
              {
                "title": "\ud83d\udd27 Pattern",
                "content": "<pre>1. If p1 == p2: return \"tie\"\n2. If (p1==rock && p2==scissors) OR\n      (p1==paper && p2==rock) OR\n      (p1==scissors && p2==paper):\n      return \"p1\"\n3. Else: return \"p2\"</pre>"
              }
            ],
            "solution": "func rps(p1, p2 string) string {\n    if p1 == p2 {\n        return \"tie\"\n    }\n    if (p1 == \"rock\" && p2 == \"scissors\") ||\n       (p1 == \"paper\" && p2 == \"rock\") ||\n       (p1 == \"scissors\" && p2 == \"paper\") {\n        return \"p1\"\n    }\n    return \"p2\"\n}"
          },
          {
            "id": "v9",
            "title": "Rating Categories",
            "description": "Write <code>func ratingCategory(rating int) string</code>: \"Poor\" (0-2), \"Fair\" (3-5), \"Good\" (6-8), \"Excellent\" (9-10).",
            "functionSignature": "func ratingCategory(rating int) string",
            "testCases": [
              {
                "input": "8",
                "output": "\"Good\""
              },
              {
                "input": "10",
                "output": "\"Excellent\""
              },
              {
                "input": "1",
                "output": "\"Poor\""
              }
            ],
            "hints": [
              {
                "title": "\ud83e\udd14 Think about it",
                "content": "Use if-else chain to check ranges. Order matters - check highest first or use <= appropriately."
              },
              {
                "title": "\ud83d\udca1 Hint",
                "content": "if rating <= 2 return \"Poor\", else if rating <= 5 return \"Fair\", etc."
              },
              {
                "title": "\ud83d\udd27 Pattern",
                "content": "<pre>if rating <= 2: Poor\nelse if rating <= 5: Fair\nelse if rating <= 8: Good\nelse: Excellent</pre>"
              }
            ],
            "solution": "func ratingCategory(rating int) string {\n    if rating <= 2 { return \"Poor\" }\n    if rating <= 5 { return \"Fair\" }\n    if rating <= 8 { return \"Good\" }\n    return \"Excellent\"\n}",
            "difficulty": 2
          },
          {
            "id": "v10",
            "title": "Message Priority",
            "description": "Write <code>func messagePriority(msg string) string</code>: \"URGENT\" if contains \"ASAP\", \"High\" if starts with \"Important\", else \"Normal\".",
            "functionSignature": "func messagePriority(msg string) string",
            "testCases": [
              {
                "input": "\"Please reply ASAP\"",
                "output": "\"URGENT\""
              },
              {
                "input": "\"Important meeting tomorrow\"",
                "output": "\"High\""
              },
              {
                "input": "\"Hello there\"",
                "output": "\"Normal\""
              }
            ],
            "hints": [
              {
                "title": "\ud83e\udd14 Think about it",
                "content": "Check for \"ASAP\" first (most urgent), then check prefix, otherwise default to Normal."
              },
              {
                "title": "\ud83d\udca1 Hint",
                "content": "Use strings.Contains() for ASAP, strings.HasPrefix() for Important."
              },
              {
                "title": "\ud83d\udd27 Pattern",
                "content": "<pre>if contains \"ASAP\": URGENT\nelse if starts with \"Important\": High\nelse: Normal</pre>"
              }
            ],
            "solution": "func messagePriority(msg string) string {\n    if strings.Contains(msg, \"ASAP\") { return \"URGENT\" }\n    if strings.HasPrefix(msg, \"Important\") { return \"High\" }\n    return \"Normal\"\n}",
            "difficulty": 2
          },
          {
            "id": "v11",
            "title": "BMI Category",
            "description": "Write <code>func bmiCategory(bmi float64) string</code> returning \"Underweight\" (bmi < 18.5), \"Normal\" (18.5-24.9), \"Overweight\" (25-29.9), or \"Obese\" (30+).",
            "functionSignature": "func bmiCategory(bmi float64) string",
            "testCases": [
              {
                "input": "22.5",
                "output": "\"Normal\""
              },
              {
                "input": "17.0",
                "output": "\"Underweight\""
              },
              {
                "input": "31.5",
                "output": "\"Obese\""
              }
            ],
            "hints": [
              {
                "title": "\ud83e\udd14 Think about it",
                "content": "Multiple ranges to check. What order should you check them to avoid incorrect matches?"
              },
              {
                "title": "\ud83d\udca1 Hint",
                "content": "Check from lowest to highest using upper bounds: if bmi < 18.5, if bmi < 25, if bmi < 30, else."
              },
              {
                "title": "\ud83d\udd27 Pattern",
                "content": "<pre>if bmi < 18.5 { return \"Underweight\" }\nif bmi < 25 { return \"Normal\" }\nif bmi < 30 { return \"Overweight\" }\nreturn \"Obese\"</pre>"
              }
            ],
            "solution": "func bmiCategory(bmi float64) string {\n    if bmi < 18.5 { return \"Underweight\" }\n    if bmi < 25 { return \"Normal\" }\n    if bmi < 30 { return \"Overweight\" }\n    return \"Obese\"\n}",
            "difficulty": 1
          },
          {
            "id": "v12",
            "title": "Water State",
            "description": "Write <code>func waterState(temp int) string</code> returning \"ice\" (temp <= 0), \"water\" (1-99), or \"steam\" (temp >= 100). Temperatures in Celsius.",
            "functionSignature": "func waterState(temp int) string",
            "testCases": [
              {
                "input": "25",
                "output": "\"water\""
              },
              {
                "input": "-5",
                "output": "\"ice\""
              },
              {
                "input": "100",
                "output": "\"steam\""
              }
            ],
            "hints": [
              {
                "title": "\ud83e\udd14 Think about it",
                "content": "Three states with specific temperature boundaries. What's the cleanest order to check them?"
              },
              {
                "title": "\ud83d\udca1 Hint",
                "content": "Check boundaries in order: if temp <= 0 (ice), else if temp >= 100 (steam), else (water)."
              },
              {
                "title": "\ud83d\udd27 Pattern",
                "content": "<pre>if temp <= 0 { return \"ice\" }\nif temp >= 100 { return \"steam\" }\nreturn \"water\"</pre>"
              }
            ],
            "solution": "func waterState(temp int) string {\n    if temp <= 0 { return \"ice\" }\n    if temp >= 100 { return \"steam\" }\n    return \"water\"\n}",
            "difficulty": 1
          },
          {
            "id": "v13",
            "title": "Discount Calculator",
            "description": "Write <code>func discount(price int, isPremium bool, quantity int) int</code>. Premium members get 20% off. Non-premium get 10% off if quantity >= 5, else no discount. Return final price.",
            "functionSignature": "func discount(price int, isPremium bool, quantity int) int",
            "testCases": [
              {
                "input": "100, true, 1",
                "output": "80",
                "note": "Premium: 20% off"
              },
              {
                "input": "100, false, 6",
                "output": "90",
                "note": "Non-premium bulk: 10% off"
              },
              {
                "input": "100, false, 3",
                "output": "100",
                "note": "Non-premium small: no discount"
              }
            ],
            "hints": [
              {
                "title": "\ud83e\udd14 Think about it",
                "content": "Multiple conditions that interact: membership status AND quantity. Check premium first since it's simpler."
              },
              {
                "title": "\ud83d\udca1 Hint",
                "content": "if isPremium \u2192 20% off. else if quantity >= 5 \u2192 10% off. else \u2192 no discount."
              },
              {
                "title": "\ud83d\udd27 Pattern",
                "content": "<pre>if isPremium { return price * 80 / 100 }\nif quantity >= 5 { return price * 90 / 100 }\nreturn price</pre>"
              }
            ],
            "solution": "func discount(price int, isPremium bool, quantity int) int {\n    if isPremium { return price * 80 / 100 }\n    if quantity >= 5 { return price * 90 / 100 }\n    return price\n}",
            "difficulty": 1
          },
          {
            "id": "v14",
            "title": "Categorize Numbers",
            "description": "Write <code>func categorizeNumbers(nums []int) map[string][]int</code> that categorizes numbers into \"small\" (<10), \"medium\" (10-99), or \"large\" (>=100). Returns a map where keys are categories and values are slices of numbers in that category.",
            "functionSignature": "func categorizeNumbers(nums []int) map[string][]int",
            "testCases": [
              {
                "input": "[]int{5, 15, 150, 8, 25, 200}",
                "output": "map[\"small\":[5, 8] \"medium\":[15, 25] \"large\":[150, 200]]"
              },
              {
                "input": "[]int{1, 10, 100}",
                "output": "map[\"small\":[1] \"medium\":[10] \"large\":[100]]"
              }
            ],
            "hints": [
              {
                "title": "\ud83e\udd14 Think about it",
                "content": "Create a map where each category name maps to a slice of integers. For each number, determine which category it belongs to and append it to that category's slice."
              },
              {
                "title": "\ud83d\udca1 Hint",
                "content": "Initialize map with three empty slices. Use if-else to check: num < 10, num < 100, else. Append to the appropriate slice."
              },
              {
                "title": "\ud83d\udd27 Pattern",
                "content": "<pre>1. Create map[string][]int\n2. For each num:\n   - num < 10? \u2192 append to \"small\"\n   - num < 100? \u2192 append to \"medium\"\n   - else \u2192 append to \"large\"\n3. Return map</pre>"
              }
            ],
            "solution": "func categorizeNumbers(nums []int) map[string][]int {\n    categories := map[string][]int{\n        \"small\": {},\n        \"medium\": {},\n        \"large\": {},\n    }\n    \n    for _, num := range nums {\n        if num < 10 {\n            categories[\"small\"] = append(categories[\"small\"], num)\n        } else if num < 100 {\n            categories[\"medium\"] = append(categories[\"medium\"], num)\n        } else {\n            categories[\"large\"] = append(categories[\"large\"], num)\n        }\n    }\n    \n    return categories\n}",
            "difficulty": 3
          },
          {
            "id": "v15",
            "title": "Score to Grade with Plus/Minus",
            "description": "Write <code>func scoreToGradePlus(score int) string</code> that converts a score to a letter grade with +/- modifiers. A+ (97-100), A (93-96), A- (90-92), B+ (87-89), B (83-86), B- (80-82), etc. Below 60 is F.",
            "functionSignature": "func scoreToGradePlus(score int) string",
            "testCases": [
              {
                "input": "98",
                "output": "\"A+\""
              },
              {
                "input": "85",
                "output": "\"B\""
              },
              {
                "input": "72",
                "output": "\"C-\""
              }
            ],
            "hints": [
              {
                "title": "\ud83e\udd14 Think about it",
                "content": "You need precise range checking for 12 different grade levels. Start from the top (100) and work down with else-if chains."
              },
              {
                "title": "\ud83d\udca1 Hint",
                "content": "Check score >= 97 for A+, >= 93 for A, >= 90 for A-, >= 87 for B+, and so on. Each check needs exact boundaries."
              },
              {
                "title": "\ud83d\udd27 Pattern",
                "content": "<pre>if score >= 97 { return \"A+\" }\nif score >= 93 { return \"A\" }\nif score >= 90 { return \"A-\" }\n... continue pattern ...\nreturn \"F\"</pre>"
              }
            ],
            "solution": "func scoreToGradePlus(score int) string {\n    if score >= 97 { return \"A+\" }\n    if score >= 93 { return \"A\" }\n    if score >= 90 { return \"A-\" }\n    if score >= 87 { return \"B+\" }\n    if score >= 83 { return \"B\" }\n    if score >= 80 { return \"B-\" }\n    if score >= 77 { return \"C+\" }\n    if score >= 73 { return \"C\" }\n    if score >= 70 { return \"C-\" }\n    if score >= 67 { return \"D+\" }\n    if score >= 63 { return \"D\" }\n    if score >= 60 { return \"D-\" }\n    return \"F\"\n}",
            "difficulty": 3
          },
          {
            "id": "v16",
            "title": "Calculate Shipping Cost",
            "description": "Write <code>func calculateShipping(weight float64, distance int, isPriority bool) float64</code> that calculates shipping cost. Base cost = weight * 0.5 + distance * 0.1. If isPriority, multiply total by 1.5. If weight > 50, add $10. If distance > 1000, add $20.",
            "functionSignature": "func calculateShipping(weight float64, distance int, isPriority bool) float64",
            "testCases": [
              {
                "input": "30.0, 500, false",
                "output": "65.0",
                "note": "30*0.5 + 500*0.1 = 15 + 50 = 65"
              },
              {
                "input": "60.0, 1200, true",
                "output": "247.5",
                "note": "(60*0.5 + 1200*0.1 + 10 + 20) * 1.5 = 165 * 1.5 = 247.5"
              }
            ],
            "hints": [
              {
                "title": "\ud83e\udd14 Think about it",
                "content": "Calculate base cost first. Then add conditional fees. Finally, apply priority multiplier if needed. Order matters!"
              },
              {
                "title": "\ud83d\udca1 Hint",
                "content": "Start: cost = weight * 0.5 + distance * 0.1. Then: if weight > 50, cost += 10. if distance > 1000, cost += 20. Finally: if isPriority, cost *= 1.5."
              },
              {
                "title": "\ud83d\udd27 Pattern",
                "content": "<pre>1. Calculate base: weight*0.5 + distance*0.1\n2. Add weight surcharge if needed\n3. Add distance surcharge if needed\n4. Apply priority multiplier if needed\n5. Return total</pre>"
              }
            ],
            "solution": "func calculateShipping(weight float64, distance int, isPriority bool) float64 {\n    cost := weight * 0.5 + float64(distance) * 0.1\n    \n    if weight > 50 {\n        cost += 10\n    }\n    \n    if distance > 1000 {\n        cost += 20\n    }\n    \n    if isPriority {\n        cost *= 1.5\n    }\n    \n    return cost\n}",
            "difficulty": 3
          }
        ]
      },
      {
        "id": "challenge_4",
        "block": 1,
        "difficulty": 1,
        "concept": "Finding Extrema",
        "docLinks": [
          {
            "url": "https://go.dev/ref/spec#Index_expressions",
            "title": "Go Spec: Index expressions",
            "note": "accessing slice elements"
          },
          {
            "url": "https://pkg.go.dev/builtin#len",
            "title": "Builtin len()",
            "note": "string and slice length"
          }
        ],
        "patternPrimer": {
          "bruteForce": "Track the current best value; update whenever you find a better one.",
          "bestApproach": "Same approach - initialize to first element, then compare each subsequent element.",
          "typical": "Typically O(n) time, O(1) extra space"
        },
        "variants": [
          {
            "id": "v1",
            "title": "Find Maximum",
            "description": "Write <code>func max(nums []int) int</code> that returns the largest number.",
            "functionSignature": "func max(nums []int) int",
            "testCases": [
              {
                "input": "[]int{3, 7, 2, 9}",
                "output": "9"
              }
            ],
            "hints": [
              {
                "title": "\ud83e\udd14 Think about it",
                "content": "If you want to track the 'best so far', what's a reasonable starting value? Hint: what if the first element is the answer?"
              },
              {
                "title": "\ud83d\udca1 Hint",
                "content": "Initialize with the first element (not 0 or some arbitrary value). Compare each subsequent element - if it's better, update your best."
              },
              {
                "title": "\ud83d\udd27 Pattern",
                "content": "<pre>1. Start with first element as \"best so far\"\n2. For each remaining element:\n   - Better than current best? \u2192 update best\n3. Return best</pre>"
              }
            ],
            "solution": "func max(nums []int) int {\n    m := nums[0]\n    for _, n := range nums {\n        if n > m { m = n }\n    }\n    return m\n}",
            "difficulty": 1
          },
          {
            "id": "v2",
            "title": "Find Minimum",
            "description": "Write <code>func min(nums []int) int</code> that returns the smallest number.",
            "functionSignature": "func min(nums []int) int",
            "testCases": [
              {
                "input": "[]int{3, 7, 2, 9}",
                "output": "2"
              }
            ],
            "hints": [
              {
                "title": "\ud83e\udd14 Think about it",
                "content": "If you want to track the 'best so far', what's a reasonable starting value? Hint: what if the first element is the answer?"
              },
              {
                "title": "\ud83d\udca1 Hint",
                "content": "Initialize with the first element (not 0 or some arbitrary value). Compare each subsequent element - if it's better, update your best."
              },
              {
                "title": "\ud83d\udd27 Pattern",
                "content": "<pre>1. Start with first element as \"best so far\"\n2. For each remaining element:\n   - Better than current best? \u2192 update best\n3. Return best</pre>"
              }
            ],
            "solution": "func min(nums []int) int {\n    m := nums[0]\n    for _, n := range nums {\n        if n < m { m = n }\n    }\n    return m\n}",
            "difficulty": 1
          },
          {
            "id": "v3",
            "title": "Longest String",
            "description": "Write <code>func longest(words []string) string</code> that returns the longest word.",
            "functionSignature": "func longest(words []string) string",
            "testCases": [
              {
                "input": "[]string{\"go\", \"python\"}",
                "output": "\"python\""
              }
            ],
            "hints": [
              {
                "title": "\ud83e\udd14 Think about it",
                "content": "If you want to track the 'best so far', what's a reasonable starting value? Hint: what if the first element is the answer?"
              },
              {
                "title": "\ud83d\udca1 Hint",
                "content": "Initialize with the first element (not 0 or some arbitrary value). Compare each subsequent element - if it's better, update your best."
              },
              {
                "title": "\ud83d\udd27 Pattern",
                "content": "<pre>1. Start with first element as \"best so far\"\n2. For each remaining element:\n   - Better than current best? \u2192 update best\n3. Return best</pre>"
              }
            ],
            "solution": "func longest(words []string) string {\n    r := words[0]\n    for _, w := range words {\n        if len(w) > len(r) { r = w }\n    }\n    return r\n}",
            "difficulty": 1
          },
          {
            "id": "v4",
            "title": "Shortest String",
            "description": "Write <code>func shortest(words []string) string</code> that returns the shortest word.",
            "functionSignature": "func shortest(words []string) string",
            "testCases": [
              {
                "input": "[]string{\"go\", \"python\", \"java\"}",
                "output": "\"go\""
              }
            ],
            "hints": [
              {
                "title": "\ud83e\udd14 Think about it",
                "content": "If you want to track the 'best so far', what's a reasonable starting value? Hint: what if the first element is the answer?"
              },
              {
                "title": "\ud83d\udca1 Hint",
                "content": "Initialize with the first element. Compare each subsequent element - if it's shorter, update your best."
              },
              {
                "title": "\ud83d\udd27 Pattern",
                "content": "<pre>1. Start with first element as \"best so far\"\n2. For each remaining element:\n   - Shorter than current best? \u2192 update best\n3. Return best</pre>"
              }
            ],
            "solution": "func shortest(words []string) string {\n    r := words[0]\n    for _, w := range words {\n        if len(w) < len(r) { r = w }\n    }\n    return r\n}",
            "difficulty": 1
          },
          {
            "id": "v5",
            "title": "Second Largest",
            "description": "Write <code>func secondLargest(nums []int) int</code> that returns the second largest number. Assume at least 2 distinct numbers.",
            "functionSignature": "func secondLargest(nums []int) int",
            "testCases": [
              {
                "input": "[]int{5, 1, 9, 3}",
                "output": "5"
              },
              {
                "input": "[]int{10, 10, 8, 5}",
                "output": "8"
              }
            ],
            "hints": [
              {
                "title": "\ud83e\udd14 Think about it",
                "content": "You need to track TWO values: the best so far AND the second best. When should each one update?"
              },
              {
                "title": "\ud83d\udca1 Hint",
                "content": "Track first and second. When you find a new max, the old max becomes second. When you find something bigger than second but smaller than first, that becomes the new second."
              },
              {
                "title": "\ud83d\udd27 Pattern",
                "content": "<pre>1. Initialize first and second with smallest possible values\n2. For each element:\n   - Bigger than first? \u2192 second = first, first = element\n   - Bigger than second (and != first)? \u2192 second = element\n3. Return second</pre>"
              }
            ],
            "solution": "func secondLargest(nums []int) int {\n    first, second := nums[0], nums[1]\n    if second > first { first, second = second, first }\n    for _, n := range nums[2:] {\n        if n > first { second, first = first, n\n        } else if n > second && n != first { second = n }\n    }\n    return second\n}",
            "difficulty": 3
          },
          {
            "id": "v6",
            "title": "Smallest Positive",
            "description": "Write <code>func smallestPositive(nums []int) int</code> that returns the smallest positive number, or -1 if none exist.",
            "functionSignature": "func smallestPositive(nums []int) int",
            "testCases": [
              {
                "input": "[]int{-5, 3, -1, 7, 2}",
                "output": "2"
              },
              {
                "input": "[]int{-3, -1, 0}",
                "output": "-1"
              }
            ],
            "hints": [
              {
                "title": "\ud83e\udd14 Think about it",
                "content": "You need to find an extrema (minimum) but with a condition (must be positive). What's tricky about initializing the 'best so far'?"
              },
              {
                "title": "\ud83d\udca1 Hint",
                "content": "You can't initialize with nums[0] if it might not be positive. Either find the first positive to initialize, or use a flag to track if you've found any positive."
              },
              {
                "title": "\ud83d\udd27 Pattern",
                "content": "<pre>1. Initialize result to -1 (not found)\n2. For each element:\n   - Is positive AND (first positive OR smaller than result)?\n   \u2192 update result\n3. Return result</pre>"
              }
            ],
            "solution": "func smallestPositive(nums []int) int {\n    result := -1\n    for _, n := range nums {\n        if n > 0 && (result == -1 || n < result) {\n            result = n\n        }\n    }\n    return result\n}",
            "difficulty": 2
          },
          {
            "id": "v7",
            "title": "Highest Temperature",
            "description": "Write <code>func highestTemp(temps []float64) float64</code> that returns the highest temperature reading.",
            "functionSignature": "func highestTemp(temps []float64) float64",
            "testCases": [
              {
                "input": "[]float64{23.5, 28.7, 22.1, 30.2}",
                "output": "30.2"
              },
              {
                "input": "[]float64{-5.5, -2.0, -10.0}",
                "output": "-2.0"
              }
            ],
            "hints": [
              {
                "title": "\ud83e\udd14 Think about it",
                "content": "Track the highest temperature seen so far. Initialize with the first reading."
              },
              {
                "title": "\ud83d\udca1 Hint",
                "content": "Same pattern as finding max - start with first element, update when you find a higher value."
              },
              {
                "title": "\ud83d\udd27 Pattern",
                "content": "<pre>1. highest := temps[0]\n2. For each temp:\n   - temp > highest? \u2192 highest = temp\n3. Return highest</pre>"
              }
            ],
            "solution": "func highestTemp(temps []float64) float64 {\n    highest := temps[0]\n    for _, t := range temps {\n        if t > highest { highest = t }\n    }\n    return highest\n}",
            "difficulty": 1
          },
          {
            "id": "v8",
            "title": "Best Game Score",
            "description": "Write <code>func bestScore(scores []int) int</code> that finds the highest score. Return -1 if no valid scores (all negative).",
            "functionSignature": "func bestScore(scores []int) int",
            "testCases": [
              {
                "input": "[]int{450, 320, 580, 410}",
                "output": "580"
              },
              {
                "input": "[]int{-1, -5, -3}",
                "output": "-1"
              }
            ],
            "hints": [
              {
                "title": "\ud83e\udd14 Think about it",
                "content": "Find the maximum, but only count non-negative scores as valid. What if all scores are negative?"
              },
              {
                "title": "\ud83d\udca1 Hint",
                "content": "Track the max, but initialize to -1. Only update if you find a score >= 0 that's also greater than current max."
              },
              {
                "title": "\ud83d\udd27 Pattern",
                "content": "<pre>1. bestScore := -1\n2. For each score:\n   - score >= 0 AND score > bestScore?\n     \u2192 bestScore = score\n3. Return bestScore</pre>"
              }
            ],
            "solution": "func bestScore(scores []int) int {\n    bestScore := -1\n    for _, s := range scores {\n        if s >= 0 && s > bestScore {\n            bestScore = s\n        }\n    }\n    return bestScore\n}",
            "difficulty": 2
          },
          {
            "id": "v9",
            "title": "Most Expensive Item",
            "description": "Write <code>func mostExpensive(prices []float64) int</code> that returns the INDEX of the most expensive item.",
            "functionSignature": "func mostExpensive(prices []float64) int",
            "testCases": [
              {
                "input": "[]float64{12.99, 45.50, 23.75, 50.00}",
                "output": "3"
              },
              {
                "input": "[]float64{100.0, 200.0, 150.0}",
                "output": "1"
              }
            ],
            "hints": [
              {
                "title": "\ud83e\udd14 Think about it",
                "content": "Instead of tracking the maximum VALUE, track the INDEX where the maximum occurs."
              },
              {
                "title": "\ud83d\udca1 Hint",
                "content": "Keep two variables: maxPrice and maxIndex. When you find a higher price, update both."
              },
              {
                "title": "\ud83d\udd27 Pattern",
                "content": "<pre>1. maxPrice, maxIndex := prices[0], 0\n2. For i, price:\n   - price > maxPrice?\n     \u2192 maxPrice = price, maxIndex = i\n3. Return maxIndex</pre>"
              }
            ],
            "solution": "func mostExpensive(prices []float64) int {\n    maxPrice, maxIndex := prices[0], 0\n    for i, price := range prices {\n        if price > maxPrice {\n            maxPrice = price\n            maxIndex = i\n        }\n    }\n    return maxIndex\n}",
            "difficulty": 2
          },
          {
            "id": "v10",
            "title": "Find Two Largest",
            "description": "Write <code>func findTwoLargest(nums []int) (int, int)</code> that returns the two largest distinct values. First return value is the largest, second is second-largest.",
            "functionSignature": "func findTwoLargest(nums []int) (int, int)",
            "testCases": [
              {
                "input": "[]int{3, 7, 2, 9, 5}",
                "output": "9, 7"
              },
              {
                "input": "[]int{1, 2, 3, 4, 5}",
                "output": "5, 4"
              }
            ],
            "hints": [
              {
                "title": "\ud83e\udd14 Think about it",
                "content": "You need to track TWO values as you iterate: the largest and second-largest. When you find a new max, the old max becomes second-max."
              },
              {
                "title": "\ud83d\udca1 Hint",
                "content": "Initialize first and second to very small values. For each number: if it's bigger than first, shift first to second, then update first. Else if it's bigger than second, update second."
              },
              {
                "title": "\ud83d\udd27 Pattern",
                "content": "<pre>1. first, second := nums[0], nums[1]\n   (handle if first < second)\n2. For each remaining num:\n   - num > first? \u2192 second = first, first = num\n   - num > second? \u2192 second = num\n3. Return first, second</pre>"
              }
            ],
            "solution": "func findTwoLargest(nums []int) (int, int) {\n    first, second := nums[0], nums[1]\n    if first < second {\n        first, second = second, first\n    }\n    \n    for i := 2; i < len(nums); i++ {\n        if nums[i] > first {\n            second = first\n            first = nums[i]\n        } else if nums[i] > second {\n            second = nums[i]\n        }\n    }\n    \n    return first, second\n}",
            "difficulty": 3
          },
          {
            "id": "v11",
            "title": "Longest String and Length",
            "description": "Write <code>func longestStringAndLen(words []string) (string, int)</code> that returns the longest string and its length. If multiple strings tie for longest, return the first one.",
            "functionSignature": "func longestStringAndLen(words []string) (string, int)",
            "testCases": [
              {
                "input": "[\"go\", \"rust\", \"python\"]",
                "output": "\"python\", 6"
              },
              {
                "input": "[\"hello\", \"world\"]",
                "output": "\"hello\", 5",
                "note": "both length 5, return first"
              }
            ],
            "hints": [
              {
                "title": "\ud83e\udd14 Think about it",
                "content": "Track both the longest word AND its length. For each word, compute len(word) and compare to current max length."
              },
              {
                "title": "\ud83d\udca1 Hint",
                "content": "Keep longest string and maxLen. For each word, if len(word) > maxLen, update both longest and maxLen."
              },
              {
                "title": "\ud83d\udd27 Pattern",
                "content": "<pre>1. longest := words[0], maxLen := len(words[0])\n2. For each word:\n   - len(word) > maxLen?\n     \u2192 longest = word, maxLen = len(word)\n3. Return longest, maxLen</pre>"
              }
            ],
            "solution": "func longestStringAndLen(words []string) (string, int) {\n    longest := words[0]\n    maxLen := len(words[0])\n    \n    for _, word := range words {\n        if len(word) > maxLen {\n            longest = word\n            maxLen = len(word)\n        }\n    }\n    \n    return longest, maxLen\n}",
            "difficulty": 3
          },
          {
            "id": "v12",
            "title": "Find Range (Max - Min)",
            "description": "Write <code>func findRange(nums []int) int</code> that returns the difference between the maximum and minimum values in the slice (range = max - min).",
            "functionSignature": "func findRange(nums []int) int",
            "testCases": [
              {
                "input": "[]int{3, 7, 2, 9, 5}",
                "output": "7",
                "note": "9 - 2 = 7"
              },
              {
                "input": "[]int{1, 1, 1}",
                "output": "0"
              }
            ],
            "hints": [
              {
                "title": "\ud83e\udd14 Think about it",
                "content": "You need to find both the maximum and minimum values, then calculate their difference."
              },
              {
                "title": "\ud83d\udca1 Hint",
                "content": "Track both max and min as you iterate. Initialize both to nums[0]. For each number, update max if larger, update min if smaller. Return max - min."
              },
              {
                "title": "\ud83d\udd27 Pattern",
                "content": "<pre>1. max, min := nums[0], nums[0]\n2. For each num:\n   - num > max? \u2192 max = num\n   - num < min? \u2192 min = num\n3. Return max - min</pre>"
              }
            ],
            "solution": "func findRange(nums []int) int {\n    max, min := nums[0], nums[0]\n    \n    for _, num := range nums {\n        if num > max {\n            max = num\n        }\n        if num < min {\n            min = num\n        }\n    }\n    \n    return max - min\n}",
            "difficulty": 3
          },
          {
            "id": "v1",
            "title": "Best Time to Buy and Sell Stock",
            "description": "Given an array of stock prices where prices[i] is the price on day i, find the maximum profit from one buy and one sell. You must buy before you sell. <code>func maxProfit(prices []int) int</code>",
            "functionSignature": "func maxProfit(prices []int) int",
            "testCases": [
              {
                "input": "[]int{7, 1, 5, 3, 6, 4}",
                "output": "5",
                "note": "buy at 1, sell at 6"
              },
              {
                "input": "[]int{7, 6, 4, 3, 1}",
                "output": "0",
                "note": "prices only go down, no profit possible"
              },
              {
                "input": "[]int{2, 4, 1}",
                "output": "2",
                "note": "buy at 2, sell at 4"
              }
            ],
            "solution": "func maxProfit(prices []int) int {\n    if len(prices) == 0 {\n        return 0\n    }\n    \n    minPrice := prices[0]\n    maxProfit := 0\n    \n    for _, price := range prices {\n        if price < minPrice {\n            minPrice = price\n        } else if price - minPrice > maxProfit {\n            maxProfit = price - minPrice\n        }\n    }\n    return maxProfit\n}",
            "difficulty": 4
          },
          {
            "id": "v2",
            "title": "Maximum Difference",
            "description": "Find the maximum difference between any two elements where the larger element comes after the smaller one. Return 0 if no such pair exists. <code>func maxDiff(nums []int) int</code>",
            "functionSignature": "func maxDiff(nums []int) int",
            "testCases": [
              {
                "input": "[]int{2, 3, 10, 6, 4, 8, 1}",
                "output": "8",
                "note": "10 - 2 = 8"
              },
              {
                "input": "[]int{7, 9, 5, 6, 3, 2}",
                "output": "2",
                "note": "9 - 7 = 2"
              },
              {
                "input": "[]int{5, 4, 3, 2, 1}",
                "output": "0",
                "note": "decreasing, no valid pair"
              }
            ],
            "solution": "func maxDiff(nums []int) int {\n    if len(nums) < 2 {\n        return 0\n    }\n    \n    minSoFar := nums[0]\n    maxDiff := 0\n    \n    for i := 1; i < len(nums); i++ {\n        diff := nums[i] - minSoFar\n        if diff > maxDiff {\n            maxDiff = diff\n        }\n        if nums[i] < minSoFar {\n            minSoFar = nums[i]\n        }\n    }\n    return maxDiff\n}",
            "solutionNotes": "This is the same problem as Best Time to Buy/Sell Stock! Track the minimum seen so far, and at each position calculate the potential profit/difference.",
            "difficulty": 4
          },
          {
            "id": "v3",
            "title": "Best Sightseeing Pair",
            "description": "Given an array of values, find max score of values[i] + values[j] + i - j where i < j. <code>func maxScoreSightseeingPair(values []int) int</code>",
            "functionSignature": "func maxScoreSightseeingPair(values []int) int",
            "testCases": [
              {
                "input": "[]int{8, 1, 5, 2, 6}",
                "output": "11",
                "note": "i=0, j=2: 8+5+0-2=11"
              },
              {
                "input": "[]int{1, 2}",
                "output": "2",
                "note": "1+2+0-1=2"
              },
              {
                "input": "[]int{1, 3, 5}",
                "output": "7",
                "note": "i=1, j=2: 3+5+1-2=7"
              }
            ],
            "solution": "func maxScoreSightseeingPair(values []int) int {\n    maxScore := 0\n    bestI := values[0] + 0  // values[i] + i\n    \n    for j := 1; j < len(values); j++ {\n        score := bestI + values[j] - j\n        if score > maxScore {\n            maxScore = score\n        }\n        if values[j] + j > bestI {\n            bestI = values[j] + j\n        }\n    }\n    return maxScore\n}",
            "solutionNotes": "Rewrite the formula: (values[i] + i) + (values[j] - j). Track the best (values[i] + i) seen so far, then for each j compute the score. Same pattern as stock problem!",
            "difficulty": 4
          },
          {
            "id": "v4",
            "title": "Maximum Subarray (Kadane's)",
            "description": "Find the contiguous subarray with the largest sum. <code>func maxSubArray(nums []int) int</code>",
            "functionSignature": "func maxSubArray(nums []int) int",
            "testCases": [
              {
                "input": "[]int{-2, 1, -3, 4, -1, 2, 1, -5, 4}",
                "output": "6",
                "note": "[4,-1,2,1] = 6"
              },
              {
                "input": "[]int{1}",
                "output": "1"
              },
              {
                "input": "[]int{-1, -2, -3}",
                "output": "-1",
                "note": "least negative"
              }
            ],
            "solution": "func maxSubArray(nums []int) int {\n    maxSum := nums[0]\n    currentSum := nums[0]\n    \n    for i := 1; i < len(nums); i++ {\n        if currentSum < 0 {\n            currentSum = nums[i]\n        } else {\n            currentSum += nums[i]\n        }\n        if currentSum > maxSum {\n            maxSum = currentSum\n        }\n    }\n    return maxSum\n}",
            "solutionNotes": "Kadane's algorithm: at each position, decide whether to extend the current subarray or start fresh. Track the best sum seen so far. Same 'best so far' pattern!",
            "difficulty": 4
          },
          {
            "id": "v5",
            "title": "Best Time to Buy and Sell Stock II",
            "description": "You can buy and sell multiple times (but must sell before buying again). Find the maximum total profit. <code>func maxProfitII(prices []int) int</code>",
            "functionSignature": "func maxProfitII(prices []int) int",
            "testCases": [
              {
                "input": "[]int{7, 1, 5, 3, 6, 4}",
                "output": "7",
                "note": "buy@1 sell@5 (+4), buy@3 sell@6 (+3)"
              },
              {
                "input": "[]int{1, 2, 3, 4, 5}",
                "output": "4",
                "note": "buy@1 sell@5, or buy/sell each day"
              },
              {
                "input": "[]int{7, 6, 4, 3, 1}",
                "output": "0",
                "note": "no profit possible"
              }
            ],
            "solution": "func maxProfitII(prices []int) int {\n    profit := 0\n    \n    for i := 1; i < len(prices); i++ {\n        if prices[i] > prices[i-1] {\n            profit += prices[i] - prices[i-1]\n        }\n    }\n    return profit\n}",
            "solutionNotes": "Greedy insight: capture every upward movement! If tomorrow's price is higher, that's profit. Sum all positive differences. Much simpler than it seems!",
            "difficulty": 4
          },
          {
            "id": "v6",
            "title": "Trapping Rain Water",
            "description": "Given an elevation map where width of each bar is 1, compute how much water can be trapped after raining. <code>func trap(height []int) int</code>",
            "functionSignature": "func trap(height []int) int",
            "testCases": [
              {
                "input": "[]int{0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1}",
                "output": "6"
              },
              {
                "input": "[]int{4, 2, 0, 3, 2, 5}",
                "output": "9"
              },
              {
                "input": "[]int{1, 2, 3}",
                "output": "0",
                "note": "strictly increasing, no trapping"
              }
            ],
            "solution": "func trap(height []int) int {\n    if len(height) == 0 {\n        return 0\n    }\n    \n    n := len(height)\n    maxLeft := make([]int, n)\n    maxRight := make([]int, n)\n    \n    maxLeft[0] = height[0]\n    for i := 1; i < n; i++ {\n        if height[i] > maxLeft[i-1] {\n            maxLeft[i] = height[i]\n        } else {\n            maxLeft[i] = maxLeft[i-1]\n        }\n    }\n    \n    maxRight[n-1] = height[n-1]\n    for i := n - 2; i >= 0; i-- {\n        if height[i] > maxRight[i+1] {\n            maxRight[i] = height[i]\n        } else {\n            maxRight[i] = maxRight[i+1]\n        }\n    }\n    \n    water := 0\n    for i := 0; i < n; i++ {\n        level := maxLeft[i]\n        if maxRight[i] < level {\n            level = maxRight[i]\n        }\n        water += level - height[i]\n    }\n    return water\n}",
            "solutionNotes": "At each position, water level = min(maxLeft, maxRight). Pre-compute maxLeft[i] and maxRight[i] arrays using the 'best so far' pattern in both directions!",
            "difficulty": 4
          }
        ]
      },
      {
        "id": "challenge_5",
        "block": 2,
        "difficulty": 2,
        "concept": "Filter with Append",
        "docLinks": [
          {
            "url": "https://pkg.go.dev/builtin#append",
            "title": "Builtin append()",
            "note": "growing slices dynamically"
          },
          {
            "url": "https://go.dev/blog/slices-intro",
            "title": "Go Blog: Slices introduction",
            "note": "slice internals"
          }
        ],
        "patternPrimer": {
          "bruteForce": "Create a new slice and append elements that pass the condition.",
          "bestApproach": "Same approach - loop once, append conditionally. Can't do better than O(n).",
          "typical": "Typically O(n) time, O(k) extra space where k = filtered elements"
        },
        "variants": [
          {
            "id": "v1",
            "title": "Filter Positives",
            "description": "Write <code>func filterPositives(nums []int) []int</code> returning only positive numbers.",
            "functionSignature": "func filterPositives(nums []int) []int",
            "testCases": [
              {
                "input": "[]int{-2, 3, -1, 5}",
                "output": "[3, 5]"
              }
            ],
            "hints": [
              {
                "title": "\ud83e\udd14 Think about it",
                "content": "You want to build a new collection containing only some elements. What do you start with, and how do you add elements that pass your test?"
              },
              {
                "title": "\ud83d\udca1 Hint",
                "content": "Start with an empty slice. Loop through, check your condition, and append elements that pass."
              },
              {
                "title": "\ud83d\udd27 Pattern",
                "content": "<pre>1. Start with empty result collection\n2. For each element:\n   - Passes test? \u2192 add to result\n3. Return result</pre>"
              }
            ],
            "solution": "func filterPositives(nums []int) []int {\n    r := []int{}\n    for _, n := range nums {\n        if n > 0 { r = append(r, n) }\n    }\n    return r\n}",
            "difficulty": 1
          },
          {
            "id": "v2",
            "title": "Filter Evens",
            "description": "Write <code>func filterEvens(nums []int) []int</code> returning only even numbers.",
            "functionSignature": "func filterEvens(nums []int) []int",
            "testCases": [
              {
                "input": "[]int{1, 2, 3, 4}",
                "output": "[2, 4]"
              }
            ],
            "hints": [
              {
                "title": "\ud83e\udd14 Think about it",
                "content": "You want to build a new collection containing only some elements. What do you start with, and how do you add elements that pass your test?"
              },
              {
                "title": "\ud83d\udca1 Hint",
                "content": "Start with an empty slice. Loop through, check your condition, and append elements that pass."
              },
              {
                "title": "\ud83d\udd27 Pattern",
                "content": "<pre>1. Start with empty result collection\n2. For each element:\n   - Passes test? \u2192 add to result\n3. Return result</pre>"
              }
            ],
            "solution": "func filterEvens(nums []int) []int {\n    r := []int{}\n    for _, n := range nums {\n        if n%2 == 0 { r = append(r, n) }\n    }\n    return r\n}",
            "difficulty": 1
          },
          {
            "id": "v3",
            "title": "Filter Short Words",
            "description": "Write <code>func filterShort(words []string, max int) []string</code> returning words with len <= max.",
            "functionSignature": "func filterShort(words []string, max int) []string",
            "testCases": [
              {
                "input": "[]string{\"go\", \"python\"}, 3",
                "output": "[\"go\"]"
              }
            ],
            "hints": [
              {
                "title": "\ud83e\udd14 Think about it",
                "content": "You want to build a new collection containing only some elements. What do you start with, and how do you add elements that pass your test?"
              },
              {
                "title": "\ud83d\udca1 Hint",
                "content": "Start with an empty slice. Loop through, check your condition, and append elements that pass."
              },
              {
                "title": "\ud83d\udd27 Pattern",
                "content": "<pre>1. Start with empty result collection\n2. For each element:\n   - Passes test? \u2192 add to result\n3. Return result</pre>"
              }
            ],
            "solution": "func filterShort(words []string, max int) []string {\n    r := []string{}\n    for _, w := range words {\n        if len(w) <= max { r = append(r, w) }\n    }\n    return r\n}",
            "difficulty": 2
          },
          {
            "id": "v4",
            "title": "Filter Greater Than",
            "description": "Write <code>func filterGreater(nums []int, threshold int) []int</code> returning only numbers greater than threshold.",
            "functionSignature": "func filterGreater(nums []int, threshold int) []int",
            "testCases": [
              {
                "input": "[]int{1, 5, 3, 8, 2}, 3",
                "output": "[5, 8]"
              }
            ],
            "hints": [
              {
                "title": "\ud83e\udd14 Think about it",
                "content": "You want to build a new collection containing only some elements. What do you start with, and how do you add elements that pass your test?"
              },
              {
                "title": "\ud83d\udca1 Hint",
                "content": "Start with an empty slice. Loop through, check if n > threshold, and append elements that pass."
              },
              {
                "title": "\ud83d\udd27 Pattern",
                "content": "<pre>1. Start with empty result slice\n2. For each element:\n   - Passes test? \u2192 append to result\n3. Return result</pre>"
              }
            ],
            "solution": "func filterGreater(nums []int, threshold int) []int {\n    r := []int{}\n    for _, n := range nums {\n        if n > threshold { r = append(r, n) }\n    }\n    return r\n}",
            "difficulty": 1
          },
          {
            "id": "v5",
            "title": "Filter Non-Empty",
            "description": "Write <code>func filterNonEmpty(words []string) []string</code> returning only non-empty strings.",
            "functionSignature": "func filterNonEmpty(words []string) []string",
            "testCases": [
              {
                "input": "[]string{\"go\", \"\", \"python\", \"\"}",
                "output": "[\"go\", \"python\"]"
              }
            ],
            "hints": [
              {
                "title": "\ud83e\udd14 Think about it",
                "content": "You want to filter out empty strings. How do you check if a string is empty?"
              },
              {
                "title": "\ud83d\udca1 Hint",
                "content": "Check if len(w) > 0 or equivalently w != \"\". Append only strings that pass this test."
              },
              {
                "title": "\ud83d\udd27 Pattern",
                "content": "<pre>1. Start with empty result slice\n2. For each element:\n   - Not empty? \u2192 append to result\n3. Return result</pre>"
              }
            ],
            "solution": "func filterNonEmpty(words []string) []string {\n    r := []string{}\n    for _, w := range words {\n        if w != \"\" { r = append(r, w) }\n    }\n    return r\n}",
            "difficulty": 1
          },
          {
            "id": "v6",
            "title": "Filter In Range",
            "description": "Write <code>func filterInRange(nums []int, min, max int) []int</code> returning numbers where min <= n <= max.",
            "functionSignature": "func filterInRange(nums []int, min, max int) []int",
            "testCases": [
              {
                "input": "[]int{1, 5, 3, 8, 2}, 2, 5",
                "output": "[5, 3, 2]"
              }
            ],
            "hints": [
              {
                "title": "\ud83e\udd14 Think about it",
                "content": "You need to check TWO conditions: the number must be >= min AND <= max."
              },
              {
                "title": "\ud83d\udca1 Hint",
                "content": "Use n >= min && n <= max as your filter condition. Only append elements that satisfy both conditions."
              },
              {
                "title": "\ud83d\udd27 Pattern",
                "content": "<pre>1. Start with empty result slice\n2. For each element:\n   - In range [min, max]? \u2192 append to result\n3. Return result</pre>"
              }
            ],
            "solution": "func filterInRange(nums []int, min, max int) []int {\n    r := []int{}\n    for _, n := range nums {\n        if n >= min && n <= max { r = append(r, n) }\n    }\n    return r\n}",
            "difficulty": 2
          },
          {
            "id": "v7",
            "title": "Filter Palindromes",
            "difficulty": 3,
            "description": "Write <code>func filterPalindromes(words []string) []string</code> that returns only palindromes (words that read the same forwards and backwards). Ignore case.",
            "functionSignature": "func filterPalindromes(words []string) []string",
            "testCases": [
              {
                "input": "[]string{\"racecar\", \"hello\", \"level\", \"world\", \"noon\"}",
                "output": "[\"racecar\", \"level\", \"noon\"]"
              },
              {
                "input": "[]string{\"Go\", \"was\", \"it\", \"a\", \"cat\", \"I\", \"saw\"}",
                "output": "[\"a\", \"I\"]",
                "note": "Single chars are palindromes"
              }
            ],
            "hints": [
              {
                "title": "\ud83e\udd14 Think about it",
                "content": "You need to filter, but the condition itself is complex (checking if a word is a palindrome). You'll need a helper function."
              },
              {
                "title": "\ud83d\udca1 Hint",
                "content": "Create isPalindrome(s string) bool that uses two pointers from opposite ends. Then filter: for each word, if isPalindrome(word), append it."
              },
              {
                "title": "\ud83d\udd27 Pattern",
                "content": "<pre>1. result := []string{}\n2. For each word:\n   - If isPalindrome(word): append to result\n3. Return result\n\nisPalindrome(s):\n  - left, right pointers from ends\n  - Compare chars moving inward</pre>"
              }
            ],
            "solution": "func filterPalindromes(words []string) []string {\n    result := []string{}\n    for _, w := range words {\n        if isPalindrome(w) {\n            result = append(result, w)\n        }\n    }\n    return result\n}\n\nfunc isPalindrome(s string) bool {\n    s = strings.ToLower(s)\n    left, right := 0, len(s)-1\n    for left < right {\n        if s[left] != s[right] {\n            return false\n        }\n        left++\n        right--\n    }\n    return true\n}"
          },
          {
            "id": "v8",
            "title": "Filter Prime Numbers",
            "difficulty": 3,
            "description": "Write <code>func filterPrimes(nums []int) []int</code> that returns only prime numbers. A prime is > 1 and divisible only by 1 and itself.",
            "functionSignature": "func filterPrimes(nums []int) []int",
            "testCases": [
              {
                "input": "[]int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}",
                "output": "[2, 3, 5, 7]"
              },
              {
                "input": "[]int{11, 12, 13, 14, 15}",
                "output": "[11, 13]"
              }
            ],
            "hints": [
              {
                "title": "\ud83e\udd14 Think about it",
                "content": "Filtering + prime checking. You'll need an isPrime helper function that checks divisibility."
              },
              {
                "title": "\ud83d\udca1 Hint",
                "content": "Create isPrime(n int) bool. A number is prime if n > 1 and no number from 2 to sqrt(n) divides it evenly. Then filter using this function."
              },
              {
                "title": "\ud83d\udd27 Pattern",
                "content": "<pre>1. result := []int{}\n2. For each num:\n   - If isPrime(num): append to result\n3. Return result</pre>"
              }
            ],
            "solution": "func filterPrimes(nums []int) []int {\n    result := []int{}\n    for _, n := range nums {\n        if isPrime(n) {\n            result = append(result, n)\n        }\n    }\n    return result\n}\n\nfunc isPrime(n int) bool {\n    if n <= 1 {\n        return false\n    }\n    for i := 2; i*i <= n; i++ {\n        if n%i == 0 {\n            return false\n        }\n    }\n    return true\n}"
          },
          {
            "id": "v9",
            "title": "Affordable Items",
            "description": "Write <code>func affordableItems(prices []float64, budget float64) []float64</code> that returns prices within budget.",
            "functionSignature": "func affordableItems(prices []float64, budget float64) []float64",
            "testCases": [
              {
                "input": "[]float64{29.99, 45.00, 15.50, 60.00}, 40.0",
                "output": "[]float64{29.99, 15.50}"
              },
              {
                "input": "[]float64{100.0, 200.0}, 50.0",
                "output": "[]float64{}"
              }
            ],
            "hints": [
              {
                "title": "\ud83e\udd14 Think about it",
                "content": "Filter prices that are <= budget. Append matching prices to result slice."
              },
              {
                "title": "\ud83d\udca1 Hint",
                "content": "Standard filter pattern: if price <= budget, append it."
              },
              {
                "title": "\ud83d\udd27 Pattern",
                "content": "<pre>1. result := []float64{}\n2. For each price:\n   - price <= budget? \u2192 append to result\n3. Return result</pre>"
              }
            ],
            "solution": "func affordableItems(prices []float64, budget float64) []float64 {\n    result := []float64{}\n    for _, price := range prices {\n        if price <= budget {\n            result = append(result, price)\n        }\n    }\n    return result\n}",
            "difficulty": 1
          },
          {
            "id": "v10",
            "title": "Valid Emails",
            "description": "Write <code>func validEmails(emails []string) []string</code> that returns emails containing '@' symbol.",
            "functionSignature": "func validEmails(emails []string) []string",
            "testCases": [
              {
                "input": "[]string{\"user@example.com\", \"invalid\", \"admin@site.org\"}",
                "output": "[]string{\"user@example.com\", \"admin@site.org\"}"
              },
              {
                "input": "[]string{\"nope\", \"nada\"}",
                "output": "[]string{}"
              }
            ],
            "hints": [
              {
                "title": "\ud83e\udd14 Think about it",
                "content": "Simple validation: check if email contains '@'. Use strings.Contains()."
              },
              {
                "title": "\ud83d\udca1 Hint",
                "content": "Filter emails where strings.Contains(email, \"@\") is true."
              },
              {
                "title": "\ud83d\udd27 Pattern",
                "content": "<pre>1. result := []string{}\n2. For each email:\n   - contains '@'? \u2192 append to result\n3. Return result</pre>"
              }
            ],
            "solution": "func validEmails(emails []string) []string {\n    result := []string{}\n    for _, email := range emails {\n        if strings.Contains(email, \"@\") {\n            result = append(result, email)\n        }\n    }\n    return result\n}",
            "difficulty": 1
          },
          {
            "id": "v11",
            "title": "Filter By Length Range",
            "description": "Write <code>func filterByLengthRange(words []string, minLen, maxLen int) []string</code> that returns words where minLen <= len(word) <= maxLen.",
            "functionSignature": "func filterByLengthRange(words []string, minLen, maxLen int) []string",
            "testCases": [
              {
                "input": "[]string{\"go\", \"rust\", \"python\", \"c\"}, 2, 4",
                "output": "[]string{\"go\", \"rust\"}"
              },
              {
                "input": "[]string{\"a\", \"ab\", \"abc\", \"abcd\"}, 2, 3",
                "output": "[]string{\"ab\", \"abc\"}"
              }
            ],
            "hints": [
              {
                "title": "\ud83e\udd14 Think about it",
                "content": "Check two conditions: length must be >= minLen AND <= maxLen."
              },
              {
                "title": "\ud83d\udca1 Hint",
                "content": "Filter words where len(word) >= minLen && len(word) <= maxLen."
              },
              {
                "title": "\ud83d\udd27 Pattern",
                "content": "<pre>1. result := []string{}\n2. For each word:\n   - len(word) in range? \u2192 append\n3. Return result</pre>"
              }
            ],
            "solution": "func filterByLengthRange(words []string, minLen, maxLen int) []string {\n    result := []string{}\n    for _, word := range words {\n        if len(word) >= minLen && len(word) <= maxLen {\n            result = append(result, word)\n        }\n    }\n    return result\n}",
            "difficulty": 2
          },
          {
            "id": "v12",
            "title": "Filter Multiples",
            "description": "Write <code>func filterMultiples(nums []int, divisor int) []int</code> that returns only numbers divisible by divisor (multiples of divisor).",
            "functionSignature": "func filterMultiples(nums []int, divisor int) []int",
            "testCases": [
              {
                "input": "[]int{3, 6, 7, 9, 12, 15}, 3",
                "output": "[]int{3, 6, 9, 12, 15}"
              },
              {
                "input": "[]int{1, 2, 3, 4, 5, 6}, 2",
                "output": "[]int{2, 4, 6}"
              }
            ],
            "hints": [
              {
                "title": "\ud83e\udd14 Think about it",
                "content": "A number is divisible by divisor if num % divisor == 0. Filter based on this condition."
              },
              {
                "title": "\ud83d\udca1 Hint",
                "content": "For each number, check if num % divisor == 0, then append to result."
              },
              {
                "title": "\ud83d\udd27 Pattern",
                "content": "<pre>1. result := []int{}\n2. For each num:\n   - num % divisor == 0? \u2192 append\n3. Return result</pre>"
              }
            ],
            "solution": "func filterMultiples(nums []int, divisor int) []int {\n    result := []int{}\n    for _, num := range nums {\n        if num % divisor == 0 {\n            result = append(result, num)\n        }\n    }\n    return result\n}",
            "difficulty": 2
          },
          {
            "id": "v13",
            "title": "Filter Contains Substring",
            "description": "Write <code>func filterContains(words []string, substr string) []string</code> that returns words containing the substring.",
            "functionSignature": "func filterContains(words []string, substr string) []string",
            "testCases": [
              {
                "input": "[]string{\"hello\", \"world\", \"help\", \"loop\"}, \"lo\"",
                "output": "[]string{\"hello\", \"loop\"}"
              },
              {
                "input": "[]string{\"go\", \"gopher\", \"python\"}, \"go\"",
                "output": "[]string{\"go\", \"gopher\"}"
              }
            ],
            "hints": [
              {
                "title": "\ud83e\udd14 Think about it",
                "content": "Use strings.Contains() to check if a word contains the substring."
              },
              {
                "title": "\ud83d\udca1 Hint",
                "content": "Import strings. Filter words where strings.Contains(word, substr) is true."
              },
              {
                "title": "\ud83d\udd27 Pattern",
                "content": "<pre>1. result := []string{}\n2. For each word:\n   - contains substr? \u2192 append\n3. Return result</pre>"
              }
            ],
            "solution": "import \"strings\"\n\nfunc filterContains(words []string, substr string) []string {\n    result := []string{}\n    for _, word := range words {\n        if strings.Contains(word, substr) {\n            result = append(result, word)\n        }\n    }\n    return result\n}",
            "difficulty": 2
          }
        ]
      },
      {
        "id": "challenge_6",
        "block": 2,
        "difficulty": 2,
        "concept": "Find Index",
        "docLinks": [
          {
            "url": "https://go.dev/ref/spec#For_statements",
            "title": "Go Spec: For statements",
            "note": "range with index"
          },
          {
            "url": "https://go.dev/ref/spec#Return_statements",
            "title": "Go Spec: Return statements",
            "note": "early returns"
          }
        ],
        "patternPrimer": {
          "bruteForce": "Loop through, return index immediately when found; return -1 if not found.",
          "bestApproach": "Same approach - early return is already optimal! No need to continue after finding match.",
          "typical": "Typically O(n) time worst case, O(1) if found early, O(1) extra space"
        },
        "variants": [
          {
            "id": "v1",
            "title": "Find Index",
            "description": "Write <code>func findIndex(nums []int, target int) int</code> returning index or -1.",
            "functionSignature": "func findIndex(nums []int, target int) int",
            "testCases": [
              {
                "input": "[]int{10, 20, 30}, 20",
                "output": "1"
              }
            ],
            "hints": [
              {
                "title": "\ud83e\udd14 Think about it",
                "content": "If you're looking for something specific, when should you stop looking? What should you return if you never find it?"
              },
              {
                "title": "\ud83d\udca1 Hint",
                "content": "Loop with the index variable. When you find a match, return that index immediately (early return). If the loop completes without finding anything, return -1."
              },
              {
                "title": "\ud83d\udd27 Pattern",
                "content": "<pre>1. For each element with its index:\n   - Matches target? \u2192 return index immediately\n2. Loop finished? \u2192 return -1 (not found)</pre>"
              }
            ],
            "solution": "func findIndex(nums []int, target int) int {\n    for i, n := range nums {\n        if n == target { return i }\n    }\n    return -1\n}",
            "difficulty": 1
          },
          {
            "id": "v2",
            "title": "Find Word",
            "description": "Write <code>func findWord(words []string, target string) int</code> returning index or -1.",
            "functionSignature": "func findWord(words []string, target string) int",
            "testCases": [
              {
                "input": "[]string{\"go\", \"py\"}, \"py\"",
                "output": "1"
              }
            ],
            "hints": [
              {
                "title": "\ud83e\udd14 Think about it",
                "content": "If you're looking for something specific, when should you stop looking? What should you return if you never find it?"
              },
              {
                "title": "\ud83d\udca1 Hint",
                "content": "Loop with the index variable. When you find a match, return that index immediately (early return). If the loop completes without finding anything, return -1."
              },
              {
                "title": "\ud83d\udd27 Pattern",
                "content": "<pre>1. For each element with its index:\n   - Matches target? \u2192 return index immediately\n2. Loop finished? \u2192 return -1 (not found)</pre>"
              }
            ],
            "solution": "func findWord(words []string, target string) int {\n    for i, w := range words {\n        if w == target { return i }\n    }\n    return -1\n}",
            "difficulty": 1
          },
          {
            "id": "v3",
            "title": "First Negative Index",
            "description": "Write <code>func firstNegIdx(nums []int) int</code> returning index of first negative or -1.",
            "functionSignature": "func firstNegIdx(nums []int) int",
            "testCases": [
              {
                "input": "[]int{5, -2, 3}",
                "output": "1"
              }
            ],
            "hints": [
              {
                "title": "\ud83e\udd14 Think about it",
                "content": "If you're looking for something specific, when should you stop looking? What should you return if you never find it?"
              },
              {
                "title": "\ud83d\udca1 Hint",
                "content": "Loop with the index variable. When you find a match, return that index immediately (early return). If the loop completes without finding anything, return -1."
              },
              {
                "title": "\ud83d\udd27 Pattern",
                "content": "<pre>1. For each element with its index:\n   - Matches target? \u2192 return index immediately\n2. Loop finished? \u2192 return -1 (not found)</pre>"
              }
            ],
            "solution": "func firstNegIdx(nums []int) int {\n    for i, n := range nums {\n        if n < 0 { return i }\n    }\n    return -1\n}",
            "difficulty": 1
          },
          {
            "id": "v4",
            "title": "Find First Even",
            "description": "Write <code>func firstEvenIdx(nums []int) int</code> returning the index of the first even number, or -1 if none.",
            "functionSignature": "func firstEvenIdx(nums []int) int",
            "testCases": [
              {
                "input": "[]int{1, 3, 4, 5}",
                "output": "2"
              },
              {
                "input": "[]int{1, 3, 5}",
                "output": "-1"
              }
            ],
            "hints": [
              {
                "title": "\ud83e\udd14 Think about it",
                "content": "How do you check if a number is even? Use the modulo operator."
              },
              {
                "title": "\ud83d\udca1 Hint",
                "content": "Check if n % 2 == 0. If so, return that index immediately. Otherwise keep looking."
              },
              {
                "title": "\ud83d\udd27 Pattern",
                "content": "<pre>1. For each element with its index:\n   - Is even (n % 2 == 0)? \u2192 return index\n2. Loop finished? \u2192 return -1 (not found)</pre>"
              }
            ],
            "solution": "func firstEvenIdx(nums []int) int {\n    for i, n := range nums {\n        if n % 2 == 0 { return i }\n    }\n    return -1\n}",
            "difficulty": 1
          },
          {
            "id": "v5",
            "title": "Last Index Of",
            "description": "Write <code>func lastIndex(nums []int, target int) int</code> returning the LAST index where target appears, or -1.",
            "functionSignature": "func lastIndex(nums []int, target int) int",
            "testCases": [
              {
                "input": "[]int{1, 2, 3, 2, 1}, 2",
                "output": "3"
              },
              {
                "input": "[]int{1, 2, 3}, 5",
                "output": "-1"
              }
            ],
            "hints": [
              {
                "title": "\ud83e\udd14 Think about it",
                "content": "Unlike finding the FIRST match (where you return immediately), for the LAST match you need to keep track of matches as you go."
              },
              {
                "title": "\ud83d\udca1 Hint",
                "content": "Initialize result to -1. Each time you find a match, update result to that index. After the loop, return result."
              },
              {
                "title": "\ud83d\udd27 Pattern",
                "content": "<pre>1. Initialize result := -1\n2. For each element with its index:\n   - Matches target? \u2192 result = index\n3. Return result (last match, or -1)</pre>"
              }
            ],
            "solution": "func lastIndex(nums []int, target int) int {\n    result := -1\n    for i, n := range nums {\n        if n == target { result = i }\n    }\n    return result\n}",
            "difficulty": 2
          },
          {
            "id": "v6",
            "title": "Find Long Word Index",
            "description": "Write <code>func findLongWordIdx(words []string, minLen int) int</code> returning the index of first word with length >= minLen, or -1.",
            "functionSignature": "func findLongWordIdx(words []string, minLen int) int",
            "testCases": [
              {
                "input": "[]string{\"go\", \"hi\", \"python\"}, 4",
                "output": "2"
              },
              {
                "input": "[]string{\"a\", \"bb\"}, 5",
                "output": "-1"
              }
            ],
            "hints": [
              {
                "title": "\ud83e\udd14 Think about it",
                "content": "Instead of matching an exact value, you're matching a condition (length >= minLen)."
              },
              {
                "title": "\ud83d\udca1 Hint",
                "content": "Check if len(w) >= minLen. If so, return that index immediately. Otherwise keep looking."
              },
              {
                "title": "\ud83d\udd27 Pattern",
                "content": "<pre>1. For each word with its index:\n   - Long enough? \u2192 return index\n2. Loop finished? \u2192 return -1 (not found)</pre>"
              }
            ],
            "solution": "func findLongWordIdx(words []string, minLen int) int {\n    for i, w := range words {\n        if len(w) >= minLen { return i }\n    }\n    return -1\n}",
            "difficulty": 1
          },
          {
            "id": "v7",
            "title": "Find All Indices",
            "difficulty": 3,
            "description": "Write <code>func findAllIndices(nums []int, target int) []int</code> that returns a slice of ALL positions where target appears. Return empty slice if not found.",
            "functionSignature": "func findAllIndices(nums []int, target int) []int",
            "testCases": [
              {
                "input": "[]int{1, 3, 5, 3, 7, 3}, 3",
                "output": "[1, 3, 5]",
                "note": "3 appears at indices 1, 3, and 5"
              },
              {
                "input": "[]int{1, 2, 3}, 5",
                "output": "[]",
                "note": "Not found, return empty slice"
              }
            ],
            "hints": [
              {
                "title": "\ud83e\udd14 Think about it",
                "content": "Instead of returning on first match, you need to collect ALL matching indices and keep searching."
              },
              {
                "title": "\ud83d\udca1 Hint",
                "content": "Create an empty result slice. Loop through all elements - whenever you find a match, append the index to result. Don't return early, keep searching."
              },
              {
                "title": "\ud83d\udd27 Pattern",
                "content": "<pre>1. indices := []int{}\n2. For i, num in enumerate:\n   - If num == target: append i to indices\n3. Return indices (might be empty)</pre>"
              }
            ],
            "solution": "func findAllIndices(nums []int, target int) []int {\n    indices := []int{}\n    for i, n := range nums {\n        if n == target {\n            indices = append(indices, i)\n        }\n    }\n    return indices\n}"
          },
          {
            "id": "v8",
            "title": "Binary Search Index",
            "difficulty": 3,
            "description": "Write <code>func binarySearch(nums []int, target int) int</code> that finds target in a SORTED slice using binary search. Return index or -1. Must use divide-and-conquer, not linear search.",
            "functionSignature": "func binarySearch(nums []int, target int) int",
            "testCases": [
              {
                "input": "[]int{1, 3, 5, 7, 9, 11}, 7",
                "output": "3"
              },
              {
                "input": "[]int{1, 3, 5, 7, 9, 11}, 4",
                "output": "-1"
              },
              {
                "input": "[]int{2, 4, 6, 8, 10}, 2",
                "output": "0"
              }
            ],
            "hints": [
              {
                "title": "\ud83e\udd14 Think about it",
                "content": "Since the slice is sorted, you don't need to check every element. Compare target to the middle element - this tells you which half to search next."
              },
              {
                "title": "\ud83d\udca1 Hint",
                "content": "Use two pointers: left = 0, right = len-1. While left <= right: calculate mid = (left+right)/2. If nums[mid] == target, found it! If target < nums[mid], search left half (right = mid-1). Otherwise search right half (left = mid+1)."
              },
              {
                "title": "\ud83d\udd27 Pattern",
                "content": "<pre>1. left := 0, right := len(nums)-1\n2. While left <= right:\n   - mid := (left + right) / 2\n   - If nums[mid] == target: return mid\n   - If target < nums[mid]: right = mid - 1\n   - Else: left = mid + 1\n3. Return -1 (not found)</pre>"
              }
            ],
            "solution": "func binarySearch(nums []int, target int) int {\n    left, right := 0, len(nums)-1\n    for left <= right {\n        mid := (left + right) / 2\n        if nums[mid] == target {\n            return mid\n        } else if target < nums[mid] {\n            right = mid - 1\n        } else {\n            left = mid + 1\n        }\n    }\n    return -1\n}"
          },
          {
            "id": "v9",
            "title": "First Negative Index",
            "description": "Write <code>func firstNegativeIdx(nums []int) int</code> that returns index of first negative number, or -1.",
            "functionSignature": "func firstNegativeIdx(nums []int) int",
            "testCases": [
              {
                "input": "[]int{5, 3, -2, 8}",
                "output": "2"
              },
              {
                "input": "[]int{1, 2, 3}",
                "output": "-1"
              }
            ],
            "hints": [
              {
                "title": "\ud83e\udd14 Think about it",
                "content": "Return index as soon as you find num < 0."
              },
              {
                "title": "\ud83d\udca1 Hint",
                "content": "Early return pattern: for i, num := range nums { if num < 0 { return i } }"
              },
              {
                "title": "\ud83d\udd27 Pattern",
                "content": "<pre>1. For i, num:\n   - num < 0? \u2192 return i\n2. Return -1</pre>"
              }
            ],
            "solution": "func firstNegativeIdx(nums []int) int {\n    for i, num := range nums {\n        if num < 0 { return i }\n    }\n    return -1\n}",
            "difficulty": 1
          },
          {
            "id": "v10",
            "title": "Find Keyword Position",
            "description": "Write <code>func findKeyword(words []string, keyword string) int</code> that returns index of keyword (case-insensitive).",
            "functionSignature": "func findKeyword(words []string, keyword string) int",
            "testCases": [
              {
                "input": "[]string{\"hello\", \"WORLD\", \"Go\"}, \"world\"",
                "output": "1"
              },
              {
                "input": "[]string{\"apple\", \"banana\"}, \"orange\"",
                "output": "-1"
              }
            ],
            "hints": [
              {
                "title": "\ud83e\udd14 Think about it",
                "content": "Compare lowercase versions of both word and keyword."
              },
              {
                "title": "\ud83d\udca1 Hint",
                "content": "Use strings.ToLower() to normalize before comparing."
              },
              {
                "title": "\ud83d\udd27 Pattern",
                "content": "<pre>1. For i, word:\n   - ToLower(word) == ToLower(keyword)?\n     \u2192 return i\n2. Return -1</pre>"
              }
            ],
            "solution": "func findKeyword(words []string, keyword string) int {\n    keyword = strings.ToLower(keyword)\n    for i, word := range words {\n        if strings.ToLower(word) == keyword {\n            return i\n        }\n    }\n    return -1\n}",
            "difficulty": 2
          },
          {
            "id": "v11",
            "title": "Find First Negative",
            "description": "Write <code>func findFirstNegative(nums []int) int</code> that returns the index of the first negative number, or -1 if none found.",
            "functionSignature": "func findFirstNegative(nums []int) int",
            "testCases": [
              {
                "input": "[]int{5, 3, -2, 8, -1}",
                "output": "2"
              },
              {
                "input": "[]int{1, 2, 3}",
                "output": "-1"
              }
            ],
            "hints": [
              {
                "title": "\ud83e\udd14 Think about it",
                "content": "Loop through and check each number. Return the index as soon as you find a negative."
              },
              {
                "title": "\ud83d\udca1 Hint",
                "content": "Use early return: if num < 0, return i immediately."
              },
              {
                "title": "\ud83d\udd27 Pattern",
                "content": "<pre>1. For i, num:\n   - num < 0? \u2192 return i\n2. Return -1 (not found)</pre>"
              }
            ],
            "solution": "func findFirstNegative(nums []int) int {\n    for i, num := range nums {\n        if num < 0 {\n            return i\n        }\n    }\n    return -1\n}",
            "difficulty": 2
          },
          {
            "id": "v12",
            "title": "Find Last Index Of",
            "description": "Write <code>func findLastIndexOf(nums []int, target int) int</code> that returns the index of the LAST occurrence of target, or -1 if not found.",
            "functionSignature": "func findLastIndexOf(nums []int, target int) int",
            "testCases": [
              {
                "input": "[]int{1, 2, 3, 2, 5}, 2",
                "output": "3",
                "note": "last occurrence of 2 is at index 3"
              },
              {
                "input": "[]int{5, 5, 5}, 5",
                "output": "2"
              }
            ],
            "hints": [
              {
                "title": "\ud83e\udd14 Think about it",
                "content": "Loop through all elements and track the most recent index where you found the target."
              },
              {
                "title": "\ud83d\udca1 Hint",
                "content": "Keep updating lastIndex whenever you find target. Initialize to -1."
              },
              {
                "title": "\ud83d\udd27 Pattern",
                "content": "<pre>1. lastIndex := -1\n2. For i, num:\n   - num == target? \u2192 lastIndex = i\n3. Return lastIndex</pre>"
              }
            ],
            "solution": "func findLastIndexOf(nums []int, target int) int {\n    lastIndex := -1\n    for i, num := range nums {\n        if num == target {\n            lastIndex = i\n        }\n    }\n    return lastIndex\n}",
            "difficulty": 2
          },
          {
            "id": "v13",
            "title": "Find Index of Longest Word",
            "description": "Write <code>func findLongestWordIndex(words []string) int</code> that returns the index of the longest word. If multiple words tie, return the first occurrence.",
            "functionSignature": "func findLongestWordIndex(words []string) int",
            "testCases": [
              {
                "input": "[]string{\"go\", \"rust\", \"python\", \"c\"}",
                "output": "2",
                "note": "python is longest at index 2"
              },
              {
                "input": "[]string{\"hello\", \"world\"}",
                "output": "0",
                "note": "both length 5, return first"
              }
            ],
            "hints": [
              {
                "title": "\ud83e\udd14 Think about it",
                "content": "Track both the maximum length seen and the index where it occurred."
              },
              {
                "title": "\ud83d\udca1 Hint",
                "content": "Keep maxLen and maxIndex. For each word, if len(word) > maxLen, update both."
              },
              {
                "title": "\ud83d\udd27 Pattern",
                "content": "<pre>1. maxLen := 0, maxIndex := 0\n2. For i, word:\n   - len(word) > maxLen?\n     \u2192 maxLen = len(word), maxIndex = i\n3. Return maxIndex</pre>"
              }
            ],
            "solution": "func findLongestWordIndex(words []string) int {\n    maxLen := 0\n    maxIndex := 0\n    \n    for i, word := range words {\n        if len(word) > maxLen {\n            maxLen = len(word)\n            maxIndex = i\n        }\n    }\n    \n    return maxIndex\n}",
            "difficulty": 2
          }
        ]
      },
      {
        "id": "challenge_7",
        "block": 2,
        "difficulty": 2,
        "concept": "Frequency Map",
        "docLinks": [
          {
            "url": "https://go.dev/blog/maps",
            "title": "Go Blog: Go maps in action",
            "note": "map operations"
          },
          {
            "url": "https://go.dev/ref/spec#Making_slices_maps_and_channels",
            "title": "Go Spec: make()",
            "note": "creating maps"
          }
        ],
        "patternPrimer": {
          "bruteForce": "Nested loops: for each unique element, scan the entire array again to count occurrences.",
          "bestApproach": "Single pass with a map, incrementing counts[element]++ as we go. Map automatically tracks unique keys.",
          "typical": "Typically O(n) time, O(n) extra space"
        },
        "variants": [
          {
            "id": "v1",
            "title": "Count Occurrences",
            "description": "Write <code>func countOccurrences(nums []int) map[int]int</code>.",
            "functionSignature": "func countOccurrences(nums []int) map[int]int",
            "testCases": [
              {
                "input": "[]int{1, 2, 2, 3, 3, 3}",
                "output": "map[1:1 2:2 3:3]"
              }
            ],
            "hints": [
              {
                "title": "\ud83e\udd14 Think about it",
                "content": "You want to count how many times each element appears. What data structure maps 'thing' to 'count of that thing'?"
              },
              {
                "title": "\ud83d\udca1 Hint",
                "content": "Use a map where keys are the elements and values are counts. The magic: accessing a non-existent key returns 0, so you can just do counts[item]++ even for the first occurrence."
              },
              {
                "title": "\ud83d\udd27 Pattern",
                "content": "<pre>1. Create empty count map\n2. For each element:\n   - Increment count for that element\n3. Return map</pre>"
              }
            ],
            "solution": "func countOccurrences(nums []int) map[int]int {\n    c := make(map[int]int)\n    for _, n := range nums { c[n]++ }\n    return c\n}",
            "difficulty": 1
          },
          {
            "id": "v2",
            "title": "Count Characters",
            "description": "Write <code>func countChars(s string) map[rune]int</code>.",
            "functionSignature": "func countChars(s string) map[rune]int",
            "testCases": [
              {
                "input": "\"hello\"",
                "output": "map[e:1 h:1 l:2 o:1]"
              }
            ],
            "hints": [
              {
                "title": "\ud83e\udd14 Think about it",
                "content": "You want to count how many times each element appears. What data structure maps 'thing' to 'count of that thing'?"
              },
              {
                "title": "\ud83d\udca1 Hint",
                "content": "Use a map where keys are the elements and values are counts. The magic: accessing a non-existent key returns 0, so you can just do counts[item]++ even for the first occurrence."
              },
              {
                "title": "\ud83d\udd27 Pattern",
                "content": "<pre>1. Create empty count map\n2. For each element:\n   - Increment count for that element\n3. Return map</pre>"
              }
            ],
            "solution": "func countChars(s string) map[rune]int {\n    c := make(map[rune]int)\n    for _, r := range s { c[r]++ }\n    return c\n}",
            "difficulty": 1
          },
          {
            "id": "v3",
            "title": "Word Frequency",
            "description": "Write <code>func wordFreq(words []string) map[string]int</code>.",
            "functionSignature": "func wordFreq(words []string) map[string]int",
            "testCases": [
              {
                "input": "[]string{\"go\", \"go\", \"py\"}",
                "output": "map[go:2 py:1]"
              }
            ],
            "hints": [
              {
                "title": "\ud83e\udd14 Think about it",
                "content": "You want to count how many times each element appears. What data structure maps 'thing' to 'count of that thing'?"
              },
              {
                "title": "\ud83d\udca1 Hint",
                "content": "Use a map where keys are the elements and values are counts. The magic: accessing a non-existent key returns 0, so you can just do counts[item]++ even for the first occurrence."
              },
              {
                "title": "\ud83d\udd27 Pattern",
                "content": "<pre>1. Create empty count map\n2. For each element:\n   - Increment count for that element\n3. Return map</pre>"
              }
            ],
            "solution": "func wordFreq(words []string) map[string]int {\n    c := make(map[string]int)\n    for _, w := range words { c[w]++ }\n    return c\n}",
            "difficulty": 1
          },
          {
            "id": "v4",
            "title": "Count Even and Odd",
            "description": "Write <code>func countEvenOdd(nums []int) map[string]int</code> returning a map with keys \"even\" and \"odd\" showing how many of each.",
            "functionSignature": "func countEvenOdd(nums []int) map[string]int",
            "testCases": [
              {
                "input": "[]int{1, 2, 3, 4, 5}",
                "output": "map[even:2 odd:3]"
              }
            ],
            "hints": [
              {
                "title": "\ud83e\udd14 Think about it",
                "content": "Similar to counting positives/negatives, but now store the counts in a map instead of separate variables."
              },
              {
                "title": "\ud83d\udca1 Hint",
                "content": "Use num % 2 to check: if it equals 0, the number is even. Increment the appropriate key in your map."
              },
              {
                "title": "\ud83d\udd27 Pattern",
                "content": "<pre>1. Create empty count map\n2. For each element:\n   - Is it even (num % 2 == 0)? \u2192 increment \"even\"\n   - Otherwise \u2192 increment \"odd\"\n3. Return map</pre>"
              }
            ],
            "solution": "func countEvenOdd(nums []int) map[string]int {\n    c := make(map[string]int)\n    for _, n := range nums {\n        if n % 2 == 0 { c[\"even\"]++ } else { c[\"odd\"]++ }\n    }\n    return c\n}",
            "difficulty": 2
          },
          {
            "id": "v5",
            "title": "Invert Count Map",
            "description": "Write <code>func invertCounts(counts map[string]int) map[int][]string</code> that inverts a frequency map. Keys become values grouped by their original values.",
            "functionSignature": "func invertCounts(counts map[string]int) map[int][]string",
            "testCases": [
              {
                "input": "map[string]int{\"a\": 2, \"b\": 1, \"c\": 2}",
                "output": "map[1:[b] 2:[a c]]",
                "note": "words with count 1: [b], words with count 2: [a, c]"
              }
            ],
            "hints": [
              {
                "title": "\ud83e\udd14 Think about it",
                "content": "You're flipping the relationship: instead of word\u2192count, you want count\u2192[words with that count]."
              },
              {
                "title": "\ud83d\udca1 Hint",
                "content": "Loop through the original map. For each key-value pair, append the key to the slice stored at the value in your new map."
              },
              {
                "title": "\ud83d\udd27 Pattern",
                "content": "<pre>1. Create result map[int][]string\n2. For each word, count in original:\n   - Append word to result[count]\n3. Return result</pre>"
              }
            ],
            "solution": "func invertCounts(counts map[string]int) map[int][]string {\n    result := make(map[int][]string)\n    for word, count := range counts {\n        result[count] = append(result[count], word)\n    }\n    return result\n}",
            "difficulty": 3
          },
          {
            "id": "v6",
            "title": "Count by Length",
            "description": "Write <code>func countByLength(words []string) map[int]int</code> that groups words by their length and counts how many words are in each group. Keys are lengths, values are counts.",
            "functionSignature": "func countByLength(words []string) map[int]int",
            "testCases": [
              {
                "input": "[]string{\"go\", \"rust\", \"c\", \"js\"}",
                "output": "map[1:1 2:2 4:1]",
                "note": "1 word of length 1 (c), 2 words of length 2 (go, js), 1 word of length 4 (rust)"
              }
            ],
            "hints": [
              {
                "title": "\ud83e\udd14 Think about it",
                "content": "Instead of counting the words themselves, you're counting a property of each word. What property? Its length."
              },
              {
                "title": "\ud83d\udca1 Hint",
                "content": "Use len(word) as the key. Same counting pattern, just using the length instead of the word itself."
              },
              {
                "title": "\ud83d\udd27 Pattern",
                "content": "<pre>1. Create empty count map\n2. For each word:\n   - Get its length with len(word)\n   - Increment count for that length\n3. Return map</pre>"
              }
            ],
            "solution": "func countByLength(words []string) map[int]int {\n    c := make(map[int]int)\n    for _, w := range words { c[len(w)]++ }\n    return c\n}",
            "difficulty": 2
          },
          {
            "id": "v7",
            "title": "Count by Remainder",
            "description": "Write <code>func countByRemainder(nums []int, divisor int) map[int]int</code> that groups numbers by their remainder when divided by divisor.",
            "functionSignature": "func countByRemainder(nums []int, divisor int) map[int]int",
            "testCases": [
              {
                "input": "[]int{1, 2, 3, 4, 5, 6}, 3",
                "output": "map[0:2 1:2 2:2]",
                "note": "3,6 have remainder 0; 1,4 have remainder 1; 2,5 have remainder 2"
              },
              {
                "input": "[]int{10, 20, 30}, 10",
                "output": "map[0:3]"
              }
            ],
            "hints": [
              {
                "title": "\ud83e\udd14 Think about it",
                "content": "The key is num % divisor (the remainder). Count how many numbers give each remainder."
              },
              {
                "title": "\ud83d\udca1 Hint",
                "content": "Same counting pattern as before, but use num % divisor as the key."
              },
              {
                "title": "\ud83d\udd27 Pattern",
                "content": "<pre>1. Create empty count map\n2. For each num:\n   - remainder := num % divisor\n   - counts[remainder]++\n3. Return counts</pre>"
              }
            ],
            "solution": "func countByRemainder(nums []int, divisor int) map[int]int {\n    c := make(map[int]int)\n    for _, n := range nums { c[n % divisor]++ }\n    return c\n}",
            "difficulty": 2
          },
          {
            "id": "v8",
            "title": "Group by First Letter",
            "description": "Write <code>func countByFirstLetter(words []string) map[string]int</code> that counts how many words start with each letter. Use lowercase keys.",
            "functionSignature": "func countByFirstLetter(words []string) map[string]int",
            "testCases": [
              {
                "input": "[]string{\"apple\", \"ant\", \"bear\", \"ace\"}",
                "output": "map[a:3 b:1]"
              },
              {
                "input": "[]string{\"Go\", \"great\", \"Python\"}",
                "output": "map[g:2 p:1]",
                "note": "lowercase keys"
              }
            ],
            "hints": [
              {
                "title": "\ud83e\udd14 Think about it",
                "content": "Extract the first character of each word and use it as the key. How do you get the first character of a string?"
              },
              {
                "title": "\ud83d\udca1 Hint",
                "content": "Use strings.ToLower(string(word[0])) to get the lowercase first letter as a string. Then count like before."
              },
              {
                "title": "\ud83d\udd27 Pattern",
                "content": "<pre>1. Create empty count map\n2. For each word:\n   - Get first letter (lowercase)\n   - Increment count for that letter\n3. Return map</pre>"
              }
            ],
            "solution": "func countByFirstLetter(words []string) map[string]int {\n    c := make(map[string]int)\n    for _, w := range words {\n        if len(w) > 0 {\n            first := strings.ToLower(string(w[0]))\n            c[first]++\n        }\n    }\n    return c\n}",
            "difficulty": 2
          },
          {
            "id": "v9",
            "title": "Vote Tally",
            "description": "Write <code>func voteTally(votes []string) map[string]int</code> that counts votes for each candidate.",
            "functionSignature": "func voteTally(votes []string) map[string]int",
            "testCases": [
              {
                "input": "[]string{\"Alice\", \"Bob\", \"Alice\", \"Charlie\", \"Alice\"}",
                "output": "map[string]int{\"Alice\": 3, \"Bob\": 1, \"Charlie\": 1}"
              },
              {
                "input": "[]string{\"Yes\", \"No\", \"Yes\"}",
                "output": "map[string]int{\"Yes\": 2, \"No\": 1}"
              }
            ],
            "hints": [
              {
                "title": "\ud83e\udd14 Think about it",
                "content": "Standard frequency map: increment count for each vote."
              },
              {
                "title": "\ud83d\udca1 Hint",
                "content": "counts[vote]++ for each vote."
              },
              {
                "title": "\ud83d\udd27 Pattern",
                "content": "<pre>1. counts := make(map[string]int)\n2. For each vote:\n   - counts[vote]++\n3. Return counts</pre>"
              }
            ],
            "solution": "func voteTally(votes []string) map[string]int {\n    counts := make(map[string]int)\n    for _, vote := range votes {\n        counts[vote]++\n    }\n    return counts\n}",
            "difficulty": 1
          },
          {
            "id": "v10",
            "title": "Grade Distribution",
            "description": "Write <code>func gradeDistribution(grades []string) map[string]int</code> that counts how many of each letter grade.",
            "functionSignature": "func gradeDistribution(grades []string) map[string]int",
            "testCases": [
              {
                "input": "[]string{\"A\", \"B\", \"A\", \"C\", \"A\", \"B\"}",
                "output": "map[string]int{\"A\": 3, \"B\": 2, \"C\": 1}"
              },
              {
                "input": "[]string{\"F\", \"F\", \"D\"}",
                "output": "map[string]int{\"F\": 2, \"D\": 1}"
              }
            ],
            "hints": [
              {
                "title": "\ud83e\udd14 Think about it",
                "content": "Another frequency map - count occurrences of each grade."
              },
              {
                "title": "\ud83d\udca1 Hint",
                "content": "Same pattern: dist[grade]++ for each grade."
              },
              {
                "title": "\ud83d\udd27 Pattern",
                "content": "<pre>1. dist := make(map[string]int)\n2. For each grade:\n   - dist[grade]++\n3. Return dist</pre>"
              }
            ],
            "solution": "func gradeDistribution(grades []string) map[string]int {\n    dist := make(map[string]int)\n    for _, grade := range grades {\n        dist[grade]++\n    }\n    return dist\n}",
            "difficulty": 1
          },
          {
            "id": "v11",
            "title": "Most Common Element",
            "description": "Write <code>func mostCommonElement(items []string) string</code> that returns the element appearing most frequently. If multiple items tie for most common, return the one that appeared first.",
            "functionSignature": "func mostCommonElement(items []string) string",
            "testCases": [
              {
                "input": "[\"cat\", \"dog\", \"cat\", \"bird\", \"dog\", \"dog\"]",
                "output": "\"dog\"",
                "note": "dog appears 3 times"
              },
              {
                "input": "[\"a\", \"b\", \"a\"]",
                "output": "\"a\""
              }
            ],
            "hints": [
              {
                "title": "\ud83e\udd14 Think about it",
                "content": "First build a frequency map to count all items. Then find the key with the highest value. Track both the item and its frequency as you search."
              },
              {
                "title": "\ud83d\udca1 Hint",
                "content": "Build frequency map with freq[item]++. Then loop through the map to find the key with maximum value. Keep track of maxCount and mostCommon item."
              },
              {
                "title": "\ud83d\udd27 Pattern",
                "content": "<pre>1. Build frequency map\n2. maxCount := 0, mostCommon := \"\"\n3. For each item, count in map:\n   - count > maxCount?\n     \u2192 maxCount = count, mostCommon = item\n4. Return mostCommon</pre>"
              }
            ],
            "solution": "func mostCommonElement(items []string) string {\n    freq := make(map[string]int)\n    for _, item := range items {\n        freq[item]++\n    }\n    \n    maxCount := 0\n    mostCommon := \"\"\n    \n    for item, count := range freq {\n        if count > maxCount {\n            maxCount = count\n            mostCommon = item\n        }\n    }\n    \n    return mostCommon\n}",
            "difficulty": 3
          },
          {
            "id": "v12",
            "title": "Frequency Histogram",
            "description": "Write <code>func frequencyHistogram(nums []int) map[int]int</code> that returns a \"meta-map\" showing how many elements appear each number of times. For example, if 2 elements appear once and 1 element appears twice, return map[1:2, 2:1].",
            "functionSignature": "func frequencyHistogram(nums []int) map[int]int",
            "testCases": [
              {
                "input": "[]int{1, 1, 2, 3, 3, 3}",
                "output": "map[1:1 2:2 3:1]",
                "note": "one element appears 1x (2), two elements appear 2x (1), one element appears 3x (3)"
              },
              {
                "input": "[]int{5, 5, 5, 5}",
                "output": "map[4:1]",
                "note": "one element appears 4 times"
              }
            ],
            "hints": [
              {
                "title": "\ud83e\udd14 Think about it",
                "content": "Build a frequency map first to count how often each number appears. Then build a second map that counts how many numbers have each frequency."
              },
              {
                "title": "\ud83d\udca1 Hint",
                "content": "Step 1: Build freq map with freq[num]++. Step 2: Build histogram with histogram[count]++ for each count in freq. This creates a frequency-of-frequencies map."
              },
              {
                "title": "\ud83d\udd27 Pattern",
                "content": "<pre>1. Build freq map (num \u2192 count)\n2. Create histogram map[int]int\n3. For each count in freq.values:\n   - histogram[count]++\n4. Return histogram</pre>"
              }
            ],
            "solution": "func frequencyHistogram(nums []int) map[int]int {\n    freq := make(map[int]int)\n    for _, num := range nums {\n        freq[num]++\n    }\n    \n    histogram := make(map[int]int)\n    for _, count := range freq {\n        histogram[count]++\n    }\n    \n    return histogram\n}",
            "difficulty": 3
          },
          {
            "id": "v13",
            "title": "Merge Frequency Maps",
            "description": "Write <code>func mergeFrequencyMaps(map1, map2 map[string]int) map[string]int</code> that merges two frequency maps by adding their counts. If a key exists in both maps, add the counts together.",
            "functionSignature": "func mergeFrequencyMaps(map1, map2 map[string]int) map[string]int",
            "testCases": [
              {
                "input": "map[\"a\":2, \"b\":1], map[\"a\":1, \"c\":3]",
                "output": "map[\"a\":3 \"b\":1 \"c\":3]"
              },
              {
                "input": "map[\"x\":5], map[\"x\":3]",
                "output": "map[\"x\":8]"
              }
            ],
            "hints": [
              {
                "title": "\ud83e\udd14 Think about it",
                "content": "Copy all entries from map1 to result. Then iterate through map2, adding each count to result (which may already have that key)."
              },
              {
                "title": "\ud83d\udca1 Hint",
                "content": "Create result map. Copy map1: result[k] = v. Then for each k, v in map2: result[k] += v. This adds to existing or creates new entry."
              },
              {
                "title": "\ud83d\udd27 Pattern",
                "content": "<pre>1. Create result map\n2. Copy all from map1 to result\n3. For each key, value in map2:\n   - result[key] += value\n4. Return result</pre>"
              }
            ],
            "solution": "func mergeFrequencyMaps(map1, map2 map[string]int) map[string]int {\n    result := make(map[string]int)\n    \n    for k, v := range map1 {\n        result[k] = v\n    }\n    \n    for k, v := range map2 {\n        result[k] += v\n    }\n    \n    return result\n}",
            "difficulty": 3
          },
          {
            "id": "v1",
            "title": "Contains Duplicate",
            "description": "Write a function <code>func containsDuplicate(nums []int) bool</code> that returns <code>true</code> if any number appears more than once in the slice, <code>false</code> if all numbers are unique.",
            "functionSignature": "func containsDuplicate(nums []int) bool",
            "testCases": [
              {
                "input": "[]int{1, 2, 3, 1}",
                "output": "true"
              },
              {
                "input": "[]int{1, 2, 3, 4}",
                "output": "false"
              },
              {
                "input": "[]int{1, 1, 1, 1}",
                "output": "true"
              }
            ],
            "solution": "func containsDuplicate(nums []int) bool {\n    seen := make(map[int]bool)\n    for _, num := range nums {\n        if seen[num] {\n            return true\n        }\n        seen[num] = true\n    }\n    return false\n}",
            "difficulty": 4
          },
          {
            "id": "v2",
            "title": "First Duplicate Value",
            "description": "Write a function <code>func firstDuplicate(nums []int) int</code> that returns the first number that appears twice (the second occurrence). Return <code>-1</code> if no duplicates exist.",
            "functionSignature": "func firstDuplicate(nums []int) int",
            "testCases": [
              {
                "input": "[]int{2, 1, 3, 5, 3, 2}",
                "output": "3",
                "note": "3 is seen again before 2 is"
              },
              {
                "input": "[]int{1, 2, 3, 4}",
                "output": "-1"
              },
              {
                "input": "[]int{1, 1, 2, 2}",
                "output": "1"
              }
            ],
            "solution": "func firstDuplicate(nums []int) int {\n    seen := make(map[int]bool)\n    for _, num := range nums {\n        if seen[num] {\n            return num\n        }\n        seen[num] = true\n    }\n    return -1\n}",
            "solutionNotes": "Unlike Contains Duplicate which returns a bool, this returns the actual duplicate value. Same pattern, different return type!",
            "difficulty": 4
          },
          {
            "id": "v3",
            "title": "Count Unique Elements",
            "description": "Write a function <code>func countUnique(nums []int) int</code> that returns how many distinct values are in the slice.",
            "functionSignature": "func countUnique(nums []int) int",
            "testCases": [
              {
                "input": "[]int{1, 2, 2, 3, 3, 3}",
                "output": "3",
                "note": "unique values: 1, 2, 3"
              },
              {
                "input": "[]int{5, 5, 5, 5}",
                "output": "1"
              },
              {
                "input": "[]int{1, 2, 3, 4, 5}",
                "output": "5"
              }
            ],
            "solution": "func countUnique(nums []int) int {\n    seen := make(map[int]bool)\n    for _, num := range nums {\n        seen[num] = true\n    }\n    return len(seen)\n}",
            "solutionNotes": "Here we don't check if seen - we just add everything. The map handles duplicates automatically, and <code>len(seen)</code> gives us the count of unique keys!",
            "difficulty": 4
          },
          {
            "id": "v4",
            "title": "Find All Duplicates",
            "description": "Write a function <code>func findDuplicates(nums []int) []int</code> that returns a slice containing each number that appears more than once. Each duplicate should only appear once in the result.",
            "functionSignature": "func findDuplicates(nums []int) []int",
            "testCases": [
              {
                "input": "[]int{4, 3, 2, 7, 8, 2, 3, 1}",
                "output": "[2, 3]"
              },
              {
                "input": "[]int{1, 1, 2, 2, 3, 3}",
                "output": "[1, 2, 3]"
              },
              {
                "input": "[]int{1, 2, 3}",
                "output": "[]"
              }
            ],
            "solution": "func findDuplicates(nums []int) []int {\n    seen := make(map[int]bool)\n    added := make(map[int]bool)\n    result := []int{}\n    \n    for _, num := range nums {\n        if seen[num] && !added[num] {\n            result = append(result, num)\n            added[num] = true\n        }\n        seen[num] = true\n    }\n    return result\n}",
            "solutionNotes": "We need TWO maps here: one to track what we've seen, and one to avoid adding the same duplicate twice to the result.",
            "difficulty": 4
          },
          {
            "id": "v5",
            "title": "Common Elements",
            "description": "Write a function <code>func hasCommon(a, b []int) bool</code> that returns <code>true</code> if the two slices share at least one common element.",
            "functionSignature": "func hasCommon(a, b []int) bool",
            "testCases": [
              {
                "input": "[]int{1, 2, 3}, []int{3, 4, 5}",
                "output": "true",
                "note": "3 is common"
              },
              {
                "input": "[]int{1, 2}, []int{3, 4}",
                "output": "false"
              },
              {
                "input": "[]int{1}, []int{1}",
                "output": "true"
              }
            ],
            "solution": "func hasCommon(a, b []int) bool {\n    setA := make(map[int]bool)\n    for _, num := range a {\n        setA[num] = true\n    }\n    \n    for _, num := range b {\n        if setA[num] {\n            return true\n        }\n    }\n    return false\n}",
            "solutionNotes": "Build a set from the first slice, then check if any element from the second slice exists in it. This is O(n+m) instead of O(n*m)!",
            "difficulty": 4
          },
          {
            "id": "v6",
            "title": "Find Intersection",
            "description": "Write a function <code>func intersection(a, b []int) []int</code> that returns a slice of elements that appear in both input slices. Each element should appear only once in the result.",
            "functionSignature": "func intersection(a, b []int) []int",
            "testCases": [
              {
                "input": "[]int{1, 2, 2, 1}, []int{2, 2}",
                "output": "[2]"
              },
              {
                "input": "[]int{4, 9, 5}, []int{9, 4, 9, 8, 4}",
                "output": "[9, 4]",
                "note": "or [4, 9] - order doesn't matter"
              },
              {
                "input": "[]int{1, 2}, []int{3, 4}",
                "output": "[]"
              }
            ],
            "solution": "func intersection(a, b []int) []int {\n    setA := make(map[int]bool)\n    for _, num := range a {\n        setA[num] = true\n    }\n    \n    result := []int{}\n    seen := make(map[int]bool)\n    for _, num := range b {\n        if setA[num] && !seen[num] {\n            result = append(result, num)\n            seen[num] = true\n        }\n    }\n    return result\n}",
            "solutionNotes": "Similar to hasCommon, but we collect the common elements instead of just returning true. We use a second map to avoid adding duplicates to the result.",
            "difficulty": 4
          },
          {
            "id": "v1",
            "title": "Word Counter",
            "description": "Write <code>func wordCount(s string) map[string]int</code> that counts how many times each word appears in a string.",
            "functionSignature": "func wordCount(s string) map[string]int",
            "testCases": [
              {
                "input": "\"the quick brown fox jumps over the lazy dog\"",
                "output": "map[brown:1 dog:1 fox:1 jumps:1 lazy:1 over:1 quick:1 the:2]"
              }
            ],
            "solution": "import \"strings\"\n\nfunc wordCount(s string) map[string]int {\n    counts := make(map[string]int)\n    for _, word := range strings.Fields(s) {\n        counts[word]++\n    }\n    return counts\n}",
            "difficulty": 4
          },
          {
            "id": "v2",
            "title": "Most Frequent Element",
            "description": "Write <code>func mostFrequent(nums []int) int</code> that returns the element that appears most frequently. If there's a tie, return any of them.",
            "functionSignature": "func mostFrequent(nums []int) int",
            "testCases": [
              {
                "input": "[]int{1, 3, 2, 1, 4, 1}",
                "output": "1",
                "note": "1 appears 3 times"
              },
              {
                "input": "[]int{5, 5, 4, 4, 4}",
                "output": "4"
              },
              {
                "input": "[]int{7}",
                "output": "7"
              }
            ],
            "solution": "func mostFrequent(nums []int) int {\n    counts := make(map[int]int)\n    for _, num := range nums {\n        counts[num]++\n    }\n    \n    maxCount := 0\n    result := nums[0]\n    for num, count := range counts {\n        if count > maxCount {\n            maxCount = count\n            result = num\n        }\n    }\n    return result\n}",
            "solutionNotes": "First count everything, then iterate the map to find the max. This is a two-pass approach over different data structures.",
            "difficulty": 4
          },
          {
            "id": "v3",
            "title": "First Unique Character",
            "description": "Write <code>func firstUniqChar(s string) int</code> that returns the index of the first non-repeating character. Return -1 if none exists.",
            "functionSignature": "func firstUniqChar(s string) int",
            "testCases": [
              {
                "input": "\"leetcode\"",
                "output": "0",
                "note": "'l' is first unique"
              },
              {
                "input": "\"loveleetcode\"",
                "output": "2",
                "note": "'v' is first unique"
              },
              {
                "input": "\"aabb\"",
                "output": "-1"
              }
            ],
            "solution": "func firstUniqChar(s string) int {\n    counts := make(map[rune]int)\n    runes := []rune(s)\n    \n    for _, r := range runes {\n        counts[r]++\n    }\n    \n    for i, r := range runes {\n        if counts[r] == 1 {\n            return i\n        }\n    }\n    return -1\n}",
            "solutionNotes": "Two passes needed: first to count, second to find the first character with count == 1. We iterate the original string (not the map) to preserve order.",
            "difficulty": 4
          },
          {
            "id": "v4",
            "title": "Is Anagram",
            "description": "Write <code>func isAnagram(s, t string) bool</code> that returns true if t is an anagram of s (same letters, different order).",
            "functionSignature": "func isAnagram(s, t string) bool",
            "testCases": [
              {
                "input": "\"anagram\", \"nagaram\"",
                "output": "true"
              },
              {
                "input": "\"rat\", \"car\"",
                "output": "false"
              },
              {
                "input": "\"listen\", \"silent\"",
                "output": "true"
              }
            ],
            "solution": "func isAnagram(s, t string) bool {\n    if len(s) != len(t) {\n        return false\n    }\n    \n    counts := make(map[rune]int)\n    for _, r := range s {\n        counts[r]++\n    }\n    for _, r := range t {\n        counts[r]--\n        if counts[r] < 0 {\n            return false\n        }\n    }\n    return true\n}",
            "solutionNotes": "Count characters in s (increment), then 'uncount' characters in t (decrement). If we ever go negative, t has a character s doesn't have.",
            "difficulty": 4
          },
          {
            "id": "v5",
            "title": "Can Construct",
            "description": "Write <code>func canConstruct(ransomNote, magazine string) bool</code> that returns true if ransomNote can be constructed from magazine letters (each letter used once).",
            "functionSignature": "func canConstruct(ransomNote, magazine string) bool",
            "testCases": [
              {
                "input": "\"a\", \"b\"",
                "output": "false"
              },
              {
                "input": "\"aa\", \"aab\"",
                "output": "true"
              },
              {
                "input": "\"aa\", \"ab\"",
                "output": "false",
                "note": "need 2 a's but only 1"
              }
            ],
            "solution": "func canConstruct(ransomNote, magazine string) bool {\n    available := make(map[rune]int)\n    \n    for _, r := range magazine {\n        available[r]++\n    }\n    \n    for _, r := range ransomNote {\n        available[r]--\n        if available[r] < 0 {\n            return false\n        }\n    }\n    return true\n}",
            "solutionNotes": "Similar to anagram check, but one-directional: we only need to verify ransomNote letters exist in magazine, not vice versa.",
            "difficulty": 4
          },
          {
            "id": "v6",
            "title": "Majority Element",
            "description": "Write <code>func majorityElement(nums []int) int</code> that finds the element appearing more than n/2 times. Assume such element always exists.",
            "functionSignature": "func majorityElement(nums []int) int",
            "testCases": [
              {
                "input": "[]int{3, 2, 3}",
                "output": "3"
              },
              {
                "input": "[]int{2, 2, 1, 1, 1, 2, 2}",
                "output": "2"
              },
              {
                "input": "[]int{1, 1, 1, 1}",
                "output": "1"
              }
            ],
            "solution": "func majorityElement(nums []int) int {\n    counts := make(map[int]int)\n    threshold := len(nums) / 2\n    \n    for _, num := range nums {\n        counts[num]++\n        if counts[num] > threshold {\n            return num\n        }\n    }\n    return -1\n}",
            "solutionNotes": "We can return early as soon as any element exceeds n/2 count. No need to finish counting everything!",
            "difficulty": 4
          }
        ]
      },
      {
        "id": "challenge_8",
        "block": 3,
        "difficulty": 3,
        "concept": "Swap Pattern",
        "docLinks": [
          {
            "url": "https://go.dev/ref/spec#Assignments",
            "title": "Go Spec: Assignments",
            "note": "tuple assignment (a, b = b, a)"
          },
          {
            "url": "https://go.dev/ref/spec#Index_expressions",
            "title": "Go Spec: Index expressions",
            "note": "slice indexing"
          }
        ],
        "patternPrimer": {
          "bruteForce": "Use a temp variable: temp = a, a = b, b = temp (three operations).",
          "bestApproach": "Go's simultaneous assignment: a, b = b, a (evaluates right side first, then assigns).",
          "typical": "Typically O(1) time, O(1) extra space"
        },
        "variants": [
          {
            "id": "v1",
            "title": "Swap Elements",
            "description": "Write <code>func swap(nums []int, i, j int)</code> that swaps elements at i and j.",
            "functionSignature": "func swap(nums []int, i, j int)",
            "testCases": [
              {
                "input": "[]int{1,2,3}, 0, 2",
                "output": "[3,2,1]"
              }
            ],
            "hints": [
              {
                "title": "\ud83e\udd14 Think about it",
                "content": "How do you swap two values without losing one of them? Think about what happens if you just write a = b."
              },
              {
                "title": "\ud83d\udca1 Hint",
                "content": "Go has a special syntax for simultaneous assignment: a, b = b, a. This evaluates the right side first, then assigns, so nothing is lost."
              },
              {
                "title": "\ud83d\udd27 Pattern",
                "content": "<pre>1. Simultaneous assignment: left, right = right, left\n(Both sides evaluated before assignment - nothing lost!)</pre>"
              }
            ],
            "solution": "func swap(nums []int, i, j int) {\n    nums[i], nums[j] = nums[j], nums[i]\n}",
            "difficulty": 1
          },
          {
            "id": "v2",
            "title": "Swap Using Temp",
            "description": "Write <code>func swapWithTemp(nums []int, i, j int)</code> that swaps elements using a temporary variable (not Go's simultaneous assignment).",
            "functionSignature": "func swapWithTemp(nums []int, i, j int)",
            "testCases": [
              {
                "input": "[]int{1,2,3,4}, 0, 3",
                "output": "[4,2,3,1]"
              }
            ],
            "hints": [
              {
                "title": "\ud83e\udd14 Think about it",
                "content": "The classic 3-step swap: save one value, overwrite it, then use the saved value."
              },
              {
                "title": "\ud83d\udca1 Hint",
                "content": "temp := nums[i], then nums[i] = nums[j], then nums[j] = temp."
              },
              {
                "title": "\ud83d\udd27 Pattern",
                "content": "<pre>1. temp := nums[i]  // save first value\n2. nums[i] = nums[j]  // overwrite with second\n3. nums[j] = temp  // put saved value in second spot</pre>"
              }
            ],
            "solution": "func swapWithTemp(nums []int, i, j int) {\n    temp := nums[i]\n    nums[i] = nums[j]\n    nums[j] = temp\n}",
            "difficulty": 1
          },
          {
            "id": "v3",
            "title": "Swap Adjacent Pairs",
            "description": "Write <code>func swapPairs(nums []int)</code> that swaps elements at indices 0&1, 2&3, 4&5, etc. If odd length, last element stays.",
            "functionSignature": "func swapPairs(nums []int)",
            "testCases": [
              {
                "input": "[]int{1,2,3,4,5}",
                "output": "[2,1,4,3,5]"
              },
              {
                "input": "[]int{1,2,3,4}",
                "output": "[2,1,4,3]"
              }
            ],
            "hints": [
              {
                "title": "\ud83e\udd14 Think about it",
                "content": "How do you swap two values without losing one of them? Think about what happens if you just write a = b."
              },
              {
                "title": "\ud83d\udca1 Hint",
                "content": "Loop through the slice incrementing by 2 each time. Use Go's simultaneous assignment to swap pairs: nums[i], nums[i+1] = nums[i+1], nums[i]."
              },
              {
                "title": "\ud83d\udd27 Pattern",
                "content": "<pre>1. Loop with i += 2\n2. Check i+1 < len to avoid out of bounds\n3. Swap: nums[i], nums[i+1] = nums[i+1], nums[i]</pre>"
              }
            ],
            "solution": "func swapPairs(nums []int) {\n    for i := 0; i+1 < len(nums); i += 2 {\n        nums[i], nums[i+1] = nums[i+1], nums[i]\n    }\n}",
            "difficulty": 2
          },
          {
            "id": "v4",
            "title": "Swap First Two",
            "description": "Write <code>func swapFirstTwo(nums []int)</code> that swaps the elements at index 0 and index 1. Assume slice has at least 2 elements.",
            "functionSignature": "func swapFirstTwo(nums []int)",
            "testCases": [
              {
                "input": "[]int{1,2,3,4}",
                "output": "[2,1,3,4]"
              },
              {
                "input": "[]int{5,10}",
                "output": "[10,5]"
              }
            ],
            "hints": [
              {
                "title": "\ud83e\udd14 Think about it",
                "content": "This is just one swap - no loop needed. What indices do you need?"
              },
              {
                "title": "\ud83d\udca1 Hint",
                "content": "Swap nums[0] and nums[1] using simultaneous assignment."
              },
              {
                "title": "\ud83d\udd27 Pattern",
                "content": "<pre>nums[0], nums[1] = nums[1], nums[0]</pre>"
              }
            ],
            "solution": "func swapFirstTwo(nums []int) {\n    nums[0], nums[1] = nums[1], nums[0]\n}",
            "difficulty": 1
          },
          {
            "id": "v5",
            "title": "Swap Middle Two",
            "description": "Write <code>func swapMiddle(nums []int)</code> that swaps the two middle elements. Assume even length.",
            "functionSignature": "func swapMiddle(nums []int)",
            "testCases": [
              {
                "input": "[]int{1,2,3,4}",
                "output": "[1,3,2,4]"
              },
              {
                "input": "[]int{10,20,30,40,50,60}",
                "output": "[10,20,40,30,50,60]"
              }
            ],
            "hints": [
              {
                "title": "\ud83e\udd14 Think about it",
                "content": "For a slice of length n, the two middle elements are at indices n/2-1 and n/2."
              },
              {
                "title": "\ud83d\udca1 Hint",
                "content": "Calculate mid := len(nums)/2. Then swap nums[mid-1] and nums[mid]."
              },
              {
                "title": "\ud83d\udd27 Pattern",
                "content": "<pre>mid := len(nums) / 2\nnums[mid-1], nums[mid] = nums[mid], nums[mid-1]</pre>"
              }
            ],
            "solution": "func swapMiddle(nums []int) {\n    mid := len(nums) / 2\n    nums[mid-1], nums[mid] = nums[mid], nums[mid-1]\n}",
            "difficulty": 2
          },
          {
            "id": "v6",
            "title": "Swap at Offset",
            "description": "Write <code>func swapAtOffset(nums []int, k int)</code> that swaps element at index k with element at index len-1-k (mirror positions from each end).",
            "functionSignature": "func swapAtOffset(nums []int, k int)",
            "testCases": [
              {
                "input": "[]int{1,2,3,4,5}, 1",
                "output": "[1,4,3,2,5]",
                "note": "swaps index 1 with index 3"
              },
              {
                "input": "[]int{1,2,3,4,5}, 0",
                "output": "[5,2,3,4,1]",
                "note": "swaps index 0 with index 4 (same as swapEnds)"
              }
            ],
            "hints": [
              {
                "title": "\ud83e\udd14 Think about it",
                "content": "The mirror position of index k from the start is len-1-k from the end."
              },
              {
                "title": "\ud83d\udca1 Hint",
                "content": "Swap nums[k] with nums[len(nums)-1-k]."
              },
              {
                "title": "\ud83d\udd27 Pattern",
                "content": "<pre>nums[k], nums[len(nums)-1-k] = nums[len(nums)-1-k], nums[k]</pre>"
              }
            ],
            "solution": "func swapAtOffset(nums []int, k int) {\n    nums[k], nums[len(nums)-1-k] = nums[len(nums)-1-k], nums[k]\n}",
            "difficulty": 2
          },
          {
            "id": "v7",
            "title": "Swap Min and Max",
            "description": "Write <code>func swapMinMax(nums []int)</code> that finds the minimum and maximum elements and swaps their positions.",
            "functionSignature": "func swapMinMax(nums []int)",
            "testCases": [
              {
                "input": "[]int{3,1,4,1,5}",
                "output": "[3,5,4,1,1]"
              },
              {
                "input": "[]int{5,2,8,1}",
                "output": "[5,2,1,8]"
              }
            ],
            "hints": [
              {
                "title": "\ud83e\udd14 Think about it",
                "content": "First you need to find WHERE the min and max are (their indices), then swap the elements at those positions."
              },
              {
                "title": "\ud83d\udca1 Hint",
                "content": "Track minIdx and maxIdx as you loop. Start with both at 0. Update minIdx when you find a smaller value, maxIdx when you find a larger value. Then swap at the end."
              },
              {
                "title": "\ud83d\udd27 Pattern",
                "content": "<pre>1. Initialize minIdx = 0, maxIdx = 0\n2. Loop through slice:\n   - nums[i] < nums[minIdx]? \u2192 minIdx = i\n   - nums[i] > nums[maxIdx]? \u2192 maxIdx = i\n3. Swap: nums[minIdx], nums[maxIdx] = nums[maxIdx], nums[minIdx]</pre>"
              }
            ],
            "solution": "func swapMinMax(nums []int) {\n    minIdx, maxIdx := 0, 0\n    for i := range nums {\n        if nums[i] < nums[minIdx] { minIdx = i }\n        if nums[i] > nums[maxIdx] { maxIdx = i }\n    }\n    nums[minIdx], nums[maxIdx] = nums[maxIdx], nums[minIdx]\n}",
            "difficulty": 3
          },
          {
            "id": "v8",
            "title": "Rotate Left by One",
            "description": "Write <code>func rotateLeft(nums []int)</code> that shifts all elements one position left, wrapping the first element to the end. E.g., [1,2,3,4] \u2192 [2,3,4,1].",
            "functionSignature": "func rotateLeft(nums []int)",
            "testCases": [
              {
                "input": "[]int{1,2,3,4}",
                "output": "[2,3,4,1]"
              },
              {
                "input": "[]int{5,10,15}",
                "output": "[10,15,5]"
              }
            ],
            "hints": [
              {
                "title": "\ud83e\udd14 Think about it",
                "content": "You need to save the first element, shift everything left, then put the saved element at the end."
              },
              {
                "title": "\ud83d\udca1 Hint",
                "content": "Save first := nums[0]. Loop from i=0 to len-2, copying nums[i+1] to nums[i]. Finally set nums[len-1] = first."
              },
              {
                "title": "\ud83d\udd27 Pattern",
                "content": "<pre>1. Save first element: first := nums[0]\n2. Shift elements left: for i := 0; i < len-1; i++ \u2192 nums[i] = nums[i+1]\n3. Place first at end: nums[len-1] = first</pre>"
              }
            ],
            "solution": "func rotateLeft(nums []int) {\n    if len(nums) == 0 { return }\n    first := nums[0]\n    for i := 0; i < len(nums)-1; i++ {\n        nums[i] = nums[i+1]\n    }\n    nums[len(nums)-1] = first\n}",
            "difficulty": 2
          },
          {
            "id": "v9",
            "title": "Swap Halves",
            "description": "Write <code>func swapHalves(nums []int)</code> that swaps the first half with the second half. For [1,2,3,4] \u2192 [3,4,1,2]. Assume even length.",
            "functionSignature": "func swapHalves(nums []int)",
            "testCases": [
              {
                "input": "[]int{1,2,3,4}",
                "output": "[3,4,1,2]"
              },
              {
                "input": "[]int{10,20,30,40,50,60}",
                "output": "[40,50,60,10,20,30]"
              }
            ],
            "hints": [
              {
                "title": "\ud83e\udd14 Think about it",
                "content": "You need to swap element 0 with element n/2, element 1 with element n/2+1, etc. How many swaps is that?"
              },
              {
                "title": "\ud83d\udca1 Hint",
                "content": "Loop from i=0 to len/2. Each iteration swaps nums[i] with nums[i + len/2]."
              },
              {
                "title": "\ud83d\udd27 Pattern",
                "content": "<pre>1. Calculate mid := len(nums) / 2\n2. Loop i from 0 to mid:\n   - Swap nums[i] with nums[i + mid]\n</pre>"
              }
            ],
            "solution": "func swapHalves(nums []int) {\n    mid := len(nums) / 2\n    for i := 0; i < mid; i++ {\n        nums[i], nums[i+mid] = nums[i+mid], nums[i]\n    }\n}",
            "difficulty": 2
          },
          {
            "id": "v10",
            "title": "Bubble Up",
            "description": "Write <code>func bubbleUp(nums []int, idx int)</code> that 'bubbles' the element at idx towards the front by swapping with its left neighbor until it reaches index 0.",
            "functionSignature": "func bubbleUp(nums []int, idx int)",
            "testCases": [
              {
                "input": "[]int{1,2,3,4}, 3",
                "output": "[4,1,2,3]",
                "note": "4 bubbles from idx 3 to idx 0"
              },
              {
                "input": "[]int{5,10,15}, 1",
                "output": "[10,5,15]",
                "note": "10 bubbles from idx 1 to idx 0"
              }
            ],
            "hints": [
              {
                "title": "\ud83e\udd14 Think about it",
                "content": "Start at idx and work backwards to 0, swapping adjacent elements each step."
              },
              {
                "title": "\ud83d\udca1 Hint",
                "content": "Loop from idx down to 1: for i := idx; i > 0; i--. Each iteration swap nums[i] with nums[i-1]."
              },
              {
                "title": "\ud83d\udd27 Pattern",
                "content": "<pre>1. for i := idx; i > 0; i--\n2.   swap nums[i] and nums[i-1]\n(Element 'bubbles' left one position each iteration)</pre>"
              }
            ],
            "solution": "func bubbleUp(nums []int, idx int) {\n    for i := idx; i > 0; i-- {\n        nums[i], nums[i-1] = nums[i-1], nums[i]\n    }\n}",
            "difficulty": 3
          },
          {
            "id": "v11",
            "title": "Swap If Out of Order",
            "description": "Write <code>func swapIfGreater(nums []int, i, j int)</code> that swaps elements at i and j only if nums[i] > nums[j]. This is a building block for sorting!",
            "functionSignature": "func swapIfGreater(nums []int, i, j int)",
            "testCases": [
              {
                "input": "[]int{5,2,8,1}, 0, 1",
                "output": "[2,5,8,1]",
                "note": "5 > 2, so swap"
              },
              {
                "input": "[]int{1,5,3,4}, 0, 1",
                "output": "[1,5,3,4]",
                "note": "1 < 5, no swap"
              }
            ],
            "hints": [
              {
                "title": "\ud83e\udd14 Think about it",
                "content": "Check if the first element is greater. If yes, swap. If no, do nothing."
              },
              {
                "title": "\ud83d\udca1 Hint",
                "content": "Use an if statement: if nums[i] > nums[j], then do the swap."
              },
              {
                "title": "\ud83d\udd27 Pattern",
                "content": "<pre>if nums[i] > nums[j] {\n    nums[i], nums[j] = nums[j], nums[i]\n}</pre>"
              }
            ],
            "solution": "func swapIfGreater(nums []int, i, j int) {\n    if nums[i] > nums[j] {\n        nums[i], nums[j] = nums[j], nums[i]\n    }\n}",
            "difficulty": 2
          },
          {
            "id": "v12",
            "title": "Move to Front",
            "description": "Write <code>func moveToFront(nums []int, idx int)</code> that moves the element at idx to the front, shifting other elements right. E.g., [1,2,3,4] with idx=2 \u2192 [3,1,2,4].",
            "functionSignature": "func moveToFront(nums []int, idx int)",
            "testCases": [
              {
                "input": "[]int{1,2,3,4}, 2",
                "output": "[3,1,2,4]"
              },
              {
                "input": "[]int{10,20,30,40}, 3",
                "output": "[40,10,20,30]"
              }
            ],
            "hints": [
              {
                "title": "\ud83e\udd14 Think about it",
                "content": "Save the element at idx. Shift elements from 0 to idx-1 one position right. Put saved element at front."
              },
              {
                "title": "\ud83d\udca1 Hint",
                "content": "Save val := nums[idx]. Loop backwards from idx down to 1, copying nums[i-1] to nums[i]. Set nums[0] = val."
              },
              {
                "title": "\ud83d\udd27 Pattern",
                "content": "<pre>1. Save element: val := nums[idx]\n2. Shift right: for i := idx; i > 0; i-- \u2192 nums[i] = nums[i-1]\n3. Place at front: nums[0] = val</pre>"
              }
            ],
            "solution": "func moveToFront(nums []int, idx int) {\n    val := nums[idx]\n    for i := idx; i > 0; i-- {\n        nums[i] = nums[i-1]\n    }\n    nums[0] = val\n}",
            "difficulty": 2
          },
          {
            "id": "v1",
            "title": "Reverse a String",
            "description": "Write <code>func reverse(s string) string</code> that reverses any string, including Unicode characters like emojis.",
            "functionSignature": "func reverse(s string) string",
            "testCases": [
              {
                "input": "\"hello\"",
                "output": "\"olleh\""
              },
              {
                "input": "\"\u4e16\u754c\"",
                "output": "\"\u754c\u4e16\""
              },
              {
                "input": "\"Go\ud83d\ude80\"",
                "output": "\"\ud83d\ude80oG\""
              }
            ],
            "solution": "func reverse(s string) string {\n    runes := []rune(s)\n    for i, j := 0, len(runes)-1; i < j; i, j = i+1, j-1 {\n        runes[i], runes[j] = runes[j], runes[i]\n    }\n    return string(runes)\n}",
            "difficulty": 4
          },
          {
            "id": "v2",
            "title": "Is Palindrome",
            "description": "Write <code>func isPalindrome(s string) bool</code> that checks if a string reads the same forwards and backwards. Consider only alphanumeric characters and ignore case.",
            "functionSignature": "func isPalindrome(s string) bool",
            "testCases": [
              {
                "input": "\"A man, a plan, a canal: Panama\"",
                "output": "true"
              },
              {
                "input": "\"race a car\"",
                "output": "false"
              },
              {
                "input": "\"Was it a car or a cat I saw?\"",
                "output": "true"
              }
            ],
            "solution": "import \"unicode\"\n\nfunc isPalindrome(s string) bool {\n    runes := []rune{}\n    for _, r := range s {\n        if unicode.IsLetter(r) || unicode.IsDigit(r) {\n            runes = append(runes, unicode.ToLower(r))\n        }\n    }\n    \n    for i, j := 0, len(runes)-1; i < j; i, j = i+1, j-1 {\n        if runes[i] != runes[j] {\n            return false\n        }\n    }\n    return true\n}",
            "solutionNotes": "First filter to only alphanumeric and lowercase, then use two-pointer comparison. The <code>unicode</code> package helps with character classification.",
            "difficulty": 4
          },
          {
            "id": "v3",
            "title": "Reverse Words in String",
            "description": "Write <code>func reverseWords(s string) string</code> that reverses the order of words (not characters). Words are separated by spaces.",
            "functionSignature": "func reverseWords(s string) string",
            "testCases": [
              {
                "input": "\"hello world\"",
                "output": "\"world hello\""
              },
              {
                "input": "\"the sky is blue\"",
                "output": "\"blue is sky the\""
              },
              {
                "input": "\"Go\"",
                "output": "\"Go\""
              }
            ],
            "solution": "import \"strings\"\n\nfunc reverseWords(s string) string {\n    words := strings.Fields(s)\n    \n    for i, j := 0, len(words)-1; i < j; i, j = i+1, j-1 {\n        words[i], words[j] = words[j], words[i]\n    }\n    \n    return strings.Join(words, \" \")\n}",
            "solutionNotes": "Use <code>strings.Fields</code> to split by whitespace, reverse the slice of words, then <code>strings.Join</code> back together.",
            "difficulty": 4
          },
          {
            "id": "v4",
            "title": "Reverse Only Letters",
            "description": "Write <code>func reverseOnlyLetters(s string) string</code> that reverses only the letters in a string. All other characters stay in their original positions.",
            "functionSignature": "func reverseOnlyLetters(s string) string",
            "testCases": [
              {
                "input": "\"a-bC-dEf-ghIj\"",
                "output": "\"j-Ih-gfE-dCba\""
              },
              {
                "input": "\"ab-cd\"",
                "output": "\"dc-ba\""
              },
              {
                "input": "\"Test1ng-Leet=code-Q!\"",
                "output": "\"Qedo1teleC-test=gnin-T!\"",
                "note": "wait that's wrong"
              }
            ],
            "solution": "import \"unicode\"\n\nfunc reverseOnlyLetters(s string) string {\n    runes := []rune(s)\n    i, j := 0, len(runes)-1\n    \n    for i < j {\n        for i < j && !unicode.IsLetter(runes[i]) {\n            i++\n        }\n        for i < j && !unicode.IsLetter(runes[j]) {\n            j--\n        }\n        if i < j {\n            runes[i], runes[j] = runes[j], runes[i]\n            i++\n            j--\n        }\n    }\n    return string(runes)\n}",
            "solutionNotes": "Two pointers that skip non-letters. Only swap when both pointers are on letters. This is a variation of the standard reverse with added skip logic.",
            "difficulty": 4
          },
          {
            "id": "v5",
            "title": "Valid Palindrome II",
            "description": "Write <code>func validPalindromeII(s string) bool</code> that returns true if the string can become a palindrome by removing <strong>at most one</strong> character.",
            "functionSignature": "func validPalindromeII(s string) bool",
            "testCases": [
              {
                "input": "\"aba\"",
                "output": "true",
                "note": "already palindrome"
              },
              {
                "input": "\"abca\"",
                "output": "true",
                "note": "remove 'c' or 'b'"
              },
              {
                "input": "\"abc\"",
                "output": "false"
              }
            ],
            "solution": "func validPalindromeII(s string) bool {\n    runes := []rune(s)\n    \n    isPalin := func(i, j int) bool {\n        for i < j {\n            if runes[i] != runes[j] {\n                return false\n            }\n            i++\n            j--\n        }\n        return true\n    }\n    \n    i, j := 0, len(runes)-1\n    for i < j {\n        if runes[i] != runes[j] {\n            return isPalin(i+1, j) || isPalin(i, j-1)\n        }\n        i++\n        j--\n    }\n    return true\n}",
            "solutionNotes": "When we find a mismatch, we have one chance: try skipping the left char OR the right char. If either results in a palindrome, return true.",
            "difficulty": 4
          },
          {
            "id": "v6",
            "title": "Rotate String Left",
            "description": "Write <code>func rotateLeft(s string, k int) string</code> that rotates a string left by k positions. Characters that fall off the left reappear on the right.",
            "functionSignature": "func rotateLeft(s string, k int) string",
            "testCases": [
              {
                "input": "\"abcdef\", 2",
                "output": "\"cdefab\""
              },
              {
                "input": "\"hello\", 1",
                "output": "\"elloh\""
              },
              {
                "input": "\"Go\", 4",
                "output": "\"Go\"",
                "note": "k=4 is same as k=0 for len=2"
              }
            ],
            "solution": "func rotateLeft(s string, k int) string {\n    if len(s) == 0 {\n        return s\n    }\n    runes := []rune(s)\n    k = k % len(runes)\n    \n    reverse := func(start, end int) {\n        for start < end {\n            runes[start], runes[end] = runes[end], runes[start]\n            start++\n            end--\n        }\n    }\n    \n    reverse(0, k-1)\n    reverse(k, len(runes)-1)\n    reverse(0, len(runes)-1)\n    \n    return string(runes)\n}",
            "solutionNotes": "The \"reversal algorithm\" for rotation: reverse the first k elements, reverse the rest, then reverse the entire array. Three reversals achieve a rotation!",
            "difficulty": 4
          }
        ]
      },
      {
        "id": "challenge_9",
        "block": 3,
        "difficulty": 3,
        "concept": "Two-Pointer Comparison",
        "docLinks": [
          {
            "url": "https://go.dev/ref/spec#For_statements",
            "title": "Go Spec: For statements",
            "note": "two-variable initialization (i, j := ...)"
          },
          {
            "url": "https://go.dev/ref/spec#Comparison_operators",
            "title": "Go Spec: Comparison operators",
            "note": "!= for mismatch detection"
          }
        ],
        "patternPrimer": {
          "bruteForce": "Create a reversed copy of the array, then compare element-by-element with the original.",
          "bestApproach": "Compare from both ends simultaneously, moving inward; stop as soon as mismatch found.",
          "typical": "Typically O(n) time, O(1) extra space"
        },
        "variants": [
          {
            "id": "v1",
            "title": "Palindrome Check",
            "description": "Write <code>func isPalindrome(nums []int) bool</code> - same forwards/backwards.",
            "functionSignature": "func isPalindrome(nums []int) bool",
            "testCases": [
              {
                "input": "[]int{1,2,3,2,1}",
                "output": "true"
              }
            ],
            "hints": [
              {
                "title": "\ud83e\udd14 Think about it",
                "content": "To check if something reads the same forwards and backwards, where should you start comparing? Do you need to check every element?"
              },
              {
                "title": "\ud83d\udca1 Hint",
                "content": "Compare from both ends moving inward. Start with pointers at index 0 and len-1. If any pair doesn't match, it's not a palindrome. If you make it to the middle without mismatches, it is."
              },
              {
                "title": "\ud83d\udd27 Pattern",
                "content": "<pre>1. left pointer at start, right pointer at end\n2. While left < right:\n   - Compare elements at both pointers\n   - Mismatch? \u2192 return false\n   - Move both pointers inward\n3. Return true (all pairs matched)</pre>"
              }
            ],
            "solution": "func isPalindrome(nums []int) bool {\n    for i, j := 0, len(nums)-1; i < j; i, j = i+1, j-1 {\n        if nums[i] != nums[j] { return false }\n    }\n    return true\n}",
            "difficulty": 3
          },
          {
            "id": "v2",
            "title": "String Palindrome",
            "description": "Write <code>func isSymmetric(s string) bool</code>.",
            "functionSignature": "func isSymmetric(s string) bool",
            "testCases": [
              {
                "input": "\"racecar\"",
                "output": "true"
              }
            ],
            "hints": [
              {
                "title": "\ud83e\udd14 Think about it",
                "content": "To check if something reads the same forwards and backwards, where should you start comparing? Do you need to check every element?"
              },
              {
                "title": "\ud83d\udca1 Hint",
                "content": "Compare from both ends moving inward. Start with pointers at index 0 and len-1. If any pair doesn't match, it's not a palindrome. If you make it to the middle without mismatches, it is."
              },
              {
                "title": "\ud83d\udd27 Pattern",
                "content": "<pre>1. left pointer at start, right pointer at end\n2. While left < right:\n   - Compare elements at both pointers\n   - Mismatch? \u2192 return false\n   - Move both pointers inward\n3. Return true (all pairs matched)</pre>"
              }
            ],
            "solution": "func isSymmetric(s string) bool {\n    r := []rune(s)\n    for i, j := 0, len(r)-1; i < j; i, j = i+1, j-1 {\n        if r[i] != r[j] { return false }\n    }\n    return true\n}",
            "difficulty": 3
          },
          {
            "id": "v3",
            "title": "Is Sorted Ascending",
            "description": "Write <code>func isSorted(nums []int) bool</code> - true if each element <= the next.",
            "functionSignature": "func isSorted(nums []int) bool",
            "testCases": [
              {
                "input": "[]int{1,2,3,4}",
                "output": "true"
              },
              {
                "input": "[]int{1,3,2,4}",
                "output": "false"
              }
            ],
            "hints": [
              {
                "title": "\ud83e\udd14 Think about it",
                "content": "To verify sorted order, what pairs of elements do you need to compare? Do you need to compare every element to every other element?"
              },
              {
                "title": "\ud83d\udca1 Hint",
                "content": "Check adjacent pairs: compare nums[i] with nums[i+1]. If any pair is out of order (nums[i] > nums[i+1]), return false immediately."
              },
              {
                "title": "\ud83d\udd27 Pattern",
                "content": "<pre>1. Loop through indices 0 to len-2\n2. Compare each element with the next\n3. If nums[i] > nums[i+1] \u2192 return false\n4. Return true (all pairs in order)</pre>"
              }
            ],
            "solution": "func isSorted(nums []int) bool {\n    for i := 0; i < len(nums)-1; i++ {\n        if nums[i] > nums[i+1] { return false }\n    }\n    return true\n}",
            "difficulty": 2
          },
          {
            "id": "v4",
            "title": "Has Adjacent Duplicates",
            "description": "Write <code>func hasAdjacentDups(nums []int) bool</code> - true if any two adjacent elements are equal.",
            "functionSignature": "func hasAdjacentDups(nums []int) bool",
            "testCases": [
              {
                "input": "[]int{1, 2, 2, 3}",
                "output": "true"
              },
              {
                "input": "[]int{1, 2, 3, 4}",
                "output": "false"
              }
            ],
            "hints": [
              {
                "title": "\ud83e\udd14 Think about it",
                "content": "You need to compare each element with its neighbor. What pairs should you check?"
              },
              {
                "title": "\ud83d\udca1 Hint",
                "content": "Loop through indices 0 to len-2. Compare nums[i] with nums[i+1]. If they're equal, you found adjacent duplicates."
              },
              {
                "title": "\ud83d\udd27 Pattern",
                "content": "<pre>1. Loop through indices 0 to len-2\n2. Compare each element with the next\n3. If nums[i] == nums[i+1] \u2192 return true\n4. Return false (no adjacent duplicates)</pre>"
              }
            ],
            "solution": "func hasAdjacentDups(nums []int) bool {\n    for i := 0; i < len(nums)-1; i++ {\n        if nums[i] == nums[i+1] { return true }\n    }\n    return false\n}",
            "difficulty": 2
          },
          {
            "id": "v5",
            "title": "All Increasing",
            "description": "Write <code>func allIncreasing(nums []int) bool</code> - true if strictly increasing (each element < next).",
            "functionSignature": "func allIncreasing(nums []int) bool",
            "testCases": [
              {
                "input": "[]int{1, 2, 3, 4}",
                "output": "true"
              },
              {
                "input": "[]int{1, 2, 2, 3}",
                "output": "false"
              }
            ],
            "hints": [
              {
                "title": "\ud83e\udd14 Think about it",
                "content": "Strictly increasing means each element must be LESS than (not equal to) the next."
              },
              {
                "title": "\ud83d\udca1 Hint",
                "content": "Compare adjacent pairs. If nums[i] >= nums[i+1], it's not strictly increasing."
              },
              {
                "title": "\ud83d\udd27 Pattern",
                "content": "<pre>1. Loop through indices 0 to len-2\n2. Compare each element with the next\n3. If nums[i] >= nums[i+1] \u2192 return false\n4. Return true (all strictly increasing)</pre>"
              }
            ],
            "solution": "func allIncreasing(nums []int) bool {\n    for i := 0; i < len(nums)-1; i++ {\n        if nums[i] >= nums[i+1] { return false }\n    }\n    return true\n}",
            "difficulty": 2
          },
          {
            "id": "v6",
            "title": "Starts And Ends Same",
            "description": "Write <code>func startsEndsSame(nums []int, k int) bool</code> - true if first k elements match last k elements.",
            "functionSignature": "func startsEndsSame(nums []int, k int) bool",
            "testCases": [
              {
                "input": "[]int{1, 2, 3, 1, 2}, 2",
                "output": "true"
              },
              {
                "input": "[]int{1, 2, 3, 4, 5}, 2",
                "output": "false"
              }
            ],
            "hints": [
              {
                "title": "\ud83e\udd14 Think about it",
                "content": "You need to compare the first k elements with the last k elements. What are the corresponding indices?"
              },
              {
                "title": "\ud83d\udca1 Hint",
                "content": "Element at index i should match element at index len-k+i. Check all k pairs."
              },
              {
                "title": "\ud83d\udd27 Pattern",
                "content": "<pre>1. Loop i from 0 to k-1\n2. Compare nums[i] with nums[len-k+i]\n3. If mismatch \u2192 return false\n4. Return true (all pairs match)</pre>"
              }
            ],
            "solution": "func startsEndsSame(nums []int, k int) bool {\n    n := len(nums)\n    for i := 0; i < k; i++ {\n        if nums[i] != nums[n-k+i] { return false }\n    }\n    return true\n}",
            "difficulty": 1
          },
          {
            "id": "v7",
            "title": "Mirror Halves",
            "description": "Write <code>func mirrorHalves(nums []int) bool</code> - true if first half mirrors second half. Assume even length.",
            "functionSignature": "func mirrorHalves(nums []int) bool",
            "testCases": [
              {
                "input": "[]int{1, 2, 2, 1}",
                "output": "true"
              },
              {
                "input": "[]int{5, 3, 3, 5}",
                "output": "true"
              },
              {
                "input": "[]int{1, 2, 3, 4}",
                "output": "false"
              }
            ],
            "hints": [
              {
                "title": "\ud83e\udd14 Think about it",
                "content": "Compare first half with second half in reverse. Element at index i should match element at index n-1-i."
              },
              {
                "title": "\ud83d\udca1 Hint",
                "content": "Use two pointers starting at both ends, moving inward. Compare only the first n/2 pairs."
              },
              {
                "title": "\ud83d\udd27 Pattern",
                "content": "<pre>1. left = 0, right = len-1\n2. While left < right:\n   - nums[left] != nums[right]? \u2192 return false\n   - left++, right--\n3. Return true</pre>"
              }
            ],
            "solution": "func mirrorHalves(nums []int) bool {\n    for i, j := 0, len(nums)-1; i < j; i, j = i+1, j-1 {\n        if nums[i] != nums[j] { return false }\n    }\n    return true\n}",
            "difficulty": 2
          },
          {
            "id": "v8",
            "title": "Valid Score Sequence",
            "description": "Write <code>func validScoreSeq(scores []int) bool</code> - true if scores never decrease by more than 10 points between adjacent rounds.",
            "functionSignature": "func validScoreSeq(scores []int) bool",
            "testCases": [
              {
                "input": "[]int{100, 95, 98, 90}",
                "output": "true"
              },
              {
                "input": "[]int{100, 85, 90}",
                "output": "false",
                "note": "100 to 85 is -15"
              }
            ],
            "hints": [
              {
                "title": "\ud83e\udd14 Think about it",
                "content": "Compare adjacent scores. If any drop is more than 10, return false."
              },
              {
                "title": "\ud83d\udca1 Hint",
                "content": "Loop through indices, compare scores[i] with scores[i+1]. Check if scores[i] - scores[i+1] > 10."
              },
              {
                "title": "\ud83d\udd27 Pattern",
                "content": "<pre>1. For i from 0 to len-2:\n   - scores[i] - scores[i+1] > 10?\n     \u2192 return false\n2. Return true</pre>"
              }
            ],
            "solution": "func validScoreSeq(scores []int) bool {\n    for i := 0; i < len(scores)-1; i++ {\n        if scores[i] - scores[i+1] > 10 { return false }\n    }\n    return true\n}",
            "difficulty": 2
          },
          {
            "id": "v9",
            "title": "Balanced Brackets",
            "description": "Write <code>func balancedBrackets(s string) bool</code> - true if string has equal '[' and ']' counts AND they're balanced left-to-right.",
            "functionSignature": "func balancedBrackets(s string) bool",
            "testCases": [
              {
                "input": "\"[[][]]\"",
                "output": "true"
              },
              {
                "input": "\"[[]\"",
                "output": "false"
              },
              {
                "input": "\"][[\"",
                "output": "false"
              }
            ],
            "hints": [
              {
                "title": "\ud83e\udd14 Think about it",
                "content": "Track a running count: +1 for '[', -1 for ']'. Count should never go negative, and should be 0 at end."
              },
              {
                "title": "\ud83d\udca1 Hint",
                "content": "Use a counter variable. If it ever goes negative, we have ']' before matching '['. Must end at 0."
              },
              {
                "title": "\ud83d\udd27 Pattern",
                "content": "<pre>1. count := 0\n2. For each char:\n   - '[' \u2192 count++\n   - ']' \u2192 count--\n   - count < 0? \u2192 return false\n3. Return count == 0</pre>"
              }
            ],
            "solution": "func balancedBrackets(s string) bool {\n    count := 0\n    for _, c := range s {\n        if c == '[' { count++ }\n        if c == ']' { count-- }\n        if count < 0 { return false }\n    }\n    return count == 0\n}",
            "difficulty": 3
          },
          {
            "id": "v10",
            "title": "First Last Equal",
            "description": "Write <code>func firstLastEqual(nums []int) bool</code> - true if first element equals last element.",
            "functionSignature": "func firstLastEqual(nums []int) bool",
            "testCases": [
              {
                "input": "[]int{5, 2, 3, 5}",
                "output": "true"
              },
              {
                "input": "[]int{1, 2, 3}",
                "output": "false"
              }
            ],
            "hints": [
              {
                "title": "\ud83e\udd14 Think about it",
                "content": "You need to compare the first and last elements. What are their indices?"
              },
              {
                "title": "\ud83d\udca1 Hint",
                "content": "First element is at index 0, last is at index len(nums)-1. Just compare them directly."
              },
              {
                "title": "\ud83d\udd27 Pattern",
                "content": "<pre>1. Get first element: nums[0]\n2. Get last element: nums[len(nums)-1]\n3. Return whether they're equal</pre>"
              }
            ],
            "solution": "func firstLastEqual(nums []int) bool {\n    if len(nums) == 0 { return true }\n    return nums[0] == nums[len(nums)-1]\n}",
            "difficulty": 1
          },
          {
            "id": "v11",
            "title": "No Decreases",
            "description": "Write <code>func noDecreases(nums []int) bool</code> - true if array never decreases (each element >= previous). Adjacent pair comparison.",
            "functionSignature": "func noDecreases(nums []int) bool",
            "testCases": [
              {
                "input": "[]int{1, 2, 2, 3}",
                "output": "true"
              },
              {
                "input": "[]int{1, 3, 2, 4}",
                "output": "false",
                "note": "3\u21922 is a decrease"
              }
            ],
            "hints": [
              {
                "title": "\ud83e\udd14 Think about it",
                "content": "Check adjacent pairs: each element should be >= the one before it."
              },
              {
                "title": "\ud83d\udca1 Hint",
                "content": "Loop from index 1 onwards. Compare nums[i] with nums[i-1]. If nums[i] < nums[i-1], return false."
              },
              {
                "title": "\ud83d\udd27 Pattern",
                "content": "<pre>1. For i from 1 to len:\n   - If nums[i] < nums[i-1] \u2192 return false\n2. Return true</pre>"
              }
            ],
            "solution": "func noDecreases(nums []int) bool {\n    for i := 1; i < len(nums); i++ {\n        if nums[i] < nums[i-1] { return false }\n    }\n    return true\n}",
            "difficulty": 1
          },
          {
            "id": "v12",
            "title": "Sum Symmetry",
            "description": "Write <code>func sumSymmetry(nums []int) bool</code> - true if sum of first half equals sum of second half. Assume even length. Two-pointer to compare halves.",
            "functionSignature": "func sumSymmetry(nums []int) bool",
            "testCases": [
              {
                "input": "[]int{1, 2, 3, 3, 2, 1}",
                "output": "true",
                "note": "1+2+3 = 3+2+1"
              },
              {
                "input": "[]int{1, 2, 3, 4}",
                "output": "false",
                "note": "1+2 \u2260 3+4"
              }
            ],
            "hints": [
              {
                "title": "\ud83e\udd14 Think about it",
                "content": "Calculate sum of first half, then sum of second half, then compare."
              },
              {
                "title": "\ud83d\udca1 Hint",
                "content": "Loop from 0 to mid to get first sum. Loop from mid to end to get second sum. Compare them."
              },
              {
                "title": "\ud83d\udd27 Pattern",
                "content": "<pre>1. mid := len/2\n2. sum1 := sum of nums[0:mid]\n3. sum2 := sum of nums[mid:]\n4. Return sum1 == sum2</pre>"
              }
            ],
            "solution": "func sumSymmetry(nums []int) bool {\n    mid := len(nums) / 2\n    sum1, sum2 := 0, 0\n    for i := 0; i < mid; i++ {\n        sum1 += nums[i]\n    }\n    for i := mid; i < len(nums); i++ {\n        sum2 += nums[i]\n    }\n    return sum1 == sum2\n}",
            "difficulty": 1
          },
          {
            "id": "v13",
            "title": "Distance Increasing",
            "description": "Write <code>func distanceIncreasing(nums []int) bool</code> - true if distance between adjacent elements is always increasing. Distance = abs(nums[i] - nums[i-1]).",
            "functionSignature": "func distanceIncreasing(nums []int) bool",
            "testCases": [
              {
                "input": "[]int{1, 2, 5, 10}",
                "output": "true",
                "note": "Distances: 1, 3, 5 (increasing)"
              },
              {
                "input": "[]int{1, 3, 4, 8}",
                "output": "false",
                "note": "Distances: 2, 1, 4 (not increasing)"
              }
            ],
            "hints": [
              {
                "title": "\ud83e\udd14 Think about it",
                "content": "Calculate distance between each adjacent pair. Check if distances form an increasing sequence."
              },
              {
                "title": "\ud83d\udca1 Hint",
                "content": "Track previous distance. For each pair, calculate current distance, compare with previous, update previous."
              },
              {
                "title": "\ud83d\udd27 Pattern",
                "content": "<pre>1. prevDist := first pair distance\n2. For each subsequent pair:\n   - Calculate currDist\n   - If currDist <= prevDist \u2192 return false\n   - prevDist = currDist\n3. Return true</pre>"
              }
            ],
            "solution": "func distanceIncreasing(nums []int) bool {\n    if len(nums) < 3 { return true }\n    abs := func(x int) int {\n        if x < 0 { return -x }\n        return x\n    }\n    prevDist := abs(nums[1] - nums[0])\n    for i := 2; i < len(nums); i++ {\n        currDist := abs(nums[i] - nums[i-1])\n        if currDist <= prevDist { return false }\n        prevDist = currDist\n    }\n    return true\n}",
            "difficulty": 1
          },
          {
            "id": "v1",
            "title": "Maximum Sum Subarray of Size K",
            "description": "Given an array of integers and a number k, find the maximum sum of any contiguous subarray of size k. <code>func maxSumSubarray(nums []int, k int) int</code>",
            "functionSignature": "func maxSumSubarray(nums []int, k int) int",
            "testCases": [
              {
                "input": "[]int{2, 1, 5, 1, 3, 2}, 3",
                "output": "9",
                "note": "subarray [5,1,3]"
              },
              {
                "input": "[]int{2, 3, 4, 1, 5}, 2",
                "output": "7",
                "note": "subarray [3,4]"
              },
              {
                "input": "[]int{1, 1, 1, 1}, 2",
                "output": "2"
              }
            ],
            "solution": "func maxSumSubarray(nums []int, k int) int {\n    if len(nums) < k {\n        return 0\n    }\n    windowSum := 0\n    for i := 0; i < k; i++ {\n        windowSum += nums[i]\n    }\n    maxSum := windowSum\n    \n    for i := k; i < len(nums); i++ {\n        windowSum += nums[i] - nums[i-k]\n        if windowSum > maxSum {\n            maxSum = windowSum\n        }\n    }\n    return maxSum\n}",
            "solutionNotes": "Fixed-size window: calculate first window sum, then slide by adding new element and subtracting leaving element. O(n) time, O(1) space.",
            "difficulty": 4
          },
          {
            "id": "v2",
            "title": "Longest Substring Without Repeating",
            "description": "Find the length of the longest substring without repeating characters. <code>func lengthOfLongestSubstring(s string) int</code>",
            "functionSignature": "func lengthOfLongestSubstring(s string) int",
            "testCases": [
              {
                "input": "\"abcabcbb\"",
                "output": "3",
                "note": "\"abc\""
              },
              {
                "input": "\"bbbbb\"",
                "output": "1",
                "note": "\"b\""
              },
              {
                "input": "\"pwwkew\"",
                "output": "3",
                "note": "\"wke\""
              }
            ],
            "solution": "func lengthOfLongestSubstring(s string) int {\n    seen := make(map[byte]int)\n    maxLen := 0\n    left := 0\n    \n    for right := 0; right < len(s); right++ {\n        char := s[right]\n        if lastIdx, ok := seen[char]; ok && lastIdx >= left {\n            left = lastIdx + 1\n        }\n        seen[char] = right\n        if right - left + 1 > maxLen {\n            maxLen = right - left + 1\n        }\n    }\n    return maxLen\n}",
            "solutionNotes": "Variable-size window: expand right, shrink left when duplicate found. Track last seen index of each character to know where to shrink to.",
            "difficulty": 4
          },
          {
            "id": "v3",
            "title": "Minimum Size Subarray Sum",
            "description": "Find the minimal length of a contiguous subarray whose sum is >= target. Return 0 if no such subarray. <code>func minSubarrayLen(target int, nums []int) int</code>",
            "functionSignature": "func minSubarrayLen(target int, nums []int) int",
            "testCases": [
              {
                "input": "7, []int{2, 3, 1, 2, 4, 3}",
                "output": "2",
                "note": "[4,3] sums to 7"
              },
              {
                "input": "4, []int{1, 4, 4}",
                "output": "1",
                "note": "[4] alone >= 4"
              },
              {
                "input": "11, []int{1, 1, 1, 1}",
                "output": "0",
                "note": "can't reach 11"
              }
            ],
            "solution": "func minSubarrayLen(target int, nums []int) int {\n    minLen := len(nums) + 1\n    left := 0\n    sum := 0\n    \n    for right := 0; right < len(nums); right++ {\n        sum += nums[right]\n        \n        for sum >= target {\n            if right - left + 1 < minLen {\n                minLen = right - left + 1\n            }\n            sum -= nums[left]\n            left++\n        }\n    }\n    \n    if minLen == len(nums) + 1 {\n        return 0\n    }\n    return minLen\n}",
            "solutionNotes": "Variable-size window with condition: expand to increase sum, shrink while condition met to find minimum. Classic 'minimum window' pattern.",
            "difficulty": 4
          },
          {
            "id": "v4",
            "title": "Average of Subarrays of Size K",
            "description": "Given an array, find the average of all contiguous subarrays of size k. <code>func averageOfSubarrays(nums []int, k int) []float64</code>",
            "functionSignature": "func averageOfSubarrays(nums []int, k int) []float64",
            "testCases": [
              {
                "input": "[]int{1, 3, 2, 6, -1, 4, 1, 8, 2}, 5",
                "output": "[2.2, 2.8, 2.4, 3.6, 2.8]"
              },
              {
                "input": "[]int{1, 2, 3, 4}, 2",
                "output": "[1.5, 2.5, 3.5]"
              }
            ],
            "solution": "func averageOfSubarrays(nums []int, k int) []float64 {\n    result := []float64{}\n    windowSum := 0\n    \n    for i := 0; i < len(nums); i++ {\n        windowSum += nums[i]\n        \n        if i >= k-1 {\n            result = append(result, float64(windowSum)/float64(k))\n            windowSum -= nums[i-k+1]\n        }\n    }\n    return result\n}",
            "solutionNotes": "Basic fixed-window pattern. Build up sum for first k elements, then slide and track averages.",
            "difficulty": 4
          },
          {
            "id": "v5",
            "title": "Contains Duplicate Within K Distance",
            "description": "Return true if there are two distinct indices i and j where nums[i] == nums[j] and abs(i - j) <= k. <code>func containsNearbyDuplicate(nums []int, k int) bool</code>",
            "functionSignature": "func containsNearbyDuplicate(nums []int, k int) bool",
            "testCases": [
              {
                "input": "[]int{1, 2, 3, 1}, 3",
                "output": "true"
              },
              {
                "input": "[]int{1, 0, 1, 1}, 1",
                "output": "true"
              },
              {
                "input": "[]int{1, 2, 3, 1, 2, 3}, 2",
                "output": "false"
              }
            ],
            "solution": "func containsNearbyDuplicate(nums []int, k int) bool {\n    seen := make(map[int]bool)\n    \n    for i, num := range nums {\n        if seen[num] {\n            return true\n        }\n        seen[num] = true\n        \n        if i >= k {\n            delete(seen, nums[i-k])\n        }\n    }\n    return false\n}",
            "solutionNotes": "Maintain a sliding window of size k as a set. If we see a duplicate within the window, return true. Remove elements that leave the window.",
            "difficulty": 4
          },
          {
            "id": "v6",
            "title": "Max Consecutive Ones III",
            "description": "Given a binary array and integer k, return the maximum number of consecutive 1's if you can flip at most k 0's. <code>func longestOnes(nums []int, k int) int</code>",
            "functionSignature": "func longestOnes(nums []int, k int) int",
            "testCases": [
              {
                "input": "[]int{1,1,1,0,0,0,1,1,1,1,0}, 2",
                "output": "6",
                "note": "flip 0's at indices 5 and 10"
              },
              {
                "input": "[]int{0,0,1,1,0,0,1,1,1,0,1,1,0,0,0,1,1,1,1}, 3",
                "output": "10"
              }
            ],
            "solution": "func longestOnes(nums []int, k int) int {\n    left := 0\n    zeros := 0\n    maxLen := 0\n    \n    for right := 0; right < len(nums); right++ {\n        if nums[right] == 0 {\n            zeros++\n        }\n        \n        for zeros > k {\n            if nums[left] == 0 {\n                zeros--\n            }\n            left++\n        }\n        \n        if right - left + 1 > maxLen {\n            maxLen = right - left + 1\n        }\n    }\n    return maxLen\n}",
            "solutionNotes": "Variable window: expand right, count zeros. When zeros > k, shrink from left. Track maximum valid window size.",
            "difficulty": 4
          }
        ]
      },
      {
        "id": "challenge_10",
        "block": 4,
        "difficulty": 4,
        "concept": "Two-Pointer Swap",
        "docLinks": [
          {
            "url": "https://go.dev/ref/spec#Assignments",
            "title": "Go Spec: Assignments",
            "note": "simultaneous swap (a, b = b, a)"
          },
          {
            "url": "https://go.dev/blog/slices",
            "title": "Go Blog: Slices",
            "note": "in-place modifications"
          }
        ],
        "patternPrimer": {
          "bruteForce": "Create a new array and build it by iterating backwards through the original.",
          "bestApproach": "Start pointers at both ends, swap elements in place, move pointers inward until they meet.",
          "typical": "Typically O(n) time, O(1) extra space"
        },
        "variants": [
          {
            "id": "v1",
            "title": "Reverse Slice",
            "description": "Write <code>func reverse(nums []int) []int</code> that reverses in place.",
            "functionSignature": "func reverse(nums []int) []int",
            "testCases": [
              {
                "input": "[]int{1,2,3,4,5}",
                "output": "[5,4,3,2,1]"
              }
            ],
            "hints": [
              {
                "title": "\ud83e\udd14 Think about it",
                "content": "To reverse in-place, you swap elements from both ends working toward the middle. What pattern lets you walk two pointers toward each other?"
              },
              {
                "title": "\ud83d\udca1 Hint",
                "content": "Use the same two-pointer loop as palindrome check, but swap the elements instead of comparing them. Stop when the pointers meet or cross."
              },
              {
                "title": "\ud83d\udd27 Pattern",
                "content": "<pre>1. left pointer at start, right pointer at end\n2. While left < right:\n   - Swap elements at left and right\n   - Move both pointers inward\n3. Done (reversed in place)</pre>"
              }
            ],
            "solution": "func reverse(nums []int) []int {\n    for i, j := 0, len(nums)-1; i < j; i, j = i+1, j-1 {\n        nums[i], nums[j] = nums[j], nums[i]\n    }\n    return nums\n}",
            "difficulty": 3
          },
          {
            "id": "v2",
            "title": "Reverse String",
            "description": "Write <code>func reverseString(s string) string</code> that reverses a string.",
            "functionSignature": "func reverseString(s string) string",
            "testCases": [
              {
                "input": "\"hello\"",
                "output": "\"olleh\""
              },
              {
                "input": "\"Go\"",
                "output": "\"oG\""
              }
            ],
            "hints": [
              {
                "title": "\ud83e\udd14 Think about it",
                "content": "To reverse in-place, you swap elements from both ends working toward the middle. What pattern lets you walk two pointers toward each other?"
              },
              {
                "title": "\ud83d\udca1 Hint",
                "content": "Convert to []rune first (strings are immutable). Then use the same two-pointer swap as with slices."
              },
              {
                "title": "\ud83d\udd27 Pattern",
                "content": "<pre>1. Convert string to []rune\n2. left pointer at start, right pointer at end\n3. While left < right:\n   - Swap runes at left and right\n   - Move both pointers inward\n4. Convert back to string</pre>"
              }
            ],
            "solution": "func reverseString(s string) string {\n    r := []rune(s)\n    for i, j := 0, len(r)-1; i < j; i, j = i+1, j-1 {\n        r[i], r[j] = r[j], r[i]\n    }\n    return string(r)\n}",
            "difficulty": 3
          },
          {
            "id": "v3",
            "title": "Reverse Segment",
            "description": "Write <code>func reverseSegment(nums []int, start, end int)</code> that reverses elements from index start to end (inclusive).",
            "functionSignature": "func reverseSegment(nums []int, start, end int)",
            "testCases": [
              {
                "input": "[]int{1,2,3,4,5}, 1, 3",
                "output": "[1,4,3,2,5]"
              }
            ],
            "hints": [
              {
                "title": "\ud83e\udd14 Think about it",
                "content": "To reverse in-place, you swap elements from both ends working toward the middle. What pattern lets you walk two pointers toward each other?"
              },
              {
                "title": "\ud83d\udca1 Hint",
                "content": "Same two-pointer pattern, but start at 'start' instead of 0, and end at 'end' instead of len-1."
              },
              {
                "title": "\ud83d\udd27 Pattern",
                "content": "<pre>1. left pointer at start, right pointer at end\n2. While left < right:\n   - Swap elements at left and right\n   - Move both pointers inward\n3. Done (segment reversed in place)</pre>"
              }
            ],
            "solution": "func reverseSegment(nums []int, start, end int) {\n    for i, j := start, end; i < j; i, j = i+1, j-1 {\n        nums[i], nums[j] = nums[j], nums[i]\n    }\n}",
            "difficulty": 3
          },
          {
            "id": "v4",
            "title": "Swap First and Last",
            "description": "Write <code>func swapEnds(nums []int) []int</code> that swaps the first and last elements.",
            "functionSignature": "func swapEnds(nums []int) []int",
            "testCases": [
              {
                "input": "[]int{1, 2, 3, 4, 5}",
                "output": "[5, 2, 3, 4, 1]"
              }
            ],
            "hints": [
              {
                "title": "\ud83e\udd14 Think about it",
                "content": "You only need to swap two specific elements. What are their indices?"
              },
              {
                "title": "\ud83d\udca1 Hint",
                "content": "First element is at index 0, last is at index len-1. Use Go's simultaneous assignment to swap."
              },
              {
                "title": "\ud83d\udd27 Pattern",
                "content": "<pre>1. Identify indices: first = 0, last = len-1\n2. Swap: nums[0], nums[last] = nums[last], nums[0]\n3. Return the modified slice</pre>"
              }
            ],
            "solution": "func swapEnds(nums []int) []int {\n    n := len(nums)\n    nums[0], nums[n-1] = nums[n-1], nums[0]\n    return nums\n}",
            "difficulty": 2
          },
          {
            "id": "v5",
            "title": "Rotate Right by One",
            "description": "Write <code>func rotateRight(nums []int) []int</code> that moves the last element to the front.",
            "functionSignature": "func rotateRight(nums []int) []int",
            "testCases": [
              {
                "input": "[]int{1, 2, 3, 4, 5}",
                "output": "[5, 1, 2, 3, 4]"
              }
            ],
            "hints": [
              {
                "title": "\ud83e\udd14 Think about it",
                "content": "The last element goes to index 0, and all other elements shift right by one position."
              },
              {
                "title": "\ud83d\udca1 Hint",
                "content": "Save the last element. Then loop backwards, shifting each element to the right. Finally place the saved element at index 0."
              },
              {
                "title": "\ud83d\udd27 Pattern",
                "content": "<pre>1. Save last element: temp = nums[len-1]\n2. Shift all elements right: nums[i] = nums[i-1]\n3. Place saved element at front: nums[0] = temp</pre>"
              }
            ],
            "solution": "func rotateRight(nums []int) []int {\n    n := len(nums)\n    last := nums[n-1]\n    for i := n-1; i > 0; i-- {\n        nums[i] = nums[i-1]\n    }\n    nums[0] = last\n    return nums\n}",
            "difficulty": 2
          },
          {
            "id": "v6",
            "title": "Mirror Slice",
            "description": "Write <code>func mirror(nums []int) []int</code> that makes the second half mirror the first half. For [1,2,3,4] \u2192 [1,2,2,1].",
            "functionSignature": "func mirror(nums []int) []int",
            "testCases": [
              {
                "input": "[]int{1, 2, 3, 4}",
                "output": "[1, 2, 2, 1]"
              },
              {
                "input": "[]int{1, 2, 3, 4, 5}",
                "output": "[1, 2, 3, 2, 1]"
              }
            ],
            "hints": [
              {
                "title": "\ud83e\udd14 Think about it",
                "content": "You need to copy elements from the first half to matching positions in the second half."
              },
              {
                "title": "\ud83d\udca1 Hint",
                "content": "Use two pointers: one from start, one from end. Copy nums[i] to nums[j] as long as i < j."
              },
              {
                "title": "\ud83d\udd27 Pattern",
                "content": "<pre>1. left pointer at 0, right pointer at len-1\n2. While left < right:\n   - Copy nums[left] to nums[right]\n   - Move both pointers inward\n3. Return modified slice</pre>"
              }
            ],
            "solution": "func mirror(nums []int) []int {\n    for i, j := 0, len(nums)-1; i < j; i, j = i+1, j-1 {\n        nums[j] = nums[i]\n    }\n    return nums\n}",
            "difficulty": 3
          },
          {
            "id": "v7",
            "title": "Swap Ends Only",
            "difficulty": 1,
            "description": "Write <code>func swapEnds(nums []int)</code> that swaps ONLY the first and last elements. Modify the slice in place.",
            "functionSignature": "func swapEnds(nums []int)",
            "testCases": [
              {
                "input": "[]int{1, 2, 3, 4, 5}",
                "output": "[5, 2, 3, 4, 1]",
                "note": "Only first and last swapped"
              },
              {
                "input": "[]int{10, 20}",
                "output": "[20, 10]"
              }
            ],
            "hints": [
              {
                "title": "\ud83e\udd14 Think about it",
                "content": "This is just a single swap operation - no loop needed!"
              },
              {
                "title": "\ud83d\udca1 Hint",
                "content": "Swap nums[0] and nums[len(nums)-1] using Go's simultaneous assignment."
              },
              {
                "title": "\ud83d\udd27 Pattern",
                "content": "<pre>nums[0], nums[len(nums)-1] = nums[len(nums)-1], nums[0]</pre>"
              }
            ],
            "solution": "func swapEnds(nums []int) {\n    if len(nums) > 1 {\n        nums[0], nums[len(nums)-1] = nums[len(nums)-1], nums[0]\n    }\n}"
          },
          {
            "id": "v8",
            "title": "Reverse First N",
            "difficulty": 1,
            "description": "Write <code>func reverseFirstN(nums []int, n int)</code> that reverses only the first n elements using two pointers.",
            "functionSignature": "func reverseFirstN(nums []int, n int)",
            "testCases": [
              {
                "input": "[]int{1, 2, 3, 4, 5}, 3",
                "output": "[3, 2, 1, 4, 5]",
                "note": "Only first 3 elements reversed"
              },
              {
                "input": "[]int{10, 20, 30, 40}, 2",
                "output": "[20, 10, 30, 40]"
              }
            ],
            "hints": [
              {
                "title": "\ud83e\udd14 Think about it",
                "content": "This is like reversing a slice, but you only go up to position n instead of the end."
              },
              {
                "title": "\ud83d\udca1 Hint",
                "content": "Use two pointers: left starts at 0, right starts at n-1 (not len-1!). Swap and move inward until they meet."
              },
              {
                "title": "\ud83d\udd27 Pattern",
                "content": "<pre>1. left := 0, right := n-1\n2. While left < right:\n   - Swap nums[left] and nums[right]\n   - left++, right--</pre>"
              }
            ],
            "solution": "func reverseFirstN(nums []int, n int) {\n    if n > len(nums) {\n        n = len(nums)\n    }\n    left, right := 0, n-1\n    for left < right {\n        nums[left], nums[right] = nums[right], nums[left]\n        left++\n        right--\n    }\n}"
          },
          {
            "id": "v9",
            "title": "Move Zeros to End",
            "description": "Write <code>func moveZeros(nums []int) []int</code> that moves all zeros to the end, preserving order of non-zeros.",
            "functionSignature": "func moveZeros(nums []int) []int",
            "testCases": [
              {
                "input": "[]int{0, 1, 0, 3, 12}",
                "output": "[]int{1, 3, 12, 0, 0}"
              },
              {
                "input": "[]int{0, 0, 1}",
                "output": "[]int{1, 0, 0}"
              }
            ],
            "hints": [
              {
                "title": "\ud83e\udd14 Think about it",
                "content": "Collect all non-zero elements first, then append zeros to fill the rest."
              },
              {
                "title": "\ud83d\udca1 Hint",
                "content": "Filter non-zeros into result, then append len(nums) - len(result) zeros."
              },
              {
                "title": "\ud83d\udd27 Pattern",
                "content": "<pre>1. result := []int{}\n2. For each num:\n   - num != 0? \u2192 append to result\n3. While len(result) < len(nums):\n   - append 0\n4. Return result</pre>"
              }
            ],
            "solution": "func moveZeros(nums []int) []int {\n    result := []int{}\n    for _, num := range nums {\n        if num != 0 {\n            result = append(result, num)\n        }\n    }\n    for len(result) < len(nums) {\n        result = append(result, 0)\n    }\n    return result\n}",
            "difficulty": 2
          },
          {
            "id": "v10",
            "title": "Reverse Words in Place",
            "description": "Write <code>func reverseWords(words []string)</code> that reverses the order of words in the slice in-place.",
            "functionSignature": "func reverseWords(words []string)",
            "testCases": [
              {
                "input": "[]string{\"hello\", \"world\", \"go\"}",
                "output": "[\"go\", \"world\", \"hello\"]"
              },
              {
                "input": "[]string{\"a\", \"b\"}",
                "output": "[\"b\", \"a\"]"
              }
            ],
            "hints": [
              {
                "title": "\ud83e\udd14 Think about it",
                "content": "Two-pointer swap pattern: swap from both ends moving toward center."
              },
              {
                "title": "\ud83d\udca1 Hint",
                "content": "left starts at 0, right at len-1. Swap and move inward until they meet."
              },
              {
                "title": "\ud83d\udd27 Pattern",
                "content": "<pre>1. left = 0, right = len-1\n2. While left < right:\n   - Swap words[left] \u2194 words[right]\n   - left++, right--</pre>"
              }
            ],
            "solution": "func reverseWords(words []string) {\n    for i, j := 0, len(words)-1; i < j; i, j = i+1, j-1 {\n        words[i], words[j] = words[j], words[i]\n    }\n}",
            "difficulty": 2
          },
          {
            "id": "v11",
            "title": "Reverse Outer Pairs",
            "difficulty": 1,
            "description": "Write <code>func reverseOuterPairs(nums []int, k int)</code> that swaps k pairs from both ends: swap nums[0]\u2194nums[len-1], nums[1]\u2194nums[len-2], ..., k times. Two-pointer inward movement.",
            "functionSignature": "func reverseOuterPairs(nums []int, k int)",
            "testCases": [
              {
                "input": "[]int{1, 2, 3, 4, 5, 6}, 2",
                "output": "[6, 5, 3, 4, 2, 1]",
                "note": "Swap 2 pairs from ends"
              },
              {
                "input": "[]int{1, 2, 3, 4}, 1",
                "output": "[4, 2, 3, 1]"
              }
            ],
            "hints": [
              {
                "title": "\ud83e\udd14 Think about it",
                "content": "Start with pointers at both ends. Swap, move both inward, repeat k times."
              },
              {
                "title": "\ud83d\udca1 Hint",
                "content": "left = 0, right = len-1. Loop k times: swap nums[left] with nums[right], then left++, right--."
              },
              {
                "title": "\ud83d\udd27 Pattern",
                "content": "<pre>1. left := 0, right := len-1\n2. For i from 0 to k:\n   - Swap nums[left] \u2194 nums[right]\n   - left++, right--</pre>"
              }
            ],
            "solution": "func reverseOuterPairs(nums []int, k int) {\n    left, right := 0, len(nums)-1\n    for i := 0; i < k && left < right; i++ {\n        nums[left], nums[right] = nums[right], nums[left]\n        left++\n        right--\n    }\n}"
          },
          {
            "id": "v12",
            "title": "Outer to Inner Copy",
            "difficulty": 1,
            "description": "Write <code>func outerToInner(nums []int)</code> that copies outer elements to inner positions moving inward: [1,2,3,4,5,6] \u2192 [1,1,6,6,5,6]. Two pointers copy inward.",
            "functionSignature": "func outerToInner(nums []int)",
            "testCases": [
              {
                "input": "[]int{1, 2, 3, 4, 5, 6}",
                "output": "[1, 1, 6, 6, 5, 6]",
                "note": "Outer values copy toward center"
              },
              {
                "input": "[]int{10, 20, 30, 40}",
                "output": "[10, 10, 40, 40]"
              }
            ],
            "hints": [
              {
                "title": "\ud83e\udd14 Think about it",
                "content": "Start pointers at ends. Copy the outer values to the next inner positions, move inward."
              },
              {
                "title": "\ud83d\udca1 Hint",
                "content": "left = 0, right = len-1. While left < right-1: save outer values, move pointers inward, write saved values."
              },
              {
                "title": "\ud83d\udd27 Pattern",
                "content": "<pre>1. left := 0, right := len-1\n2. While left < right-1:\n   - Copy nums[left] to nums[left+1]\n   - Copy nums[right] to nums[right-1]\n   - left++, right--</pre>"
              }
            ],
            "solution": "func outerToInner(nums []int) {\n    left, right := 0, len(nums)-1\n    for left < right-1 {\n        leftVal, rightVal := nums[left], nums[right]\n        left++\n        right--\n        nums[left] = leftVal\n        nums[right] = rightVal\n    }\n}"
          },
          {
            "id": "v13",
            "title": "Reverse Alternating Pairs",
            "difficulty": 1,
            "description": "Write <code>func reverseAlternating(nums []int)</code> that reverses every other pair from outside in: swap positions 0\u2194last, skip next pair, swap 2\u2194(last-2), etc. Two pointers with conditional swapping.",
            "functionSignature": "func reverseAlternating(nums []int)",
            "testCases": [
              {
                "input": "[]int{1, 2, 3, 4, 5, 6, 7, 8}",
                "output": "[8, 2, 7, 4, 5, 6, 3, 1]",
                "note": "Swap pairs at positions (0,7) and (2,5), skip (1,6) and (3,4)"
              },
              {
                "input": "[]int{1, 2, 3, 4}",
                "output": "[4, 2, 3, 1]",
                "note": "Swap (0,3), skip (1,2)"
              }
            ],
            "hints": [
              {
                "title": "\ud83e\udd14 Think about it",
                "content": "Start pointers at ends. Swap, move inward by 2 (skip next pair), swap again, repeat."
              },
              {
                "title": "\ud83d\udca1 Hint",
                "content": "left = 0, right = len-1. While left < right: swap them, then left += 2, right -= 2 (to skip next pair)."
              },
              {
                "title": "\ud83d\udd27 Pattern",
                "content": "<pre>1. left := 0, right := len-1\n2. While left < right:\n   - Swap nums[left] \u2194 nums[right]\n   - left += 2, right -= 2</pre>"
              }
            ],
            "solution": "func reverseAlternating(nums []int) {\n    left, right := 0, len(nums)-1\n    for left < right {\n        nums[left], nums[right] = nums[right], nums[left]\n        left += 2\n        right -= 2\n    }\n}"
          },
          {
            "id": "v1",
            "title": "Remove Duplicates from Sorted Array",
            "description": "Write a function <code>func removeDuplicates(nums []int) int</code> that removes duplicates from a sorted slice <strong>in-place</strong>. Return the number of unique elements. The first k elements should contain the unique values.",
            "functionSignature": "func removeDuplicates(nums []int) int",
            "testCases": [
              {
                "input": "[]int{1, 1, 2}",
                "output": "2",
                "note": "array becomes [1, 2, _]"
              },
              {
                "input": "[]int{0, 0, 1, 1, 2, 2, 3}",
                "output": "4",
                "note": "array becomes [0, 1, 2, 3, _, _, _]"
              },
              {
                "input": "[]int{1, 2, 3}",
                "output": "3"
              }
            ],
            "solution": "func removeDuplicates(nums []int) int {\n    if len(nums) == 0 {\n        return 0\n    }\n    slow := 0\n    for fast := 1; fast < len(nums); fast++ {\n        if nums[fast] != nums[slow] {\n            slow++\n            nums[slow] = nums[fast]\n        }\n    }\n    return slow + 1\n}",
            "difficulty": 4
          },
          {
            "id": "v2",
            "title": "Remove Element",
            "description": "Write a function <code>func removeElement(nums []int, val int) int</code> that removes all occurrences of <code>val</code> <strong>in-place</strong>. Return the number of elements remaining. Order doesn't need to be preserved.",
            "functionSignature": "func removeElement(nums []int, val int) int",
            "testCases": [
              {
                "input": "[]int{3, 2, 2, 3}, 3",
                "output": "2",
                "note": "array becomes [2, 2, _, _]"
              },
              {
                "input": "[]int{0, 1, 2, 2, 3, 0, 4, 2}, 2",
                "output": "5"
              },
              {
                "input": "[]int{1}, 1",
                "output": "0"
              }
            ],
            "solution": "func removeElement(nums []int, val int) int {\n    slow := 0\n    for fast := 0; fast < len(nums); fast++ {\n        if nums[fast] != val {\n            nums[slow] = nums[fast]\n            slow++\n        }\n    }\n    return slow\n}",
            "solutionNotes": "Unlike Remove Duplicates, here we compare against a fixed value, not the previous element. And both pointers start at 0.",
            "difficulty": 4
          },
          {
            "id": "v3",
            "title": "Move Zeroes",
            "description": "Write a function <code>func moveZeroes(nums []int)</code> that moves all <code>0</code>s to the end of the slice while maintaining the relative order of non-zero elements. Modify in-place.",
            "functionSignature": "func moveZeroes(nums []int)",
            "testCases": [
              {
                "input": "[]int{0, 1, 0, 3, 12}",
                "output": "[1, 3, 12, 0, 0]"
              },
              {
                "input": "[]int{0, 0, 1}",
                "output": "[1, 0, 0]"
              },
              {
                "input": "[]int{1, 2, 3}",
                "output": "[1, 2, 3]",
                "note": "no zeroes"
              }
            ],
            "solution": "func moveZeroes(nums []int) {\n    slow := 0\n    \n    for fast := 0; fast < len(nums); fast++ {\n        if nums[fast] != 0 {\n            nums[slow] = nums[fast]\n            slow++\n        }\n    }\n    \n    for i := slow; i < len(nums); i++ {\n        nums[i] = 0\n    }\n}",
            "solutionNotes": "This is a two-pass solution. First pass moves non-zeroes forward, second pass fills remaining positions with zeroes. Can also be done in one pass with swapping!",
            "difficulty": 4
          },
          {
            "id": "v4",
            "title": "Remove Duplicates II (Allow 2)",
            "description": "Write a function <code>func removeDuplicatesII(nums []int) int</code> that removes duplicates from a sorted array such that each element appears <strong>at most twice</strong>. Return the new length.",
            "functionSignature": "func removeDuplicatesII(nums []int) int",
            "testCases": [
              {
                "input": "[]int{1, 1, 1, 2, 2, 3}",
                "output": "5",
                "note": "becomes [1, 1, 2, 2, 3, _]"
              },
              {
                "input": "[]int{0, 0, 1, 1, 1, 1, 2, 3, 3}",
                "output": "7"
              },
              {
                "input": "[]int{1, 1}",
                "output": "2"
              }
            ],
            "solution": "func removeDuplicatesII(nums []int) int {\n    if len(nums) <= 2 {\n        return len(nums)\n    }\n    \n    slow := 2\n    for fast := 2; fast < len(nums); fast++ {\n        if nums[fast] != nums[slow-2] {\n            nums[slow] = nums[fast]\n            slow++\n        }\n    }\n    return slow\n}",
            "solutionNotes": "The key insight: compare with nums[slow-2], not nums[slow-1]. This ensures at most 2 of each value. Start both pointers at index 2.",
            "difficulty": 4
          },
          {
            "id": "v5",
            "title": "Sorted Squares",
            "description": "Write a function <code>func sortedSquares(nums []int) []int</code> that returns an array of the squares of each number, sorted in ascending order. Input is sorted but may contain negatives.",
            "functionSignature": "func sortedSquares(nums []int) []int",
            "testCases": [
              {
                "input": "[]int{-4, -1, 0, 3, 10}",
                "output": "[0, 1, 9, 16, 100]"
              },
              {
                "input": "[]int{-7, -3, 2, 3, 11}",
                "output": "[4, 9, 9, 49, 121]"
              },
              {
                "input": "[]int{1, 2, 3}",
                "output": "[1, 4, 9]"
              }
            ],
            "solution": "func sortedSquares(nums []int) []int {\n    n := len(nums)\n    result := make([]int, n)\n    left, right := 0, n-1\n    pos := n - 1\n    \n    for left <= right {\n        leftSq := nums[left] * nums[left]\n        rightSq := nums[right] * nums[right]\n        \n        if leftSq > rightSq {\n            result[pos] = leftSq\n            left++\n        } else {\n            result[pos] = rightSq\n            right--\n        }\n        pos--\n    }\n    return result\n}",
            "solutionNotes": "This uses two pointers from OPPOSITE ENDS (not slow/fast). The largest squares are at the edges (most negative or most positive). Fill result array from the back.",
            "difficulty": 4
          },
          {
            "id": "v6",
            "title": "Merge Sorted Array",
            "description": "Write a function <code>func merge(nums1 []int, m int, nums2 []int, n int)</code> that merges nums2 into nums1 <strong>in-place</strong>. nums1 has length m+n, with the last n elements being 0 (placeholders).",
            "functionSignature": "func merge(nums1 []int, m int, nums2 []int, n int)",
            "testCases": [
              {
                "input": "[]int{1, 2, 3, 0, 0, 0}, 3, []int{2, 5, 6}, 3",
                "output": "[1, 2, 2, 3, 5, 6]"
              },
              {
                "input": "[]int{1}, 1, []int{}, 0",
                "output": "[1]"
              },
              {
                "input": "[]int{0}, 0, []int{1}, 1",
                "output": "[1]"
              }
            ],
            "solution": "func merge(nums1 []int, m int, nums2 []int, n int) {\n    p1 := m - 1\n    p2 := n - 1\n    pos := m + n - 1\n    \n    for p2 >= 0 {\n        if p1 >= 0 && nums1[p1] > nums2[p2] {\n            nums1[pos] = nums1[p1]\n            p1--\n        } else {\n            nums1[pos] = nums2[p2]\n            p2--\n        }\n        pos--\n    }\n}",
            "solutionNotes": "Work BACKWARDS to avoid overwriting elements we haven't processed. The loop continues until all of nums2 is merged. If nums1 elements remain, they're already in place.",
            "difficulty": 4
          }
        ]
      },
      {
        "id": "challenge_11",
        "block": 4,
        "difficulty": 4,
        "concept": "Map Lookup + Early Return",
        "docLinks": [
          {
            "url": "https://go.dev/blog/maps",
            "title": "Go Blog: Go maps in action",
            "note": "map as a set pattern"
          },
          {
            "url": "https://go.dev/ref/spec#Index_expressions",
            "title": "Go Spec: Index expressions",
            "note": "checking if key exists"
          }
        ],
        "patternPrimer": {
          "bruteForce": "Nested loops: for each element, scan all previous elements to check if it appeared before.",
          "bestApproach": "Track seen elements in a map; check map in O(1) time, return immediately when found.",
          "typical": "Typically O(n) time, O(n) extra space"
        },
        "variants": [
          {
            "id": "v1",
            "title": "First Duplicate Index",
            "description": "Write <code>func firstDupIdx(nums []int) int</code> - index of first repeat, or -1.",
            "functionSignature": "func firstDupIdx(nums []int) int",
            "testCases": [
              {
                "input": "[]int{1,2,3,2}",
                "output": "3"
              }
            ],
            "hints": [
              {
                "title": "\ud83e\udd14 Think about it",
                "content": "You want to find the first element that appears twice. As you go through, how do you know if you've seen something before?"
              },
              {
                "title": "\ud83d\udca1 Hint",
                "content": "Use a map as a 'seen' set. For each element, first check if it's in the map - if yes, you found a duplicate! If no, add it to the map and continue."
              },
              {
                "title": "\ud83d\udd27 Pattern",
                "content": "<pre>1. Create empty \"seen\" tracker\n2. For each element:\n   - Already seen? \u2192 return (found duplicate!)\n   - Not seen? \u2192 add to tracker\n3. Loop finished? \u2192 return not found</pre>"
              }
            ],
            "solution": "func firstDupIdx(nums []int) int {\n    seen := make(map[int]bool)\n    for i, n := range nums {\n        if seen[n] { return i }\n        seen[n] = true\n    }\n    return -1\n}",
            "difficulty": 2
          },
          {
            "id": "v2",
            "title": "First Repeat Char",
            "description": "Write <code>func firstRepeat(s string) rune</code> - first repeated char, or 0.",
            "functionSignature": "func firstRepeat(s string) rune",
            "testCases": [
              {
                "input": "\"abcab\"",
                "output": "'a'"
              }
            ],
            "hints": [
              {
                "title": "\ud83e\udd14 Think about it",
                "content": "You want to find the first element that appears twice. As you go through, how do you know if you've seen something before?"
              },
              {
                "title": "\ud83d\udca1 Hint",
                "content": "Use a map as a 'seen' set. For each element, first check if it's in the map - if yes, you found a duplicate! If no, add it to the map and continue."
              },
              {
                "title": "\ud83d\udd27 Pattern",
                "content": "<pre>1. Create empty \"seen\" tracker\n2. For each element:\n   - Already seen? \u2192 return (found duplicate!)\n   - Not seen? \u2192 add to tracker\n3. Loop finished? \u2192 return not found</pre>"
              }
            ],
            "solution": "func firstRepeat(s string) rune {\n    seen := make(map[rune]bool)\n    for _, r := range s {\n        if seen[r] { return r }\n        seen[r] = true\n    }\n    return 0\n}",
            "difficulty": 2
          },
          {
            "id": "v3",
            "title": "Find Missing in Sequence",
            "description": "Write <code>func findMissing(nums []int, n int) int</code> - given numbers 1 to n with one missing, find it.",
            "functionSignature": "func findMissing(nums []int, n int) int",
            "testCases": [
              {
                "input": "[]int{1,2,4,5}, 5",
                "output": "3",
                "note": "3 is missing from 1-5"
              },
              {
                "input": "[]int{2,3,4}, 4",
                "output": "1"
              }
            ],
            "hints": [
              {
                "title": "\ud83e\udd14 Think about it",
                "content": "Put all the numbers you have into a set. Then check which number from 1 to n is not in the set."
              },
              {
                "title": "\ud83d\udca1 Hint",
                "content": "First loop: add all nums to a map. Second loop: check 1 to n, return the one not in the map."
              },
              {
                "title": "\ud83d\udd27 Pattern",
                "content": "<pre>1. Add all nums to a 'have' map\n2. For i from 1 to n:\n   - If !have[i] \u2192 return i (found missing!)\n3. Return 0 (shouldn't happen)</pre>"
              }
            ],
            "solution": "func findMissing(nums []int, n int) int {\n    have := make(map[int]bool)\n    for _, num := range nums { have[num] = true }\n    for i := 1; i <= n; i++ {\n        if !have[i] { return i }\n    }\n    return 0\n}",
            "difficulty": 3
          },
          {
            "id": "v4",
            "title": "Two Sum Exists",
            "description": "Write <code>func twoSumExists(nums []int, target int) bool</code> - true if any two numbers add to target.",
            "functionSignature": "func twoSumExists(nums []int, target int) bool",
            "testCases": [
              {
                "input": "[]int{2, 7, 11, 15}, 9",
                "output": "true"
              },
              {
                "input": "[]int{2, 7, 11, 15}, 10",
                "output": "false"
              }
            ],
            "hints": [
              {
                "title": "\ud83e\udd14 Think about it",
                "content": "For each number, what complement would you need to see to make the target sum? How can you check if you've seen that complement?"
              },
              {
                "title": "\ud83d\udca1 Hint",
                "content": "For each num, check if (target - num) is in your 'seen' set. If yes, you found a pair! If no, add num to seen and continue."
              },
              {
                "title": "\ud83d\udd27 Pattern",
                "content": "<pre>1. Create empty \"seen\" map\n2. For each num:\n   - complement = target - num\n   - seen[complement]? \u2192 return true\n   - Add num to seen\n3. Return false</pre>"
              }
            ],
            "solution": "func twoSumExists(nums []int, target int) bool {\n    seen := make(map[int]bool)\n    for _, n := range nums {\n        if seen[target-n] { return true }\n        seen[n] = true\n    }\n    return false\n}",
            "difficulty": 3
          },
          {
            "id": "v5",
            "title": "All Unique Words",
            "description": "Write <code>func allUnique(words []string) bool</code> - true if no word appears twice.",
            "functionSignature": "func allUnique(words []string) bool",
            "testCases": [
              {
                "input": "[]string{\"go\", \"rust\", \"python\"}",
                "output": "true"
              },
              {
                "input": "[]string{\"go\", \"rust\", \"go\"}",
                "output": "false"
              }
            ],
            "hints": [
              {
                "title": "\ud83e\udd14 Think about it",
                "content": "This is the inverse of 'has duplicate'. When should you return false?"
              },
              {
                "title": "\ud83d\udca1 Hint",
                "content": "Use a map to track seen words. If you ever encounter a word you've already seen, return false. If you finish the loop, return true."
              },
              {
                "title": "\ud83d\udd27 Pattern",
                "content": "<pre>1. Create empty \"seen\" map\n2. For each word:\n   - Already seen? \u2192 return false\n   - Add to seen\n3. Return true (all unique)</pre>"
              }
            ],
            "solution": "func allUnique(words []string) bool {\n    seen := make(map[string]bool)\n    for _, w := range words {\n        if seen[w] { return false }\n        seen[w] = true\n    }\n    return true\n}",
            "difficulty": 2
          },
          {
            "id": "v6",
            "title": "First Non-Repeating",
            "description": "Write <code>func firstNonRepeating(s string) rune</code> - first character that appears exactly once, or 0 if all repeat.",
            "functionSignature": "func firstNonRepeating(s string) rune",
            "testCases": [
              {
                "input": "\"aabbccd\"",
                "output": "'d'"
              },
              {
                "input": "\"aabbcc\"",
                "output": "0"
              }
            ],
            "hints": [
              {
                "title": "\ud83e\udd14 Think about it",
                "content": "You need TWO passes: first count all characters, then find the first one with count == 1."
              },
              {
                "title": "\ud83d\udca1 Hint",
                "content": "First pass: build a frequency map. Second pass: iterate through string again and return the first char with count == 1."
              },
              {
                "title": "\ud83d\udd27 Pattern",
                "content": "<pre>1. First pass: count each character\n2. Second pass: for each character\n   - Count == 1? \u2192 return it\n3. Return 0 (none found)</pre>"
              }
            ],
            "solution": "func firstNonRepeating(s string) rune {\n    counts := make(map[rune]int)\n    for _, r := range s { counts[r]++ }\n    for _, r := range s {\n        if counts[r] == 1 { return r }\n    }\n    return 0\n}",
            "difficulty": 3
          },
          {
            "id": "v7",
            "title": "Contains Value",
            "difficulty": 1,
            "description": "Write <code>func containsValue(nums []int, target int) bool</code> that returns true if target exists in the slice. Use a map for O(n) solution.",
            "functionSignature": "func containsValue(nums []int, target int) bool",
            "testCases": [
              {
                "input": "[]int{1, 2, 3, 4, 5}, 3",
                "output": "true"
              },
              {
                "input": "[]int{1, 2, 3, 4, 5}, 6",
                "output": "false"
              }
            ],
            "hints": [
              {
                "title": "\ud83e\udd14 Think about it",
                "content": "You could use linear search, but this pattern is about using maps. How can a map help you check membership quickly?"
              },
              {
                "title": "\ud83d\udca1 Hint",
                "content": "Build a map[int]bool to track which numbers exist. Then check if target is in the map using the comma-ok pattern."
              },
              {
                "title": "\ud83d\udd27 Pattern",
                "content": "<pre>1. Create set map[int]bool\n2. For each num: set[num] = true\n3. Return set[target] exists</pre>"
              }
            ],
            "solution": "func containsValue(nums []int, target int) bool {\n    seen := make(map[int]bool)\n    for _, n := range nums {\n        seen[n] = true\n    }\n    return seen[target]\n}"
          },
          {
            "id": "v8",
            "title": "Count Unique",
            "difficulty": 1,
            "description": "Write <code>func countUnique(nums []int) int</code> that returns how many unique/distinct numbers exist in the slice.",
            "functionSignature": "func countUnique(nums []int) int",
            "testCases": [
              {
                "input": "[]int{1, 2, 2, 3, 3, 3}",
                "output": "3",
                "note": "Three unique values: 1, 2, 3"
              },
              {
                "input": "[]int{5, 5, 5}",
                "output": "1"
              }
            ],
            "hints": [
              {
                "title": "\ud83e\udd14 Think about it",
                "content": "Maps automatically deduplicate! What property of a map tells you how many unique keys it has?"
              },
              {
                "title": "\ud83d\udca1 Hint",
                "content": "Add all numbers to a map[int]bool as keys. The map will only keep unique keys. Return len(map)."
              },
              {
                "title": "\ud83d\udd27 Pattern",
                "content": "<pre>1. Create set map[int]bool\n2. For each num: set[num] = true\n3. Return len(set)</pre>"
              }
            ],
            "solution": "func countUnique(nums []int) int {\n    seen := make(map[int]bool)\n    for _, n := range nums {\n        seen[n] = true\n    }\n    return len(seen)\n}"
          },
          {
            "id": "v9",
            "title": "Employee ID Lookup",
            "description": "Write <code>func employeeName(ids map[int]string, id int) string</code> that returns employee name or \"Unknown\".",
            "functionSignature": "func employeeName(ids map[int]string, id int) string",
            "testCases": [
              {
                "input": "map[int]string{101: \"Alice\", 102: \"Bob\"}, 101",
                "output": "\"Alice\""
              },
              {
                "input": "map[int]string{101: \"Alice\"}, 999",
                "output": "\"Unknown\""
              }
            ],
            "hints": [
              {
                "title": "\ud83e\udd14 Think about it",
                "content": "Use comma-ok idiom to check if ID exists in map."
              },
              {
                "title": "\ud83d\udca1 Hint",
                "content": "name, exists := ids[id]; if exists return name, else return \"Unknown\""
              },
              {
                "title": "\ud83d\udd27 Pattern",
                "content": "<pre>1. name, exists := ids[id]\n2. If exists \u2192 return name\n3. Return \"Unknown\"</pre>"
              }
            ],
            "solution": "func employeeName(ids map[int]string, id int) string {\n    if name, exists := ids[id]; exists {\n        return name\n    }\n    return \"Unknown\"\n}",
            "difficulty": 2
          },
          {
            "id": "v10",
            "title": "Country Capital",
            "description": "Write <code>func getCapital(capitals map[string]string, country string) (string, bool)</code> that returns capital and whether found.",
            "functionSignature": "func getCapital(capitals map[string]string, country string) (string, bool)",
            "testCases": [
              {
                "input": "map[string]string{\"USA\": \"Washington DC\", \"France\": \"Paris\"}, \"France\"",
                "output": "\"Paris\", true"
              },
              {
                "input": "map[string]string{\"USA\": \"Washington DC\"}, \"Spain\"",
                "output": "\"\", false"
              }
            ],
            "hints": [
              {
                "title": "\ud83e\udd14 Think about it",
                "content": "This is a direct map lookup with comma-ok pattern - return both value and existence."
              },
              {
                "title": "\ud83d\udca1 Hint",
                "content": "capital, exists := capitals[country]; return capital, exists"
              },
              {
                "title": "\ud83d\udd27 Pattern",
                "content": "<pre>capital, exists := capitals[country]\nreturn capital, exists</pre>"
              }
            ],
            "solution": "func getCapital(capitals map[string]string, country string) (string, bool) {\n    capital, exists := capitals[country]\n    return capital, exists\n}",
            "difficulty": 1
          },
          {
            "id": "v1",
            "title": "Two Sum",
            "description": "Given a slice of ints and a target, return indices of two numbers that add up to the target. <code>func twoSum(nums []int, target int) []int</code>",
            "functionSignature": "func twoSum(nums []int, target int) []int",
            "testCases": [
              {
                "input": "[]int{2, 7, 11, 15}, 9",
                "output": "[0, 1]"
              },
              {
                "input": "[]int{3, 2, 4}, 6",
                "output": "[1, 2]"
              },
              {
                "input": "[]int{3, 3}, 6",
                "output": "[0, 1]"
              }
            ],
            "solution": "func twoSum(nums []int, target int) []int {\n    seen := make(map[int]int)\n    for i, num := range nums {\n        complement := target - num\n        if j, ok := seen[complement]; ok {\n            return []int{j, i}\n        }\n        seen[num] = i\n    }\n    return nil\n}",
            "difficulty": 4
          },
          {
            "id": "v2",
            "title": "Two Sum II (Sorted Input)",
            "description": "Given a <strong>sorted</strong> array and target, return indices (1-indexed) of two numbers that add to target. Use two pointers instead of a hash map. <code>func twoSumSorted(nums []int, target int) []int</code>",
            "functionSignature": "func twoSumSorted(nums []int, target int) []int",
            "testCases": [
              {
                "input": "[]int{2, 7, 11, 15}, 9",
                "output": "[1, 2]",
                "note": "1-indexed!"
              },
              {
                "input": "[]int{2, 3, 4}, 6",
                "output": "[1, 3]"
              },
              {
                "input": "[]int{-1, 0}, -1",
                "output": "[1, 2]"
              }
            ],
            "solution": "func twoSumSorted(nums []int, target int) []int {\n    left, right := 0, len(nums)-1\n    \n    for left < right {\n        sum := nums[left] + nums[right]\n        if sum == target {\n            return []int{left + 1, right + 1}\n        } else if sum < target {\n            left++\n        } else {\n            right--\n        }\n    }\n    return nil\n}",
            "solutionNotes": "When input is sorted, two pointers is O(1) space vs O(n) for hash map. Move left pointer right for larger sum, right pointer left for smaller sum.",
            "difficulty": 4
          },
          {
            "id": "v3",
            "title": "Pair with Difference",
            "description": "Find two numbers whose <strong>difference</strong> equals the target. Return their indices (smaller index first). <code>func pairWithDiff(nums []int, target int) []int</code>",
            "functionSignature": "func pairWithDiff(nums []int, target int) []int",
            "testCases": [
              {
                "input": "[]int{5, 20, 3, 2, 50, 80}, 78",
                "output": "[1, 5]",
                "note": "80 - 2 = 78... wait"
              },
              {
                "input": "[]int{1, 5, 3}, 2",
                "output": "[0, 2]",
                "note": "3 - 1 = 2"
              },
              {
                "input": "[]int{1, 2, 3}, 10",
                "output": "nil"
              }
            ],
            "solution": "func pairWithDiff(nums []int, target int) []int {\n    seen := make(map[int]int)\n    \n    for i, num := range nums {\n        if j, ok := seen[num-target]; ok {\n            return []int{j, i}\n        }\n        if j, ok := seen[num+target]; ok {\n            return []int{j, i}\n        }\n        seen[num] = i\n    }\n    return nil\n}",
            "solutionNotes": "Unlike Two Sum where we look for target-num, here we look for BOTH num-target AND num+target because either could be the pair (a-b=k or b-a=k).",
            "difficulty": 4
          },
          {
            "id": "v4",
            "title": "Count Pairs with Sum",
            "description": "Count how many pairs of numbers add up to exactly the target. Each element can only be used once. <code>func countPairs(nums []int, target int) int</code>",
            "functionSignature": "func countPairs(nums []int, target int) int",
            "testCases": [
              {
                "input": "[]int{1, 5, 7, 1}, 6",
                "output": "2",
                "note": "(1,5) and (1,5)"
              },
              {
                "input": "[]int{1, 1, 1, 1}, 2",
                "output": "2",
                "note": "two pairs of 1+1"
              },
              {
                "input": "[]int{1, 2, 3}, 10",
                "output": "0"
              }
            ],
            "solution": "func countPairs(nums []int, target int) int {\n    counts := make(map[int]int)\n    for _, num := range nums {\n        counts[num]++\n    }\n    \n    pairs := 0\n    for num, count := range counts {\n        complement := target - num\n        if complement == num {\n            pairs += count * (count - 1) / 2\n        } else if compCount, ok := counts[complement]; ok && complement > num {\n            pairs += count * compCount\n        }\n    }\n    return pairs\n}",
            "solutionNotes": "This is trickier! We count occurrences first, then for each unique number, find pairs. Handle same-number pairs specially (n choose 2). Use complement > num to avoid double counting.",
            "difficulty": 4
          },
          {
            "id": "v5",
            "title": "Three Sum Exists",
            "description": "Return <code>true</code> if any three numbers in the array sum to zero. <code>func threeSumExists(nums []int) bool</code>",
            "functionSignature": "func threeSumExists(nums []int) bool",
            "testCases": [
              {
                "input": "[]int{-1, 0, 1, 2}",
                "output": "true",
                "note": "-1 + 0 + 1 = 0"
              },
              {
                "input": "[]int{1, 2, 3}",
                "output": "false"
              },
              {
                "input": "[]int{0, 0, 0}",
                "output": "true"
              }
            ],
            "solution": "import \"sort\"\n\nfunc threeSumExists(nums []int) bool {\n    sort.Ints(nums)\n    n := len(nums)\n    \n    for i := 0; i < n-2; i++ {\n        if i > 0 && nums[i] == nums[i-1] {\n            continue\n        }\n        \n        left, right := i+1, n-1\n        target := -nums[i]\n        \n        for left < right {\n            sum := nums[left] + nums[right]\n            if sum == target {\n                return true\n            } else if sum < target {\n                left++\n            } else {\n                right--\n            }\n        }\n    }\n    return false\n}",
            "solutionNotes": "Fix one number, then use Two Sum II (sorted) for the other two. Sorting first enables the two-pointer approach. O(n\u00b2) total.",
            "difficulty": 4
          },
          {
            "id": "v6",
            "title": "Subarray Sum Equals K",
            "description": "Count the number of continuous subarrays whose elements sum to k. <code>func subarraySum(nums []int, k int) int</code>",
            "functionSignature": "func subarraySum(nums []int, k int) int",
            "testCases": [
              {
                "input": "[]int{1, 1, 1}, 2",
                "output": "2",
                "note": "[1,1] at positions 0-1 and 1-2"
              },
              {
                "input": "[]int{1, 2, 3}, 3",
                "output": "2",
                "note": "[1,2] and [3]"
              },
              {
                "input": "[]int{1, -1, 0}, 0",
                "output": "3"
              }
            ],
            "solution": "func subarraySum(nums []int, k int) int {\n    count := 0\n    prefixSum := 0\n    seen := make(map[int]int)\n    seen[0] = 1\n    \n    for _, num := range nums {\n        prefixSum += num\n        if c, ok := seen[prefixSum-k]; ok {\n            count += c\n        }\n        seen[prefixSum]++\n    }\n    return count\n}",
            "solutionNotes": "This uses the prefix sum technique with a hash map. If prefix[j] - prefix[i] = k, then subarray [i+1...j] sums to k. We track how many times each prefix sum has occurred.",
            "difficulty": 4
          }
        ]
      },
      {
        "id": "challenge_12",
        "block": 1,
        "difficulty": 1,
        "concept": "Simple Tallying",
        "docLinks": [
          {
            "url": "https://go.dev/blog/maps",
            "title": "Go Blog: Go maps in action",
            "note": "intro to maps"
          }
        ],
        "patternPrimer": {
          "bruteForce": "Loop through and increment a counter when condition matches.",
          "bestApproach": "Same approach - single pass counting is already optimal.",
          "typical": "Typically O(n) time, O(1) extra space"
        },
        "variants": [
          {
            "id": "v1",
            "title": "Count Specific Value",
            "description": "Write <code>func countValue(nums []int, target int) int</code> that counts how many times target appears.",
            "functionSignature": "func countValue(nums []int, target int) int",
            "testCases": [
              {
                "input": "[]int{1, 2, 2, 3, 2}, 2",
                "output": "3"
              },
              {
                "input": "[]int{5, 5, 5}, 5",
                "output": "3"
              }
            ],
            "hints": [
              {
                "title": "\ud83e\udd14 Think about it",
                "content": "Start with count = 0. Each time you see the target, increment count."
              },
              {
                "title": "\ud83d\udca1 Hint",
                "content": "Loop through the slice. If element == target, do count++."
              },
              {
                "title": "\ud83d\udd27 Pattern",
                "content": "<pre>1. count := 0\n2. For each element:\n   - element == target? \u2192 count++\n3. Return count</pre>"
              }
            ],
            "solution": "func countValue(nums []int, target int) int {\n    count := 0\n    for _, n := range nums {\n        if n == target { count++ }\n    }\n    return count\n}",
            "difficulty": 1
          },
          {
            "id": "v2",
            "title": "Track Seen Values",
            "description": "Write <code>func trackSeen(nums []int) map[int]bool</code> that returns a map marking which values were seen.",
            "functionSignature": "func trackSeen(nums []int) map[int]bool",
            "testCases": [
              {
                "input": "[]int{1, 2, 2, 3}",
                "output": "map[1:true 2:true 3:true]"
              },
              {
                "input": "[]int{5, 5}",
                "output": "map[5:true]"
              }
            ],
            "hints": [
              {
                "title": "\ud83e\udd14 Think about it",
                "content": "Create a map, then mark each number as seen (true)."
              },
              {
                "title": "\ud83d\udca1 Hint",
                "content": "For each number, set seen[num] = true. Maps automatically handle duplicates."
              },
              {
                "title": "\ud83d\udd27 Pattern",
                "content": "<pre>1. Create map[int]bool\n2. For each num:\n   - seen[num] = true\n3. Return map</pre>"
              }
            ],
            "solution": "func trackSeen(nums []int) map[int]bool {\n    seen := make(map[int]bool)\n    for _, n := range nums { seen[n] = true }\n    return seen\n}",
            "difficulty": 2
          },
          {
            "id": "v3",
            "title": "Count True Values",
            "description": "Write <code>func countTrue(flags []bool) int</code> that counts how many true values are in the slice.",
            "functionSignature": "func countTrue(flags []bool) int",
            "testCases": [
              {
                "input": "[]bool{true, false, true, true}",
                "output": "3"
              },
              {
                "input": "[]bool{false, false}",
                "output": "0"
              }
            ],
            "hints": [
              {
                "title": "\ud83e\udd14 Think about it",
                "content": "Same as counting any specific value - count when you see true."
              },
              {
                "title": "\ud83d\udca1 Hint",
                "content": "if flag { count++ }"
              },
              {
                "title": "\ud83d\udd27 Pattern",
                "content": "<pre>1. count := 0\n2. For each flag:\n   - flag == true? \u2192 count++\n3. Return count</pre>"
              }
            ],
            "solution": "func countTrue(flags []bool) int {\n    count := 0\n    for _, f := range flags {\n        if f { count++ }\n    }\n    return count\n}",
            "difficulty": 1
          },
          {
            "id": "v4",
            "title": "Tally by Type",
            "description": "Write <code>func tallyTypes(words []string) map[string]int</code> that counts how many of each word type. Simple tallying intro!",
            "functionSignature": "func tallyTypes(words []string) map[string]int",
            "testCases": [
              {
                "input": "[]string{\"cat\", \"dog\", \"cat\", \"bird\"}",
                "output": "map[cat:2 dog:1 bird:1]"
              }
            ],
            "hints": [
              {
                "title": "\ud83e\udd14 Think about it",
                "content": "For each word, increment its count in the map. Maps default to 0 when accessing non-existent keys."
              },
              {
                "title": "\ud83d\udca1 Hint",
                "content": "counts[word]++ works even if word isn't in the map yet (starts at 0)."
              },
              {
                "title": "\ud83d\udd27 Pattern",
                "content": "<pre>1. Create map[string]int\n2. For each word:\n   - counts[word]++\n3. Return map</pre>"
              }
            ],
            "solution": "func tallyTypes(words []string) map[string]int {\n    counts := make(map[string]int)\n    for _, w := range words { counts[w]++ }\n    return counts\n}",
            "difficulty": 2
          },
          {
            "id": "v5",
            "title": "Count Vowels and Consonants",
            "description": "Write <code>func countVowelsConsonants(s string) (int, int)</code> that returns vowel count and consonant count.",
            "functionSignature": "func countVowelsConsonants(s string) (int, int)",
            "testCases": [
              {
                "input": "\"hello\"",
                "output": "2, 3",
                "note": "e,o are vowels; h,l,l are consonants"
              },
              {
                "input": "\"aaa\"",
                "output": "3, 0"
              }
            ],
            "hints": [
              {
                "title": "\ud83e\udd14 Think about it",
                "content": "Check if each character is a vowel (a,e,i,o,u). Count separately."
              },
              {
                "title": "\ud83d\udca1 Hint",
                "content": "Create a helper check: isVowel := char == 'a' || char == 'e' || ..."
              },
              {
                "title": "\ud83d\udd27 Pattern",
                "content": "<pre>1. vowels, consonants := 0, 0\n2. For each char:\n   - Is vowel? \u2192 vowels++\n   - Else \u2192 consonants++\n3. Return both</pre>"
              }
            ],
            "solution": "func countVowelsConsonants(s string) (int, int) {\n    vowels, consonants := 0, 0\n    for _, r := range s {\n        lower := strings.ToLower(string(r))\n        if lower == \"a\" || lower == \"e\" || lower == \"i\" || lower == \"o\" || lower == \"u\" {\n            vowels++\n        } else {\n            consonants++\n        }\n    }\n    return vowels, consonants\n}",
            "difficulty": 2
          },
          {
            "id": "v6",
            "title": "Has Value",
            "description": "Write <code>func hasValue(nums []int, target int) bool</code> that returns true if target is in the slice.",
            "functionSignature": "func hasValue(nums []int, target int) bool",
            "testCases": [
              {
                "input": "[]int{1, 2, 3}, 2",
                "output": "true"
              },
              {
                "input": "[]int{1, 2, 3}, 5",
                "output": "false"
              }
            ],
            "hints": [
              {
                "title": "\ud83e\udd14 Think about it",
                "content": "As soon as you find target, return true. If loop finishes, return false."
              },
              {
                "title": "\ud83d\udca1 Hint",
                "content": "This is early return pattern - return as soon as found."
              },
              {
                "title": "\ud83d\udd27 Pattern",
                "content": "<pre>1. For each num:\n   - num == target? \u2192 return true\n2. Return false (not found)</pre>"
              }
            ],
            "solution": "func hasValue(nums []int, target int) bool {\n    for _, n := range nums {\n        if n == target { return true }\n    }\n    return false\n}",
            "difficulty": 1
          },
          {
            "id": "v7",
            "title": "Count Even Numbers",
            "description": "Write <code>func countEvens(nums []int) int</code> that counts how many even numbers are in the slice.",
            "functionSignature": "func countEvens(nums []int) int",
            "testCases": [
              {
                "input": "[]int{1, 2, 3, 4, 5, 6}",
                "output": "3"
              },
              {
                "input": "[]int{1, 3, 5}",
                "output": "0"
              }
            ],
            "hints": [
              {
                "title": "\ud83e\udd14 Think about it",
                "content": "A number is even if num % 2 == 0. Count how many satisfy this condition."
              },
              {
                "title": "\ud83d\udca1 Hint",
                "content": "Loop through, increment counter when num % 2 == 0."
              },
              {
                "title": "\ud83d\udd27 Pattern",
                "content": "<pre>1. count := 0\n2. For each num:\n   - num % 2 == 0? \u2192 count++\n3. Return count</pre>"
              }
            ],
            "solution": "func countEvens(nums []int) int {\n    count := 0\n    for _, n := range nums {\n        if n % 2 == 0 { count++ }\n    }\n    return count\n}",
            "difficulty": 1
          },
          {
            "id": "v8",
            "title": "Passing Grades",
            "description": "Write <code>func passingGrades(grades []int) int</code> that counts how many grades are 60 or above.",
            "functionSignature": "func passingGrades(grades []int) int",
            "testCases": [
              {
                "input": "[]int{85, 55, 90, 45, 70}",
                "output": "3"
              },
              {
                "input": "[]int{30, 40, 50}",
                "output": "0"
              }
            ],
            "hints": [
              {
                "title": "\ud83e\udd14 Think about it",
                "content": "Count grades that are >= 60."
              },
              {
                "title": "\ud83d\udca1 Hint",
                "content": "Simple counter: if grade >= 60, increment count."
              },
              {
                "title": "\ud83d\udd27 Pattern",
                "content": "<pre>1. count := 0\n2. For each grade:\n   - grade >= 60? \u2192 count++\n3. Return count</pre>"
              }
            ],
            "solution": "func passingGrades(grades []int) int {\n    count := 0\n    for _, g := range grades {\n        if g >= 60 { count++ }\n    }\n    return count\n}",
            "difficulty": 1
          },
          {
            "id": "v9",
            "title": "Inventory Below Threshold",
            "description": "Write <code>func lowStock(inventory map[string]int, threshold int) []string</code> that returns item names with stock below threshold.",
            "functionSignature": "func lowStock(inventory map[string]int, threshold int) []string",
            "testCases": [
              {
                "input": "map[string]int{\"apples\": 5, \"oranges\": 15, \"bananas\": 3}, 10",
                "output": "[\"apples\", \"bananas\"]"
              },
              {
                "input": "map[string]int{\"pens\": 100, \"paper\": 200}, 50",
                "output": "[]"
              }
            ],
            "hints": [
              {
                "title": "\ud83e\udd14 Think about it",
                "content": "Loop through the map, collect items where count < threshold."
              },
              {
                "title": "\ud83d\udca1 Hint",
                "content": "For each key-value pair, if value < threshold, append key to result slice."
              },
              {
                "title": "\ud83d\udd27 Pattern",
                "content": "<pre>1. result := []string{}\n2. For item, count in inventory:\n   - count < threshold?\n     \u2192 append item to result\n3. Return result</pre>"
              }
            ],
            "solution": "func lowStock(inventory map[string]int, threshold int) []string {\n    result := []string{}\n    for item, count := range inventory {\n        if count < threshold {\n            result = append(result, item)\n        }\n    }\n    return result\n}",
            "difficulty": 2
          },
          {
            "id": "v10",
            "title": "Group By First Letter",
            "description": "Write <code>func groupByFirstLetter(words []string) map[rune][]string</code> that groups words by their first letter. Returns a map where keys are first letters and values are slices of all words starting with that letter.",
            "functionSignature": "func groupByFirstLetter(words []string) map[rune][]string",
            "testCases": [
              {
                "input": "[\"go\", \"rust\", \"ruby\", \"python\", \"perl\"]",
                "output": "map['g':[\"go\"] 'r':[\"rust\", \"ruby\"] 'p':[\"python\", \"perl\"]]"
              },
              {
                "input": "[\"apple\", \"ant\", \"bat\", \"bear\"]",
                "output": "map['a':[\"apple\", \"ant\"] 'b':[\"bat\", \"bear\"]]"
              }
            ],
            "hints": [
              {
                "title": "\ud83e\udd14 Think about it",
                "content": "You need to build a map where each key points to a slice. For each word, get its first letter and append the word to that letter's slice."
              },
              {
                "title": "\ud83d\udca1 Hint",
                "content": "Create map[rune][]string. For each word, get first letter with rune(word[0]). Append word to groups[firstLetter]. If the slice doesn't exist yet, append creates it."
              },
              {
                "title": "\ud83d\udd27 Pattern",
                "content": "<pre>1. Create map[rune][]string\n2. For each word:\n   - Get first letter: rune(word[0])\n   - Append word to map[firstLetter]\n3. Return map</pre>"
              }
            ],
            "solution": "func groupByFirstLetter(words []string) map[rune][]string {\n    groups := make(map[rune][]string)\n    for _, word := range words {\n        if len(word) > 0 {\n            firstLetter := rune(word[0])\n            groups[firstLetter] = append(groups[firstLetter], word)\n        }\n    }\n    return groups\n}",
            "difficulty": 3
          },
          {
            "id": "v11",
            "title": "Frequency Sorted Keys",
            "description": "Write <code>func frequencySortedKeys(items []string) []string</code> that returns unique items sorted by frequency (most common first). If frequencies are tied, maintain the order items were first seen.",
            "functionSignature": "func frequencySortedKeys(items []string) []string",
            "testCases": [
              {
                "input": "[\"cat\", \"dog\", \"cat\", \"bird\", \"cat\", \"dog\"]",
                "output": "[\"cat\", \"dog\", \"bird\"]",
                "note": "cat appears 3x, dog 2x, bird 1x"
              },
              {
                "input": "[\"a\", \"b\", \"a\", \"c\", \"a\", \"b\"]",
                "output": "[\"a\", \"b\", \"c\"]"
              }
            ],
            "hints": [
              {
                "title": "\ud83e\udd14 Think about it",
                "content": "First build a frequency map to count occurrences. Then you need to create a result by iterating through unique items and sorting by their frequency. Track the order items first appeared."
              },
              {
                "title": "\ud83d\udca1 Hint",
                "content": "Build two things: a frequency map and a list of unique items in order seen. Then sort the unique list by looking up frequencies. Use a simple comparison to sort."
              },
              {
                "title": "\ud83d\udd27 Pattern",
                "content": "<pre>1. Build frequency map\n2. Track unique items in order\n3. Sort unique items by frequency\n   (most frequent first)\n4. Return sorted list</pre>"
              }
            ],
            "solution": "func frequencySortedKeys(items []string) []string {\n    freq := make(map[string]int)\n    var order []string\n    seen := make(map[string]bool)\n    \n    for _, item := range items {\n        freq[item]++\n        if !seen[item] {\n            order = append(order, item)\n            seen[item] = true\n        }\n    }\n    \n    // Simple bubble sort by frequency\n    for i := 0; i < len(order); i++ {\n        for j := i + 1; j < len(order); j++ {\n            if freq[order[j]] > freq[order[i]] {\n                order[i], order[j] = order[j], order[i]\n            }\n        }\n    }\n    \n    return order\n}",
            "difficulty": 3
          },
          {
            "id": "v12",
            "title": "Count Multi-Condition",
            "description": "Write <code>func countMultiCondition(nums []int, min, max, divisor int) map[string]int</code> that categorizes numbers into four groups: \"in_range\" (min <= n <= max), \"divisible\" (n % divisor == 0), \"both\" (satisfies both conditions), and \"neither\".",
            "functionSignature": "func countMultiCondition(nums []int, min, max, divisor int) map[string]int",
            "testCases": [
              {
                "input": "[]int{5, 10, 15, 20}, 10, 20, 5",
                "output": "map[\"in_range\":3 \"divisible\":4 \"both\":3 \"neither\":0]",
                "note": "10,15,20 in range; all divisible by 5; 10,15,20 satisfy both; 5 satisfies neither"
              },
              {
                "input": "[]int{1, 2, 3}, 5, 10, 2",
                "output": "map[\"in_range\":0 \"divisible\":1 \"both\":0 \"neither\":2]"
              }
            ],
            "hints": [
              {
                "title": "\ud83e\udd14 Think about it",
                "content": "For each number, check both conditions independently. Count how many satisfy: just range, just divisible, both, or neither. All four counts are independent."
              },
              {
                "title": "\ud83d\udca1 Hint",
                "content": "Create a map with 4 keys initialized to 0. For each number, check inRange := (n >= min && n <= max) and isDivisible := (n % divisor == 0). Then increment the appropriate counters."
              },
              {
                "title": "\ud83d\udd27 Pattern",
                "content": "<pre>1. Create map with 4 categories = 0\n2. For each num:\n   - Check if in range\n   - Check if divisible\n   - Increment all matching categories\n3. Return map</pre>"
              }
            ],
            "solution": "func countMultiCondition(nums []int, min, max, divisor int) map[string]int {\n    counts := map[string]int{\"in_range\": 0, \"divisible\": 0, \"both\": 0, \"neither\": 0}\n    \n    for _, n := range nums {\n        inRange := n >= min && n <= max\n        isDivisible := n % divisor == 0\n        \n        if inRange {\n            counts[\"in_range\"]++\n        }\n        if isDivisible {\n            counts[\"divisible\"]++\n        }\n        if inRange && isDivisible {\n            counts[\"both\"]++\n        }\n        if !inRange && !isDivisible {\n            counts[\"neither\"]++\n        }\n    }\n    \n    return counts\n}",
            "difficulty": 3
          },
          {
            "id": "v13",
            "title": "Tally By Category",
            "description": "Write <code>func tallyByCategory(items []string, categories map[string]string) map[string]int</code> that counts items per category. Given items and a map of item\u2192category, return count of items per category.",
            "functionSignature": "func tallyByCategory(items []string, categories map[string]string) map[string]int",
            "testCases": [
              {
                "input": "[\"apple\", \"banana\", \"carrot\", \"broccoli\"], map[\"apple\":\"fruit\", \"banana\":\"fruit\", \"carrot\":\"veggie\", \"broccoli\":\"veggie\"]",
                "output": "map[\"fruit\":2 \"veggie\":2]"
              },
              {
                "input": "[\"a\", \"b\", \"c\"], map[\"a\":\"x\", \"b\":\"x\", \"c\":\"y\"]",
                "output": "map[\"x\":2 \"y\":1]"
              }
            ],
            "hints": [
              {
                "title": "\ud83e\udd14 Think about it",
                "content": "For each item, look up its category in the categories map, then increment that category's count in your result map."
              },
              {
                "title": "\ud83d\udca1 Hint",
                "content": "Create a result map for counting. For each item, get category := categories[item], then do counts[category]++. The map lookup gives you the indirect key to increment."
              },
              {
                "title": "\ud83d\udd27 Pattern",
                "content": "<pre>1. Create counts map[string]int\n2. For each item:\n   - Look up category from categories map\n   - Increment counts[category]\n3. Return counts</pre>"
              }
            ],
            "solution": "func tallyByCategory(items []string, categories map[string]string) map[string]int {\n    counts := make(map[string]int)\n    for _, item := range items {\n        category := categories[item]\n        counts[category]++\n    }\n    return counts\n}",
            "difficulty": 3
          }
        ]
      },
      {
        "id": "challenge_13",
        "block": 1,
        "difficulty": 1,
        "concept": "Basic Swap Operations",
        "docLinks": [
          {
            "url": "https://go.dev/ref/spec#Assignments",
            "title": "Go Spec: Assignments",
            "note": "simultaneous assignment"
          }
        ],
        "patternPrimer": {
          "bruteForce": "Use a temp variable: temp = a, a = b, b = temp (works but verbose).",
          "bestApproach": "Go's simultaneous assignment: a, b = b, a (cleaner, evaluates right side first).",
          "typical": "Typically O(1) time, O(1) extra space"
        },
        "variants": [
          {
            "id": "v1",
            "title": "Swap Two Variables",
            "description": "Write <code>func swapVars(a, b int) (int, int)</code> that returns the values swapped.",
            "functionSignature": "func swapVars(a, b int) (int, int)",
            "testCases": [
              {
                "input": "3, 7",
                "output": "7, 3"
              },
              {
                "input": "10, 20",
                "output": "20, 10"
              }
            ],
            "hints": [
              {
                "title": "\ud83e\udd14 Think about it",
                "content": "Go's simultaneous assignment makes this trivial."
              },
              {
                "title": "\ud83d\udca1 Hint",
                "content": "return b, a - just return them in opposite order!"
              },
              {
                "title": "\ud83d\udd27 Pattern",
                "content": "<pre>return b, a</pre>"
              }
            ],
            "solution": "func swapVars(a, b int) (int, int) {\n    return b, a\n}",
            "difficulty": 1
          },
          {
            "id": "v2",
            "title": "Swap First Two Elements",
            "description": "Write <code>func swapFirstTwo(nums []int)</code> that swaps the first two elements in place. Assume at least 2 elements.",
            "functionSignature": "func swapFirstTwo(nums []int)",
            "testCases": [
              {
                "input": "[]int{1, 2, 3}",
                "output": "[2, 1, 3]"
              },
              {
                "input": "[]int{5, 10}",
                "output": "[10, 5]"
              }
            ],
            "hints": [
              {
                "title": "\ud83e\udd14 Think about it",
                "content": "Use simultaneous assignment on slice indices."
              },
              {
                "title": "\ud83d\udca1 Hint",
                "content": "nums[0], nums[1] = nums[1], nums[0]"
              },
              {
                "title": "\ud83d\udd27 Pattern",
                "content": "<pre>nums[0], nums[1] = nums[1], nums[0]</pre>"
              }
            ],
            "solution": "func swapFirstTwo(nums []int) {\n    nums[0], nums[1] = nums[1], nums[0]\n}",
            "difficulty": 1
          },
          {
            "id": "v3",
            "title": "Swap Ends",
            "description": "Write <code>func swapEnds(nums []int)</code> that swaps first and last elements.",
            "functionSignature": "func swapEnds(nums []int)",
            "testCases": [
              {
                "input": "[]int{1, 2, 3, 4}",
                "output": "[4, 2, 3, 1]"
              },
              {
                "input": "[]int{5, 10}",
                "output": "[10, 5]"
              }
            ],
            "hints": [
              {
                "title": "\ud83e\udd14 Think about it",
                "content": "Last element is at index len(nums)-1."
              },
              {
                "title": "\ud83d\udca1 Hint",
                "content": "Swap nums[0] with nums[len(nums)-1]."
              },
              {
                "title": "\ud83d\udd27 Pattern",
                "content": "<pre>nums[0], nums[len(nums)-1] = nums[len(nums)-1], nums[0]</pre>"
              }
            ],
            "solution": "func swapEnds(nums []int) {\n    nums[0], nums[len(nums)-1] = nums[len(nums)-1], nums[0]\n}",
            "difficulty": 1
          },
          {
            "id": "v4",
            "title": "Swap at Indices",
            "description": "Write <code>func swapAt(nums []int, i, j int)</code> that swaps elements at positions i and j.",
            "functionSignature": "func swapAt(nums []int, i, j int)",
            "testCases": [
              {
                "input": "[]int{1, 2, 3, 4}, 0, 2",
                "output": "[3, 2, 1, 4]"
              },
              {
                "input": "[]int{5, 10, 15}, 1, 2",
                "output": "[5, 15, 10]"
              }
            ],
            "hints": [
              {
                "title": "\ud83e\udd14 Think about it",
                "content": "Just swap the elements at the given indices."
              },
              {
                "title": "\ud83d\udca1 Hint",
                "content": "nums[i], nums[j] = nums[j], nums[i]"
              },
              {
                "title": "\ud83d\udd27 Pattern",
                "content": "<pre>nums[i], nums[j] = nums[j], nums[i]</pre>"
              }
            ],
            "solution": "func swapAt(nums []int, i, j int) {\n    nums[i], nums[j] = nums[j], nums[i]\n}",
            "difficulty": 1
          },
          {
            "id": "v5",
            "title": "Swap String Parts",
            "description": "Write <code>func swapStrings(a, b string) (string, string)</code> that swaps two strings.",
            "functionSignature": "func swapStrings(a, b string) (string, string)",
            "testCases": [
              {
                "input": "\"hello\", \"world\"",
                "output": "\"world\", \"hello\""
              },
              {
                "input": "\"go\", \"rust\"",
                "output": "\"rust\", \"go\""
              }
            ],
            "hints": [
              {
                "title": "\ud83e\udd14 Think about it",
                "content": "Same as swapping ints - just return in opposite order."
              },
              {
                "title": "\ud83d\udca1 Hint",
                "content": "return b, a"
              },
              {
                "title": "\ud83d\udd27 Pattern",
                "content": "<pre>return b, a</pre>"
              }
            ],
            "solution": "func swapStrings(a, b string) (string, string) {\n    return b, a\n}",
            "difficulty": 2
          },
          {
            "id": "v6",
            "title": "Conditional Swap",
            "description": "Write <code>func swapIfGreater(a, b int) (int, int)</code> that swaps only if a > b, ensuring smaller comes first.",
            "functionSignature": "func swapIfGreater(a, b int) (int, int)",
            "testCases": [
              {
                "input": "5, 2",
                "output": "2, 5",
                "note": "5 > 2, so swap"
              },
              {
                "input": "3, 7",
                "output": "3, 7",
                "note": "3 < 7, no swap"
              }
            ],
            "hints": [
              {
                "title": "\ud83e\udd14 Think about it",
                "content": "Check if a > b. If so, swap. Else, leave as-is."
              },
              {
                "title": "\ud83d\udca1 Hint",
                "content": "if a > b { return b, a } else { return a, b }"
              },
              {
                "title": "\ud83d\udd27 Pattern",
                "content": "<pre>if a > b {\n    return b, a\n}\nreturn a, b</pre>"
              }
            ],
            "solution": "func swapIfGreater(a, b int) (int, int) {\n    if a > b {\n        return b, a\n    }\n    return a, b\n}",
            "difficulty": 2
          },
          {
            "id": "v7",
            "title": "Swap Pairs",
            "description": "Write <code>func swapPairs(nums []int)</code> that swaps adjacent pairs (0\u21941, 2\u21943, etc). Assume even length.",
            "functionSignature": "func swapPairs(nums []int)",
            "testCases": [
              {
                "input": "[]int{1, 2, 3, 4}",
                "output": "[2, 1, 4, 3]"
              },
              {
                "input": "[]int{5, 10, 15, 20}",
                "output": "[10, 5, 20, 15]"
              }
            ],
            "hints": [
              {
                "title": "\ud83e\udd14 Think about it",
                "content": "Loop with step size 2, swapping nums[i] with nums[i+1]."
              },
              {
                "title": "\ud83d\udca1 Hint",
                "content": "for i := 0; i < len(nums); i += 2 { swap nums[i] and nums[i+1] }"
              },
              {
                "title": "\ud83d\udd27 Pattern",
                "content": "<pre>1. For i = 0, 2, 4, ... (step 2):\n   - Swap nums[i] \u2194 nums[i+1]\n2. Done</pre>"
              }
            ],
            "solution": "func swapPairs(nums []int) {\n    for i := 0; i < len(nums); i += 2 {\n        nums[i], nums[i+1] = nums[i+1], nums[i]\n    }\n}",
            "difficulty": 2
          },
          {
            "id": "v8",
            "title": "Rotate Three",
            "description": "Write <code>func rotateThree(a, b, c int) (int, int, int)</code> that rotates values: a\u2192b, b\u2192c, c\u2192a.",
            "functionSignature": "func rotateThree(a, b, c int) (int, int, int)",
            "testCases": [
              {
                "input": "1, 2, 3",
                "output": "3, 1, 2"
              },
              {
                "input": "10, 20, 30",
                "output": "30, 10, 20"
              }
            ],
            "hints": [
              {
                "title": "\ud83e\udd14 Think about it",
                "content": "This is a circular rotation. Use simultaneous assignment."
              },
              {
                "title": "\ud83d\udca1 Hint",
                "content": "The pattern is: return c, a, b"
              },
              {
                "title": "\ud83d\udd27 Pattern",
                "content": "<pre>return c, a, b</pre>"
              }
            ],
            "solution": "func rotateThree(a, b, c int) (int, int, int) {\n    return c, a, b\n}",
            "difficulty": 2
          },
          {
            "id": "v9",
            "title": "Swap Min and Max",
            "description": "Write <code>func swapMinMax(nums []int)</code> that swaps the positions of minimum and maximum values.",
            "functionSignature": "func swapMinMax(nums []int)",
            "testCases": [
              {
                "input": "[]int{3, 1, 4, 9, 2}",
                "output": "[3, 9, 4, 1, 2]",
                "note": "min=1 at idx 1, max=9 at idx 3"
              },
              {
                "input": "[]int{5, 2, 8, 2}",
                "output": "[5, 8, 2, 2]",
                "note": "first occurrence of min"
              }
            ],
            "hints": [
              {
                "title": "\ud83e\udd14 Think about it",
                "content": "First find indices of min and max values, then swap elements at those indices."
              },
              {
                "title": "\ud83d\udca1 Hint",
                "content": "Loop twice: once to find minIdx and maxIdx, then swap nums[minIdx] with nums[maxIdx]."
              },
              {
                "title": "\ud83d\udd27 Pattern",
                "content": "<pre>1. Find minIdx and maxIdx\n2. Swap nums[minIdx] \u2194 nums[maxIdx]\n3. Done</pre>"
              }
            ],
            "solution": "func swapMinMax(nums []int) {\n    minIdx, maxIdx := 0, 0\n    for i := range nums {\n        if nums[i] < nums[minIdx] { minIdx = i }\n        if nums[i] > nums[maxIdx] { maxIdx = i }\n    }\n    nums[minIdx], nums[maxIdx] = nums[maxIdx], nums[minIdx]\n}",
            "difficulty": 3
          },
          {
            "id": "v10",
            "title": "Rotate Slice Left",
            "description": "Write <code>func rotateLeft(nums []int, k int) []int</code> that rotates the slice left by k positions. For example, [1,2,3,4,5] rotated left by 2 becomes [3,4,5,1,2].",
            "functionSignature": "func rotateLeft(nums []int, k int) []int",
            "testCases": [
              {
                "input": "[]int{10, 20, 30, 40}, 1",
                "output": "[20, 30, 40, 10]"
              },
              {
                "input": "[]int{1, 2, 3, 4, 5}, 2",
                "output": "[3, 4, 5, 1, 2]"
              }
            ],
            "hints": [
              {
                "title": "\ud83e\udd14 Think about it",
                "content": "Rotating left by k means taking the first k elements and moving them to the end. You can use slice operations to split and recombine."
              },
              {
                "title": "\ud83d\udca1 Hint",
                "content": "Split the slice at position k: first part is nums[:k], second part is nums[k:]. Concatenate them in reverse order: append(nums[k:], nums[:k]...)."
              },
              {
                "title": "\ud83d\udd27 Pattern",
                "content": "<pre>1. Split at k: left = nums[:k], right = nums[k:]\n2. Concatenate: result = append(right, left...)\n3. Return result</pre>"
              }
            ],
            "solution": "func rotateLeft(nums []int, k int) []int {\n    k = k % len(nums)\n    return append(nums[k:], nums[:k]...)\n}",
            "difficulty": 3
          },
          {
            "id": "v11",
            "title": "Swap All Pairs",
            "description": "Write <code>func swapAllPairs(nums []int) []int</code> that swaps every pair of adjacent elements. If the slice has odd length, the last element stays in place. For example, [1,2,3,4,5] becomes [2,1,4,3,5].",
            "functionSignature": "func swapAllPairs(nums []int) []int",
            "testCases": [
              {
                "input": "[]int{10, 20, 30, 40}",
                "output": "[20, 10, 40, 30]"
              },
              {
                "input": "[]int{1, 2, 3}",
                "output": "[2, 1, 3]",
                "note": "last element stays"
              }
            ],
            "hints": [
              {
                "title": "\ud83e\udd14 Think about it",
                "content": "Loop through pairs (i=0, 2, 4...) and swap each pair. Make sure to stop before going out of bounds on odd-length slices."
              },
              {
                "title": "\ud83d\udca1 Hint",
                "content": "Create a copy of nums. Loop with i += 2, and swap result[i] with result[i+1] if i+1 < len(result)."
              },
              {
                "title": "\ud83d\udd27 Pattern",
                "content": "<pre>1. Create copy of nums\n2. For i = 0, 2, 4, ... (step by 2):\n   - If i+1 exists:\n     \u2192 swap result[i] with result[i+1]\n3. Return result</pre>"
              }
            ],
            "solution": "func swapAllPairs(nums []int) []int {\n    result := make([]int, len(nums))\n    copy(result, nums)\n    \n    for i := 0; i < len(result)-1; i += 2 {\n        result[i], result[i+1] = result[i+1], result[i]\n    }\n    \n    return result\n}",
            "difficulty": 3
          },
          {
            "id": "v12",
            "title": "Bubble Sort One Pass",
            "description": "Write <code>func bubbleSortOnePass(nums []int) []int</code> that performs one pass of bubble sort. Compare each pair of adjacent elements and swap if they're in wrong order. This makes the largest element \"bubble\" to the end.",
            "functionSignature": "func bubbleSortOnePass(nums []int) []int",
            "testCases": [
              {
                "input": "[]int{3, 1, 4, 2}",
                "output": "[1, 3, 2, 4]",
                "note": "after one pass, 4 bubbles to end"
              },
              {
                "input": "[]int{5, 3, 8, 1}",
                "output": "[3, 5, 1, 8]"
              }
            ],
            "hints": [
              {
                "title": "\ud83e\udd14 Think about it",
                "content": "Compare each adjacent pair. If left > right, swap them. After one full pass, the largest element will be at the end."
              },
              {
                "title": "\ud83d\udca1 Hint",
                "content": "Create a copy. Loop through i from 0 to len-2. For each i, if result[i] > result[i+1], swap them."
              },
              {
                "title": "\ud83d\udd27 Pattern",
                "content": "<pre>1. Create copy of nums\n2. For i from 0 to len-2:\n   - result[i] > result[i+1]?\n     \u2192 swap them\n3. Return result</pre>"
              }
            ],
            "solution": "func bubbleSortOnePass(nums []int) []int {\n    result := make([]int, len(nums))\n    copy(result, nums)\n    \n    for i := 0; i < len(result)-1; i++ {\n        if result[i] > result[i+1] {\n            result[i], result[i+1] = result[i+1], result[i]\n        }\n    }\n    \n    return result\n}",
            "difficulty": 3
          }
        ]
      },
      {
        "id": "challenge_14",
        "block": 2,
        "difficulty": 2,
        "concept": "Element Comparison",
        "docLinks": [
          {
            "url": "https://go.dev/ref/spec#For_statements",
            "title": "Go Spec: For statements",
            "note": "iteration patterns"
          }
        ],
        "patternPrimer": {
          "bruteForce": "Compare adjacent elements or compare all to first element; early return on mismatch.",
          "bestApproach": "Same approach - single pass with comparisons is already optimal.",
          "typical": "Typically O(n) time, O(1) extra space"
        },
        "variants": [
          {
            "id": "v1",
            "title": "Are Equal",
            "description": "Write <code>func areEqual(nums []int) bool</code> that returns true if all elements are the same.",
            "functionSignature": "func areEqual(nums []int) bool",
            "testCases": [
              {
                "input": "[]int{5, 5, 5}",
                "output": "true"
              },
              {
                "input": "[]int{5, 5, 6}",
                "output": "false"
              }
            ],
            "hints": [
              {
                "title": "\ud83e\udd14 Think about it",
                "content": "If all are equal, they all equal the first element."
              },
              {
                "title": "\ud83d\udca1 Hint",
                "content": "Compare each element to nums[0]. If any differs, return false."
              },
              {
                "title": "\ud83d\udd27 Pattern",
                "content": "<pre>1. For each num:\n   - num != nums[0]? \u2192 return false\n2. Return true (all equal)</pre>"
              }
            ],
            "solution": "func areEqual(nums []int) bool {\n    for _, n := range nums {\n        if n != nums[0] { return false }\n    }\n    return true\n}",
            "difficulty": 1
          },
          {
            "id": "v2",
            "title": "Has Adjacent Equal",
            "description": "Write <code>func hasAdjacentEqual(nums []int) bool</code> - true if any two adjacent elements are equal.",
            "functionSignature": "func hasAdjacentEqual(nums []int) bool",
            "testCases": [
              {
                "input": "[]int{1, 2, 2, 3}",
                "output": "true"
              },
              {
                "input": "[]int{1, 2, 3, 4}",
                "output": "false"
              }
            ],
            "hints": [
              {
                "title": "\ud83e\udd14 Think about it",
                "content": "Loop through, comparing each element to the next one."
              },
              {
                "title": "\ud83d\udca1 Hint",
                "content": "for i := 0; i < len(nums)-1; i++ - compare nums[i] to nums[i+1]."
              },
              {
                "title": "\ud83d\udd27 Pattern",
                "content": "<pre>1. For i from 0 to len-2:\n   - nums[i] == nums[i+1]? \u2192 return true\n2. Return false</pre>"
              }
            ],
            "solution": "func hasAdjacentEqual(nums []int) bool {\n    for i := 0; i < len(nums)-1; i++ {\n        if nums[i] == nums[i+1] { return true }\n    }\n    return false\n}",
            "difficulty": 2
          },
          {
            "id": "v3",
            "title": "Is Increasing",
            "description": "Write <code>func isIncreasing(nums []int) bool</code> - true if each element is greater than the previous.",
            "functionSignature": "func isIncreasing(nums []int) bool",
            "testCases": [
              {
                "input": "[]int{1, 2, 3, 4}",
                "output": "true"
              },
              {
                "input": "[]int{1, 3, 2, 4}",
                "output": "false"
              }
            ],
            "hints": [
              {
                "title": "\ud83e\udd14 Think about it",
                "content": "Compare adjacent elements - each should be > previous."
              },
              {
                "title": "\ud83d\udca1 Hint",
                "content": "If nums[i+1] <= nums[i], it's not strictly increasing."
              },
              {
                "title": "\ud83d\udd27 Pattern",
                "content": "<pre>1. For i from 0 to len-2:\n   - nums[i+1] <= nums[i]? \u2192 return false\n2. Return true</pre>"
              }
            ],
            "solution": "func isIncreasing(nums []int) bool {\n    for i := 0; i < len(nums)-1; i++ {\n        if nums[i+1] <= nums[i] { return false }\n    }\n    return true\n}",
            "difficulty": 2
          },
          {
            "id": "v4",
            "title": "First Greater Index",
            "description": "Write <code>func firstGreater(nums []int, threshold int) int</code> - index of first element > threshold, or -1.",
            "functionSignature": "func firstGreater(nums []int, threshold int) int",
            "testCases": [
              {
                "input": "[]int{1, 3, 5, 7}, 4",
                "output": "2",
                "note": "5 is first > 4"
              },
              {
                "input": "[]int{1, 2, 3}, 10",
                "output": "-1"
              }
            ],
            "hints": [
              {
                "title": "\ud83e\udd14 Think about it",
                "content": "Loop through with index, return index when you find one > threshold."
              },
              {
                "title": "\ud83d\udca1 Hint",
                "content": "for i, n := range nums - if n > threshold return i."
              },
              {
                "title": "\ud83d\udd27 Pattern",
                "content": "<pre>1. For i, num:\n   - num > threshold? \u2192 return i\n2. Return -1</pre>"
              }
            ],
            "solution": "func firstGreater(nums []int, threshold int) int {\n    for i, n := range nums {\n        if n > threshold { return i }\n    }\n    return -1\n}",
            "difficulty": 2
          },
          {
            "id": "v5",
            "title": "Starts With Same",
            "description": "Write <code>func startsWithSame(nums []int, k int) bool</code> - true if first k elements are all equal.",
            "functionSignature": "func startsWithSame(nums []int, k int) bool",
            "testCases": [
              {
                "input": "[]int{5, 5, 5, 7}, 3",
                "output": "true"
              },
              {
                "input": "[]int{5, 5, 6, 7}, 3",
                "output": "false"
              }
            ],
            "hints": [
              {
                "title": "\ud83e\udd14 Think about it",
                "content": "Check if first k elements all equal nums[0]."
              },
              {
                "title": "\ud83d\udca1 Hint",
                "content": "Loop i from 0 to k-1, compare nums[i] to nums[0]."
              },
              {
                "title": "\ud83d\udd27 Pattern",
                "content": "<pre>1. For i from 0 to k-1:\n   - nums[i] != nums[0]? \u2192 return false\n2. Return true</pre>"
              }
            ],
            "solution": "func startsWithSame(nums []int, k int) bool {\n    for i := 0; i < k; i++ {\n        if nums[i] != nums[0] { return false }\n    }\n    return true\n}",
            "difficulty": 1
          },
          {
            "id": "v6",
            "title": "Longest Streak of Value",
            "description": "Write <code>func longestStreak(nums []int, target int) int</code> - length of longest consecutive run of target.",
            "functionSignature": "func longestStreak(nums []int, target int) int",
            "testCases": [
              {
                "input": "[]int{1, 2, 2, 2, 1, 2, 2}, 2",
                "output": "3",
                "note": "three 2's in a row"
              },
              {
                "input": "[]int{1, 1, 3, 1}, 1",
                "output": "2"
              }
            ],
            "hints": [
              {
                "title": "\ud83e\udd14 Think about it",
                "content": "Track current streak and max streak. When you see target, increment current. When you don't, reset current."
              },
              {
                "title": "\ud83d\udca1 Hint",
                "content": "Keep current and max variables. Update max whenever current > max."
              },
              {
                "title": "\ud83d\udd27 Pattern",
                "content": "<pre>1. current, max := 0, 0\n2. For each num:\n   - num == target? \u2192 current++, update max\n   - else \u2192 current = 0\n3. Return max</pre>"
              }
            ],
            "solution": "func longestStreak(nums []int, target int) int {\n    current, max := 0, 0\n    for _, n := range nums {\n        if n == target {\n            current++\n            if current > max { max = current }\n        } else {\n            current = 0\n        }\n    }\n    return max\n}",
            "difficulty": 3
          },
          {
            "id": "v7",
            "title": "All Positive",
            "description": "Write <code>func allPositive(nums []int) bool</code> that returns true if all numbers are greater than 0.",
            "functionSignature": "func allPositive(nums []int) bool",
            "testCases": [
              {
                "input": "[]int{1, 5, 10, 3}",
                "output": "true"
              },
              {
                "input": "[]int{1, 0, 5}",
                "output": "false"
              }
            ],
            "hints": [
              {
                "title": "\ud83e\udd14 Think about it",
                "content": "Check each number. If any is <= 0, return false immediately."
              },
              {
                "title": "\ud83d\udca1 Hint",
                "content": "Early return pattern: as soon as you find non-positive, return false."
              },
              {
                "title": "\ud83d\udd27 Pattern",
                "content": "<pre>1. For each num:\n   - num <= 0? \u2192 return false\n2. Return true</pre>"
              }
            ],
            "solution": "func allPositive(nums []int) bool {\n    for _, n := range nums {\n        if n <= 0 { return false }\n    }\n    return true\n}",
            "difficulty": 1
          },
          {
            "id": "v8",
            "title": "Price Drop Count",
            "description": "Write <code>func priceDrops(prices []float64) int</code> that counts how many times price decreased from one day to next.",
            "functionSignature": "func priceDrops(prices []float64) int",
            "testCases": [
              {
                "input": "[]float64{100.0, 95.0, 97.0, 90.0}",
                "output": "2",
                "note": "100\u219295 and 97\u219290"
              },
              {
                "input": "[]float64{50.0, 55.0, 60.0}",
                "output": "0"
              }
            ],
            "hints": [
              {
                "title": "\ud83e\udd14 Think about it",
                "content": "Compare adjacent prices. Count when prices[i+1] < prices[i]."
              },
              {
                "title": "\ud83d\udca1 Hint",
                "content": "Loop through indices, increment counter when next price is lower than current."
              },
              {
                "title": "\ud83d\udd27 Pattern",
                "content": "<pre>1. count := 0\n2. For i from 0 to len-2:\n   - prices[i+1] < prices[i]? \u2192 count++\n3. Return count</pre>"
              }
            ],
            "solution": "func priceDrops(prices []float64) int {\n    count := 0\n    for i := 0; i < len(prices)-1; i++ {\n        if prices[i+1] < prices[i] { count++ }\n    }\n    return count\n}",
            "difficulty": 2
          },
          {
            "id": "v9",
            "title": "Length Matches Position",
            "description": "Write <code>func lengthMatchesPos(words []string) bool</code> - true if each word's length equals its position+1.",
            "functionSignature": "func lengthMatchesPos(words []string) bool",
            "testCases": [
              {
                "input": "[]string{\"a\", \"hi\", \"cat\", \"dogs\"}",
                "output": "true",
                "note": "lengths: 1,2,3,4"
              },
              {
                "input": "[]string{\"a\", \"ab\", \"abc\"}",
                "output": "false",
                "note": "position 1: \"ab\" has length 2, needs 2 \u2713; position 2: \"abc\" has length 3, needs 3 \u2713... wait this should be true!"
              }
            ],
            "hints": [
              {
                "title": "\ud83e\udd14 Think about it",
                "content": "For each word at index i, check if len(word) == i+1."
              },
              {
                "title": "\ud83d\udca1 Hint",
                "content": "Loop with index: if len(words[i]) != i+1, return false."
              },
              {
                "title": "\ud83d\udd27 Pattern",
                "content": "<pre>1. For i, word:\n   - len(word) != i+1? \u2192 return false\n2. Return true</pre>"
              }
            ],
            "solution": "func lengthMatchesPos(words []string) bool {\n    for i, word := range words {\n        if len(word) != i+1 { return false }\n    }\n    return true\n}",
            "difficulty": 2
          },
          {
            "id": "v10",
            "title": "Find All Peaks",
            "description": "Write <code>func findAllPeaks(nums []int) []int</code> that returns the indices where an element is greater than both its neighbors. First and last elements cannot be peaks.",
            "functionSignature": "func findAllPeaks(nums []int) []int",
            "testCases": [
              {
                "input": "[]int{1, 3, 2, 4, 1}",
                "output": "[1, 3]",
                "note": "nums[1]=3 > neighbors (1,2); nums[3]=4 > neighbors (2,1)"
              },
              {
                "input": "[]int{1, 2, 3, 4}",
                "output": "[]",
                "note": "monotonic increasing, no peaks"
              }
            ],
            "hints": [
              {
                "title": "\ud83e\udd14 Think about it",
                "content": "A peak is at index i where nums[i] > nums[i-1] AND nums[i] > nums[i+1]. Loop from index 1 to len-2 (excluding first and last)."
              },
              {
                "title": "\ud83d\udca1 Hint",
                "content": "Create empty result slice. Loop i from 1 to len(nums)-2. If nums[i] > nums[i-1] && nums[i] > nums[i+1], append i to result."
              },
              {
                "title": "\ud83d\udd27 Pattern",
                "content": "<pre>1. result := []int{}\n2. For i from 1 to len-2:\n   - nums[i] > both neighbors?\n     \u2192 append i to result\n3. Return result</pre>"
              }
            ],
            "solution": "func findAllPeaks(nums []int) []int {\n    result := []int{}\n    \n    for i := 1; i < len(nums)-1; i++ {\n        if nums[i] > nums[i-1] && nums[i] > nums[i+1] {\n            result = append(result, i)\n        }\n    }\n    \n    return result\n}",
            "difficulty": 3
          },
          {
            "id": "v11",
            "title": "Longest Increasing Sequence",
            "description": "Write <code>func longestIncreasingLength(nums []int) int</code> that finds the length of the longest consecutive increasing subsequence.",
            "functionSignature": "func longestIncreasingLength(nums []int) int",
            "testCases": [
              {
                "input": "[]int{1, 2, 3, 1, 2, 3, 4, 5}",
                "output": "5",
                "note": "sequence 1,2,3,4,5 at end"
              },
              {
                "input": "[]int{5, 4, 3, 2, 1}",
                "output": "1",
                "note": "all decreasing, max streak is 1"
              }
            ],
            "hints": [
              {
                "title": "\ud83e\udd14 Think about it",
                "content": "Track the current streak length and the maximum streak seen so far. When nums[i] > nums[i-1], increment streak. Otherwise, reset streak to 1."
              },
              {
                "title": "\ud83d\udca1 Hint",
                "content": "currentStreak := 1, maxStreak := 1. For each i from 1 to end: if nums[i] > nums[i-1], currentStreak++, else currentStreak = 1. Update maxStreak if currentStreak is larger."
              },
              {
                "title": "\ud83d\udd27 Pattern",
                "content": "<pre>1. currentStreak = 1, maxStreak = 1\n2. For i from 1 to len:\n   - Increasing? \u2192 currentStreak++\n   - Not? \u2192 currentStreak = 1\n   - Update maxStreak\n3. Return maxStreak</pre>"
              }
            ],
            "solution": "func longestIncreasingLength(nums []int) int {\n    if len(nums) == 0 { return 0 }\n    \n    currentStreak := 1\n    maxStreak := 1\n    \n    for i := 1; i < len(nums); i++ {\n        if nums[i] > nums[i-1] {\n            currentStreak++\n            if currentStreak > maxStreak {\n                maxStreak = currentStreak\n            }\n        } else {\n            currentStreak = 1\n        }\n    }\n    \n    return maxStreak\n}",
            "difficulty": 3
          },
          {
            "id": "v12",
            "title": "Count Direction Changes",
            "description": "Write <code>func countDirectionChanges(nums []int) int</code> that counts how many times the sequence changes from increasing to decreasing or vice versa.",
            "functionSignature": "func countDirectionChanges(nums []int) int",
            "testCases": [
              {
                "input": "[]int{1, 3, 2, 4, 3}",
                "output": "3",
                "note": "up(1\u21923), down(3\u21922), up(2\u21924), down(4\u21923) = 3 changes"
              },
              {
                "input": "[]int{1, 2, 3}",
                "output": "0",
                "note": "monotonic increasing, no direction changes"
              }
            ],
            "hints": [
              {
                "title": "\ud83e\udd14 Think about it",
                "content": "Track whether you're currently going up or down. When the direction switches, increment the change counter."
              },
              {
                "title": "\ud83d\udca1 Hint",
                "content": "Start with direction based on first two elements. For each next element, determine new direction. If it differs from previous direction, count a change."
              },
              {
                "title": "\ud83d\udd27 Pattern",
                "content": "<pre>1. Determine initial direction\n2. changes := 0\n3. For each next pair:\n   - Determine new direction\n   - Different from previous? \u2192 changes++\n   - Update previous direction\n4. Return changes</pre>"
              }
            ],
            "solution": "func countDirectionChanges(nums []int) int {\n    if len(nums) < 2 { return 0 }\n    \n    changes := 0\n    var prevDirection string\n    \n    for i := 1; i < len(nums); i++ {\n        var currentDirection string\n        if nums[i] > nums[i-1] {\n            currentDirection = \"up\"\n        } else if nums[i] < nums[i-1] {\n            currentDirection = \"down\"\n        } else {\n            continue\n        }\n        \n        if prevDirection != \"\" && currentDirection != prevDirection {\n            changes++\n        }\n        prevDirection = currentDirection\n    }\n    \n    return changes\n}",
            "difficulty": 3
          }
        ]
      }
    ],
    "advanced": [
      {
        "id": "advanced_1",
        "difficulty": 5,
        "baseTitle": "Map as Set",
        "concept": "Map as Set - Have I Seen This?",
        "variants": [
          {
            "id": "v1",
            "title": "Contains Duplicate",
            "description": "Write a function <code>func containsDuplicate(nums []int) bool</code> that returns <code>true</code> if any number appears more than once in the slice, <code>false</code> if all numbers are unique.",
            "functionSignature": "func containsDuplicate(nums []int) bool",
            "testCases": [
              {
                "input": "[]int{1, 2, 3, 1}",
                "output": "true"
              },
              {
                "input": "[]int{1, 2, 3, 4}",
                "output": "false"
              },
              {
                "input": "[]int{1, 1, 1, 1}",
                "output": "true"
              }
            ],
            "solution": "func containsDuplicate(nums []int) bool {\n    seen := make(map[int]bool)\n    for _, num := range nums {\n        if seen[num] {\n            return true\n        }\n        seen[num] = true\n    }\n    return false\n}"
          },
          {
            "id": "v2",
            "title": "First Duplicate Value",
            "description": "Write a function <code>func firstDuplicate(nums []int) int</code> that returns the first number that appears twice (the second occurrence). Return <code>-1</code> if no duplicates exist.",
            "functionSignature": "func firstDuplicate(nums []int) int",
            "testCases": [
              {
                "input": "[]int{2, 1, 3, 5, 3, 2}",
                "output": "3",
                "note": "3 is seen again before 2 is"
              },
              {
                "input": "[]int{1, 2, 3, 4}",
                "output": "-1"
              },
              {
                "input": "[]int{1, 1, 2, 2}",
                "output": "1"
              }
            ],
            "solution": "func firstDuplicate(nums []int) int {\n    seen := make(map[int]bool)\n    for _, num := range nums {\n        if seen[num] {\n            return num\n        }\n        seen[num] = true\n    }\n    return -1\n}",
            "solutionNotes": "Unlike Contains Duplicate which returns a bool, this returns the actual duplicate value. Same pattern, different return type!"
          },
          {
            "id": "v3",
            "title": "Count Unique Elements",
            "description": "Write a function <code>func countUnique(nums []int) int</code> that returns how many distinct values are in the slice.",
            "functionSignature": "func countUnique(nums []int) int",
            "testCases": [
              {
                "input": "[]int{1, 2, 2, 3, 3, 3}",
                "output": "3",
                "note": "unique values: 1, 2, 3"
              },
              {
                "input": "[]int{5, 5, 5, 5}",
                "output": "1"
              },
              {
                "input": "[]int{1, 2, 3, 4, 5}",
                "output": "5"
              }
            ],
            "solution": "func countUnique(nums []int) int {\n    seen := make(map[int]bool)\n    for _, num := range nums {\n        seen[num] = true\n    }\n    return len(seen)\n}",
            "solutionNotes": "Here we don't check if seen - we just add everything. The map handles duplicates automatically, and <code>len(seen)</code> gives us the count of unique keys!"
          },
          {
            "id": "v4",
            "title": "Find All Duplicates",
            "description": "Write a function <code>func findDuplicates(nums []int) []int</code> that returns a slice containing each number that appears more than once. Each duplicate should only appear once in the result.",
            "functionSignature": "func findDuplicates(nums []int) []int",
            "testCases": [
              {
                "input": "[]int{4, 3, 2, 7, 8, 2, 3, 1}",
                "output": "[2, 3]"
              },
              {
                "input": "[]int{1, 1, 2, 2, 3, 3}",
                "output": "[1, 2, 3]"
              },
              {
                "input": "[]int{1, 2, 3}",
                "output": "[]"
              }
            ],
            "solution": "func findDuplicates(nums []int) []int {\n    seen := make(map[int]bool)\n    added := make(map[int]bool)\n    result := []int{}\n    \n    for _, num := range nums {\n        if seen[num] && !added[num] {\n            result = append(result, num)\n            added[num] = true\n        }\n        seen[num] = true\n    }\n    return result\n}",
            "solutionNotes": "We need TWO maps here: one to track what we've seen, and one to avoid adding the same duplicate twice to the result."
          },
          {
            "id": "v5",
            "title": "Common Elements",
            "description": "Write a function <code>func hasCommon(a, b []int) bool</code> that returns <code>true</code> if the two slices share at least one common element.",
            "functionSignature": "func hasCommon(a, b []int) bool",
            "testCases": [
              {
                "input": "[]int{1, 2, 3}, []int{3, 4, 5}",
                "output": "true",
                "note": "3 is common"
              },
              {
                "input": "[]int{1, 2}, []int{3, 4}",
                "output": "false"
              },
              {
                "input": "[]int{1}, []int{1}",
                "output": "true"
              }
            ],
            "solution": "func hasCommon(a, b []int) bool {\n    setA := make(map[int]bool)\n    for _, num := range a {\n        setA[num] = true\n    }\n    \n    for _, num := range b {\n        if setA[num] {\n            return true\n        }\n    }\n    return false\n}",
            "solutionNotes": "Build a set from the first slice, then check if any element from the second slice exists in it. This is O(n+m) instead of O(n*m)!"
          },
          {
            "id": "v6",
            "title": "Find Intersection",
            "description": "Write a function <code>func intersection(a, b []int) []int</code> that returns a slice of elements that appear in both input slices. Each element should appear only once in the result.",
            "functionSignature": "func intersection(a, b []int) []int",
            "testCases": [
              {
                "input": "[]int{1, 2, 2, 1}, []int{2, 2}",
                "output": "[2]"
              },
              {
                "input": "[]int{4, 9, 5}, []int{9, 4, 9, 8, 4}",
                "output": "[9, 4]",
                "note": "or [4, 9] - order doesn't matter"
              },
              {
                "input": "[]int{1, 2}, []int{3, 4}",
                "output": "[]"
              }
            ],
            "solution": "func intersection(a, b []int) []int {\n    setA := make(map[int]bool)\n    for _, num := range a {\n        setA[num] = true\n    }\n    \n    result := []int{}\n    seen := make(map[int]bool)\n    for _, num := range b {\n        if setA[num] && !seen[num] {\n            result = append(result, num)\n            seen[num] = true\n        }\n    }\n    return result\n}",
            "solutionNotes": "Similar to hasCommon, but we collect the common elements instead of just returning true. We use a second map to avoid adding duplicates to the result."
          }
        ]
      },
      {
        "id": "advanced_2",
        "difficulty": 5,
        "baseTitle": "Two-Pointer In-Place",
        "concept": "Slow/Fast Pointer Pattern",
        "variants": [
          {
            "id": "v1",
            "title": "Remove Duplicates from Sorted Array",
            "description": "Write a function <code>func removeDuplicates(nums []int) int</code> that removes duplicates from a sorted slice <strong>in-place</strong>. Return the number of unique elements. The first k elements should contain the unique values.",
            "functionSignature": "func removeDuplicates(nums []int) int",
            "testCases": [
              {
                "input": "[]int{1, 1, 2}",
                "output": "2",
                "note": "array becomes [1, 2, _]"
              },
              {
                "input": "[]int{0, 0, 1, 1, 2, 2, 3}",
                "output": "4",
                "note": "array becomes [0, 1, 2, 3, _, _, _]"
              },
              {
                "input": "[]int{1, 2, 3}",
                "output": "3"
              }
            ],
            "solution": "func removeDuplicates(nums []int) int {\n    if len(nums) == 0 {\n        return 0\n    }\n    slow := 0\n    for fast := 1; fast < len(nums); fast++ {\n        if nums[fast] != nums[slow] {\n            slow++\n            nums[slow] = nums[fast]\n        }\n    }\n    return slow + 1\n}"
          },
          {
            "id": "v2",
            "title": "Remove Element",
            "description": "Write a function <code>func removeElement(nums []int, val int) int</code> that removes all occurrences of <code>val</code> <strong>in-place</strong>. Return the number of elements remaining. Order doesn't need to be preserved.",
            "functionSignature": "func removeElement(nums []int, val int) int",
            "testCases": [
              {
                "input": "[]int{3, 2, 2, 3}, 3",
                "output": "2",
                "note": "array becomes [2, 2, _, _]"
              },
              {
                "input": "[]int{0, 1, 2, 2, 3, 0, 4, 2}, 2",
                "output": "5"
              },
              {
                "input": "[]int{1}, 1",
                "output": "0"
              }
            ],
            "solution": "func removeElement(nums []int, val int) int {\n    slow := 0\n    for fast := 0; fast < len(nums); fast++ {\n        if nums[fast] != val {\n            nums[slow] = nums[fast]\n            slow++\n        }\n    }\n    return slow\n}",
            "solutionNotes": "Unlike Remove Duplicates, here we compare against a fixed value, not the previous element. And both pointers start at 0."
          },
          {
            "id": "v3",
            "title": "Move Zeroes",
            "description": "Write a function <code>func moveZeroes(nums []int)</code> that moves all <code>0</code>s to the end of the slice while maintaining the relative order of non-zero elements. Modify in-place.",
            "functionSignature": "func moveZeroes(nums []int)",
            "testCases": [
              {
                "input": "[]int{0, 1, 0, 3, 12}",
                "output": "[1, 3, 12, 0, 0]"
              },
              {
                "input": "[]int{0, 0, 1}",
                "output": "[1, 0, 0]"
              },
              {
                "input": "[]int{1, 2, 3}",
                "output": "[1, 2, 3]",
                "note": "no zeroes"
              }
            ],
            "solution": "func moveZeroes(nums []int) {\n    slow := 0\n    \n    for fast := 0; fast < len(nums); fast++ {\n        if nums[fast] != 0 {\n            nums[slow] = nums[fast]\n            slow++\n        }\n    }\n    \n    for i := slow; i < len(nums); i++ {\n        nums[i] = 0\n    }\n}",
            "solutionNotes": "This is a two-pass solution. First pass moves non-zeroes forward, second pass fills remaining positions with zeroes. Can also be done in one pass with swapping!"
          },
          {
            "id": "v4",
            "title": "Remove Duplicates II (Allow 2)",
            "description": "Write a function <code>func removeDuplicatesII(nums []int) int</code> that removes duplicates from a sorted array such that each element appears <strong>at most twice</strong>. Return the new length.",
            "functionSignature": "func removeDuplicatesII(nums []int) int",
            "testCases": [
              {
                "input": "[]int{1, 1, 1, 2, 2, 3}",
                "output": "5",
                "note": "becomes [1, 1, 2, 2, 3, _]"
              },
              {
                "input": "[]int{0, 0, 1, 1, 1, 1, 2, 3, 3}",
                "output": "7"
              },
              {
                "input": "[]int{1, 1}",
                "output": "2"
              }
            ],
            "solution": "func removeDuplicatesII(nums []int) int {\n    if len(nums) <= 2 {\n        return len(nums)\n    }\n    \n    slow := 2\n    for fast := 2; fast < len(nums); fast++ {\n        if nums[fast] != nums[slow-2] {\n            nums[slow] = nums[fast]\n            slow++\n        }\n    }\n    return slow\n}",
            "solutionNotes": "The key insight: compare with nums[slow-2], not nums[slow-1]. This ensures at most 2 of each value. Start both pointers at index 2."
          },
          {
            "id": "v5",
            "title": "Sorted Squares",
            "description": "Write a function <code>func sortedSquares(nums []int) []int</code> that returns an array of the squares of each number, sorted in ascending order. Input is sorted but may contain negatives.",
            "functionSignature": "func sortedSquares(nums []int) []int",
            "testCases": [
              {
                "input": "[]int{-4, -1, 0, 3, 10}",
                "output": "[0, 1, 9, 16, 100]"
              },
              {
                "input": "[]int{-7, -3, 2, 3, 11}",
                "output": "[4, 9, 9, 49, 121]"
              },
              {
                "input": "[]int{1, 2, 3}",
                "output": "[1, 4, 9]"
              }
            ],
            "solution": "func sortedSquares(nums []int) []int {\n    n := len(nums)\n    result := make([]int, n)\n    left, right := 0, n-1\n    pos := n - 1\n    \n    for left <= right {\n        leftSq := nums[left] * nums[left]\n        rightSq := nums[right] * nums[right]\n        \n        if leftSq > rightSq {\n            result[pos] = leftSq\n            left++\n        } else {\n            result[pos] = rightSq\n            right--\n        }\n        pos--\n    }\n    return result\n}",
            "solutionNotes": "This uses two pointers from OPPOSITE ENDS (not slow/fast). The largest squares are at the edges (most negative or most positive). Fill result array from the back."
          },
          {
            "id": "v6",
            "title": "Merge Sorted Array",
            "description": "Write a function <code>func merge(nums1 []int, m int, nums2 []int, n int)</code> that merges nums2 into nums1 <strong>in-place</strong>. nums1 has length m+n, with the last n elements being 0 (placeholders).",
            "functionSignature": "func merge(nums1 []int, m int, nums2 []int, n int)",
            "testCases": [
              {
                "input": "[]int{1, 2, 3, 0, 0, 0}, 3, []int{2, 5, 6}, 3",
                "output": "[1, 2, 2, 3, 5, 6]"
              },
              {
                "input": "[]int{1}, 1, []int{}, 0",
                "output": "[1]"
              },
              {
                "input": "[]int{0}, 0, []int{1}, 1",
                "output": "[1]"
              }
            ],
            "solution": "func merge(nums1 []int, m int, nums2 []int, n int) {\n    p1 := m - 1\n    p2 := n - 1\n    pos := m + n - 1\n    \n    for p2 >= 0 {\n        if p1 >= 0 && nums1[p1] > nums2[p2] {\n            nums1[pos] = nums1[p1]\n            p1--\n        } else {\n            nums1[pos] = nums2[p2]\n            p2--\n        }\n        pos--\n    }\n}",
            "solutionNotes": "Work BACKWARDS to avoid overwriting elements we haven't processed. The loop continues until all of nums2 is merged. If nums1 elements remain, they're already in place."
          }
        ]
      },
      {
        "id": "advanced_3",
        "difficulty": 5,
        "baseTitle": "String Manipulation",
        "concept": "Runes + Two-Pointer Swap",
        "variants": [
          {
            "id": "v1",
            "title": "Reverse a String",
            "description": "Write <code>func reverse(s string) string</code> that reverses any string, including Unicode characters like emojis.",
            "functionSignature": "func reverse(s string) string",
            "testCases": [
              {
                "input": "\"hello\"",
                "output": "\"olleh\""
              },
              {
                "input": "\"\u4e16\u754c\"",
                "output": "\"\u754c\u4e16\""
              },
              {
                "input": "\"Go\ud83d\ude80\"",
                "output": "\"\ud83d\ude80oG\""
              }
            ],
            "solution": "func reverse(s string) string {\n    runes := []rune(s)\n    for i, j := 0, len(runes)-1; i < j; i, j = i+1, j-1 {\n        runes[i], runes[j] = runes[j], runes[i]\n    }\n    return string(runes)\n}"
          },
          {
            "id": "v2",
            "title": "Is Palindrome",
            "description": "Write <code>func isPalindrome(s string) bool</code> that checks if a string reads the same forwards and backwards. Consider only alphanumeric characters and ignore case.",
            "functionSignature": "func isPalindrome(s string) bool",
            "testCases": [
              {
                "input": "\"A man, a plan, a canal: Panama\"",
                "output": "true"
              },
              {
                "input": "\"race a car\"",
                "output": "false"
              },
              {
                "input": "\"Was it a car or a cat I saw?\"",
                "output": "true"
              }
            ],
            "solution": "import \"unicode\"\n\nfunc isPalindrome(s string) bool {\n    runes := []rune{}\n    for _, r := range s {\n        if unicode.IsLetter(r) || unicode.IsDigit(r) {\n            runes = append(runes, unicode.ToLower(r))\n        }\n    }\n    \n    for i, j := 0, len(runes)-1; i < j; i, j = i+1, j-1 {\n        if runes[i] != runes[j] {\n            return false\n        }\n    }\n    return true\n}",
            "solutionNotes": "First filter to only alphanumeric and lowercase, then use two-pointer comparison. The <code>unicode</code> package helps with character classification."
          },
          {
            "id": "v3",
            "title": "Reverse Words in String",
            "description": "Write <code>func reverseWords(s string) string</code> that reverses the order of words (not characters). Words are separated by spaces.",
            "functionSignature": "func reverseWords(s string) string",
            "testCases": [
              {
                "input": "\"hello world\"",
                "output": "\"world hello\""
              },
              {
                "input": "\"the sky is blue\"",
                "output": "\"blue is sky the\""
              },
              {
                "input": "\"Go\"",
                "output": "\"Go\""
              }
            ],
            "solution": "import \"strings\"\n\nfunc reverseWords(s string) string {\n    words := strings.Fields(s)\n    \n    for i, j := 0, len(words)-1; i < j; i, j = i+1, j-1 {\n        words[i], words[j] = words[j], words[i]\n    }\n    \n    return strings.Join(words, \" \")\n}",
            "solutionNotes": "Use <code>strings.Fields</code> to split by whitespace, reverse the slice of words, then <code>strings.Join</code> back together."
          },
          {
            "id": "v4",
            "title": "Reverse Only Letters",
            "description": "Write <code>func reverseOnlyLetters(s string) string</code> that reverses only the letters in a string. All other characters stay in their original positions.",
            "functionSignature": "func reverseOnlyLetters(s string) string",
            "testCases": [
              {
                "input": "\"a-bC-dEf-ghIj\"",
                "output": "\"j-Ih-gfE-dCba\""
              },
              {
                "input": "\"ab-cd\"",
                "output": "\"dc-ba\""
              },
              {
                "input": "\"Test1ng-Leet=code-Q!\"",
                "output": "\"Qedo1teleC-test=gnin-T!\"",
                "note": "wait that's wrong"
              }
            ],
            "solution": "import \"unicode\"\n\nfunc reverseOnlyLetters(s string) string {\n    runes := []rune(s)\n    i, j := 0, len(runes)-1\n    \n    for i < j {\n        for i < j && !unicode.IsLetter(runes[i]) {\n            i++\n        }\n        for i < j && !unicode.IsLetter(runes[j]) {\n            j--\n        }\n        if i < j {\n            runes[i], runes[j] = runes[j], runes[i]\n            i++\n            j--\n        }\n    }\n    return string(runes)\n}",
            "solutionNotes": "Two pointers that skip non-letters. Only swap when both pointers are on letters. This is a variation of the standard reverse with added skip logic."
          },
          {
            "id": "v5",
            "title": "Valid Palindrome II",
            "description": "Write <code>func validPalindromeII(s string) bool</code> that returns true if the string can become a palindrome by removing <strong>at most one</strong> character.",
            "functionSignature": "func validPalindromeII(s string) bool",
            "testCases": [
              {
                "input": "\"aba\"",
                "output": "true",
                "note": "already palindrome"
              },
              {
                "input": "\"abca\"",
                "output": "true",
                "note": "remove 'c' or 'b'"
              },
              {
                "input": "\"abc\"",
                "output": "false"
              }
            ],
            "solution": "func validPalindromeII(s string) bool {\n    runes := []rune(s)\n    \n    isPalin := func(i, j int) bool {\n        for i < j {\n            if runes[i] != runes[j] {\n                return false\n            }\n            i++\n            j--\n        }\n        return true\n    }\n    \n    i, j := 0, len(runes)-1\n    for i < j {\n        if runes[i] != runes[j] {\n            return isPalin(i+1, j) || isPalin(i, j-1)\n        }\n        i++\n        j--\n    }\n    return true\n}",
            "solutionNotes": "When we find a mismatch, we have one chance: try skipping the left char OR the right char. If either results in a palindrome, return true."
          },
          {
            "id": "v6",
            "title": "Rotate String Left",
            "description": "Write <code>func rotateLeft(s string, k int) string</code> that rotates a string left by k positions. Characters that fall off the left reappear on the right.",
            "functionSignature": "func rotateLeft(s string, k int) string",
            "testCases": [
              {
                "input": "\"abcdef\", 2",
                "output": "\"cdefab\""
              },
              {
                "input": "\"hello\", 1",
                "output": "\"elloh\""
              },
              {
                "input": "\"Go\", 4",
                "output": "\"Go\"",
                "note": "k=4 is same as k=0 for len=2"
              }
            ],
            "solution": "func rotateLeft(s string, k int) string {\n    if len(s) == 0 {\n        return s\n    }\n    runes := []rune(s)\n    k = k % len(runes)\n    \n    reverse := func(start, end int) {\n        for start < end {\n            runes[start], runes[end] = runes[end], runes[start]\n            start++\n            end--\n        }\n    }\n    \n    reverse(0, k-1)\n    reverse(k, len(runes)-1)\n    reverse(0, len(runes)-1)\n    \n    return string(runes)\n}",
            "solutionNotes": "The \"reversal algorithm\" for rotation: reverse the first k elements, reverse the rest, then reverse the entire array. Three reversals achieve a rotation!"
          }
        ]
      },
      {
        "id": "advanced_4",
        "difficulty": 5,
        "baseTitle": "Map Counting",
        "concept": "Map Counting Pattern",
        "variants": [
          {
            "id": "v1",
            "title": "Word Counter",
            "description": "Write <code>func wordCount(s string) map[string]int</code> that counts how many times each word appears in a string.",
            "functionSignature": "func wordCount(s string) map[string]int",
            "testCases": [
              {
                "input": "\"the quick brown fox jumps over the lazy dog\"",
                "output": "map[brown:1 dog:1 fox:1 jumps:1 lazy:1 over:1 quick:1 the:2]"
              }
            ],
            "solution": "import \"strings\"\n\nfunc wordCount(s string) map[string]int {\n    counts := make(map[string]int)\n    for _, word := range strings.Fields(s) {\n        counts[word]++\n    }\n    return counts\n}"
          },
          {
            "id": "v2",
            "title": "Most Frequent Element",
            "description": "Write <code>func mostFrequent(nums []int) int</code> that returns the element that appears most frequently. If there's a tie, return any of them.",
            "functionSignature": "func mostFrequent(nums []int) int",
            "testCases": [
              {
                "input": "[]int{1, 3, 2, 1, 4, 1}",
                "output": "1",
                "note": "1 appears 3 times"
              },
              {
                "input": "[]int{5, 5, 4, 4, 4}",
                "output": "4"
              },
              {
                "input": "[]int{7}",
                "output": "7"
              }
            ],
            "solution": "func mostFrequent(nums []int) int {\n    counts := make(map[int]int)\n    for _, num := range nums {\n        counts[num]++\n    }\n    \n    maxCount := 0\n    result := nums[0]\n    for num, count := range counts {\n        if count > maxCount {\n            maxCount = count\n            result = num\n        }\n    }\n    return result\n}",
            "solutionNotes": "First count everything, then iterate the map to find the max. This is a two-pass approach over different data structures."
          },
          {
            "id": "v3",
            "title": "First Unique Character",
            "description": "Write <code>func firstUniqChar(s string) int</code> that returns the index of the first non-repeating character. Return -1 if none exists.",
            "functionSignature": "func firstUniqChar(s string) int",
            "testCases": [
              {
                "input": "\"leetcode\"",
                "output": "0",
                "note": "'l' is first unique"
              },
              {
                "input": "\"loveleetcode\"",
                "output": "2",
                "note": "'v' is first unique"
              },
              {
                "input": "\"aabb\"",
                "output": "-1"
              }
            ],
            "solution": "func firstUniqChar(s string) int {\n    counts := make(map[rune]int)\n    runes := []rune(s)\n    \n    for _, r := range runes {\n        counts[r]++\n    }\n    \n    for i, r := range runes {\n        if counts[r] == 1 {\n            return i\n        }\n    }\n    return -1\n}",
            "solutionNotes": "Two passes needed: first to count, second to find the first character with count == 1. We iterate the original string (not the map) to preserve order."
          },
          {
            "id": "v4",
            "title": "Is Anagram",
            "description": "Write <code>func isAnagram(s, t string) bool</code> that returns true if t is an anagram of s (same letters, different order).",
            "functionSignature": "func isAnagram(s, t string) bool",
            "testCases": [
              {
                "input": "\"anagram\", \"nagaram\"",
                "output": "true"
              },
              {
                "input": "\"rat\", \"car\"",
                "output": "false"
              },
              {
                "input": "\"listen\", \"silent\"",
                "output": "true"
              }
            ],
            "solution": "func isAnagram(s, t string) bool {\n    if len(s) != len(t) {\n        return false\n    }\n    \n    counts := make(map[rune]int)\n    for _, r := range s {\n        counts[r]++\n    }\n    for _, r := range t {\n        counts[r]--\n        if counts[r] < 0 {\n            return false\n        }\n    }\n    return true\n}",
            "solutionNotes": "Count characters in s (increment), then 'uncount' characters in t (decrement). If we ever go negative, t has a character s doesn't have."
          },
          {
            "id": "v5",
            "title": "Can Construct",
            "description": "Write <code>func canConstruct(ransomNote, magazine string) bool</code> that returns true if ransomNote can be constructed from magazine letters (each letter used once).",
            "functionSignature": "func canConstruct(ransomNote, magazine string) bool",
            "testCases": [
              {
                "input": "\"a\", \"b\"",
                "output": "false"
              },
              {
                "input": "\"aa\", \"aab\"",
                "output": "true"
              },
              {
                "input": "\"aa\", \"ab\"",
                "output": "false",
                "note": "need 2 a's but only 1"
              }
            ],
            "solution": "func canConstruct(ransomNote, magazine string) bool {\n    available := make(map[rune]int)\n    \n    for _, r := range magazine {\n        available[r]++\n    }\n    \n    for _, r := range ransomNote {\n        available[r]--\n        if available[r] < 0 {\n            return false\n        }\n    }\n    return true\n}",
            "solutionNotes": "Similar to anagram check, but one-directional: we only need to verify ransomNote letters exist in magazine, not vice versa."
          },
          {
            "id": "v6",
            "title": "Majority Element",
            "description": "Write <code>func majorityElement(nums []int) int</code> that finds the element appearing more than n/2 times. Assume such element always exists.",
            "functionSignature": "func majorityElement(nums []int) int",
            "testCases": [
              {
                "input": "[]int{3, 2, 3}",
                "output": "3"
              },
              {
                "input": "[]int{2, 2, 1, 1, 1, 2, 2}",
                "output": "2"
              },
              {
                "input": "[]int{1, 1, 1, 1}",
                "output": "1"
              }
            ],
            "solution": "func majorityElement(nums []int) int {\n    counts := make(map[int]int)\n    threshold := len(nums) / 2\n    \n    for _, num := range nums {\n        counts[num]++\n        if counts[num] > threshold {\n            return num\n        }\n    }\n    return -1\n}",
            "solutionNotes": "We can return early as soon as any element exceeds n/2 count. No need to finish counting everything!"
          }
        ]
      },
      {
        "id": "advanced_5",
        "difficulty": 5,
        "baseTitle": "Hash Map Lookup",
        "concept": "Hash Map Complement Pattern",
        "variants": [
          {
            "id": "v1",
            "title": "Two Sum",
            "description": "Given a slice of ints and a target, return indices of two numbers that add up to the target. <code>func twoSum(nums []int, target int) []int</code>",
            "functionSignature": "func twoSum(nums []int, target int) []int",
            "testCases": [
              {
                "input": "[]int{2, 7, 11, 15}, 9",
                "output": "[0, 1]"
              },
              {
                "input": "[]int{3, 2, 4}, 6",
                "output": "[1, 2]"
              },
              {
                "input": "[]int{3, 3}, 6",
                "output": "[0, 1]"
              }
            ],
            "solution": "func twoSum(nums []int, target int) []int {\n    seen := make(map[int]int)\n    for i, num := range nums {\n        complement := target - num\n        if j, ok := seen[complement]; ok {\n            return []int{j, i}\n        }\n        seen[num] = i\n    }\n    return nil\n}"
          },
          {
            "id": "v2",
            "title": "Two Sum II (Sorted Input)",
            "description": "Given a <strong>sorted</strong> array and target, return indices (1-indexed) of two numbers that add to target. Use two pointers instead of a hash map. <code>func twoSumSorted(nums []int, target int) []int</code>",
            "functionSignature": "func twoSumSorted(nums []int, target int) []int",
            "testCases": [
              {
                "input": "[]int{2, 7, 11, 15}, 9",
                "output": "[1, 2]",
                "note": "1-indexed!"
              },
              {
                "input": "[]int{2, 3, 4}, 6",
                "output": "[1, 3]"
              },
              {
                "input": "[]int{-1, 0}, -1",
                "output": "[1, 2]"
              }
            ],
            "solution": "func twoSumSorted(nums []int, target int) []int {\n    left, right := 0, len(nums)-1\n    \n    for left < right {\n        sum := nums[left] + nums[right]\n        if sum == target {\n            return []int{left + 1, right + 1}\n        } else if sum < target {\n            left++\n        } else {\n            right--\n        }\n    }\n    return nil\n}",
            "solutionNotes": "When input is sorted, two pointers is O(1) space vs O(n) for hash map. Move left pointer right for larger sum, right pointer left for smaller sum."
          },
          {
            "id": "v3",
            "title": "Pair with Difference",
            "description": "Find two numbers whose <strong>difference</strong> equals the target. Return their indices (smaller index first). <code>func pairWithDiff(nums []int, target int) []int</code>",
            "functionSignature": "func pairWithDiff(nums []int, target int) []int",
            "testCases": [
              {
                "input": "[]int{5, 20, 3, 2, 50, 80}, 78",
                "output": "[1, 5]",
                "note": "80 - 2 = 78... wait"
              },
              {
                "input": "[]int{1, 5, 3}, 2",
                "output": "[0, 2]",
                "note": "3 - 1 = 2"
              },
              {
                "input": "[]int{1, 2, 3}, 10",
                "output": "nil"
              }
            ],
            "solution": "func pairWithDiff(nums []int, target int) []int {\n    seen := make(map[int]int)\n    \n    for i, num := range nums {\n        if j, ok := seen[num-target]; ok {\n            return []int{j, i}\n        }\n        if j, ok := seen[num+target]; ok {\n            return []int{j, i}\n        }\n        seen[num] = i\n    }\n    return nil\n}",
            "solutionNotes": "Unlike Two Sum where we look for target-num, here we look for BOTH num-target AND num+target because either could be the pair (a-b=k or b-a=k)."
          },
          {
            "id": "v4",
            "title": "Count Pairs with Sum",
            "description": "Count how many pairs of numbers add up to exactly the target. Each element can only be used once. <code>func countPairs(nums []int, target int) int</code>",
            "functionSignature": "func countPairs(nums []int, target int) int",
            "testCases": [
              {
                "input": "[]int{1, 5, 7, 1}, 6",
                "output": "2",
                "note": "(1,5) and (1,5)"
              },
              {
                "input": "[]int{1, 1, 1, 1}, 2",
                "output": "2",
                "note": "two pairs of 1+1"
              },
              {
                "input": "[]int{1, 2, 3}, 10",
                "output": "0"
              }
            ],
            "solution": "func countPairs(nums []int, target int) int {\n    counts := make(map[int]int)\n    for _, num := range nums {\n        counts[num]++\n    }\n    \n    pairs := 0\n    for num, count := range counts {\n        complement := target - num\n        if complement == num {\n            pairs += count * (count - 1) / 2\n        } else if compCount, ok := counts[complement]; ok && complement > num {\n            pairs += count * compCount\n        }\n    }\n    return pairs\n}",
            "solutionNotes": "This is trickier! We count occurrences first, then for each unique number, find pairs. Handle same-number pairs specially (n choose 2). Use complement > num to avoid double counting."
          },
          {
            "id": "v5",
            "title": "Three Sum Exists",
            "description": "Return <code>true</code> if any three numbers in the array sum to zero. <code>func threeSumExists(nums []int) bool</code>",
            "functionSignature": "func threeSumExists(nums []int) bool",
            "testCases": [
              {
                "input": "[]int{-1, 0, 1, 2}",
                "output": "true",
                "note": "-1 + 0 + 1 = 0"
              },
              {
                "input": "[]int{1, 2, 3}",
                "output": "false"
              },
              {
                "input": "[]int{0, 0, 0}",
                "output": "true"
              }
            ],
            "solution": "import \"sort\"\n\nfunc threeSumExists(nums []int) bool {\n    sort.Ints(nums)\n    n := len(nums)\n    \n    for i := 0; i < n-2; i++ {\n        if i > 0 && nums[i] == nums[i-1] {\n            continue\n        }\n        \n        left, right := i+1, n-1\n        target := -nums[i]\n        \n        for left < right {\n            sum := nums[left] + nums[right]\n            if sum == target {\n                return true\n            } else if sum < target {\n                left++\n            } else {\n                right--\n            }\n        }\n    }\n    return false\n}",
            "solutionNotes": "Fix one number, then use Two Sum II (sorted) for the other two. Sorting first enables the two-pointer approach. O(n\u00b2) total."
          },
          {
            "id": "v6",
            "title": "Subarray Sum Equals K",
            "description": "Count the number of continuous subarrays whose elements sum to k. <code>func subarraySum(nums []int, k int) int</code>",
            "functionSignature": "func subarraySum(nums []int, k int) int",
            "testCases": [
              {
                "input": "[]int{1, 1, 1}, 2",
                "output": "2",
                "note": "[1,1] at positions 0-1 and 1-2"
              },
              {
                "input": "[]int{1, 2, 3}, 3",
                "output": "2",
                "note": "[1,2] and [3]"
              },
              {
                "input": "[]int{1, -1, 0}, 0",
                "output": "3"
              }
            ],
            "solution": "func subarraySum(nums []int, k int) int {\n    count := 0\n    prefixSum := 0\n    seen := make(map[int]int)\n    seen[0] = 1\n    \n    for _, num := range nums {\n        prefixSum += num\n        if c, ok := seen[prefixSum-k]; ok {\n            count += c\n        }\n        seen[prefixSum]++\n    }\n    return count\n}",
            "solutionNotes": "This uses the prefix sum technique with a hash map. If prefix[j] - prefix[i] = k, then subarray [i+1...j] sums to k. We track how many times each prefix sum has occurred."
          }
        ]
      },
      {
        "id": "advanced_6",
        "difficulty": 5,
        "baseTitle": "Sliding Window",
        "concept": "Sliding Window Pattern",
        "variants": [
          {
            "id": "v1",
            "title": "Maximum Sum Subarray of Size K",
            "description": "Given an array of integers and a number k, find the maximum sum of any contiguous subarray of size k. <code>func maxSumSubarray(nums []int, k int) int</code>",
            "functionSignature": "func maxSumSubarray(nums []int, k int) int",
            "testCases": [
              {
                "input": "[]int{2, 1, 5, 1, 3, 2}, 3",
                "output": "9",
                "note": "subarray [5,1,3]"
              },
              {
                "input": "[]int{2, 3, 4, 1, 5}, 2",
                "output": "7",
                "note": "subarray [3,4]"
              },
              {
                "input": "[]int{1, 1, 1, 1}, 2",
                "output": "2"
              }
            ],
            "solution": "func maxSumSubarray(nums []int, k int) int {\n    if len(nums) < k {\n        return 0\n    }\n    windowSum := 0\n    for i := 0; i < k; i++ {\n        windowSum += nums[i]\n    }\n    maxSum := windowSum\n    \n    for i := k; i < len(nums); i++ {\n        windowSum += nums[i] - nums[i-k]\n        if windowSum > maxSum {\n            maxSum = windowSum\n        }\n    }\n    return maxSum\n}",
            "solutionNotes": "Fixed-size window: calculate first window sum, then slide by adding new element and subtracting leaving element. O(n) time, O(1) space."
          },
          {
            "id": "v2",
            "title": "Longest Substring Without Repeating",
            "description": "Find the length of the longest substring without repeating characters. <code>func lengthOfLongestSubstring(s string) int</code>",
            "functionSignature": "func lengthOfLongestSubstring(s string) int",
            "testCases": [
              {
                "input": "\"abcabcbb\"",
                "output": "3",
                "note": "\"abc\""
              },
              {
                "input": "\"bbbbb\"",
                "output": "1",
                "note": "\"b\""
              },
              {
                "input": "\"pwwkew\"",
                "output": "3",
                "note": "\"wke\""
              }
            ],
            "solution": "func lengthOfLongestSubstring(s string) int {\n    seen := make(map[byte]int)\n    maxLen := 0\n    left := 0\n    \n    for right := 0; right < len(s); right++ {\n        char := s[right]\n        if lastIdx, ok := seen[char]; ok && lastIdx >= left {\n            left = lastIdx + 1\n        }\n        seen[char] = right\n        if right - left + 1 > maxLen {\n            maxLen = right - left + 1\n        }\n    }\n    return maxLen\n}",
            "solutionNotes": "Variable-size window: expand right, shrink left when duplicate found. Track last seen index of each character to know where to shrink to."
          },
          {
            "id": "v3",
            "title": "Minimum Size Subarray Sum",
            "description": "Find the minimal length of a contiguous subarray whose sum is >= target. Return 0 if no such subarray. <code>func minSubarrayLen(target int, nums []int) int</code>",
            "functionSignature": "func minSubarrayLen(target int, nums []int) int",
            "testCases": [
              {
                "input": "7, []int{2, 3, 1, 2, 4, 3}",
                "output": "2",
                "note": "[4,3] sums to 7"
              },
              {
                "input": "4, []int{1, 4, 4}",
                "output": "1",
                "note": "[4] alone >= 4"
              },
              {
                "input": "11, []int{1, 1, 1, 1}",
                "output": "0",
                "note": "can't reach 11"
              }
            ],
            "solution": "func minSubarrayLen(target int, nums []int) int {\n    minLen := len(nums) + 1\n    left := 0\n    sum := 0\n    \n    for right := 0; right < len(nums); right++ {\n        sum += nums[right]\n        \n        for sum >= target {\n            if right - left + 1 < minLen {\n                minLen = right - left + 1\n            }\n            sum -= nums[left]\n            left++\n        }\n    }\n    \n    if minLen == len(nums) + 1 {\n        return 0\n    }\n    return minLen\n}",
            "solutionNotes": "Variable-size window with condition: expand to increase sum, shrink while condition met to find minimum. Classic 'minimum window' pattern."
          },
          {
            "id": "v4",
            "title": "Average of Subarrays of Size K",
            "description": "Given an array, find the average of all contiguous subarrays of size k. <code>func averageOfSubarrays(nums []int, k int) []float64</code>",
            "functionSignature": "func averageOfSubarrays(nums []int, k int) []float64",
            "testCases": [
              {
                "input": "[]int{1, 3, 2, 6, -1, 4, 1, 8, 2}, 5",
                "output": "[2.2, 2.8, 2.4, 3.6, 2.8]"
              },
              {
                "input": "[]int{1, 2, 3, 4}, 2",
                "output": "[1.5, 2.5, 3.5]"
              }
            ],
            "solution": "func averageOfSubarrays(nums []int, k int) []float64 {\n    result := []float64{}\n    windowSum := 0\n    \n    for i := 0; i < len(nums); i++ {\n        windowSum += nums[i]\n        \n        if i >= k-1 {\n            result = append(result, float64(windowSum)/float64(k))\n            windowSum -= nums[i-k+1]\n        }\n    }\n    return result\n}",
            "solutionNotes": "Basic fixed-window pattern. Build up sum for first k elements, then slide and track averages."
          },
          {
            "id": "v5",
            "title": "Contains Duplicate Within K Distance",
            "description": "Return true if there are two distinct indices i and j where nums[i] == nums[j] and abs(i - j) <= k. <code>func containsNearbyDuplicate(nums []int, k int) bool</code>",
            "functionSignature": "func containsNearbyDuplicate(nums []int, k int) bool",
            "testCases": [
              {
                "input": "[]int{1, 2, 3, 1}, 3",
                "output": "true"
              },
              {
                "input": "[]int{1, 0, 1, 1}, 1",
                "output": "true"
              },
              {
                "input": "[]int{1, 2, 3, 1, 2, 3}, 2",
                "output": "false"
              }
            ],
            "solution": "func containsNearbyDuplicate(nums []int, k int) bool {\n    seen := make(map[int]bool)\n    \n    for i, num := range nums {\n        if seen[num] {\n            return true\n        }\n        seen[num] = true\n        \n        if i >= k {\n            delete(seen, nums[i-k])\n        }\n    }\n    return false\n}",
            "solutionNotes": "Maintain a sliding window of size k as a set. If we see a duplicate within the window, return true. Remove elements that leave the window."
          },
          {
            "id": "v6",
            "title": "Max Consecutive Ones III",
            "description": "Given a binary array and integer k, return the maximum number of consecutive 1's if you can flip at most k 0's. <code>func longestOnes(nums []int, k int) int</code>",
            "functionSignature": "func longestOnes(nums []int, k int) int",
            "testCases": [
              {
                "input": "[]int{1,1,1,0,0,0,1,1,1,1,0}, 2",
                "output": "6",
                "note": "flip 0's at indices 5 and 10"
              },
              {
                "input": "[]int{0,0,1,1,0,0,1,1,1,0,1,1,0,0,0,1,1,1,1}, 3",
                "output": "10"
              }
            ],
            "solution": "func longestOnes(nums []int, k int) int {\n    left := 0\n    zeros := 0\n    maxLen := 0\n    \n    for right := 0; right < len(nums); right++ {\n        if nums[right] == 0 {\n            zeros++\n        }\n        \n        for zeros > k {\n            if nums[left] == 0 {\n                zeros--\n            }\n            left++\n        }\n        \n        if right - left + 1 > maxLen {\n            maxLen = right - left + 1\n        }\n    }\n    return maxLen\n}",
            "solutionNotes": "Variable window: expand right, count zeros. When zeros > k, shrink from left. Track maximum valid window size."
          }
        ]
      },
      {
        "id": "advanced_7",
        "difficulty": 5,
        "baseTitle": "Track Min/Max While Scanning",
        "concept": "Best So Far Pattern",
        "variants": [
          {
            "id": "v1",
            "title": "Best Time to Buy and Sell Stock",
            "description": "Given an array of stock prices where prices[i] is the price on day i, find the maximum profit from one buy and one sell. You must buy before you sell. <code>func maxProfit(prices []int) int</code>",
            "functionSignature": "func maxProfit(prices []int) int",
            "testCases": [
              {
                "input": "[]int{7, 1, 5, 3, 6, 4}",
                "output": "5",
                "note": "buy at 1, sell at 6"
              },
              {
                "input": "[]int{7, 6, 4, 3, 1}",
                "output": "0",
                "note": "prices only go down, no profit possible"
              },
              {
                "input": "[]int{2, 4, 1}",
                "output": "2",
                "note": "buy at 2, sell at 4"
              }
            ],
            "solution": "func maxProfit(prices []int) int {\n    if len(prices) == 0 {\n        return 0\n    }\n    \n    minPrice := prices[0]\n    maxProfit := 0\n    \n    for _, price := range prices {\n        if price < minPrice {\n            minPrice = price\n        } else if price - minPrice > maxProfit {\n            maxProfit = price - minPrice\n        }\n    }\n    return maxProfit\n}"
          },
          {
            "id": "v2",
            "title": "Maximum Difference",
            "description": "Find the maximum difference between any two elements where the larger element comes after the smaller one. Return 0 if no such pair exists. <code>func maxDiff(nums []int) int</code>",
            "functionSignature": "func maxDiff(nums []int) int",
            "testCases": [
              {
                "input": "[]int{2, 3, 10, 6, 4, 8, 1}",
                "output": "8",
                "note": "10 - 2 = 8"
              },
              {
                "input": "[]int{7, 9, 5, 6, 3, 2}",
                "output": "2",
                "note": "9 - 7 = 2"
              },
              {
                "input": "[]int{5, 4, 3, 2, 1}",
                "output": "0",
                "note": "decreasing, no valid pair"
              }
            ],
            "solution": "func maxDiff(nums []int) int {\n    if len(nums) < 2 {\n        return 0\n    }\n    \n    minSoFar := nums[0]\n    maxDiff := 0\n    \n    for i := 1; i < len(nums); i++ {\n        diff := nums[i] - minSoFar\n        if diff > maxDiff {\n            maxDiff = diff\n        }\n        if nums[i] < minSoFar {\n            minSoFar = nums[i]\n        }\n    }\n    return maxDiff\n}",
            "solutionNotes": "This is the same problem as Best Time to Buy/Sell Stock! Track the minimum seen so far, and at each position calculate the potential profit/difference."
          },
          {
            "id": "v3",
            "title": "Best Sightseeing Pair",
            "description": "Given an array of values, find max score of values[i] + values[j] + i - j where i < j. <code>func maxScoreSightseeingPair(values []int) int</code>",
            "functionSignature": "func maxScoreSightseeingPair(values []int) int",
            "testCases": [
              {
                "input": "[]int{8, 1, 5, 2, 6}",
                "output": "11",
                "note": "i=0, j=2: 8+5+0-2=11"
              },
              {
                "input": "[]int{1, 2}",
                "output": "2",
                "note": "1+2+0-1=2"
              },
              {
                "input": "[]int{1, 3, 5}",
                "output": "7",
                "note": "i=1, j=2: 3+5+1-2=7"
              }
            ],
            "solution": "func maxScoreSightseeingPair(values []int) int {\n    maxScore := 0\n    bestI := values[0] + 0  // values[i] + i\n    \n    for j := 1; j < len(values); j++ {\n        score := bestI + values[j] - j\n        if score > maxScore {\n            maxScore = score\n        }\n        if values[j] + j > bestI {\n            bestI = values[j] + j\n        }\n    }\n    return maxScore\n}",
            "solutionNotes": "Rewrite the formula: (values[i] + i) + (values[j] - j). Track the best (values[i] + i) seen so far, then for each j compute the score. Same pattern as stock problem!"
          },
          {
            "id": "v4",
            "title": "Maximum Subarray (Kadane's)",
            "description": "Find the contiguous subarray with the largest sum. <code>func maxSubArray(nums []int) int</code>",
            "functionSignature": "func maxSubArray(nums []int) int",
            "testCases": [
              {
                "input": "[]int{-2, 1, -3, 4, -1, 2, 1, -5, 4}",
                "output": "6",
                "note": "[4,-1,2,1] = 6"
              },
              {
                "input": "[]int{1}",
                "output": "1"
              },
              {
                "input": "[]int{-1, -2, -3}",
                "output": "-1",
                "note": "least negative"
              }
            ],
            "solution": "func maxSubArray(nums []int) int {\n    maxSum := nums[0]\n    currentSum := nums[0]\n    \n    for i := 1; i < len(nums); i++ {\n        if currentSum < 0 {\n            currentSum = nums[i]\n        } else {\n            currentSum += nums[i]\n        }\n        if currentSum > maxSum {\n            maxSum = currentSum\n        }\n    }\n    return maxSum\n}",
            "solutionNotes": "Kadane's algorithm: at each position, decide whether to extend the current subarray or start fresh. Track the best sum seen so far. Same 'best so far' pattern!"
          },
          {
            "id": "v5",
            "title": "Best Time to Buy and Sell Stock II",
            "description": "You can buy and sell multiple times (but must sell before buying again). Find the maximum total profit. <code>func maxProfitII(prices []int) int</code>",
            "functionSignature": "func maxProfitII(prices []int) int",
            "testCases": [
              {
                "input": "[]int{7, 1, 5, 3, 6, 4}",
                "output": "7",
                "note": "buy@1 sell@5 (+4), buy@3 sell@6 (+3)"
              },
              {
                "input": "[]int{1, 2, 3, 4, 5}",
                "output": "4",
                "note": "buy@1 sell@5, or buy/sell each day"
              },
              {
                "input": "[]int{7, 6, 4, 3, 1}",
                "output": "0",
                "note": "no profit possible"
              }
            ],
            "solution": "func maxProfitII(prices []int) int {\n    profit := 0\n    \n    for i := 1; i < len(prices); i++ {\n        if prices[i] > prices[i-1] {\n            profit += prices[i] - prices[i-1]\n        }\n    }\n    return profit\n}",
            "solutionNotes": "Greedy insight: capture every upward movement! If tomorrow's price is higher, that's profit. Sum all positive differences. Much simpler than it seems!"
          },
          {
            "id": "v6",
            "title": "Trapping Rain Water",
            "description": "Given an elevation map where width of each bar is 1, compute how much water can be trapped after raining. <code>func trap(height []int) int</code>",
            "functionSignature": "func trap(height []int) int",
            "testCases": [
              {
                "input": "[]int{0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1}",
                "output": "6"
              },
              {
                "input": "[]int{4, 2, 0, 3, 2, 5}",
                "output": "9"
              },
              {
                "input": "[]int{1, 2, 3}",
                "output": "0",
                "note": "strictly increasing, no trapping"
              }
            ],
            "solution": "func trap(height []int) int {\n    if len(height) == 0 {\n        return 0\n    }\n    \n    n := len(height)\n    maxLeft := make([]int, n)\n    maxRight := make([]int, n)\n    \n    maxLeft[0] = height[0]\n    for i := 1; i < n; i++ {\n        if height[i] > maxLeft[i-1] {\n            maxLeft[i] = height[i]\n        } else {\n            maxLeft[i] = maxLeft[i-1]\n        }\n    }\n    \n    maxRight[n-1] = height[n-1]\n    for i := n - 2; i >= 0; i-- {\n        if height[i] > maxRight[i+1] {\n            maxRight[i] = height[i]\n        } else {\n            maxRight[i] = maxRight[i+1]\n        }\n    }\n    \n    water := 0\n    for i := 0; i < n; i++ {\n        level := maxLeft[i]\n        if maxRight[i] < level {\n            level = maxRight[i]\n        }\n        water += level - height[i]\n    }\n    return water\n}",
            "solutionNotes": "At each position, water level = min(maxLeft, maxRight). Pre-compute maxLeft[i] and maxRight[i] arrays using the 'best so far' pattern in both directions!"
          }
        ]
      }
    ],
    "preExercises": {
      "advanced_1": {
        "title": "Pre-exercise: Map as a Set",
        "description": "Before tackling the algorithm, let's practice the core pattern: using a map to track what you've seen.",
        "exercises": [
          {
            "id": "pre1",
            "title": "Track Visited Pages",
            "problem": "You're building a browser history tracker. Write code that creates a <code>map[string]bool</code> called <code>visited</code>, marks three pages as visited, then checks if \"google.com\" has been visited.",
            "hints": [
              {
                "title": "Creating the map",
                "content": "Create with: <code>visited := make(map[string]bool)</code><br>This creates an empty map where keys are strings and values are booleans."
              },
              {
                "title": "Marking as visited",
                "content": "To mark a page as visited: <code>visited[\"google.com\"] = true</code><br>Do this for three different pages."
              },
              {
                "title": "Checking if visited",
                "content": "The simple way: <code>if visited[\"google.com\"]</code><br>This works because if the key doesn't exist, Go returns <code>false</code> (the zero value for bool)!"
              }
            ],
            "solution": "visited := make(map[string]bool)\n\n// Mark pages as visited\nvisited[\"google.com\"] = true\nvisited[\"github.com\"] = true\nvisited[\"go.dev\"] = true\n\n// Check if google.com was visited\nif visited[\"google.com\"] {\n    fmt.Println(\"You've been to google.com\")\n}\n\n// Check something NOT visited\nif visited[\"facebook.com\"] {\n    fmt.Println(\"You've been to facebook.com\")\n} else {\n    fmt.Println(\"Never visited facebook.com\")\n}",
            "expectedOutput": "You've been to google.com\nNever visited facebook.com",
            "keyInsight": "When you access a key that doesn't exist in a <code>map[T]bool</code>, Go returns <code>false</code>. This makes <code>if visited[key]</code> a clean way to check membership - no need for the comma-ok pattern here!"
          },
          {
            "id": "pre2",
            "title": "Unique Letter Collector",
            "problem": "Write code that loops through the string \"banana\" and collects each unique letter into a <code>map[rune]bool</code>. Print how many unique letters there are.",
            "hints": [
              {
                "title": "Setup",
                "content": "Create the map: <code>letters := make(map[rune]bool)</code><br>Loop with: <code>for _, char := range \"banana\"</code>"
              },
              {
                "title": "Collecting",
                "content": "For each character, just mark it as seen: <code>letters[char] = true</code><br>Maps automatically handle duplicates - setting the same key twice just overwrites."
              },
              {
                "title": "Counting",
                "content": "The number of unique letters is: <code>len(letters)</code>"
              }
            ],
            "solution": "letters := make(map[rune]bool)\n\nfor _, char := range \"banana\" {\n    letters[char] = true\n}\n\nfmt.Printf(\"Unique letters: %d\\n\", len(letters))  // 3: b, a, n",
            "expectedOutput": "Unique letters: 3",
            "keyInsight": "A map automatically handles duplicates - you can set the same key multiple times and it just overwrites. This is why <code>len(map)</code> gives you the count of unique keys!"
          }
        ]
      },
      "advanced_2": {
        "title": "Pre-exercise: Slow/Fast Pointer Prep",
        "description": "Before the in-place algorithm, let's practice the core logic of detecting duplicates in sorted arrays.",
        "exercises": [
          {
            "id": "pre2a",
            "title": "Copy Unique to New Slice",
            "problem": "Given the sorted slice <code>[]int{1, 1, 2, 2, 3}</code>, create a NEW slice containing only the unique values <code>[1, 2, 3]</code>. Don't modify the original - just build a new one with <code>append</code>.",
            "hints": [
              {
                "title": "Step 1: Setup",
                "content": "<pre>nums := []int{1, 1, 2, 2, 3}\nresult := []int{nums[0]}  // First element is always unique</pre>"
              },
              {
                "title": "Step 2: Loop starting from index 1",
                "content": "<pre>for i := 1; i < len(nums); i++ {\n    // Compare current with previous\n}</pre>"
              },
              {
                "title": "Step 3: Append when different",
                "content": "<pre>if nums[i] != nums[i-1] {\n    result = append(result, nums[i])\n}</pre>"
              }
            ],
            "solution": "nums := []int{1, 1, 2, 2, 3}\nresult := []int{nums[0]}  // First element always unique\n\nfor i := 1; i < len(nums); i++ {\n    if nums[i] != nums[i-1] {\n        result = append(result, nums[i])\n    }\n}\n\nfmt.Println(result)  // [1 2 3]",
            "expectedOutput": "[1 2 3]",
            "keyInsight": "In a sorted array, duplicates are always adjacent! So we only need to compare each element with the one before it. This same logic powers the in-place algorithm - we'll just write to the array instead of appending."
          },
          {
            "id": "pre2b",
            "title": "Count Consecutive Groups",
            "problem": "Given the sorted slice <code>[]int{1, 1, 2, 2, 2, 3}</code>, count how many distinct groups there are. Answer: 3 (the 1s, the 2s, and the 3).",
            "hints": [
              {
                "title": "Step 1: Initialize counter",
                "content": "<pre>nums := []int{1, 1, 2, 2, 2, 3}\ngroups := 1  // First element starts the first group</pre>"
              },
              {
                "title": "Step 2: Loop and count transitions",
                "content": "<pre>for i := 1; i < len(nums); i++ {\n    if nums[i] != nums[i-1] {\n        groups++  // New value = new group\n    }\n}</pre>"
              }
            ],
            "solution": "nums := []int{1, 1, 2, 2, 2, 3}\ngroups := 1  // First element starts the first group\n\nfor i := 1; i < len(nums); i++ {\n    if nums[i] != nums[i-1] {\n        groups++  // New value = new group\n    }\n}\n\nfmt.Printf(\"Groups: %d\\n\", groups)",
            "expectedOutput": "Groups: 3",
            "keyInsight": "This is exactly what the slow/fast algorithm returns! The slow pointer ends up at the last unique position, so slow+1 = number of unique elements = number of groups."
          }
        ]
      },
      "advanced_3": {
        "title": "Pre-exercise: Strings vs Runes",
        "description": "Before manipulating strings character-by-character, let's understand the difference between bytes and runes in Go.",
        "exercises": [
          {
            "id": "pre3a",
            "title": "Explore String Length vs Rune Count",
            "problem": "Compare the byte length and rune count of these strings: <code>\"hello\"</code>, <code>\"\u4e16\u754c\"</code>, and <code>\"\ud83c\udf89\"</code>. Print both <code>len(s)</code> and <code>len([]rune(s))</code> for each.",
            "hints": [
              {
                "title": "Step 1: ASCII string",
                "content": "<pre>s1 := \"hello\"\nfmt.Printf(\"%s: %d bytes, %d runes\\n\", s1, len(s1), len([]rune(s1)))</pre>"
              },
              {
                "title": "Step 2: Chinese characters",
                "content": "<pre>s2 := \"\u4e16\u754c\"\nfmt.Printf(\"%s: %d bytes, %d runes\\n\", s2, len(s2), len([]rune(s2)))</pre>"
              },
              {
                "title": "Step 3: Emoji",
                "content": "<pre>s3 := \"\ud83c\udf89\"\nfmt.Printf(\"%s: %d bytes, %d runes\\n\", s3, len(s3), len([]rune(s3)))</pre>"
              }
            ],
            "solution": "s1 := \"hello\"\nfmt.Printf(\"%s: %d bytes, %d runes\\n\", s1, len(s1), len([]rune(s1)))\n\ns2 := \"\u4e16\u754c\"\nfmt.Printf(\"%s: %d bytes, %d runes\\n\", s2, len(s2), len([]rune(s2)))\n\ns3 := \"\ud83c\udf89\"\nfmt.Printf(\"%s: %d bytes, %d runes\\n\", s3, len(s3), len([]rune(s3)))",
            "expectedOutput": "hello: 5 bytes, 5 runes\n\u4e16\u754c: 6 bytes, 2 runes\n\ud83c\udf89: 4 bytes, 1 runes",
            "keyInsight": "ASCII characters are 1 byte each, but Unicode characters can be 2-4 bytes! <code>len(string)</code> counts bytes, <code>len([]rune(string))</code> counts actual characters. Always convert to <code>[]rune</code> when you need to work with individual characters."
          },
          {
            "id": "pre3b",
            "title": "Convert, Modify, Convert Back",
            "problem": "Take the string <code>\"Go!\"</code>, convert to runes, change the first character to <code>'g'</code>, and convert back to a string. Print the result.",
            "hints": [
              {
                "title": "Step 1: Convert to runes",
                "content": "<pre>s := \"Go!\"\nrunes := []rune(s)</pre>"
              },
              {
                "title": "Step 2: Modify",
                "content": "<pre>runes[0] = 'g'  // Single quotes for rune literal</pre>"
              },
              {
                "title": "Step 3: Convert back",
                "content": "<pre>result := string(runes)\nfmt.Println(result)</pre>"
              }
            ],
            "solution": "s := \"Go!\"\nrunes := []rune(s)\n\nrunes[0] = 'g'  // Modify first character\n\nresult := string(runes)\nfmt.Println(result)",
            "expectedOutput": "go!",
            "keyInsight": "Strings in Go are immutable - you can't do <code>s[0] = 'g'</code>. The pattern is: convert to <code>[]rune</code>, modify the slice, convert back to <code>string</code>. This is exactly what we'll do for reversing strings!"
          }
        ]
      },
      "advanced_4": {
        "title": "Pre-exercise: Map Counting Prep",
        "description": "Before counting words, let's practice the building blocks: splitting strings and incrementing map values.",
        "exercises": [
          {
            "id": "pre4a",
            "title": "Explore strings.Fields",
            "problem": "Use <code>strings.Fields</code> to split the string <code>\"hello world go\"</code> into words and print each word on its own line.",
            "hints": [
              {
                "title": "Step 1: Import and split",
                "content": "<pre>import \"strings\"\n\nwords := strings.Fields(\"hello world go\")</pre>"
              },
              {
                "title": "Step 2: Loop and print",
                "content": "<pre>for _, word := range words {\n    fmt.Println(word)\n}</pre>"
              }
            ],
            "solution": "import \"strings\"\n\nwords := strings.Fields(\"hello world go\")\nfor _, word := range words {\n    fmt.Println(word)\n}",
            "expectedOutput": "hello\nworld\ngo",
            "keyInsight": "<code>strings.Fields</code> splits on any whitespace (spaces, tabs, newlines) and returns a <code>[]string</code>. It's smarter than <code>strings.Split(s, \" \")</code> because it handles multiple spaces correctly."
          },
          {
            "id": "pre4b",
            "title": "Count Letters (Simpler)",
            "problem": "Count how many times each letter appears in <code>\"hello\"</code>. Store in a <code>map[rune]int</code> and print the counts.",
            "hints": [
              {
                "title": "Step 1: Create the map",
                "content": "<pre>counts := make(map[rune]int)</pre>"
              },
              {
                "title": "Step 2: Loop through string",
                "content": "<pre>for _, char := range \"hello\" {\n    counts[char]++\n}</pre>"
              },
              {
                "title": "Step 3: Print results",
                "content": "<pre>for char, count := range counts {\n    fmt.Printf(\"%c: %d\\n\", char, count)\n}</pre>"
              }
            ],
            "solution": "counts := make(map[rune]int)\n\nfor _, char := range \"hello\" {\n    counts[char]++\n}\n\nfor char, count := range counts {\n    fmt.Printf(\"%c: %d\\n\", char, count)\n}",
            "expectedOutput": "h: 1\ne: 1\nl: 2\no: 1",
            "keyInsight": "The <code>++</code> operator works on map values! When the key doesn't exist, Go returns 0 (the zero value for int), then increments to 1. So <code>counts[char]++</code> handles both first-time and repeat cases."
          }
        ]
      },
      "advanced_5": {
        "title": "Pre-exercise: Two Sum Building Blocks",
        "description": "Before the full algorithm, let's practice the two key operations: looking up complements and building index maps.",
        "exercises": [
          {
            "id": "pre5a",
            "title": "Find Complement in Map",
            "problem": "Given this pre-built map <code>map[int]int{2: 0, 7: 1, 11: 2}</code> (value to index), target=9, and current number=7: calculate the complement and check if it exists in the map. Print the result.",
            "hints": [
              {
                "title": "Step 1: Setup",
                "content": "<pre>seen := map[int]int{2: 0, 7: 1, 11: 2}\ntarget := 9\nnum := 7</pre>"
              },
              {
                "title": "Step 2: Calculate complement",
                "content": "<pre>complement := target - num  // 9 - 7 = 2</pre>"
              },
              {
                "title": "Step 3: Check map with comma-ok",
                "content": "<pre>if idx, ok := seen[complement]; ok {\n    fmt.Printf(\"Found! %d is at index %d\\n\", complement, idx)\n}</pre>"
              }
            ],
            "solution": "seen := map[int]int{2: 0, 7: 1, 11: 2}\ntarget := 9\nnum := 7\n\ncomplement := target - num  // 9 - 7 = 2\n\nif idx, ok := seen[complement]; ok {\n    fmt.Printf(\"Found %d at index %d\\n\", complement, idx)\n} else {\n    fmt.Println(\"Not found\")\n}",
            "expectedOutput": "Found 2 at index 0",
            "keyInsight": "The complement is <code>target - current</code>. If we're looking for two numbers that sum to 9, and we have 7, we need to find 2. The map tells us WHERE we saw the 2 (at index 0)."
          },
          {
            "id": "pre5b",
            "title": "Build Value-to-Index Map",
            "problem": "Given <code>[]int{2, 7, 11}</code>, build a map that maps each value to its index: <code>map[int]int{2: 0, 7: 1, 11: 2}</code>.",
            "hints": [
              {
                "title": "Step 1: Create empty map",
                "content": "<pre>nums := []int{2, 7, 11}\nvalueToIndex := make(map[int]int)</pre>"
              },
              {
                "title": "Step 2: Loop with index",
                "content": "<pre>for i, num := range nums {\n    valueToIndex[num] = i\n}</pre>"
              }
            ],
            "solution": "nums := []int{2, 7, 11}\nvalueToIndex := make(map[int]int)\n\nfor i, num := range nums {\n    valueToIndex[num] = i\n}\n\nfmt.Println(valueToIndex)",
            "expectedOutput": "map[2:0 7:1 11:2]",
            "keyInsight": "The Two Sum algorithm builds this map AS it loops - checking for the complement first, then adding the current number. This ensures we don't match a number with itself!"
          }
        ]
      },
      "advanced_6": {
        "title": "Pre-exercise: Sliding Window Fundamentals",
        "description": "Before tackling sliding window problems, let's practice the core mechanics: managing a window and efficiently updating its state.",
        "exercises": [
          {
            "id": "pre6a",
            "title": "Fixed Window Sum",
            "problem": "Given <code>[]int{1, 2, 3, 4, 5}</code> and window size k=3, calculate the sum of the first window [1,2,3], then slide it one position and calculate the new sum [2,3,4] WITHOUT re-summing all elements.",
            "hints": [
              {
                "title": "Step 1: Calculate first window sum",
                "content": "<pre>nums := []int{1, 2, 3, 4, 5}\nk := 3\n\n// Sum first k elements\nwindowSum := 0\nfor i := 0; i < k; i++ {\n    windowSum += nums[i]\n}\nfmt.Println(windowSum)  // 6</pre>"
              },
              {
                "title": "Step 2: Slide the window",
                "content": "<pre>// The trick: add new element, subtract old element\n// New element is at index k (which is 3)\n// Old element is at index 0\nwindowSum = windowSum + nums[k] - nums[0]</pre>"
              },
              {
                "title": "Step 3: General formula",
                "content": "When sliding from position i-1 to i:<pre>windowSum = windowSum + nums[i+k-1] - nums[i-1]</pre>Or equivalently, when the right edge moves to index i:<pre>windowSum = windowSum + nums[i] - nums[i-k]</pre>"
              }
            ],
            "solution": "nums := []int{1, 2, 3, 4, 5}\nk := 3\n\n// Sum first window\nwindowSum := 0\nfor i := 0; i < k; i++ {\n    windowSum += nums[i]\n}\nfmt.Printf(\"Window [0:3] sum: %d\\n\", windowSum)  // 6\n\n// Slide window: add nums[3], remove nums[0]\nwindowSum = windowSum + nums[3] - nums[0]\nfmt.Printf(\"Window [1:4] sum: %d\\n\", windowSum)  // 9\n\n// Slide again: add nums[4], remove nums[1]\nwindowSum = windowSum + nums[4] - nums[1]\nfmt.Printf(\"Window [2:5] sum: %d\\n\", windowSum)  // 12",
            "expectedOutput": "Window [0:3] sum: 6\nWindow [1:4] sum: 9\nWindow [2:5] sum: 12",
            "keyInsight": "The sliding window trick: instead of recalculating the entire sum (O(k)), just add the new element and subtract the leaving element (O(1)). This makes processing all windows O(n) instead of O(n*k)!"
          },
          {
            "id": "pre6b",
            "title": "Variable Window with Map",
            "problem": "Track characters in a variable-size window. Given string \"abca\", add characters one by one to a <code>map[byte]int</code> (tracking counts), then simulate shrinking by decrementing counts.",
            "hints": [
              {
                "title": "Step 1: Setup and expand",
                "content": "<pre>s := \"abca\"\nseen := make(map[byte]int)\n\n// Add each character (expanding window)\nfor i := 0; i < len(s); i++ {\n    seen[s[i]]++\n    fmt.Printf(\"Added %c, counts: %v\\n\", s[i], seen)\n}</pre>"
              },
              {
                "title": "Step 2: Shrink from left",
                "content": "<pre>// Remove the first character (shrink)\nseen[s[0]]--\nif seen[s[0]] == 0 {\n    delete(seen, s[0])  // Clean up zero counts\n}\nfmt.Printf(\"After removing %c: %v\\n\", s[0], seen)</pre>"
              }
            ],
            "solution": "s := \"abca\"\nseen := make(map[byte]int)\n\n// Expand: add all characters\nfor i := 0; i < len(s); i++ {\n    seen[s[i]]++\n}\nfmt.Printf(\"Full window: %v\\n\", seen)  // a:2, b:1, c:1\n\n// Shrink: remove from left (index 0 = 'a')\nseen[s[0]]--\nif seen[s[0]] == 0 {\n    delete(seen, s[0])\n}\nfmt.Printf(\"After removing s[0]: %v\\n\", seen)  // a:1, b:1, c:1\n\n// Shrink more: remove s[1] = 'b'\nseen[s[1]]--\nif seen[s[1]] == 0 {\n    delete(seen, s[1])\n}\nfmt.Printf(\"After removing s[1]: %v\\n\", seen)  // a:1, c:1",
            "expectedOutput": "Full window: map[97:2 98:1 99:1]\nAfter removing s[0]: map[97:1 98:1 99:1]\nAfter removing s[1]: map[97:1 99:1]",
            "keyInsight": "Variable sliding windows use a map to track what's in the window. When expanding (right pointer moves), increment counts. When shrinking (left pointer moves), decrement counts. Delete keys when count hits 0 to keep the map clean."
          }
        ]
      },
      "advanced_7": {
        "title": "Pre-exercise: Tracking Best So Far",
        "description": "Before tackling optimization problems, let's practice the core pattern: tracking a running minimum/maximum while scanning.",
        "exercises": [
          {
            "id": "pre7a",
            "title": "Track Running Minimum",
            "problem": "Given <code>[]int{5, 3, 8, 1, 9, 2}</code>, print the running minimum after each element. Output should show: 5, 3, 3, 1, 1, 1.",
            "hints": [
              {
                "title": "Step 1: Initialize",
                "content": "<pre>nums := []int{5, 3, 8, 1, 9, 2}\nminSoFar := nums[0]\nfmt.Println(minSoFar)  // First element is the min so far</pre>"
              },
              {
                "title": "Step 2: Loop and update",
                "content": "<pre>for i := 1; i < len(nums); i++ {\n    if nums[i] < minSoFar {\n        minSoFar = nums[i]\n    }\n    fmt.Println(minSoFar)\n}</pre>"
              }
            ],
            "solution": "nums := []int{5, 3, 8, 1, 9, 2}\nminSoFar := nums[0]\nfmt.Println(minSoFar)\n\nfor i := 1; i < len(nums); i++ {\n    if nums[i] < minSoFar {\n        minSoFar = nums[i]\n    }\n    fmt.Println(minSoFar)\n}",
            "expectedOutput": "5\n3\n3\n1\n1\n1",
            "keyInsight": "At each position, <code>minSoFar</code> holds the smallest value we've seen from the start up to that point. This is the foundation of the 'Best So Far' pattern - we don't need to remember ALL previous values, just the one that matters!"
          },
          {
            "id": "pre7b",
            "title": "Calculate Difference from Minimum",
            "problem": "Given <code>[]int{5, 3, 8, 1, 9}</code>, for each element print the difference between it and the minimum of all PREVIOUS elements. Skip the first element (no previous elements). Output: -2, 5, -2, 8.",
            "hints": [
              {
                "title": "Step 1: Initialize",
                "content": "<pre>nums := []int{5, 3, 8, 1, 9}\nminSoFar := nums[0]  // Min of elements before current</pre>"
              },
              {
                "title": "Step 2: Loop from second element",
                "content": "<pre>for i := 1; i < len(nums); i++ {\n    diff := nums[i] - minSoFar\n    fmt.Println(diff)\n    // Update minSoFar AFTER calculating diff\n    if nums[i] < minSoFar {\n        minSoFar = nums[i]\n    }\n}</pre>"
              },
              {
                "title": "Key insight",
                "content": "The order matters! Calculate the difference BEFORE updating minSoFar. This ensures we're comparing to the minimum of previous elements, not including the current one."
              }
            ],
            "solution": "nums := []int{5, 3, 8, 1, 9}\nminSoFar := nums[0]\n\nfor i := 1; i < len(nums); i++ {\n    diff := nums[i] - minSoFar\n    fmt.Println(diff)\n    \n    // Update min AFTER calculating diff\n    if nums[i] < minSoFar {\n        minSoFar = nums[i]\n    }\n}",
            "expectedOutput": "-2\n5\n-2\n8",
            "keyInsight": "This is exactly the stock problem! The difference <code>nums[i] - minSoFar</code> is the profit if you bought at the minimum price so far and sold today. The maximum of all these differences is your answer. Notice we update minSoFar AFTER calculating the diff - order matters!"
          }
        ]
      }
    }
  }
}