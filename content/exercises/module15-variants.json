{
  "conceptLinks": {
    "Sets with Maps": "#lesson-sets",
    "Set Operations": "#lesson-set-ops",
    "Map as Set": "#lesson-maps-as-sets",
    "Diffing Collections": "#lesson-diffing"
  },
  "sharedContent": {},
  "variants": {
    "warmups": [
      {
        "id": "warmup_1",
        "concept": "Sets with Maps",
        "variants": [
          {
            "id": "v1",
            "title": "Directory Diff",
            "description": "Write a program that compares filenames in two string slices representing directories. Print files only in A, only in B, and in both.",
            "hints": [
              "Build a <code>map[string]struct{}</code> from each slice, then iterate to find differences."
            ],
            "solution": "func directoryDiff(a, b []string) (onlyA, onlyB, both []string) {\n    setA := make(map[string]struct{})\n    for _, f := range a {\n        setA[f] = struct{}{}\n    }\n    setB := make(map[string]struct{})\n    for _, f := range b {\n        setB[f] = struct{}{}\n    }\n    for f := range setA {\n        if _, ok := setB[f]; ok {\n            both = append(both, f)\n        } else {\n            onlyA = append(onlyA, f)\n        }\n    }\n    for f := range setB {\n        if _, ok := setA[f]; !ok {\n            onlyB = append(onlyB, f)\n        }\n    }\n    return\n}",
            "annotations": [
              { "type": "idiom", "label": "Empty Struct Set", "text": "Use map[string]struct{}{} as a set. The empty struct uses zero bytes of storage." },
              { "type": "complexity", "label": "O(n + m)", "text": "Building both sets and diffing them is linear in the total number of elements." }
            ]
          },
          {
            "id": "v2",
            "title": "Package Import Diff",
            "description": "Given two slices of Go import paths, find which imports are unique to each file and which are shared.",
            "hints": [
              "Use <code>map[string]struct{}</code> to build sets from each import list, then compare."
            ],
            "solution": "func importDiff(fileA, fileB []string) (onlyA, onlyB, shared []string) {\n    setA := make(map[string]struct{})\n    for _, imp := range fileA {\n        setA[imp] = struct{}{}\n    }\n    setB := make(map[string]struct{})\n    for _, imp := range fileB {\n        setB[imp] = struct{}{}\n    }\n    for imp := range setA {\n        if _, ok := setB[imp]; ok {\n            shared = append(shared, imp)\n        } else {\n            onlyA = append(onlyA, imp)\n        }\n    }\n    for imp := range setB {\n        if _, ok := setA[imp]; !ok {\n            onlyB = append(onlyB, imp)\n        }\n    }\n    return\n}",
            "annotations": [
              { "type": "idiom", "label": "Comma-Ok Pattern", "text": "Use _, ok := m[key] to check membership without caring about the value." },
              { "type": "gotcha", "label": "Map Iteration Order", "text": "Map iteration order is randomized in Go. Sort results if you need deterministic output." }
            ]
          },
          {
            "id": "v3",
            "title": "Config Key Diff",
            "description": "Given two <code>map[string]string</code> representing config files, find keys that are only in the first, only in the second, and in both.",
            "hints": [
              "You already have maps -- just iterate the keys and check for membership in the other map."
            ],
            "solution": "func configDiff(a, b map[string]string) (onlyA, onlyB, both []string) {\n    for k := range a {\n        if _, ok := b[k]; ok {\n            both = append(both, k)\n        } else {\n            onlyA = append(onlyA, k)\n        }\n    }\n    for k := range b {\n        if _, ok := a[k]; !ok {\n            onlyB = append(onlyB, k)\n        }\n    }\n    return\n}",
            "annotations": [
              { "type": "idiom", "label": "Range over Map", "text": "for k := range m iterates over keys only, ignoring values." },
              { "type": "alternative", "label": "Sorted Output", "text": "Use sort.Strings() on results if you need deterministic ordering for tests." }
            ]
          },
          {
            "id": "v4",
            "title": "Tag Diff",
            "description": "Given two slices of tag strings (e.g., blog post tags), return tags that were added, removed, and unchanged between the old and new versions.",
            "hints": [
              "Build sets from both slices. Tags in new but not old are added; tags in old but not new are removed."
            ],
            "solution": "func tagDiff(oldTags, newTags []string) (added, removed, unchanged []string) {\n    oldSet := make(map[string]struct{})\n    for _, t := range oldTags {\n        oldSet[t] = struct{}{}\n    }\n    newSet := make(map[string]struct{})\n    for _, t := range newTags {\n        newSet[t] = struct{}{}\n    }\n    for t := range newSet {\n        if _, ok := oldSet[t]; ok {\n            unchanged = append(unchanged, t)\n        } else {\n            added = append(added, t)\n        }\n    }\n    for t := range oldSet {\n        if _, ok := newSet[t]; !ok {\n            removed = append(removed, t)\n        }\n    }\n    return\n}",
            "annotations": [
              { "type": "pattern", "label": "Before/After Diff", "text": "The before/after diff pattern is fundamental: build sets, then classify items as added, removed, or unchanged." },
              { "type": "gotcha", "label": "Duplicate Tags", "text": "Using a set automatically deduplicates. If duplicates matter, use a map[string]int count instead." }
            ]
          }
        ]
      },
      {
        "id": "warmup_2",
        "concept": "Set Operations",
        "variants": [
          {
            "id": "v1",
            "title": "Find Common Words",
            "description": "Given two string slices of words, return a slice of words that appear in both lists.",
            "hints": [
              "Build a set from the first slice, then check each word in the second slice against it."
            ],
            "solution": "func findCommon(a, b []string) []string {\n    set := make(map[string]struct{})\n    for _, w := range a {\n        set[w] = struct{}{}\n    }\n    var common []string\n    seen := make(map[string]struct{})\n    for _, w := range b {\n        if _, ok := set[w]; ok {\n            if _, dup := seen[w]; !dup {\n                common = append(common, w)\n                seen[w] = struct{}{}\n            }\n        }\n    }\n    return common\n}",
            "annotations": [
              { "type": "idiom", "label": "Set Intersection", "text": "Intersection means items in both sets. Build one set, check the other against it." },
              { "type": "gotcha", "label": "Duplicates in Output", "text": "Without a 'seen' set, duplicates in the second slice could appear multiple times in the result." }
            ]
          },
          {
            "id": "v2",
            "title": "Common Permissions",
            "description": "Given two slices of permission strings (e.g., <code>[\"read\", \"write\", \"admin\"]</code>), return the permissions that both users share.",
            "hints": [
              "Build a <code>map[string]struct{}</code> from user A's permissions. Check each of user B's permissions against it."
            ],
            "solution": "func commonPermissions(userA, userB []string) []string {\n    setA := make(map[string]struct{})\n    for _, p := range userA {\n        setA[p] = struct{}{}\n    }\n    var shared []string\n    for _, p := range userB {\n        if _, ok := setA[p]; ok {\n            shared = append(shared, p)\n        }\n    }\n    return shared\n}",
            "annotations": [
              { "type": "idiom", "label": "Set Membership", "text": "Checking if _, ok := set[item]; ok is the standard Go pattern for set membership." },
              { "type": "complexity", "label": "O(n + m)", "text": "Building the first set is O(n), checking each item of the second is O(m). Total is linear." }
            ]
          },
          {
            "id": "v3",
            "title": "Shared Dependencies",
            "description": "Given two slices representing Go module dependencies, return the modules both projects depend on.",
            "hints": [
              "This is a set intersection. Build a set from one list, check the other."
            ],
            "solution": "func sharedDeps(projA, projB []string) []string {\n    setA := make(map[string]struct{})\n    for _, dep := range projA {\n        setA[dep] = struct{}{}\n    }\n    var shared []string\n    for _, dep := range projB {\n        if _, ok := setA[dep]; ok {\n            shared = append(shared, dep)\n        }\n    }\n    return shared\n}",
            "annotations": [
              { "type": "stdlib", "label": "slices Package", "text": "Go 1.21+ has slices.Contains(), but a map set is still faster for repeated lookups." },
              { "type": "complexity", "label": "O(n + m)", "text": "Map lookup is O(1) amortized, making the total operation linear." }
            ]
          },
          {
            "id": "v4",
            "title": "Common Students",
            "description": "Given two string slices representing class rosters, find students enrolled in both classes.",
            "hints": [
              "Build a set from the first roster. Iterate over the second roster and collect matches."
            ],
            "solution": "func commonStudents(classA, classB []string) []string {\n    enrolled := make(map[string]struct{})\n    for _, s := range classA {\n        enrolled[s] = struct{}{}\n    }\n    var both []string\n    for _, s := range classB {\n        if _, ok := enrolled[s]; ok {\n            both = append(both, s)\n        }\n    }\n    return both\n}",
            "annotations": [
              { "type": "idiom", "label": "Empty Struct Value", "text": "struct{}{} is the idiomatic zero-cost value for Go sets since it allocates no memory." },
              { "type": "alternative", "label": "map[string]bool", "text": "Some Go code uses map[string]bool for readability (if set[key]), but struct{} saves memory." }
            ]
          }
        ]
      }
    ],
    "challenges": [
      {
        "id": "challenge_1",
        "block": 1,
        "difficulty": 2,
        "concept": "Set Operations",
        "variants": [
          {
            "id": "v1",
            "title": "Set Calculator",
            "description": "Write a function that performs set operations (union, intersection, difference) on two string slices. The operation is specified as a string parameter.",
            "functionSignature": "func setCalc(op string, a, b []string) []string",
            "testCases": [
              { "input": "\"union\", []string{\"a\", \"b\", \"c\"}, []string{\"b\", \"c\", \"d\"}", "output": "[\"a\", \"b\", \"c\", \"d\"]" },
              { "input": "\"intersect\", []string{\"a\", \"b\", \"c\"}, []string{\"b\", \"c\", \"d\"}", "output": "[\"b\", \"c\"]" },
              { "input": "\"diff\", []string{\"a\", \"b\", \"c\"}, []string{\"b\", \"c\", \"d\"}", "output": "[\"a\"]" }
            ],
            "hints": [
              { "title": "\ud83e\udd14 Think about it", "content": "What does each set operation mean? Union = everything from both. Intersection = only shared. Difference = in A but not B." },
              { "title": "\ud83d\udca1 Hint", "content": "Build map sets from both slices. Use a switch statement on the operation string. For union, combine both sets. For intersect, find common keys. For diff, find keys only in A." },
              { "title": "\ud83d\udd27 Pattern", "content": "<pre>1. Build setA and setB from slices\n2. Switch on op:\n   - union: add all from A, then all from B not in A\n   - intersect: items in A that are also in B\n   - diff: items in A that are NOT in B\n3. Return result slice</pre>" }
            ],
            "solution": "func setCalc(op string, a, b []string) []string {\n    setA := make(map[string]struct{})\n    for _, s := range a {\n        setA[s] = struct{}{}\n    }\n    setB := make(map[string]struct{})\n    for _, s := range b {\n        setB[s] = struct{}{}\n    }\n\n    var result []string\n    switch op {\n    case \"union\":\n        for s := range setA {\n            result = append(result, s)\n        }\n        for s := range setB {\n            if _, ok := setA[s]; !ok {\n                result = append(result, s)\n            }\n        }\n    case \"intersect\":\n        for s := range setA {\n            if _, ok := setB[s]; ok {\n                result = append(result, s)\n            }\n        }\n    case \"diff\":\n        for s := range setA {\n            if _, ok := setB[s]; !ok {\n                result = append(result, s)\n            }\n        }\n    }\n    sort.Strings(result)\n    return result\n}",
            "difficulty": 2,
            "annotations": [
              { "type": "idiom", "label": "Switch on Strings", "text": "Go's switch statement works cleanly on strings without needing break statements." },
              { "type": "complexity", "label": "O(n + m)", "text": "Each operation iterates through at most both sets, giving linear time complexity." }
            ]
          },
          {
            "id": "v2",
            "title": "Permission Calculator",
            "description": "Write a function that combines or restricts permission sets. Given an operation (<code>\"grant\"</code> for union, <code>\"restrict\"</code> for intersection, <code>\"revoke\"</code> for difference), compute the resulting permission set.",
            "functionSignature": "func permCalc(op string, current, modifier []string) []string",
            "testCases": [
              { "input": "\"grant\", []string{\"read\", \"write\"}, []string{\"write\", \"admin\"}", "output": "[\"admin\", \"read\", \"write\"]" },
              { "input": "\"restrict\", []string{\"read\", \"write\", \"admin\"}, []string{\"read\", \"write\"}", "output": "[\"read\", \"write\"]" },
              { "input": "\"revoke\", []string{\"read\", \"write\", \"admin\"}, []string{\"admin\"}", "output": "[\"read\", \"write\"]" }
            ],
            "hints": [
              { "title": "\ud83e\udd14 Think about it", "content": "Grant adds new permissions (union). Restrict keeps only allowed permissions (intersection). Revoke removes specific permissions (difference)." },
              { "title": "\ud83d\udca1 Hint", "content": "Map each operation name to its set operation. Build sets from both slices, then apply the appropriate logic." },
              { "title": "\ud83d\udd27 Pattern", "content": "<pre>1. Build sets from current and modifier slices\n2. Switch on op:\n   - \"grant\": union of current + modifier\n   - \"restrict\": intersection of current and modifier\n   - \"revoke\": difference of current minus modifier\n3. Sort and return</pre>" }
            ],
            "solution": "func permCalc(op string, current, modifier []string) []string {\n    cur := make(map[string]struct{})\n    for _, p := range current {\n        cur[p] = struct{}{}\n    }\n    mod := make(map[string]struct{})\n    for _, p := range modifier {\n        mod[p] = struct{}{}\n    }\n\n    var result []string\n    switch op {\n    case \"grant\":\n        for p := range cur {\n            result = append(result, p)\n        }\n        for p := range mod {\n            if _, ok := cur[p]; !ok {\n                result = append(result, p)\n            }\n        }\n    case \"restrict\":\n        for p := range cur {\n            if _, ok := mod[p]; ok {\n                result = append(result, p)\n            }\n        }\n    case \"revoke\":\n        for p := range cur {\n            if _, ok := mod[p]; !ok {\n                result = append(result, p)\n            }\n        }\n    }\n    sort.Strings(result)\n    return result\n}",
            "difficulty": 2,
            "annotations": [
              { "type": "pattern", "label": "Domain-Specific Names", "text": "Mapping domain concepts (grant/revoke) to set operations makes code more readable in context." },
              { "type": "idiom", "label": "Sorted Output", "text": "Sorting the result ensures deterministic output, essential for testing." }
            ]
          },
          {
            "id": "v3",
            "title": "Feature Flag Manager",
            "description": "Write a function that manages feature flags using set operations. Supports <code>\"enable\"</code> (union), <code>\"common\"</code> (intersection), and <code>\"disable\"</code> (difference).",
            "functionSignature": "func featureFlags(op string, active, targets []string) []string",
            "testCases": [
              { "input": "\"enable\", []string{\"dark-mode\", \"beta-ui\"}, []string{\"beta-ui\", \"new-api\"}", "output": "[\"beta-ui\", \"dark-mode\", \"new-api\"]" },
              { "input": "\"common\", []string{\"dark-mode\", \"beta-ui\", \"new-api\"}, []string{\"beta-ui\", \"new-api\"}", "output": "[\"beta-ui\", \"new-api\"]" },
              { "input": "\"disable\", []string{\"dark-mode\", \"beta-ui\", \"new-api\"}, []string{\"beta-ui\"}", "output": "[\"dark-mode\", \"new-api\"]" }
            ],
            "hints": [
              { "title": "\ud83e\udd14 Think about it", "content": "Enable adds flags (union), common finds shared flags (intersection), disable removes flags (difference). Which set operation matches each?" },
              { "title": "\ud83d\udca1 Hint", "content": "Build sets from both slices. Switch on the operation and apply the matching set operation." },
              { "title": "\ud83d\udd27 Pattern", "content": "<pre>1. Build map sets from active and targets\n2. Switch on op:\n   - enable: union\n   - common: intersection\n   - disable: difference\n3. Collect, sort, return</pre>" }
            ],
            "solution": "func featureFlags(op string, active, targets []string) []string {\n    actSet := make(map[string]struct{})\n    for _, f := range active {\n        actSet[f] = struct{}{}\n    }\n    tgtSet := make(map[string]struct{})\n    for _, f := range targets {\n        tgtSet[f] = struct{}{}\n    }\n\n    var result []string\n    switch op {\n    case \"enable\":\n        for f := range actSet {\n            result = append(result, f)\n        }\n        for f := range tgtSet {\n            if _, ok := actSet[f]; !ok {\n                result = append(result, f)\n            }\n        }\n    case \"common\":\n        for f := range actSet {\n            if _, ok := tgtSet[f]; ok {\n                result = append(result, f)\n            }\n        }\n    case \"disable\":\n        for f := range actSet {\n            if _, ok := tgtSet[f]; !ok {\n                result = append(result, f)\n            }\n        }\n    }\n    sort.Strings(result)\n    return result\n}",
            "difficulty": 2,
            "annotations": [
              { "type": "idiom", "label": "Set as Map", "text": "Go has no built-in set type. map[T]struct{} is the canonical implementation." },
              { "type": "alternative", "label": "Generic Set", "text": "With Go generics, you could write a reusable Set[T comparable] type for all three operations." }
            ]
          },
          {
            "id": "v4",
            "title": "Ingredient Calculator",
            "description": "Write a function for recipe management. Given an operation (<code>\"combine\"</code> for union, <code>\"overlap\"</code> for intersection, <code>\"missing\"</code> for difference), calculate the result between two ingredient lists.",
            "functionSignature": "func ingredientCalc(op string, recipe, pantry []string) []string",
            "testCases": [
              { "input": "\"combine\", []string{\"flour\", \"sugar\"}, []string{\"sugar\", \"butter\"}", "output": "[\"butter\", \"flour\", \"sugar\"]" },
              { "input": "\"overlap\", []string{\"flour\", \"sugar\", \"eggs\"}, []string{\"sugar\", \"eggs\", \"milk\"}", "output": "[\"eggs\", \"sugar\"]" },
              { "input": "\"missing\", []string{\"flour\", \"sugar\", \"eggs\"}, []string{\"sugar\"}", "output": "[\"eggs\", \"flour\"]" }
            ],
            "hints": [
              { "title": "\ud83e\udd14 Think about it", "content": "Combine merges all ingredients (union). Overlap finds what you already have (intersection). Missing finds what you need to buy (difference)." },
              { "title": "\ud83d\udca1 Hint", "content": "Build sets from both slices. Apply the matching set operation based on the op string." },
              { "title": "\ud83d\udd27 Pattern", "content": "<pre>1. Build map sets from recipe and pantry\n2. Switch on op:\n   - combine: all unique items from both\n   - overlap: items in both\n   - missing: items in recipe but not pantry\n3. Sort and return</pre>" }
            ],
            "solution": "func ingredientCalc(op string, recipe, pantry []string) []string {\n    rSet := make(map[string]struct{})\n    for _, i := range recipe {\n        rSet[i] = struct{}{}\n    }\n    pSet := make(map[string]struct{})\n    for _, i := range pantry {\n        pSet[i] = struct{}{}\n    }\n\n    var result []string\n    switch op {\n    case \"combine\":\n        for i := range rSet {\n            result = append(result, i)\n        }\n        for i := range pSet {\n            if _, ok := rSet[i]; !ok {\n                result = append(result, i)\n            }\n        }\n    case \"overlap\":\n        for i := range rSet {\n            if _, ok := pSet[i]; ok {\n                result = append(result, i)\n            }\n        }\n    case \"missing\":\n        for i := range rSet {\n            if _, ok := pSet[i]; !ok {\n                result = append(result, i)\n            }\n        }\n    }\n    sort.Strings(result)\n    return result\n}",
            "difficulty": 2,
            "annotations": [
              { "type": "gotcha", "label": "Nil Slice vs Empty", "text": "If no items match, result is nil. Use make([]string, 0) if you need a non-nil empty slice for JSON." },
              { "type": "complexity", "label": "O((n+m) log(n+m))", "text": "Set operations are O(n+m) but the final sort adds O(k log k) where k is the result size." }
            ]
          }
        ]
      },
      {
        "id": "challenge_2",
        "block": 2,
        "difficulty": 3,
        "concept": "Diffing Collections",
        "variants": [
          {
            "id": "v1",
            "title": "Change Detector",
            "description": "Write a function that takes two string slices representing before/after snapshots and returns three slices: added items, removed items, and unchanged items.",
            "functionSignature": "func detectChanges(before, after []string) (added, removed, unchanged []string)",
            "testCases": [
              { "input": "[]string{\"a.txt\", \"b.txt\", \"c.txt\"}, []string{\"b.txt\", \"c.txt\", \"d.txt\"}", "output": "added=[\"d.txt\"], removed=[\"a.txt\"], unchanged=[\"b.txt\", \"c.txt\"]" },
              { "input": "[]string{\"x\"}, []string{\"x\", \"y\", \"z\"}", "output": "added=[\"y\", \"z\"], removed=[], unchanged=[\"x\"]" },
              { "input": "[]string{\"a\", \"b\"}, []string{}", "output": "added=[], removed=[\"a\", \"b\"], unchanged=[]" }
            ],
            "hints": [
              { "title": "\ud83e\udd14 Think about it", "content": "How do you classify each item? It's added if it's in 'after' but not 'before'. Removed if in 'before' but not 'after'. Unchanged if in both." },
              { "title": "\ud83d\udca1 Hint", "content": "Build a set from 'before' and a set from 'after'. Iterate each set checking membership in the other." },
              { "title": "\ud83d\udd27 Pattern", "content": "<pre>1. Build beforeSet and afterSet\n2. For each item in afterSet:\n   - In beforeSet? -> unchanged\n   - Not in beforeSet? -> added\n3. For each item in beforeSet:\n   - Not in afterSet? -> removed\n4. Sort all three slices</pre>" }
            ],
            "solution": "func detectChanges(before, after []string) (added, removed, unchanged []string) {\n    beforeSet := make(map[string]struct{})\n    for _, s := range before {\n        beforeSet[s] = struct{}{}\n    }\n    afterSet := make(map[string]struct{})\n    for _, s := range after {\n        afterSet[s] = struct{}{}\n    }\n\n    for s := range afterSet {\n        if _, ok := beforeSet[s]; ok {\n            unchanged = append(unchanged, s)\n        } else {\n            added = append(added, s)\n        }\n    }\n    for s := range beforeSet {\n        if _, ok := afterSet[s]; !ok {\n            removed = append(removed, s)\n        }\n    }\n\n    sort.Strings(added)\n    sort.Strings(removed)\n    sort.Strings(unchanged)\n    return\n}",
            "difficulty": 3,
            "annotations": [
              { "type": "idiom", "label": "Named Returns", "text": "Named return values (added, removed, unchanged) act as documentation and allow bare returns." },
              { "type": "complexity", "label": "O(n log n)", "text": "Set operations are O(n), but sorting the output adds O(n log n)." },
              { "type": "pattern", "label": "Three-Way Diff", "text": "The three-way classification (added/removed/unchanged) is the foundation of most diff algorithms." }
            ]
          },
          {
            "id": "v2",
            "title": "Config Change Tracker",
            "description": "Write a function that compares two <code>map[string]string</code> configs and returns slices of keys that were added, removed, or modified (value changed).",
            "functionSignature": "func configChanges(old, new map[string]string) (added, removed, modified []string)",
            "testCases": [
              { "input": "map[string]string{\"port\": \"8080\", \"host\": \"localhost\"}, map[string]string{\"port\": \"9090\", \"debug\": \"true\"}", "output": "added=[\"debug\"], removed=[\"host\"], modified=[\"port\"]" },
              { "input": "map[string]string{\"a\": \"1\"}, map[string]string{\"a\": \"1\"}", "output": "added=[], removed=[], modified=[]" }
            ],
            "hints": [
              { "title": "\ud83e\udd14 Think about it", "content": "This is like a diff but with an extra category: modified. A key is modified if it exists in both maps but has a different value." },
              { "title": "\ud83d\udca1 Hint", "content": "Iterate the old map: if a key is not in new, it was removed. If it is in new but with a different value, it was modified. Then iterate new for keys not in old (added)." },
              { "title": "\ud83d\udd27 Pattern", "content": "<pre>1. For each key in old:\n   - Not in new? -> removed\n   - In new with different value? -> modified\n2. For each key in new:\n   - Not in old? -> added\n3. Sort all slices</pre>" }
            ],
            "solution": "func configChanges(old, new map[string]string) (added, removed, modified []string) {\n    for k, oldVal := range old {\n        newVal, exists := new[k]\n        if !exists {\n            removed = append(removed, k)\n        } else if oldVal != newVal {\n            modified = append(modified, k)\n        }\n    }\n    for k := range new {\n        if _, exists := old[k]; !exists {\n            added = append(added, k)\n        }\n    }\n    sort.Strings(added)\n    sort.Strings(removed)\n    sort.Strings(modified)\n    return\n}",
            "difficulty": 3,
            "annotations": [
              { "type": "pattern", "label": "Value-Aware Diff", "text": "Unlike a pure set diff, this pattern also detects modifications by comparing values for shared keys." },
              { "type": "gotcha", "label": "Zero Values", "text": "Accessing a missing map key returns the zero value (empty string), so always use the comma-ok idiom to distinguish missing from empty." }
            ]
          },
          {
            "id": "v3",
            "title": "Roster Change Report",
            "description": "Write a function that compares an old and new team roster (slices of name strings) and returns a formatted report string listing who joined, who left, and who stayed.",
            "functionSignature": "func rosterReport(old, new []string) string",
            "testCases": [
              { "input": "[]string{\"Alice\", \"Bob\", \"Charlie\"}, []string{\"Bob\", \"Charlie\", \"Diana\"}", "output": "\"Joined: Diana\\nLeft: Alice\\nStayed: Bob, Charlie\"" },
              { "input": "[]string{\"Alice\"}, []string{\"Alice\"}", "output": "\"Joined: (none)\\nLeft: (none)\\nStayed: Alice\"" }
            ],
            "hints": [
              { "title": "\ud83e\udd14 Think about it", "content": "First compute the three categories (joined, left, stayed), then format them into a report string." },
              { "title": "\ud83d\udca1 Hint", "content": "Use set operations to find joined (in new, not old), left (in old, not new), stayed (in both). Then use strings.Join to format each list." },
              { "title": "\ud83d\udd27 Pattern", "content": "<pre>1. Build oldSet and newSet\n2. Compute joined, left, stayed slices\n3. Sort each slice\n4. Format with strings.Join\n5. Use \"(none)\" for empty categories</pre>" }
            ],
            "solution": "func rosterReport(old, new []string) string {\n    oldSet := make(map[string]struct{})\n    for _, n := range old {\n        oldSet[n] = struct{}{}\n    }\n    newSet := make(map[string]struct{})\n    for _, n := range new {\n        newSet[n] = struct{}{}\n    }\n\n    var joined, left, stayed []string\n    for n := range newSet {\n        if _, ok := oldSet[n]; ok {\n            stayed = append(stayed, n)\n        } else {\n            joined = append(joined, n)\n        }\n    }\n    for n := range oldSet {\n        if _, ok := newSet[n]; !ok {\n            left = append(left, n)\n        }\n    }\n\n    sort.Strings(joined)\n    sort.Strings(left)\n    sort.Strings(stayed)\n\n    format := func(label string, items []string) string {\n        if len(items) == 0 {\n            return label + \": (none)\"\n        }\n        return label + \": \" + strings.Join(items, \", \")\n    }\n\n    return format(\"Joined\", joined) + \"\\n\" + format(\"Left\", left) + \"\\n\" + format(\"Stayed\", stayed)\n}",
            "difficulty": 3,
            "annotations": [
              { "type": "idiom", "label": "strings.Join", "text": "strings.Join is the idiomatic way to combine string slices with a separator." },
              { "type": "pattern", "label": "Closures for Formatting", "text": "Using a local closure (format func) avoids code duplication for repetitive formatting logic." }
            ]
          },
          {
            "id": "v4",
            "title": "Inventory Tracker",
            "description": "Write a function that compares two <code>map[string]int</code> representing inventory counts. Return maps of items that are new, removed, increased, and decreased.",
            "functionSignature": "func inventoryDiff(before, after map[string]int) (new, removed map[string]int, increased, decreased map[string][2]int)",
            "testCases": [
              { "input": "map[string]int{\"apples\": 5, \"bananas\": 3}, map[string]int{\"apples\": 8, \"cherries\": 2}", "output": "new={\"cherries\": 2}, removed={\"bananas\": 3}, increased={\"apples\": [5, 8]}, decreased={}" },
              { "input": "map[string]int{\"a\": 10}, map[string]int{\"a\": 5}", "output": "new={}, removed={}, increased={}, decreased={\"a\": [10, 5]}" }
            ],
            "hints": [
              { "title": "\ud83e\udd14 Think about it", "content": "This extends the diff pattern with quantity awareness. Items can be new, removed, or present in both with a changed count." },
              { "title": "\ud83d\udca1 Hint", "content": "Iterate 'before': if not in 'after', it was removed. If in 'after' with higher count, it increased. If lower, decreased. Then check 'after' for new items." },
              { "title": "\ud83d\udd27 Pattern", "content": "<pre>1. Initialize result maps with make()\n2. For each item in before:\n   - Not in after -> removed\n   - In after, count higher -> increased\n   - In after, count lower -> decreased\n3. For each item in after:\n   - Not in before -> new\n4. Return all four maps</pre>" }
            ],
            "solution": "func inventoryDiff(before, after map[string]int) (newItems, removed map[string]int, increased, decreased map[string][2]int) {\n    newItems = make(map[string]int)\n    removed = make(map[string]int)\n    increased = make(map[string][2]int)\n    decreased = make(map[string][2]int)\n\n    for item, oldCount := range before {\n        newCount, exists := after[item]\n        if !exists {\n            removed[item] = oldCount\n        } else if newCount > oldCount {\n            increased[item] = [2]int{oldCount, newCount}\n        } else if newCount < oldCount {\n            decreased[item] = [2]int{oldCount, newCount}\n        }\n    }\n    for item, count := range after {\n        if _, exists := before[item]; !exists {\n            newItems[item] = count\n        }\n    }\n    return\n}",
            "difficulty": 3,
            "annotations": [
              { "type": "idiom", "label": "Array Value in Map", "text": "Using [2]int as a map value stores old/new counts without needing a struct." },
              { "type": "gotcha", "label": "Initialize Maps", "text": "Always initialize maps with make() before writing to them. Writing to a nil map causes a runtime panic." },
              { "type": "complexity", "label": "O(n + m)", "text": "Each item is visited once from each map, making the operation linear." }
            ]
          }
        ]
      }
    ]
  }
}